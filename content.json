{"meta":{"title":"孙云增的博客","subtitle":"极简生活，极致内涵","description":"极简生活，极致内涵","author":"孙云增","url":"https://sunyunzeng.com","root":"/"},"pages":[{"title":"分类","date":"2018-01-05","updated":"2022-11-05","comments":true,"path":"categories/index.html","permalink":"https://sunyunzeng.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07","updated":"2022-11-05","comments":true,"path":"link/index.html","permalink":"https://sunyunzeng.com/link/index.html","excerpt":"","text":"友链添加指南申请要求1. 文章有干货，内容持续更新 2. 网站整洁，无广告 3. 站点被百度等搜索引擎收录 4. 网站图标加载快速 5. 有独立域名 申请方式先将本站的友链添加到您的友链，相关信息如下然后按照以下格式在本站留言区留言，待博主为您添上友链 名称：孙云增的博客头像链接：https://sunyunzeng.com/img/avatar.jpg主页链接：https://sunyunzeng.com/说明信息：极简生活，极致内涵 关于失效和不规范友链 若友链有不规范、违法行为或网站长时间失效，站长将会移除友链，谢谢!"},{"title":"我的说说","date":"2022-11-05","updated":"2022-11-05","comments":false,"path":"artitalk/index.html","permalink":"https://sunyunzeng.com/artitalk/index.html","excerpt":"","text":"var per = \"5\"; //每页显示说说的数量 var username = \"syz\"; //Leancloud中设置的用户名 var placeholder1=\"只有syz才能评论哦\"; //在编辑说说的输入框中的占位符 var placeholder2=\"没有密码，不能评论！\"; //在编辑密码的输入框中的占位符 var lazy = 1; //是否开启懒加载动画 new Artitalk({ appId: 'SqucG3k7pk9RsDfzGuhqzamj-MdYXbMMI', // Your LeanCloud appId appKey: 'DFqcDQIj2x0ViNyohrEIXQpb' // Your LeanCloud appKey })"},{"title":"留言板","date":"2021-03-19","updated":"2022-11-05","comments":true,"path":"messageboard/index.html","permalink":"https://sunyunzeng.com/messageboard/index.html","excerpt":"","text":"请大家畅所欲言~~~"},{"title":"关于","date":"2022-11-05","updated":"2022-11-05","comments":false,"path":"about/index.html","permalink":"https://sunyunzeng.com/about/index.html","excerpt":"","text":"Who am I? 我是谁? 国家打工人，社会主义的建设者与接班人！ Stay foolish, Stay Hungry 读书，运动，coding、writing 个人足迹 行万里路，读万卷书！ 足迹地图教程：https://sunyunzeng.com/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%B6%B3%E8%BF%B9%E5%9C%B0%E5%9B%BE/ 足迹地图项目地址： https://github.com/SUNYunZeng/FootprintMap 感言初拾凌云志，星河入九天。待到银丝起，可曾忆少年？"},{"title":"Repositories","date":"2022-11-05","updated":"2022-11-05","comments":false,"path":"repository/index.html","permalink":"https://sunyunzeng.com/repository/index.html","excerpt":"","text":""},{"title":"我的相册","date":"2021-03-19","updated":"2022-11-05","comments":false,"path":"photos/index.html","permalink":"https://sunyunzeng.com/photos/index.html","excerpt":"","text":"星球 高清星球图 卡通 唯美卡通图 风景 大自然的风光 事物 身边的瞬间"},{"title":"卡通","date":"2021-03-19","updated":"2022-11-05","comments":false,"path":"photos/cartoon/index.html","permalink":"https://sunyunzeng.com/photos/cartoon/index.html","excerpt":"","text":"[{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/spongebob.png\",\"alt\":\"\"},{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/wallhaven.png\",\"alt\":\"\"},{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/alone.png\",\"alt\":\"\"},{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/blog_home_picture.png\",\"alt\":\"\"},{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/caodi.png\",\"alt\":\"\"}]"},{"title":"星球","date":"2021-03-19","updated":"2022-11-05","comments":false,"path":"photos/planet/index.html","permalink":"https://sunyunzeng.com/photos/planet/index.html","excerpt":"","text":"[{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/blog_mars.png\",\"alt\":\"\"},{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/blog_jupter.png\",\"alt\":\"\"},{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/footer.png\",\"alt\":\"\"},{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/glaxy.png\",\"alt\":\"\"},{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/plants.png\",\"alt\":\"\"},{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/sun.png\",\"alt\":\"\"}]"},{"title":"风景","date":"2021-03-19","updated":"2022-11-05","comments":false,"path":"photos/scene/index.html","permalink":"https://sunyunzeng.com/photos/scene/index.html","excerpt":"","text":"[{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/lmqpol.png\",\"alt\":\"\"},{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/cloud.png\",\"alt\":\"\"}]"},{"title":"事物","date":"2021-03-19","updated":"2022-11-05","comments":false,"path":"photos/things/index.html","permalink":"https://sunyunzeng.com/photos/things/index.html","excerpt":"","text":"[{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/camera.png\",\"alt\":\"\"},{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/book.png\",\"alt\":\"\"},{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/board.png\",\"alt\":\"\"},{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/astronaut.png\",\"alt\":\"\"},{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/astronaut1.png\",\"alt\":\"\"},{\"url\":\"https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/astronaut2.png\",\"alt\":\"\"}]"},{"title":"标签","date":"2018-01-05","updated":"2022-11-05","comments":true,"path":"tags/index.html","permalink":"https://sunyunzeng.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"关于中国人口的一点思考","slug":"关于中国人口的一点思考","date":"2023-01-08","updated":"2023-01-08","comments":true,"path":"关于中国人口的一点思考/","link":"","permalink":"https://sunyunzeng.com/%E5%85%B3%E4%BA%8E%E4%B8%AD%E5%9B%BD%E4%BA%BA%E5%8F%A3%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/","excerpt":"","text":"本篇博客是读了《大国空巢》后的有感而发，也算是胡言乱语吧。首发在知乎，这里只是复述一下。 这本书大陆是13年出版的，但早在07年就已经在香港出版，现在读起来觉得易教授的话振聋发聩。 虽然有些结论或者数据还需要进一步推敲，但整体的论点是立得住的。想想早在零几年大家对计划生育政策无不推崇的背景下，易教授能站在国家民族的角度发出人口问题的呼声，实在令人佩服。 现在国家的人口发展无不印证了易教授的预测，比联合国最早预测的人口低方案2027年负增长足足提前了5年（2021年中国人口净增长48万，2022年大概率负增长）。当然，最新联合国预测中国最快2023年人口负增长，但这个是不是有点马后炮呢。政策的制定是有滞后性的，如果国家能早点意识到人口负增长问题，早点放开生育，现在人口结构问题会有更多的解决空间。 现在不要只盯着中国人口总数，看起来很多，而是关注人口结构，就会发现中国老龄化问题的严重，一个社会只有年轻人才是创造力和活力的源泉，如果中国进入重度老龄化社会，那么日本就是前车之鉴，况且中国是未富先老，将来老年人的社会问题将会很大。 人力也是一种资源，是比石油，煤炭更宝贵的资源，因为自然资源只能1+1=2，而人力资源却是1+1&gt;2。 当然，人力资源并不等于年轻劳动力数量，只是人口多，人的管理和教育跟不上，那么人口并不能发挥出其100%的左右，比如隔壁的印度，但是不能小瞧印度，因为人力资源不只能生产，还是消费的主体，一切生产活动最终是为人服务的，一个庞大的人口市场，在世界中也是不容小觑的。中国最大的竞争力是能投入社会进行生产和消费的巨大的人力资源。 中国改开的经济腾飞，人口是及其重要的因素，叠加九年义务教育及强大的政府管理水平，使得中国自入世之后，靠着廉价大量的人力资源，迅速使中国变为世界工厂。 对于人口爆炸的担心是多余的。随着人口增加，不从事土地生产的人随之增加，才有可能改造技艺提高技术，发掘新的自然资源，进一步提高土地承载量。为什么工业革命后人口迎来大爆炸，还是新型自然资源的发现（第一次工业革命的煤炭，第二次工业革命的石油，以及后来的电气核能），使得粮食可以大规模机械生产，粮食不再是制约人口发展的因素。至少目前人类社会的生产力可以使全球都过上小康生活，但为什么还有挣扎在生存线上的人，说到底还是分配的问题，不是粮食的问题。 人口，尤其是可以作为人力的人口，是一个国家，一个文明得以发展、繁荣的最根本的前提。目前存在的文明，都是生殖崇拜的，那些抵御生育的文明，早已自绝于历史了。人是文明的载体，是国家的基本构成单位。当今世界的竞争，其实就是人力的竞争，高水平人力的竞争，只有人口到达一定规模，才会出现一定量的高智力人口，才能推动科技进步，技术创新，经济发展。 日本，目前陷在低生育泥潭中无法自拔，经济也是失去了三十年，后面会不会失去四十年，五十年，如果看人口结构的话，我想会的。 中国的GDP总量按照现在发展往后推测，大概率超过美国。但是否永远领先美国呢，还是要看人口，人口结构，人力资源数量。美国是一个移民国家，可以直接从全世界掠夺现成劳动力而不用负担20余年的养育投入，目前美国的生育率2021年是1.66，虽然不及世代更替要求的2.1，但是远比中国的2020年的1.3高，况且美国人口结构要远比中国健康。未来的国际竞争，中美竞争，人口是基本盘。 有人说，人口少，放烟花，你不干，有的是人干。但是，说这些话的人没有想过，人口的萎靡，带来的是市场的萎缩，就业岗位的锐减，社会活力的减少，新型岗位（如当前的新能源）的消失，怕到时候不是人口少了生活更简单，而是有工作的人更卷，来保住来之不易的岗位，同时消费策略更保守，反过来使得市场规模的进一步向下。这个时候怕是屋漏偏逢连夜雨。现在人口塌缩，直接反应在婴幼儿市场的萎靡，等5到6年后，又会传导到中小学，包括后面的高校，以及各行各业。人口下滑问题不是立竿见影的，而是几十年的周期后才能显现。我们要做的就是未雨绸缪。 现在人口低生育陷阱问题的接力棒回到了中国。 中国低生育的问题，非常复杂，但可以抽茧剥丝，寻找底层逻辑。主要核心原因，养育成本太高。 高房价，以及家长对孩子过高的教育投入，使得养育成本不断攀升。同时，城市规划不合理，房价奇高导致家庭一般首房只能小三居甚至是两局，就会出现类似于细胞分裂的接触抑制，这种情况家庭基本不会考虑多要娃。而且，现在独生子女观念深入人心，家家只生一个娃，对于生多个娃的家庭就是不公平的。因为全家之力凝聚在一个娃身上的家庭要远比多娃家庭的孩子更有竞争力，导致大家都不敢多生，陷入鸡娃竞赛中，养育成本不断攀升。中国用养育三个娃的成本只养了一个娃（养娃的成本是边际递减的，第二个娃成本是第一个娃的60%，第三个娃是第一个娃的20%），结果却只产生了一个娃的生产力。况且，现在养儿防不了老，甚至会啃老，又不说养娃给女性在职场上带来的负面影响，养娃已经完全是一个亏本买卖，除了大自然基因繁衍的原始欲望或者家长特别喜欢小孩的心情等，现在90后们但凡会算账，在生孩子问题都会三思而行。 对于个人，养娃是一辈子的大事，不得不深思，如果只顾自己的欲望生娃，那将是对娃最大的不负责任。 对于国家，生孩子却是一个国家，一个民族，一个文明能持续发展，在国际中争夺话语权，让民族屹立于世界之林的头等大事。没有了人口，啥都是海市蜃楼，无源之水，无根之木，空中楼阁。 人口不是负担，而恰恰是一个国家最宝贵的财富。一个国家的兴衰总是伴随着人口的兴衰，须知，存人失地，人地皆存，存地失人，人地皆失! 文章首发 https://www.zhihu.com/question/316068996/answer/2768000787","categories":[{"name":"杂记","slug":"杂记","permalink":"https://sunyunzeng.com/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"思考","slug":"思考","permalink":"https://sunyunzeng.com/tags/%E6%80%9D%E8%80%83/"}]},{"title":"浅谈蒙特卡罗算法","slug":"浅谈蒙特卡罗算法","date":"2022-01-03","updated":"2022-11-05","comments":true,"path":"浅谈蒙特卡罗算法/","link":"","permalink":"https://sunyunzeng.com/%E6%B5%85%E8%B0%88%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E7%AE%97%E6%B3%95/","excerpt":"","text":"算法介绍蒙特克罗算法（Monte Carlo method）是以概率统计理论为指导的、通过随机抽样来解决复杂计算问题的方法。 而蒙特卡罗是南欧小国家摩纳多的一个著名的赌城，因为赌博意味着概率，而蒙特卡罗算法就是大数定理的应用。 蒙特卡罗算法的现代起源是美国的曼哈顿原子弹计划。S.M.乌拉姆（美国数学家）和冯·诺依曼为了计算中子在原子弹内的扩散和增殖情况，首先提出蒙特卡罗算法通过现代计算机模拟计算中子复杂的变化情况。 当时 S.M.乌拉姆（美国数学家）将中子在原子弹内的扩散和增殖问题等价为求解高维玻尔兹曼方程（高维偏微分方程），然后将求解高维玻尔兹曼方程（高维偏微分方程）又等价为转化成相应形式的随机问题，并通过计算模拟进行求解。 求解高维玻尔兹曼方程（高维偏微分方程）非常复杂，可以通过蒙特卡罗抽样不断逼近真实解。 应用案例求解圆周率 Π通过在圆的最小外接矩形内随机生成采样点，分别统计采样点落在圆内的数量及圆外的数量，最终得出圆周率： $\\frac{Area of Circle}{Area of Square} = \\frac{\\pi r^2}{\\left(2r\\right)^2}=\\frac\\pi4$ 求解积分积分就是求积分函数下面对应的面积，在统计范围内生成大量的采样点，并分别统计采样点落在积分函数上下的数量，得到积分数值 下面函数在 (1,1) 点的取值为1，所以整个红色区域在一个面积为1的正方形里面。在该正方形内部，产生大量随机点，可以计算出有多少点落在红色区域（判断条件 y &lt; x2）。这个比重就是所要求的积分值。 模拟随机过程通过蒙特卡罗算法来模拟博彩过程： 赌徒和庄家对赌抛硬币，如果为正面，本轮赌徒赢，庄家付给赌徒1元，结果为反面，本轮赌徒输，赌徒付给庄家1元。赌徒有初始赌本10元，手上的钱一旦输光则退出赌局，如何来模拟这个博彩过程？ 我们首先来分析一下这个过程，赌徒的博彩结果本质上依托于每次抛掷硬币的结果，每一轮博彩就是一个伯努利试验，赢的概率是p=0.5，博彩的过程就是由这一串伯努利试验构成的伯努利随机过程，每轮赌局中，如果赢则赌本增加1元，输则赌本减少1元。 当然了，如果对某一个特定的赌徒，一旦开始进入赌局，则最终由每轮赌局结果构成的序列就是唯一的。那么如果我们想观察整个博彩过程的整体特征，我们该怎么办？好办，还是使用之前讲过的蒙特卡罗方法，采用大量的样本，最终观察样本结果的整体特征。 我们为了说明问题，采用的样本数为赌徒数1000000个，轮数分别为轮数为100,1000,10000轮，也就是每个赌徒最多和庄家分别对赌100,1000,10000轮，如果在这个过程中输光了赌本，则提前退出，如果到100,1000,10000轮还有赌本，赌局也停止。 123456789101112131415161718192021222324import pandas as pdimport randomsample_list = []person_num = 100000round_num = 10000for person in range(1, person_num + 1): money = 10 for round in range(1, round_num + 1): result = random.randint(0, 1) if result == 1: money = money + 1 elif result == 0: money = money - 1 if money == 0: break sample_list.append([person, round, money])sample_df = pd.DataFrame(sample_list, columns=[&#x27;person&#x27;, &#x27;round&#x27;, &#x27;money&#x27;])sample_df.set_index(&#x27;person&#x27;,inplace=True)print(&quot;总轮数:&#123;&#125;,总人数:&#123;&#125;&quot;.format(round_num,person_num))print(&quot;输光赌本提前出局的人数:&#123;&#125;&quot;.format(person_num-len(sample_df[sample_df[&#x27;round&#x27;]==round_num])))print(&quot;赌满全场且盈利的人数:&#123;&#125;&quot;.format(len(sample_df[sample_df[&#x27;money&#x27;]&gt;10])))print(&quot;赌满全场且亏损的人数:&#123;&#125;&quot;.format(len(sample_df[sample_df[&#x27;money&#x27;]&lt;=10][sample_df[&#x27;money&#x27;]&gt;0]))) 运行结果： 1234总轮数:100,总人数:100000输光赌本提前出局的人数:31148赌满全场且盈利的人数:44458赌满全场且亏损的人数:23923 1234总轮数:1000,总人数:100000输光赌本提前出局的人数:75154赌满全场且盈利的人数:23441赌满全场且亏损的人数:1386 1234总轮数:10000,总人数:100000输光赌本提前出局的人数:91902赌满全场且盈利的人数:8060赌满全场且亏损的人数:38 从结果中不难发现，这种和庄家1:1的对赌，随着轮数的增加，基本上都破产被收割了。换句话说，哪怕庄家不出千，输赢概率各半，赌的越久，基本上都是输光破产走人，原因是什么？原因是庄家的资金量是无穷的。 接受拒绝采样例子：要求函数 $f(Z)$ 关于分布 $𝑝(𝑍|𝑋)$ 的期望，而期望的本质是求积分 \\int_{-\\infty}^{+\\infty}p(z\\vert x)f(z)\\operatorname dz ，而这个积分往往非常难求，可以根据分布 $𝑝(𝑍|𝑋)$ 采出 𝑁 个采样点， z^{(1)},z^{(2)},z^{(3)},\\cdots,z^{(N)}\\sim p(z\\vert x)\\\\ ，用样本均值来近似期望： \\frac1N{\\textstyle\\sum_{i=1}^N}f(z^i)\\approx\\\\ \\int_{-\\infty}^{+\\infty}p(z\\vert x)f(z)\\operatorname dz 但如果分布 $𝑝(𝑍|𝑋)$ 非常复杂，很难根据分布进行采样，此时采用接受拒绝采样方法实现复杂概率分布的样本采样。 首先我们采用一个已知的简单的概率密度函数 $𝑔(𝑥)$ 和常数值 $𝐶$，保证$C∗𝑔(𝑥)≥𝑝(𝑥)$，从分布 $𝑔(𝑥)$ 中获取一个采样样本 $𝑌$，也就是从累积分布函数中按照 $[0,1]$ 均匀分布采样一个概率，然后取得一个样本值。 从 $[0,1]$ 均匀分布中获取一个采样成本 $𝑈$，如果 \\frac{p(Y)}{C\\ast g(Y)}\\geq U\\\\，就接受这个采样值 $𝑌$，否则拒绝该采样，不断重复该过程，最终获得服从 $𝑝(𝑥)$ 分布的样本值。 也就是猜出的样本有 $𝑈$ 的概率被接受，有 $1-𝑈$ 的概率被拒绝。 总结 蒙特卡洛方法的思想是使用随机数来进行场景的模拟或者过程的仿真，通过不断增加采样点，逐渐逼近真实解。 其在在金融工程学，宏观经济学，计算物理学等领域应用广泛，主要应用包括但不局限于近似计算不规则面积/体积/积分、模拟随机过程、结合接受-拒绝采样来对分布的未知参数进行统计推断。 蒙特卡洛检测的优点能够简单快速地快速求解复杂问题，结合计算机大量样本的采样实验，以频率逼近概率。 参考： 知乎*如何通俗地理解「蒙特卡洛方法」，它解决问题的基本思路是什么，目前主要应用于哪些领域？ 蒙特卡罗方法入门 B站*蒙特卡洛（Monte Carlo, MCMC）方法的原理和应用","categories":[],"tags":[]},{"title":"理解最大似然估计与最大后验估计","slug":"理解最大似然估计与最大后验概率","date":"2021-04-01","updated":"2022-11-05","comments":true,"path":"理解最大似然估计与最大后验概率/","link":"","permalink":"https://sunyunzeng.com/%E7%90%86%E8%A7%A3%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E4%B8%8E%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87/","excerpt":"","text":"最大似然估计最大似然估计（Maxiumum Likelihood Esimation, MLE）是频率学派对概率模型的一种参数估计方法。 它要解决的问题是，针对一定数量的独立重采样得到的样本，如何找到模型的参数 $\\theta$，使得样本采样结果出现的概率最大。 具体来说，假设我们知道人身高的分布是正态分布，及概率密度函数的形式为： f\\left(x\\right)=\\frac1{\\sqrt{2\\pi}\\sigma}exp\\left(-\\frac{\\left(x-u\\right)^2}{2\\sigma^2}\\right)其中，人身高的采样是独立同分布的，也就是你的身高不与别人的身高有关，且你们的身高服从同样的分布，即正态分布。 我们通过问卷调查，获得的一定数量人高的样本，然后估计身高分布模型的参数值方差 $\\sigma$ 和均值 $\\mu$。 似然函数数学上采用似然函数来解释样本已知，而模型参数未知的情况。 似然函数 $f\\left(x\\left|\\theta\\right.\\right)$ 指样本 $x$ 已知，而模型参数 $\\theta$ 未知的函数。 假使模型的参数 $\\theta$ 已知，而样本 $x$ 未知的函数 $f\\left(\\theta\\left|x\\right.\\right)$ 为概率函数。 这有点像”一菜两吃“的意思，比如数学函数 $f(x,y)=x^y$，如果参数 $x$ 为定值，例如 $x=2$，则函数变为指数函数 $f(x,y)=2^y$；而如果 $y$ 为定值，例如 $y=2$，则函数变为二次函数。 因为似然函数的样本 $x$ 服从独立同分布，因此似然函数 $\\begin{array}{l}f(x_1,x_2,…,x_n\\left|\\theta\\right.)\\end{array}$ 可以变为独立同分布的样本求联合概率： \\begin{array}{l}f(x_1,x_2,...,x_n\\left|\\theta\\right.)\\\\=f(x_1\\left|\\theta\\right.)f(x_2\\left|\\theta\\right.)...f(x_n\\left|\\theta\\right.)\\\\={\\textstyle\\prod_{i=1}^n}f(x_i\\left|\\theta\\right.)\\end{array}求模型参数例子 考虑这样一个例子，一个不透明的盒子里有黑白两种颜色的小球，有放回的进行100次抽取，记录下每次抽取小球的颜色，结果出现了80次黑色小球，20次白色小球，那么求盒子里的黑白两种颜色小球的分布情况？ 转化为似然函数的问题，合理里其实黑白两种小球的分布已知，也就是说盒子中黑白小球的分布构成了模型，模型的参数已知，如何根据黑白球的采样情况，求盒子黑白球分布的情况。 我们假设黑球占比为 $p$，那么白球的占比就为 $1-p$，那么黑球每次被去取出的概率就等同于黑球的占比 $p$，因此，这次采样的似然函数为： \\begin{array}{l}f(x\\left|\\theta\\right.)=p^{80}(1-p)^{20}\\\\\\end{array}那么，模型的参数可以说有无穷种情况，如何计算模型的参数 $p$ 呢？ 极大似然估计的思想就是，使当前采样情况出行概率最大的模型参数，为求得的结果，即使似然函数取得极大值。 因此要求得黑白球分布模型，即使似然函数取得极大值，也就是对似然函数求导，使导数为零，即为结果。很容易计算得到 $p＝0.8$。 应用其实我们日常生活中无意中就采用了极大似然估计的思想。 例子1 我们想进一步统计全国人民的身高分布的模型参数，虽然我们知道模型为某一种正态分布，但是我们无法对 14 多亿全国人民都逐一统计各自的身高。这时候，我们可以随机对各省的一部分人进行采样。因为这些省份各人间的身高为独立同分布的，所以可以基于这些样本，基于最大似然估计获得一个身高分布模型。该模型就可以近似的符合全国人民身高的分布模型。 频率派认为全国人民身高模型是一定的，就像柏拉图的理想型。通过不断的扩大样本的数量，就可以逼近这个背后真正的模型。 而贝叶斯派则认为模型本身也是不定的，这个模型初始有一个参数，可由先验知识获得，然后通过不断的采样修正我们的模型，使得最终的后验概率最大。 最大后验估计最大后验估计是贝叶斯派的法宝，代表了另外一种看待世界的角度。 贝叶斯学派认为，对于要估计的模型人们会有一个预判，例如抛掷硬币正反硬币出现的次数应该五五开，这个预判就是先验函数 $p(\\theta)$ 然后根据实际采样不断调整对这个模型参数进行调整，也就是说，这个模型参数本身是不能确定的，我们只能通过不断的实验逐渐获得最合理的模型参数，这一点就完全区别于频率学派的。 贝叶斯公式最大后验估计的核心就是贝叶斯公式： \\begin{array}{l}f(\\theta\\left|X\\right.)=\\frac{f(X\\left|\\theta\\right.)\\times p(\\theta)}{p(X)}\\\\\\end{array}其中 $f(\\theta\\left|X\\right.)$ 为后验概率， $p(\\theta)$ 为先验估计，而 $f(X\\left|\\theta\\right.)$ 为前面讲的似然函数， $p(X)$ 为边缘概率，可以简单的理解为一个归一化常数。 贝叶斯公式已经成为机器学习的核心算法之一，诸如拼写检查、语言翻译、海难搜救、生物医药、疾病诊断、邮件过滤、文本分类、侦破案件、工业生产等诸多方面都有很广泛的应用，它也是很多机器学习算法的基础。在这里，有必要了解一下贝叶斯公式。 贝叶斯公式是以英国学者托马斯·贝叶斯(Thomas Bayes)命名的。1763年Richard Price整理发表了贝叶斯的成果《An Essay towards solving a Problem in the Doctrine of Chances》，这才使贝叶斯公式展现在世人的面前。 贝叶斯公式是为了解决”逆概”;问题而提出的。正概问题很常见，比如不透明袋中有黑球M个,白球N个，随手抓起一个球，求是黑球的概率，大家心算一下就能知道是 $\\frac{M}{M+N}$。当然，生活中有大量这样的例子，像人口流动统计、金融统计等等，这些统计的特征就是我们事先已经知道了所有样本的分布情况，在此基础上进行概率的计算，这就是“正概”问题。但是，如果我们不知道所有样本的信息（这样的例子比比皆是，例如物理学中我们不可能看到所有电子的运行状态，所以只能通过实验模拟观察大多数的情况去建立最合适的模型去解释），同时我们又想知道样本的概率怎么办呢？贝叶斯公式的作用就体现出来了。 还是一个袋子中装着若干小球，里面有黑色跟白色，我们随机取出一些小球，然后根据小球的情况去计算袋中小球实际的分布情况。此时我们可能有很多种模型（猜测）去解释，随着取出小球数量的增加，我们的模型也越来越精确，越来越逼近实际的情况，然后我们从这些模型中找出最贴合实际的。总结来说：不同模型的求解就是计算不同的后验概率（事件已经发生，求某种因素导致该事件发生的概率），对于连续的猜测空间是计算概率密度函数；模型比较如果不考虑先验概率（根据以往的经验和分析获得的概率）则运用了最大似然估计。这就是贝叶斯思想的核心。 下面我举一个例子：一所学校里面有 60% 的男生，40% 的女生。男生总是穿长裤，女生则一半穿长裤一半穿裙子。有了这些信息之后我们可以容易地计算“随机选取一个学生，他（她）穿长裤的概率和穿裙子的概率是多大”，这个就是前面说的“正向概率”的计算。然而，假设你走在校园中，迎面走来一个穿长裤的学生（很不幸的是你高度近似，你只看得见他（她）穿的是否长裤，而无法确定他（她）的性别），你能够推断出他（她）是男生的概率是多大吗？ 一些认知科学的研究表明（《决策与判断》以及《Rationality for Mortals》第12章：小孩也可以解决贝叶斯问题），我们对形式化的贝叶斯问题不擅长，但对于以频率形式呈现的等价问题却很擅长。在这里，我们不妨把问题重新叙述成：你在校园里面随机游走，遇到了 N 个穿长裤的人（仍然假设你无法直接观察到他们的性别），问这 N 个人里面有多少个女生多少个男生。 你说，这还不简单：算出学校里面有多少穿长裤的，然后在这些人里面再算出有多少女生，不就行了？ 我们假设全校总共有H个学生，其中男生（都穿长裤）占60%，只有50%女生穿长裤。我们首先计算穿长裤的人数：H*P(Boy)*P(Pants|Boy)+H*P(Girl)*P(Pants|Girl)，其中P(Boy)为男生比例，P(Pants|Boy)为男生中穿长裤的比率（此题中为100%），女生同理。其中创长裤的女生共有H*P(Girl)*P(Pants|Girl)个，两者一比，我们就得到： P(Girl|Pants)=\\frac{P(Girl)*P(Pants|Girl)}{P(Boy)*P(Pants|Boy)+P(Girl)*P(Pants|Girl)} 式1 而这里面男生女生可以泛指一切事物，所以通用公式为： P(B|A)=\\frac{P(B)*P(A|B)}{P(B')*P(A|B')+P(B)*P(A|B)} —-（B’为B的互补，例如男生女生） 式2 其实分母就是指所有穿长裤的人的概率P(Pants)也就是P(A)，分子是女生中穿长裤与是女生同时发生的概率，也就是P(Pants,Girl)或者说P(A,B),所以式2(全概率公式的一种特殊情况）又可以写为： P(B|A)=\\frac{P(A,B)}{P(A)} 式3 又可以写为 P(B|A)*P(A)=P(A,B) 式4 同理，我们可以得到P(A|B)*P(B)=P(A,B)，所以： P(A|B)*P(B) = P(B|A)*P(A)，即： P(A|B)=\\frac{P(A)*P(B|A)}{P(B)} 式5 式3或式4也就是贝叶斯公式。其实式2是一个问题共有两种分类时的情况，例如性别、掷硬币等只有两种情况，现实生活中很多是由多种情况构成，一件事情可能由多个原因影响，那么推广开来，就是贝叶斯公式的通式。如图1-1所示，一个事物有两个影响要素A和B，面积的大小对应发生的概率大小，C事件的发生受到A和B要素的影响。如果计算在C事件发生是受到A事件影响的概率P(A|C)，就是计算A∩C与C的面积之比，也就是P(A∩C)/P(C),P(A∩C)又可以写为P(A,C)，因为P(C|A)表示A条件下C事件发生的概率，P(A)表示A事件发生的概率，即A的面积，所以P(A)*P(C|A)即A∩C的面积，也就是即A和C同时发生的概率P(A,C)。就得到P(A∩C)=P(A)*P(C|A), 同理：P(B∩C)=P(B)*P(C|B),因为得到 P(A|C)=P(A)*P(C|A)/(P(A)*P(C|A)+P(B)*P(C|B))。这是一个事物的影响因素由两个组成的情况，我们把所有情况统一起来就是全概率公式: 贝叶斯推断什么是贝叶斯推断贝叶斯推断（BAYESIAN INFERENCE）是一种应用于不确定性条件下的决策的统计方法。贝叶斯推断的显著特征是，为了得到一个统计结论能够利用先验信息和样本信息。 通俗来讲，我想知道A事件的发生，如果没有任何的先验知识，我只能做出它发生与不发生的概率各占50%的判断。但是，幸运的是我知道B事件发生了，根据两者的关联经验，我知道它对A事件的发生起到促进作用，所以我可以更加准确的判断A事件是大概率发生的（如80%），而不是起初的非零即一的50%。如果我有更多A的关联事件，那么我可以做出更加准确的判断，这就是贝叶斯推断。 我们还是看式5：$P(B|A)=\\frac{P(A)*P(B|A)}{P(B)}$，P(A)是我们的先验概率，(Prior probability)，即在B事件发生之前，我们对A事件概率的一个判断。P(A|B)称为”后验概率”（Posterior probability），即在B事件发生之后，我们对A事件概率的重新评估。$\\frac{P(B|A)}{P(B)}$ 称为”可能性函数”（Likelyhood），这是一个调整因子，使得预估概率更接近真实概率。 为了更直观的解释贝叶斯推断，这里举一个维基百科的例子——吸毒监测： 假设一个常规的检测结果的敏感度与可靠度均为99%，即吸毒者每次检测呈阳性（+）的概率为99%。而不吸毒者每次检测呈阴性（-）的概率为99%。从检测结果的概率来看，检测结果是比较准确的，但是贝叶斯定理却可以揭示一个潜在的问题。假设某公司对全体雇员进行吸毒检测，已知0.5%的雇员吸毒。请问每位检测结果呈阳性的雇员吸毒的概率有多高？ 令“D”为雇员吸毒事件，“N”为雇员不吸毒事件，“+”为检测呈阳性事件。可得 P(D)代表雇员吸毒的概率，不考虑其他情况，该值为0.005。因为公司的预先统计表明该公司的雇员中有0.5%的人吸食毒品，所以这个值就是D的先验概率。 P(N)代表雇员不吸毒的概率，显然，该值为0.995，也就是1-P(D)。 P(+|D)代表吸毒者阳性检出率，这是一个条件概率，由于阳性检测准确性是99%，因此该值为0.99。 P(+|N)代表不吸毒者阳性检出率，也就是出错检测的概率，该值为0.01，因为对于不吸毒者，其检测为阴性的概率为99%，因此，其被误检测成阳性的概率为1 - 0.99 = 0.01。 P(+)代表不考虑其他因素的影响的阳性检出率。该值为0.0149或者1.49%。我们可以通过全概率公式计算得到：此概率 = 吸毒者阳性检出率（0.5% x 99% = 0.495%)+ 不吸毒者阳性检出率（99.5% x 1% = 0.995%)。P(+）=0.0149是检测呈阳性的先验概率。用数学公式描述为： 据上述描述，我们可以计算某人检测呈阳性时确实吸毒的条件概率P(D|+)： 尽管吸毒检测的准确率高达99%，但贝叶斯定理告诉我们：如果某人检测呈阳性，其吸毒的概率只有大约33%，不吸毒的可能性比较大。假阳性高，则检测的结果不可靠。 同时，我们可以计算一下假如一个人吸毒，但他误检测成阴性的概率P(D|-)： $P(D|-)=\\frac{P(-|D)P(D)}{P(-|D)P(D)+P(-|N)P(N)}$ =$\\frac{0.01×0.005}{0.01×0.005+0.99×0.995}$ ≈0.0000507 可见，一个人吸毒但被误检测为阴性的概率只有0.005%，也就是说一个人如果检测为阴性，则基本可以判定他没有吸毒。但是一个人如果监测为阳性，则只有33%的概率确定他吸毒。这在跟很多医学监测当中的案例很相似，假阳性比假阴性更值得我们关注！ 贝叶斯推断与拼接纠正贝叶斯推断其实有很多应用，例如语言翻译、中文分词、图像识别等，很多博客也以拼写纠正作为示例，这里我就详细讲一下拼写纠正的过程。 经典著作《人工智能：现代方法》的作者之一 Peter Norvig 曾经写过一篇介绍如何写一个拼写检查/纠正器的文章，详情戳这里。 用户在输入过程中，难免会遇到拼写错误的情况，我们要做的就是给出一个或几个纠正后的用户本来想要输入的单词推荐。这里的一个关键问题就是：用户到底想要输入什么单词？ 其实用数学的语言来描述，就是要求出P(我们猜测用户要输入的单词|用户实际输入的单词)的大小。 用T表示我们猜测用户输入的单词，用S表示用户实际输入的单词，那么就是求P(t|S) = $\\frac{P(S|t)×P(t)}{P(S)}$ 的大小。 对于同一个单词，P(S)的概率是一样的，那么就等价于P(t|S)∝ P(S|t)×P(t)。 ∝是正比于，不是无穷大 那么要是的P(t|S)最大，就是使得P(S|t)×P(t)最大。 P(S|t)名义上是指我们猜测的单词t是用户真正想输入单词的概率，不同的单词概率不同，这就涉及到最大似然估计。例如用户输入的单词是thriw,这时throw跟thraw都有可能，但是你会想到，o跟i很接近，用户可能要输的单词是throw的可能性比thraw的可能性大得多，根据最大似然估计找出最可能的单词。但是，有时候光有最大似然并不能完美的解决问题，我们还需要利用先验概率P(t)。 P(t)使我们猜测的单词出现的概率，这些单词t1、t2、t3….理论上有无穷种，但它是一种先验概率，对于单词来说，可能有点抽象。这里举一个分词的例子： The girl saw the boy with a telescope. 如果仅用最大似然估计方法的话，可能会给出两种结果：1 The girl saw | the boy with a telescope 2.The girl saw the boy | with a telescope 但是根据我们的常识，一个女孩看着一个拿着望远镜的男孩？拿着望远镜有点莫名其妙，与“看”这个动作联系起来，那么最合适的解释恐怕是女孩拿着望远镜看那个男孩。那么得出这个结论，就是用到我们的先验知识，也就是P(t)。 参考 一文搞懂极大似然估计 聊一聊机器学习的MLE和MAP：最大似然估计和最大后验估计 机器学习核心算法之——贝叶斯方法 数学之美番外篇：平凡而又神奇的贝叶斯方法","categories":[{"name":"算法","slug":"算法","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://sunyunzeng.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"理解最小二乘法","slug":"理解最小二乘法","date":"2021-03-30","updated":"2022-11-05","comments":true,"path":"理解最小二乘法/","link":"","permalink":"https://sunyunzeng.com/%E7%90%86%E8%A7%A3%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/","excerpt":"","text":"何为最小二乘 最小二乘法是十九世纪统计学的主题曲。从许多方面来看, 它之于统计学就相当于十八世纪的微积分之于数学。 ——史蒂芬·史蒂格勒的《The History of Statistics》 最小二乘是一种从一系列测量值中，计算最可能真值的数学方法。 小明真实的体重在探讨何为最小二乘时，先思考这个问题： 小明是一个健身爱好者，对自己的体重要求非常苛刻，因为这涉及到下一步的训练计划与饮食安排。为了能精确测量出自己的体重，他在市场上购买了9个都号称世界最准的体重秤（小明是个土豪）。 我们知道百分百准确的体重秤是不存在的，这种理想秤只存在于商家的口中。 那么，如何根据这9个比较准确的体重秤，测量出小明的真实体重呢？ 可能的计算方案假设每个体重秤测出小明的体重值分别为 $y_1,y_2,y_3,…,y_9$，那么可能存在以下几个方案： 取平均值 $\\frac{y_1+y_2+y_3+…+y_9}9$ 取中位数 $medium({y_1,y_2,y_3,…,y_9})$ 取极大值或极小值 取几何平均数 取调和平均数 掷色子 看心情 有很多种方案，到底哪一种才是最合理的呢？ 法国数学家，阿德里安-马里·勒让德（1752－1833）提出让总的误差的平方最小的 $y$ 就是真值，因为他假设如果测量误差是随机的话，测量值应该围绕真值上下波动。取误差平方和的原因是为了将正负误差都统一用正数值表示。 马里·勒让德假设的体重误差和的数学表达式为： S_{϶^2}=\\overset9{\\underset{i=1}{min(\\sum\\left(y-y_i\\right)^2)}}这是一个二次函数，其导数为 0 时，取得极小值： \\begin{array}{l}\\frac d{dy}S_{϶^2}=\\frac{\\displaystyle d}{\\displaystyle dy}\\sum\\left(y-y_i\\right)^2=2\\sum\\left(y-y_i\\right)\\\\=2\\left(\\left(y-y_1\\right)+\\left(y-y_2\\right)+...+\\left(y-y_9\\right)\\right)=0\\end{array}进而： 9y=y_1+y_2+y_3+...+y_9\\;\\;\\Rightarrow y=\\frac{y_1+y_2+y_3+...+y_9\\;}9确定了体重的算术平均数的确使得误差的平方和最小，也就是测量的9次体重最有可能围绕所测体重记录的平均值波动。 即测量值的平均值是最可能的真值，也是最好的计算方案。 这也就是最小二乘法的精髓，二乘即平方，最小二乘，即测量值与真值间的误差平方和最小。 这里的测量值是简单的线性函数，其实它可以为一个非线性函数 $f(x)$。 S_{϶^2}=min(\\sum\\left(y-f(x)\\right)^2)其取极小值时的 $y$ 为最可能的值。 测量误差的正态分布对于马里·勒让德，数学小王子，高斯（1777－1855）心存怀疑，这个假设如果是错的咋办？ 于是他用概率统计的框架对其进行验证。 他首先假设每次测量值 $x_i$ 与真值 $x$ 的测量误差 $϶_i=x-x_i$ 服从一个概率分布，对应的概率密度函数为 $p(϶)$ 假设所有的测量构成一个联合概率 $L(x)$ ： \\begin{array}{l}L(x)=p(\\backepsilon_1)p(\\backepsilon_2)p(\\backepsilon_3)...p(\\backepsilon_9)\\\\=p(x-x_1)p(x-x_2)p(x-x_3)...p(x-x_9)\\end{array}根据极大似然估计的思想，联合概率最大的最应该出现，即： \\frac d{dx}L(x)=0如果最小二乘时对的，那么应该在测量值的平均值 $ \\vec x = \\frac{x_1+x_2+x_3+…+x_9}9$ 处取得极值，即： \\frac d{dx}L(x)\\vert_{x=\\vec x}=0解这个微分方程，得到： p(϶)=\\frac1{\\sigma\\sqrt{2\\pi}}e^{-\\frac{϶^2}{2\\sigma^2}}得到正态分布的概率密度函数，也就是说如果马里·勒让德说的“真值回围绕测量值上下波动，那么用最小二乘法得到的值即为最可能的值”是对的，那么测量误差服从正态分布。 而且，这个过程倒推也成立，也就是说如果测量误差服从正态分布，那么最小二乘得到的值即为最可能的值，即： x=\\vec x\\Leftrightarrow p(϶)=\\frac1{\\sigma\\sqrt{2\\pi}}e^{-\\frac{϶^2}{2\\sigma^2}}那么测量误差 $p(϶)$ 是否服从正态分布呢？ 这就涉及到概率论里面的中心极限定理： 样本的平均值约等于总体的平均值。不管总体是什么分布，样本的平均值总会落到总体的平均周围，且成正态分布。 对于体重测量问题而言，体重值是被测量出来的，体重值的均值就是小明最可能的体重值，而体重值的均值的分布服从正态分布。 因此测量的误差也服从正态分布，因为测量误差会影响到均值的分布。 虽然马里·勒让德提出了最小二乘法，但是高斯从概率论上验证了最小二乘的合理性，真正奠定了最小二乘法的地位。 总结 最小二乘通过测量值与真值间的误差平方和最小，得到最可能的值。 测量值有可能需要用更复杂的函数表达。 高斯验证了对于多次测量而言，测量值的算数平均值就是最可能的值，因为测量误差服从正态分布。 参考： 知乎*最小二乘的本质是什么？ 知乎*如何理解似然函数","categories":[{"name":"算法","slug":"算法","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://sunyunzeng.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"浅谈区块链与比特币","slug":"浅谈区块链与比特币","date":"2021-03-27","updated":"2022-11-05","comments":true,"path":"浅谈区块链与比特币/","link":"","permalink":"https://sunyunzeng.com/%E6%B5%85%E8%B0%88%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81/","excerpt":"","text":"什么是区块链和比特币？有人说区块链是新一代价值互联网，有人说它是最慢的数据库，有人说区块链是一项类似于蒸汽机一样巨大的发明创新，也有人说区块链是一个巨大的庞氏骗局。到底什么是比特币，为什么它这么火？本篇文章将带你揭示比特币的前世今生。 区块链跟比特币的定义 区块链是一种去中心化的分布式记账本，而比特币是账本中所记录的数字货币的一种实现。 作为区块链的一种实际应用，比特币（Bitcoin）的原型是由中本聪（Satoshi Nakamoto）在2008年11月1日发表的一篇论文中提出的。比特币的真正诞生是在2009年1月3日。到今天为止，比特币的市值已经水涨船高，一枚比特币的价值高达55484.70美元，合362869.94元人民币！ 比特币白皮书 比特币白皮书中文版 区块链要解决什么问题？既然区块链是一种去中心化的货币结算体系，那么原来的货币结算体系有什么问题呢？中本聪在论文的原文讲到：中心化的金融机构由于信任问题，不可避免在交易过程中存在仲裁与纠纷，就导致无法实现不可撤销的交易，在撤销过程中会导致额外的支付成本。当然，这只是现有中心化货币体系不可避免的问题，而区块链基于分布式存储技术跟密码学，实现了交易的不可撤销性，通过去中心化金融机构的方式，实现点对点的交易，目的是通过加密上的可靠性解决人们之间的信任问题，从而提高效率。 互联网通过提高信息传播的速度来提高效率；区块链通过降低信任成本提高效率。 区块链的工作原理区块链是价值互联网，人们间的财富通过比特币的数量度量，比特币的交易记录代表的是价值的交换。比特币本身是一种加密货币（crypto-currency），是一种虚拟的数字货币，由一串复杂代码组成。基于密码学的设计确保了比特币的所有权不能被篡改，同时保持了一定的匿名性。 区块链为了实现分布式货币体系的功能，需要解答以下几个问题： 怎么记账？ 怎么转账？ 由谁发行货币？ 怎么记账？区块就是记账本，记账操作由区块完成。当一笔交易发生时，需向全体区块广播，然后所有区块都记录下这笔交易信息，完成记账。 区块 区块就是一个带有时间戳的记账本，链就是哈希指针，将区块相连。 区块分布在不同的网络节点中，且是分布式的。区块的组成包括块头（Block Header）跟块体（Block Body）。 块头：记录了区块链的版本、指向前一个区块块头的哈希指针（对前一个区块块头算哈希值）、Merkle tree的根哈希值、目标域（target）和随机数（nonce）。 块体：保存交易列表 其中目标域和随机数是挖矿用到的参数，而哈希指针就是连接区块的链。 哈希指针既可以指向内容地址（通过结合 key-value 的数据库实现，key为当前区块哈希值，value为指向的前一区块哈希值），又可以保存内容的哈希值。如果内容改变，哈希指针也会相应改变。这样不诚实的区块篡改区块链的交易记录几乎不可能实现，因为一旦不诚实区块的交易记录篡改，该区域的哈希值就会改变，后面所有区块的哈希值都要修改，除非不诚实的区块与后面所有区块串通，这几乎是不可能的。 哈希算法 区块链中的哈希指针通过密码学中的加密哈希算法（cryptographic hash function）计算得到，它具有三个性质： 哈希碰撞 （collision resistance） 哈希碰撞的数学表达为 $x\\neq y\\;H\\left(x\\right)=H\\left(y\\right)$，即不同的输入值得到了相同的哈希值。理论上任何一种哈希算法都不可避免哈希碰撞，因为输入空间是无限大的，而输出空间只有 $2^{256}$（以区块链所用的SHA-256算法为例）。但想制造哈希碰撞，需要通过暴力求解（brute-force）的方法。但是这种做法并不现实，因为计算量实在太大。借用此原理，可以通过检验一段信息（一串字符）的哈希值是否变化来核实这段信息是否被篡改。目前尚没有哈希函数被证明为哈希碰撞的，只能通过实践的经验。没有百分百安全的哈希函数，曾经被认为安全的哈希函数MD5已被找到人为制作哈希碰撞的方法。 计算不可逆（hiding） 哈希函数的计算为单向的，计算过程不可逆。即计算出的哈希值隐藏了输入的任何信息。只能通过暴力的方法，检测哪个输入值的哈希值为目标哈希值。但是只要输入空间足够大，且输入分布比较均匀，各种取值的可能性接近，则难以实现哈希函数的逆运算，除非地球爆炸（SHA-256算法为例）。为了使得输入满足要求，同时将输入加入一个随机数nonce，再一起哈希，即 $H(x\\parallel nonce)$，随机数的分布是比较均匀的。 puzzle friendly 值结果是不可预测的，通过输入值我无法预测将来哈希值的取值范围。主要用于挖矿中工作量证明（proof of work）的计算，通过找到一个比特币块头的随机数nonce，使得 $H(block header)\\leq target$,这个target就是目标哈希值。 Merkle tree 块体中的交易记录通过默克尔树（Markle tree）的结构体来保存。它的结构与二叉树相同，唯一的区别是指针用哈希指针替代。这样做的目的是为了快速计算记录的交易有没有变化。 Merkle tree 主要用来提供 Merkle proof（默克尔证明），来证明一笔交易是否真正发生。Merkle proof的原理是通过比较待验证交易（叶子节点）所最终得到的Merkle tree的根哈希值与轻节点块头保存的根哈希值是否相等即可，需要辅助计算的另一半哈希值由全节点的块体提供。 区块总结 区块的物理实体搭载在一个网络节点中，负责对发生过的比特币交易记账。通过哈希指针与前一个区块相连，避免了不诚实区块对交易内容的篡改。每一笔交易都用一个 Merkle tree 的叶子节点保存，通过哈希指针最终指向根节点。区块的块头只保存Merkle tree根节点的哈希值，用来进行Merkle proof检验。 区块最终会指向第一个区块，被称为创世纪块（genesis block）。 区块链分为全节点与轻节点。 全节点 轻节点 一直在线 不是一直在线 在本地硬盘上维护完整的区块链信息 不用保存整个区块链，只要保存每个区块的块头 在内存里维护UTXO集合，以便快速检验交易的正确性 不同保存全部交易，只保存与自己相关的交易 监听比特币网络上的交易信息，验证每个交易的合法性 无法检验网上发布的区块的合法性 决定哪些交易会被打包到区块里 可以验证挖矿的难度 监听别的矿工挖出来的区块，验证其合法性 只能检测哪个是最长链，不知道哪个是最长合法链 挖矿（决定沿哪条链挖下去）（当出现等长的分叉，选择哪一个分叉） 不能决定挖矿 怎么转账转账需要开户，区块链中的开户不需要向一个中心化的机构申请，只需要自己在本地创建一个公私钥对（比特币中公私钥对生成冲突的概率很小，比地球爆炸的概率还小，这样一个私钥就对应一个唯一的电子身份）。 公私钥对 公私钥对来自非对称加密（asymmetric encryption algorithm），公钥（public key）对内容加密，私钥（privte key）用来解密，同时私钥也可以用来加密，公钥用来解密。对称加密是用同一把密钥实现内容的加密，关键是找到一个安全传输密钥的途径，否则一旦密钥被破解，所加密的内容很容易被窃听或篡改。非对称加密用公钥加密，配对的私钥解密。公钥可以公开，且不能实现解密，私钥保存在本地，无需随内容传输，这样就保证了加密内容的安全，与https协议的原理一致。区块链中的利用非对称加密实现数字签名，对个人信息进行验证，用通讯方的私钥加密，然后用其公钥解密验证。 自己给对方转账只需要对方的地址、要转的比特币数量以及自己的公钥即可。 对方地址根据公钥算哈希再通过一定计算得到，自己的公钥是为了验证这笔交易的数字签名是由自己的私钥生成，验证自己的身份。 双花攻击（double-spending attack） 如果我利用网络的延迟，同时向双发转一笔矛盾的比特币，例如我只有5个比特币，我同时向甲乙两人转5个比特币，就构成了双花攻击。 区块之间除了有哈希指针指向前一个区块，还有指针指向比特币的来源，这样在转账的同时回回溯检测用户到底有没有双花行为，防范双花攻击。 由谁发行货币Coinbase transaction 是生成比特币的唯一方法. 创世纪，即第一个区块链的区块，2009年1月3日由中本聪在位于芬兰赫尔辛基的一个小型服务器上挖出，并获得了50个比特币的奖励。后面每次新块的产生，系统都会给予一定的比特币奖励，这也是比特币的唯一来源。由于比特币像黄金一样供应量极少且数量有限，所以区块的挖掘被成为挖矿。 比特币产生规则：起初的21w个区块会有50个比特币的初块奖励，超过21w个区块后，每个区块会有25个比特币，再超过21w个区块后，每个区块获得到奖励会继续减半，只有12.5个比特币。 Proof of work Proof of work —— CPU算力证明是区块被挖出的方法。因此比特币是跟CPU算力资源挂钩。 区块头有一个 target 目标域，确定了要计算的哈希值的数值范围，只要对区块计算出的哈希值在此范围内，那么这个区块就被挖出。候选区块通过修改区块头中的 nonce 随机数实现对区块哈希值的控制。由于后期挖矿的人不断增加，挖矿的设备也像军备竞赛一样越发豪华（CPU-&gt;GPU-&gt;ASIC芯片 Application Specific Integrated），因此为了保证比特币数量的稳定，通过减小target 目标域提高计算难度。出块难度为10分钟生成一个区块。比特币规定每2016个区块后调整难度阈值，大概两周调整一次。 通过CPU算力选出记账的区块，可以极大避免51%攻击。因为如果攻击者想要控制区块的生成，需要付出超过51%算力的计算资源，成本上是根本不划算的。 最长合法链 如果两个区块同时被挖出，那么区块链都认为两者有效。后续的候选区块可以选择在分叉的区块中任意选择，直到哪一条链的长度率先到达6，就将此链视为最长合法链，然后撤销另一条分叉链。 比特币初期虽然竞争少，奖励多，但当时比特币不值钱，曾经出现过2w个比特币买1个披萨的案例。而现在虽然比特币竞争激烈，所耗电费相当于挪威一年的能源消耗，但价值高。 总结区块链本身是一种理论创新，分布式存储、加密算法以及通讯都是现有的技术。它主要解决中心化货币交易体系因不信任导致的纠纷所带来的支付代价问题，包括一些已有的支付方式无法解决的问题，例如跨境付款，而不是与已有的支付方式做竞争。区块链通过密码学上的不可篡改性，把数据从不可信变成可信。从技术角度看，区块链是互联网发展的一个升级，它和互联网相同的是，能提高社会整体的工作效率；不同的是，互联网从通信速度方面提高效率，区块链从信任角度提高效率。未来的区块链项目关键是看能否可以协助人们解决生产生活中的效率问题，而不能被神话，它的概念也不能被滥用，同时它的监管仍需要很长的路要走。 参考资料 北大《区块链技术与应用》公开课 区块链白皮书 【回形针PaperClip】区块链到底是什么？ 今年世界总发电量的0.6%被用于挖比特币 区块链分享","categories":[{"name":"科技","slug":"科技","permalink":"https://sunyunzeng.com/categories/%E7%A7%91%E6%8A%80/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://sunyunzeng.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"npm 常用命令集合","slug":"npm-常用命令集合","date":"2021-03-20","updated":"2022-11-05","comments":true,"path":"npm-常用命令集合/","link":"","permalink":"https://sunyunzeng.com/npm-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/","excerpt":"","text":"npm 更新命令查看当前 npm 版本 1npm -v 更新到最新版本 1npm install -g npm 更新到指定版本 1npm -g install npm@6.8.0 npm 升级框架的依赖库1. 全局升级 cli 工具 查看版本1hexo version 升级1npm i hexo-cli -g 2. 安装 npm check 工具，检查哪些工具需要升级 12npm install -g npm-checknpm-check 3. 升级依赖包和系统插件 12npm install -g npm-upgradenpm-upgrade 4. 继续升级 12npm update -gnpm update --save","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://sunyunzeng.com/tags/%E8%AF%AD%E6%B3%95/"},{"name":"npm","slug":"npm","permalink":"https://sunyunzeng.com/tags/npm/"}]},{"title":"博客中添加足迹地图","slug":"博客中添加足迹地图","date":"2021-03-16","updated":"2022-11-05","comments":true,"path":"博客中添加足迹地图/","link":"","permalink":"https://sunyunzeng.com/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%B6%B3%E8%BF%B9%E5%9C%B0%E5%9B%BE/","excerpt":"","text":"足迹地图效果展示足迹地图可以展示你过去到访过的地方，以及到访地点的介绍与图片记录，同时不同地标的半径大小表示了访问该地点的频率高低，如下图所示： 其中每个足迹图标都可以点击，点击会弹出左边的介绍栏及对应的介绍文字与图片。图片点击可以放大显示，如下图所示： 足迹地图使用方式克隆足迹地图项目首先，将足迹地图克隆到本地。 1git clone https:&#x2F;&#x2F;github.com&#x2F;SUNYunZeng&#x2F;FootprintMap.git 会得到如下所示的目录结构： 1234567891011121314FootprintMap├─ CNAME├─ css│ ├─ index.css│ └─ jquery-jvectormap-2.0.5.css├─ data│ └─ config.json├─ index.html├─ js│ ├─ index.js│ ├─ jquery-1.9.1.min.js│ ├─ jquery-jvectormap-2.0.5.min.js│ └─ jquery-jvectormap-cn-merc-en.js└─ README.md 配置你的足迹数据其中 /data/config.json 为配置数据，在里面可以配置你的足迹数据，结构如下： 1234567891011121314[ &#123; &quot;latLng&quot;: [36.44852263442782, 118.73921200195313], &quot;name&quot;: &quot;青州&quot;, &quot;desc&quot;: &quot;我的家乡，山东东方——青州，国家著名旅游城市。\\n旅游景点包括云门山、仰天山、驼山、范公亭、青州博物馆、宋城、古街等等。\\n著名美食包括弥河银瓜、老槐树煎包、柿饼、马蹄子烧饼等等。&quot;, &quot;photos&quot;:[ &quot;http://m.qpic.cn/psc?/V115oyNl11FAq7/ETWql2gUF22pNmiMBc.OAZ37OxTay*sinik.eOjVri2aewXK1ZXizNGpMabk*In6gs0SEGmIh82UkaewyV8YgWsu29ZdAYjwW0wjuMdOkzw!/b&amp;bo=VQOAAgAAAAAFF.A!&amp;rf=viewer_4&quot;, &quot;http://m.qpic.cn/psc?/V115oyNl11FAq7/ETWql2gUF22pNmiMBc.OAQ0A4hJ0OmPEDYmJjUFJKI2t*ynCY41qGPAI.NMZlbUTh6NeqmgL7UuGmHcPH33ZKUpdGUvyUtlsxeRoKQRaaRk!/b&amp;bo=ngL3AQAAAAAFF14!&amp;rf=viewer_4&quot;, &quot;http://m.qpic.cn/psc?/V115oyNl11FAq7/ETWql2gUF22pNmiMBc.OARYef.ZynHj7VLc8N**aHzaQkp4U5oJI4Saa3W68M7O8ynmpV.j*l1JOYoOcYI*WO7r7NotbsyncY3NuLst7vwM!/b&amp;bo=ngL2AQAAAAAFF18!&amp;rf=viewer_4&quot; ], &quot;freq&quot;: 10 &#125;, ...] latLng： 为足迹的经纬度，可以通过 https://jingweidu.bmcx.com/ 查询得到 name： 足迹地点的名称 desc：足迹地点的描述， \\n 为换行符 photos：足迹地点的照片链接，为一组图片 url 数据 freq：足迹地点的到访次数，范围为 [1, 10] 将足迹地图部署到你的博客将足迹数据修改完毕后，将项目传到你的 github 中进行托管，然后启用你的足迹地图项目的 github Page 服务，会得到服务地址： http://xxxx/xxxx/. 然后利用 iframe 将足迹地图内嵌到你博客中的相应位置，示例代码如下： 1&lt;iframe scrolling=no style=&quot;min-height:480px !important;&quot; src=&quot;http://xxxx/xxxx/index.html&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/iframe&gt; 其中嵌入的样式可以根据自己需求修改。 进一步的样式调整默认的地图为中国地图，足迹点的样式及背景样式都是固定的，如果想对足迹地图进行进一步的定制化，可以对 /css/index.css 及 /js/index.js 文件进行修改。 其中 /js/jquery-jvectormap-cn-merc-en.js为中国地图，你可以替换为世界地图，具体操作见 https://jvectormap.com/ 足迹地图依赖的是 JVectorMap，关于基本的样式定义可以参考官网 https://jvectormap.com/documentation/javascript-api/jvm-map/ 续 文章首发 https://sunyunzeng.com/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%B6%B3%E8%BF%B9%E5%9C%B0%E5%9B%BE/ 项目地址 https://github.com/SUNYunZeng/FootprintMap 参考 http://www.wujiayi.vip/index.php/archives/52/","categories":[{"name":"教程","slug":"教程","permalink":"https://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://sunyunzeng.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"自己第一篇SCI文章： LSI-LSTM——个体出行目的地预测模型","slug":"自己第一篇SCI文章-LSI-LSTM-个体出行目的地预测模型","date":"2021-03-15","updated":"2022-11-05","comments":true,"path":"自己第一篇SCI文章-LSI-LSTM-个体出行目的地预测模型/","link":"","permalink":"https://sunyunzeng.com/%E8%87%AA%E5%B7%B1%E7%AC%AC%E4%B8%80%E7%AF%87SCI%E6%96%87%E7%AB%A0-LSI-LSTM-%E4%B8%AA%E4%BD%93%E5%87%BA%E8%A1%8C%E7%9B%AE%E7%9A%84%E5%9C%B0%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"内容导读个体驾驶目的地预测对于个性化服务推荐、出行导航、交通调度等基于位置的服务具有重要的参考意义。然而，个体出行不仅具有长时间依赖性，而且受到出行空间上下文的影响，使得精准实时的驾驶目的地预测面临较大挑战。目前，长时间依赖关系建模已存在一定的技术手段，但空间因素对出行过程的影响仍然较少被考虑到。事实上，出发地与沿途的城市功能区、路网关键节点均一定程度反映并影响着司机的出行意图。为此，本文提出一种基于注意力机制和长短期记忆（LSTM）的个体驾驶目的地实时预测模型LSI-LSTM。该模型在兼顾个体出行长时间依赖性学习的同时，从轨迹点的位置语义、轨迹点与目的地间的空间关联关系两个维度建模空间上下文。具体来说，使用高德POI和TF-IDF算法建立轨迹语义提取方法t-LSE，以获得轨迹点所在区域的城市功能区类型；基于转向角、速度、已行驶距离三类驾驶状态评价轨迹点的位置重要性，并利用轨迹空间注意力机制t-SAM进一步捕获与潜在目的地有强空间关联的轨迹点。基于上述城市功能区类型和位置重要性，LSI-LSTM对轨迹点的空间上下文进行建模，在不需要外部路网数据的情况下实现细粒度空间出行特征的学习。基于私家车移动轨迹数据的实验结果表明，本文模型LSI-LSTM的预测精度显著优于所选基准模型（隐马尔科夫、随机森林与LSTM）；同时，消融实验验证了t-LSE与t-SAM的有效性。此外，本文进一步探讨了出行熵、出行距离等因素对模型预测能力的影响。 本文的主要创新如下： LSI-LSTM综合考虑时间依赖、出行位置语义及空间关联对个体尺度目的地预测的影响。 轨迹位置语义提取算法t-LSE为空间出行特征中如何有效耦合城市功能性提供了参考。t-LSE有助于丰富出行位置的先验知识，为更好地捕获语义层面上的出行规律提供支撑。 轨迹空间注意力机制t-SAM使得LSI-LSTM能够以数据驱动的方式实时推测司机的驾驶意图。这得益于t-SAM能够在不依赖路网数据的情况下，利用驾驶状态数据识别位置重要性并发掘潜在空间关联关系。 引言个体驾驶出行目的地预测作为人类移动分析领域研究的分支，近年来逐渐成为研究热点。该研究关注如何根据一段尚未完成的轨迹及其上下文信息，快速、精准地预测可能抵达的目的地。个体出行过程具有复杂的时间依赖与空间关联关系，同时受到所处的空间上下文影响。个体出行长短距离混杂，并且具有长短期时间依赖关系。传统概率模型如隐马尔可夫，其概率推断的模型设计，难以捕获轨迹的长期依赖；而循环神经网络模型能够自动学习长期依赖关系，已成为主流的预测方法。但现有预测模型对轨迹的位置语义及空间关联关系的研究和利用尚显不足。 受到路网拓扑的约束及个体出行偏好选择的影响，轨迹点之间存在空间关联关系。但现有研究主要关注出发位置与目的地间的空间关联关系，而忽略了中间轨迹点与各候选目的地间空间关联的差异性；然而这种差异性往往有助于出行过程的表达。位置语义作为特定区域的城市功能描述，能够辅助揭示司机的频繁出行模式，但较少有个体出行目的地预测模型考虑上述因素的作用。 为此，本文提出一种顾及轨迹点的位置语义及空间关联关系的个体出行目的地预测模型LSI-LSTM，并通过模型对比及消融实验验证LSI-LSTM在多组轨迹数据集上的有效性。 模型设计本文的模型LSI-LSTM由输入模块、出行模式学习模块与目的地预测模块三部分组成，如图 1 所示： 图1 LSI-LSTM模型架构图 其中输入模块负责对轨迹数据、出行时空语义、驾驶状态进行编码与组织，得到移动特征序列。出行模式学习模块利用双层LSTM捕获移动特征序列的长期依赖关系，并基于轨迹空间注意力机制探测并强化关键位置的轨迹特征，最终获得个体出行模式的特征表达。目的地预测模块采用线性全连接残差网络实现特征空间到二维坐标空间的转换，输出目的地预测结果。为了建模空间上下文，输入模块和出行模式学习模块分别实现了本文提出的轨迹位置语义提取方法t-LSE和轨迹空间注意力机制t-SAM，具体介绍如下。 1）轨迹位置语义提取算法 t-LSEt-LSE算法分为位置语义地图构建和轨迹位置语义赋值两步。算法主要流程如图2所示： 图2 轨迹位置语义提取算法t-LSE 为了提高位置语义提取与赋值的效率，预先构建一幅覆盖整个研究区域的位置语义格网地图，其中每个格网单元代表特定的划分区域。t-LSE统计每个单元格内各类POI数量，并基于TF-IDF算法提取该单元格的位置语义向量，该向量的每一维取值表示对应POI类型的重要程度。相对于仅使用唯一的POI标签（如，占比最多的POI类型），语义向量能够更加全面地反映特定区域的城市功能类型。提取的深圳市位置语义示意地图如图3表示，从展示出来的关键地标建筑（如区域A中的深圳大学）可以看出位置语义格网地图能够一定程度反映城市功能性。 图3 位置语义地图 理论上，出发区域的位置语义能够辅助模型揭示司机潜在的出行偏好；途径的典型城市功能区也可能影响出行意图。因此，t-LSE基于语义地图为出发区域及所有中间轨迹点赋予位置语义。首先利用DBSCAN算法对所有出发轨迹点聚类，识别出各个出发区域。然后取同一类簇内所有轨迹点位置语义的均值作为该区域的位置语义。为避免位置语义稀疏问题，采用轨迹点所在格网内最重要的POI类型作为中间轨迹点位置语义。 2）轨迹空间注意力机制t-SAMt-SAM通过驾驶状态推测各轨迹点所在空间位置对于目的地选择而言的重要性，进而为重要的轨迹点赋予较高的注意力权重，实现司机出行模式的学习与表达。通常而言，位于路口等关键位置的轨迹点与目的地之间往往有更紧密的空间关联性，能够反映司机在前进方向的选择，进而影响最终目的地的选择。图4给出司机在具有4个路口的简化路网结构中对7个候选目的地的选择过程。 图4 简化路网中的驾驶过程示例 驾驶过程中途径路口点变化会导致候选目的地抵达概率的变化（仅考虑路网约束）。如图4所示，司机从A地出发，四个出行阶段所在路口位置对应的最可能目的地分别为H、B与C、D与E、D。结合关键位置及该位置司机的出行方向选择信息可有效地缩小潜在目的地的搜索范围。 t-LSE在无需路网数据的情况下，利用驾驶状态（速度、转向角、已行驶距离）识别位于“重要空间位置”上的轨迹点，捕获关键移动特征。基于先验知识可知，在关键路口位置或转向处，司机往往会减速慢行且前进方向发生变化，因此低速、转向角大的轨迹点常位于重要的路网位置；司机行驶距离越远，距离最终目的地也越近，轨迹点位置重要程度也相对更高。图5展示了基于某司机真实驾驶状态得到的位置重要性示例，颜色越深表示位置越重要。 图5 轨迹点在三类驾驶状态下的位置重要性可视化 如图5所示，结合转向角与驾驶速度，重要位置的轨迹点 p_5、p_12、p_25 均被成功识别。基于三类驾驶状态，t-LSE构建轨迹点位置重要性计算规则，并作为注意力机制的启发项，计算得到各个轨迹点特征的注意力权重。 实验分析为了验证模型及相关算法的有效性，本文选择深圳市内四名私家车司机2018年全年的驾驶移动轨迹记录为研究数据，其统计信息（年出行OD熵、不同的OD点簇数量、年出行距离、轨迹平均距离、轨迹总数量）如表1及图6所示： 表1 四名司机的年度出行统计 图6 四名司机的年度出行轨迹、OD弧、活动热点空间分布可视化 1） 模型有效性验证实验 本文将LSI-LSTM与三类经典的目的地预测模型（隐马尔科夫HMM、随机森林RF及LSTM）进行对比，结果如图7所示： 图7 模型有效性对比 实验结果表明，无论是平均绝对误差MAE、平均均方根误差RMSE还是平均相对误差MRE，LSI-LSTM的预测精度均显著高于三种基准模型。概率模型RF与HMM将连续稠密的轨迹数据转化为精简的出行特征，有效降低了出行过程建模的复杂性和冗余，因此比LSTM表现更好。此外，由于RF与HMM无法捕获长期的时间依赖和建模复杂的出行模式，导致面向出行熵和出行总距离较大的个体预测效果一般。结合表1的出行OD熵来看，司机的整体预测精度与出行OD熵紧密相关。出行OD熵度量了司机出行的不规律性，OD熵越高，司机的出行模式越复杂，模型整体预测精度就越低。 2）t-LSE和t-SAM的有效性验证实验 本文采用消融实验来验证算法t-LSE和t-SAM的有效性，实验的结果如图8所示： 图8 模型消融实验 图8实验结果表明，t-LSE和t-SAM均有效地提高了模型的预测精度，而综合这两种算法的LSI-LSTM预测精度最好。与t-LSE相比，t-SAM对模型精度的提升更为明显。尽管t-LSE能够刻画轨迹所在位置的城市功能性，但无法揭示用户真正活动的场所类型，导致模型难以在社会活动空间上挖掘用户的移动规律；t-SAM通过识别具有显著位置重要性的轨迹点，能够实时、准确地对出行过程进行细粒度表达。 3）t-LSE和t-SAM的影响因素实验 t-LSE需要构建位置语义格网地图，而格网的划分粒度影响着位置语义的代表性及准确性。为此，本文探讨了不同格网粒度对位置语义有效性的影响，实验结果如图9所示： 图9 不同语义地图格网粒度对四名司机平均预测精度的影响 图9的实验结果表明，太粗或太细的格网粒度均会影响位置语义对城市功能区的表达。太细格网粒度划分下的位置语义代表性下降，而太粗粒度会导致轨迹点在不同区域的位置语义区分度降低。针对四名司机的轨迹数据而言，250m-500m是较为合适的格网划分区间，不同应用场景下最优格网划分需要通过格网粒度实验获得。 t-SAM中位置重要性计算依赖于三类驾驶状态，为了探讨不同驾驶状态对t-SAM的影响，本文设计对比实验，结果如图10所示： 图10 不同驾驶状态下四名司机的平均预测精度 结果表明，三种驾驶状态均能显著提高t-SAM的有效性，因为行驶距离可以反映长短距离的移动模式，而驾驶速度及转向角可以体现出行的显著移动特征。综合这三种驾驶状态可以更全面地描述轨迹的显著特征，预测精度也最高。 为了进一步探讨t-SAM的工作原理，本文根据t-SAM学习到的各轨迹点注意力权重与预测距离误差计算空间关联度，并通过地图可视化呈现，如图11所示： 图11 某司机各轨迹点格网与候选目的地格网的空间关联度的空间分布及关系图 图11 a)为各个轨迹格网的累积空间关联度，数值越大，格子颜色越深，则表示该位置与各目的地的关联性也越大，而其中颜色较深的几个位置均位于路口附近，也验证t-SAM可以基于轨迹自身状态启发式地识别关键路网位置。图11 b) 为子区域A中各轨迹网格与目的地格网332的空间关联关系强度分布图，其中轨迹格网241、301、317、354与目的地格网332的关联度最大，它们均分布于决定未来走向的关键路口附近。图11 c) 展现了轨迹格网346与360与候选目的地格网的空间关联度，可以看出当出行轨迹经过路口轨迹格网361后，前进方向上的格网346与360分别与目的地格网229与332具有强空间关联度，这与路网拓扑约束的结果吻合。图11 d) 为不同轨迹格网与目的地格网之间的空间关联度热力表，颜色越深表明关联越紧密，可以发现路网中临近的轨迹格网对目的地有相似的关联度，如轨迹格网317与332、300及301。可视化结果表明通过对轨迹点与目的地间的空间关联关系的探测与学习，t-SAM可以一定程度上辅助用户出行模式的表达。 4）其它影响因素实验 不同出行长度及子轨迹的切分数量会影响到预测精度，为了探讨这两个因素对模型模型效果的影响，本文开展两项对比实验。 a. 出行总距离对模型精度的影响个体存在长距离出行与短距离出行并存的情况，为了探讨出行总距离对模型精度的影响，本文对比四种模型（LSI-LSTM、HMM、RF与LSTM）在四名司机的数据集上的综合表现，结果如图12所示。 图12 不同出行距离下模型的MAE和MRE表现 图12表明，随着出行总距离的增加，四种模型的MAE均逐渐增加；除了LSTM，其它三个模型的MRE均不断下降。这主要是因为随着出行距离的增加，用于模型训练的轨迹总数量不断减少（如图12子图左上角嵌套的小图可知），因此MAE上升。MRE逐渐降低的原因在于MAE增加率比出行距离增加率小。整体而言，LSI-LSTM在不同的出行距离下，在MAE及MRE上均表现最优。 b. 子轨迹生成数量对模型精度的影响子轨迹是一段已出行但并未完成的从出发点到中间点的轨迹序列，为了模拟用户的出行过程，一条完整的出行轨迹被切分为不同长度的子轨迹集合。为了探讨子轨迹的生成数量对模型精度的影响，本文针对不同子轨迹切分数量进行精度分析实验，如图13所示： 图13 子轨迹生成数量对比实验 实验结果表明，当子轨迹生成的数量越多，模型可以学习更丰富的出行细节，相应的预测精度也越高。但是随着子轨迹生成数量的增加，模型预测精度的提高有限，而模型训练时间却呈线性增长。因此，最合适的子轨迹生成数量可以综合预测精度与模型训练效率进行设置。 讨论与总结针对目的地预测任务中对于空间因素利用不足的问题，本文提出一种综合轨迹点位置语义与空间关联的预测模型，并通过实验验证分析了模型及相关算法的有效性。未来工作可以围绕如下两个方面展开： 深层位置语义提取。城市功能区类型仍属于浅层的位置语义，而更深层个体社会活动位置语义（如“在餐厅吃饭”）的提取，可以更好地揭示司机的出行行为偏好。 冷启动问题。个体目的地预测模型在数据采集初期面临数据稀疏问题，利用群体轨迹数据对模型进行预训练将提供一种解决思路。 引用论文链接LSI-LSTM: An attention-aware LSTM for real-time driving destination prediction by considering location semantics and location importance of trajectory points 引用txt格式： Zhipeng Gui, Yunzeng Sun, Le Yang, Dehua Peng, Fa Li, Huayi Wu, Chi Guo, Wenfei Guo, Jianya Gong,LSI-LSTM: An attention-aware LSTM for real-time driving destination prediction by considering location semantics and location importance of trajectory points,Neurocomputing,Volume 440,2021,Pages 72-88,ISSN 0925-2312,https://doi.org/10.1016/j.neucom.2021.01.067.(https://www.sciencedirect.com/science/article/pii/S092523122100134X) 代码链接https://github.com/ZPGuiGroupWhu/Human-Mobility-Analysis/tree/master/Travel-Destination-Prediction/LSI-LSTM 首发微信公众号首发地址：https://mp.weixin.qq.com/s/ynMufJEbiZ1lEFNUqE7_QA 团队GitHub网站链接：https://github.com/ZPGuiGroupWhu 珞珈时空计算团队微信公众号：Luojia-STC 珞珈时空计算团队网站链接：http://www.luojia-spatial.com/index.html","categories":[{"name":"算法","slug":"算法","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://sunyunzeng.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"卡尔曼滤波与粒子滤波","slug":"卡尔曼滤波与粒子滤波","date":"2020-12-16","updated":"2022-11-05","comments":true,"path":"卡尔曼滤波与粒子滤波/","link":"","permalink":"https://sunyunzeng.com/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/","excerpt":"","text":"卡尔曼滤波卡尔曼滤波解决的是如何从多个不确定数据中提取相对精确的数据。 1) 实践前提是这些数据满足高斯分布。 2) 理论前提是一个高斯斑乘以另一个高斯斑可以得到第三个高斯斑，第三个高斯斑即为提取到相对精确的数据范围。 什么是卡尔曼滤波你可以在任何含有不确定因素的动态系统里使用卡尔曼滤波，而且你应该可以通过某种数学建模对系统下一步动向做一个大概的预测。尽管系统总是会受到一些未知的干扰，但是卡尔曼滤波总是可以派上用场来提高系统预估的精确度，这样你就可以更加准确地知道到底发生了什么事情(系统状态是如何转移的)。而且它可以有效利用多个粗糙数据之间的关系，而单独面对这些数据你可能都无从下手。 卡尔曼滤波尤其适合动态系统。它对于内存要求极低（它仅需要保留系统上一个状态的数据，而不是一段跨度很长的历史数据）。并且它运算很快，这使得它非常适合解决实时问题和应用于嵌入式系统。 卡尔曼滤波我们可以做什么?我们举一个玩具的栗子：你开发了一款小型机器人，它可以在树林里自主移动，并且这款机器人需要明确自己的位置以便进行导航。 我们可以通过一组状态变量 来描述机器人的状态，包括位置和速度： 注意这个状态仅仅是系统所有状态中的一部分，你可以选取任何数据变量作为观测的状态。在我们这个例子中选取的是位置和速度，它也可以是水箱中的水位，汽车引擎的温度，一个用户的手指在平板上划过的位置，或者任何你想要跟踪的数据。 我们的机器人同时拥有一个GPS传感器，精度在10m。这已经很好了，但是对我们的机器人来说它需要以远高于10m的这个精度来定位自己的位置。在机器人所处的树林里有很多溪谷和断崖，如果机器人对位置误判了哪怕只是几步远的距离，它就有可能掉到坑里。所以仅靠GPS是不够的。 同时我们可以获取到一些机器人的运动的信息：驱动轮子的电机指令对我们也有用处。如果没有外界干扰，仅仅是朝一个方向前进，那么下一个时刻的位置只是比上一个时刻的位置在该方向上移动了一个固定距离。当然我们无法获取影响运动的所有信息：机器人可能会受到风力影响，轮子可能会打滑，或者碰到了一些特殊的路况；所以轮子转过的距离并不能完全表示机器人移动的距离，这就导致通过轮子转动预测机器人位置不会非常准确。 GPS传感器也会告知我们一些关于机器人状态的信息，但是会包含一些不确定性因素。我们通过轮子转动可以预知机器人是如何运动的，同样也有一定的不准确度。 如果我们综合两者的信息呢？可以得到比只依靠单独一个信息来源更精确的结果么？答案当然是YES，这就是卡尔曼滤波要解决的问题。 利用卡尔曼滤波如何看待你的问题?我们再来看下需要解决的问题，同样是上边的系统，系统状态包括位置和速度。 我们不知道位置和速度的准确值；但是我们可以列出一个准确数值可能落在的区间。在这个范围里，一些数值组合的可能性要高于另一些组合的可能性。 卡尔曼滤波假设所有的变量（在我们的例子中为位置和速度）是随机的且符合高斯分布（正态分布）。每个变量有一个平均值ｕ，代表了随机分布的中心值（也表示这是可能性最大的值），和一个方差 $\\sigma^2$ ，代表了不确定度。 在上图中位置和速度是无关联的，即系统状态中的一个变量并不会告诉你关于另一个变量的任何信息。 下图则展示了一些有趣的事情：在现实中，速度和位置是有关联的。如果已经确定位置的值，那么某些速度值存在的可能性更高。 假如我们已知上一个状态的位置值，现在要预测下一个状态的位置值。如果我们的速度值很高，我们移动的距离会远一点。相反，如果速度慢，机器人不会走的很远。 这种关系在跟踪系统状态时很重要，因为它给了我们更多的信息：一个测量值告诉我们另一个测量值可能是什么样子。这就是卡尔曼滤波的目的，我们要尽量从所有不确定信息中提取有价值的信息！ 这种关系可以通过一个称作协方差的矩阵表述。简而言之，矩阵中的每个元素 表示了第 i 个状态变量和第 j 个状态变量之间的关系。（你可能猜到了协方差矩阵是对称的，即交换下标 i 和 j 并无任何影响）。协方差矩阵通常表示为Σ，它的元素则表示为 。 利用矩阵描述问题 我们对系统状态的分布建模为高斯分布，所以在k时刻我们需要两个信息：最佳预估值 （平均值，有些地方也表示为u），和它的协方差矩阵 (这里我们只记录了位置和速度，但是我们可以把任何数据变量放进我们的系统状态里) 下一步，我们需要通过 k-1 时刻的状态来预测 k 时刻的状态。请注意，我们不知道状态的准确值，但是我们的预测函数并不在乎。它仅仅是对 k-1 时刻所有可能值的范围进行预测转移，然后得出一个k时刻新值的范围。 我们可以通过一个状态转移矩阵 来描述这个转换 把 k-1 时刻所有可能的状态值转移到一个新的范围内，这个新的范围代表了系统新的状态值可能存在的范围，如果 k-1 时刻估计值的范围是准确的话。 通过一个运动公式来表示这种预测下个状态的过程： 整理为矩阵: 我们现在有了一个状态转移矩阵，可以简单预测下个状态，但仍不知道如何更新协方差矩阵。 这里我们需要另一个公式。如果我们对每个点进行矩阵A转换，它的协方差矩阵Σ会发生什么变化呢？ Easy，直接告诉你结果。 结合（4）和（3）： 外界作用力 我们并没有考虑到所有影响因素。系统状态的改变并不只依靠上一个系统状态，外界作用力可能会影响系统状态的变化。 例如，跟踪一列火车的运动状态，火车驾驶员可能踩了油门使火车提速。同样，在我们机器人例子中，导航软件可能发出一些指令启动或者制动轮子。如果我们知道这些额外的信息，我们可以通过一个向量 来描述这些信息，把它添加到我们的预测方程里作为一个修正。 假如我们通过发出的指令得到预期的加速度 a，上边的运动方程可以变化为： 矩阵形式： 其中 称作控制矩阵， 称作控制向量（没有任何外界动力影响的系统，可以忽略该项）。 我们增加另一个细节，假如我们的预测转换矩阵不是100%准确呢，会发生什么呢? 外界的不确定性 如果状态只会根据系统自身特性演变那将不会有任何问题。如果我们可以把所有外界作用力对系统的影响计算清楚那也不会有任何问题。 但是如果有些外力我们无法预测呢？假如我们在跟踪一个四轴飞行器，它会受到风力影响。如果我们在跟踪一个轮式机器人，轮子可能会打滑，或者地面上的突起会使它降速。我们无法跟踪这些因素，并且这些事情发生的时候上述的预测方程可能会失灵。 我们可以把“世界”中的这些不确定性统一建模，在预测方程中增加一个不确定项。 这样，原始状态中的每一个点可以都会预测转换到一个范围，而不是某个确定的点。可以这样描述： 中的每个点移动到一个符合方差 的高斯分布里。另一种说法，我们把这些不确定因素描述为方差为 的高斯噪声。 这会产生一个新的高斯分布，方差不同，但是均值相同。 对 简单叠加，可以拿到扩展的方差，这样就得到了完整的预测转换方程。 新的预测转换方程只是引入了已知的可以预测的外力影响因素。 新的不确定性可以通过老的不确定性计算得到，通过增加外界无法预测的、不确定的因素成分。 到这里，我们得到了一个模糊的估计范围，一个通过 和 描述的范围。如果再结合我们传感器的数据呢？ 通过测量值精炼预测值 我们可能还有一些传感器来测量系统的状态。目前我们不用太关心所测量的状态变量是什么。也许一个测量位置一个测量速度。每个传感器可以提供一些关于系统状态的数据信息，每个传感器检测一个系统变量并且产生一些读数。 注意传感器测量的范围和单位可能与我们跟踪系统变量所使用的范围和单位不一致。我们需要对传感器做下建模：通过矩阵 我们可以得到传感器读数分布的范围： 卡尔曼滤波也可以处理传感器噪声。换句话说，我们的传感器有自己的精度范围，对于一个真实的位置和速度，传感器的读数受到高斯噪声影响会使读数在某个范围内波动。 我们观测到的每个数据，可以认为其对应某个真实的状态。但是因为存在不确定性，某些状态的可能性比另外一些可能性更高。 我们将这种不确定性的方差为描述为 。读数的平均值为 。 所以现在我们有了两个高斯斑，一个来自于我们预测值，另一个来自于我们测量值。 我们必须尝试去把两者的数据预测值（粉色）与观测值（绿色）融合起来。 所以我们得到的新的数据会长什么样子呢？对于任何状态( $z_1$ , $z_2$ )，我们有两个可能性：（1）传感器读数更接近系统真实状态（2）预测值更接近系统真实状态。 如果我们有两个相互独立的获取系统状态的方式，并且我们想知道两者都准确的概率值，我们只需要将两者相乘。所以我们将两个高斯斑相乘。 相乘之后得到的即为重叠部分，这个区域同时属于两个高斯斑。并且比单独任何一个区域都要精确。这个区域的平均值取决于我们更取信于哪个数据来源，这样我们也通过我们手中的数据得到了一个最好的估计值。 唔~这看上去像另一个高斯斑。 已经被证明，当你对两个均值方差都不相同的侧高斯斑进行相乘，你可以得到一个新的高斯斑。你可以自行推导：新高斯分布的均值和方差均可以通过老的均值方差求得。 高斯乘法 我们从一维数据开始，一维高斯（均值 u,方差 $\\sigma^2$ ）被定义为： 我们想知道两个高斯分布相乘会发生什么。蓝色曲线代表了两个高斯分布的交集部分。 把（9）带入（10）然后做一些变换，可以得到 因式分解出一个部分，表示为 k 注意你是如何将处理之前的预测值，仅仅是简单将两者叠加相乘就可以得到新的预测值。现在看下这个公式是多么简单。 如果是一个多维矩阵呢？我们将（12）与（13）表示为矩阵形式。Σ 表示协方差矩阵， 表示平均向量： K 被称为卡尔曼增益，待会会用到。 简单，我们快结束了。 综合所有信息 我们有两个独立的维度去估计系统状态： 预测值 测量值 将两者相乘带入（15）寻找他们的重叠区域： 从（14）可知，卡尔曼增益为 将（16）中的 从两边约去，注意（17）中的K也包含 。得到 至此，我们得到了每个状态的更新步骤 是我们最佳的预测值，我们可以持续迭代（独立于 ）。 总结以上所有公式，仅需要实现（7）（18）（19） 这使你可以对任何线性系统建模。对于非线性系统，可以使用扩展卡尔曼滤波，只是对观测值和预测值的平均值进行简单线性化。 如果我可以利用卡尔曼解决我的问题，那么希望读者也可以认识到这有多酷，并且在某个新的领域将它实用。 参考知乎_如何通俗并尽可能详细地解释卡尔曼滤波？ How a Kalman filter works, in pictures 粒子滤波什么是粒子滤波粒子滤波是卡尔曼滤波的简化，放松了约束条件，即数据分布不一定是高斯分布，使其更具有泛化能力及对离散值有很好的支持，但是其计算复杂度也相应增加。 粒子滤波的工作原理粒子滤波关键是粒子的选取，粒子其实就是预测状态各种有限的可能取值，称为“粒子”，初始粒子的分布一般假设均匀分布。 测量系统负责给出粒子。 状态系统通过上一时刻的粒子状态得到评估这一时刻的粒子各个概率大小。 测量系统给出各个粒子的权重，对所有粒子加权求和得到当前的粒子状态。 测量系统根据粒子的权重，筛选得到下一时刻的粒子，权重大的粒子被选出来的概率大， 循环往复，直到预测完成。 总结粒子滤波的关键在于粒子的选择。","categories":[{"name":"算法","slug":"算法","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"控制论","slug":"控制论","permalink":"https://sunyunzeng.com/tags/%E6%8E%A7%E5%88%B6%E8%AE%BA/"}]},{"title":"深入了解JS基础","slug":"深入了解JS基础","date":"2020-07-25","updated":"2022-11-05","comments":true,"path":"深入了解JS基础/","link":"","permalink":"https://sunyunzeng.com/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3JS%E5%9F%BA%E7%A1%80/","excerpt":"","text":"JS 的 Number 类型精度问题我们知道，Java 语言中的长整型范围为 +2^63-1 ~ -2^63-1，而 JavaScript 的 Number 基本类型采用 64 位浮点型表示，为什么 JS 中整型的最大安全范围不是 +2^63-1 ~ -2^63-1 呢？ Java的 的长整型整数也是采用 64 位表示，除了第一位是符号位，剩下的 63 位都可以表示数字。 而 JavaScript 没有单独的整型类型 (Bigint 除外，且 Bigint 不能参与与 Number 类型的运算)，整型、浮点型都统一用 64 位浮点型来表示，采用的是 IEEE754 标准。 IEEE754 规定，64 位的浮点型中，第 1 位表示正负，2~12 位表示指数位 (实际存储的时候必须加上一个偏移值 1023)，剩下的 64 - 1- 11 = 52 位表示整数位，因为浮点数采用科学计数法，第一位固定是 1，可以不用表示，但是运算时会加上。 比如： 0 01111111011 0000000000000000000000000000000000000000000000000000 表示的就是 1.0000000000000000000000000000000000000000000000000000 * 2^(1019 - 1023) = 0.0625 Number.Max_Value 与 Number.MAX_SAFE_INTEGER我们打印 Number 的这两个属性： 12345console.log(Number.MAX_VALUE);console.log(Number.MAX_SAFE_INTEGER);// 1.7976931348623157e+308// 9007199254740991 1. Number.Max_Value 其中 Number.Max_Value 就是 Number 类型可以表示的最大浮点数，计算方式如下： 你可以猜到会是： 0 11111111111 1111111111111111111111111111111111111111111111111111, 但这种情况在 IEEE754 标准中表示 NaN，最大的数其实是： 0 11111111110 1111111111111111111111111111111111111111111111111111 转换成二进制的科学计数法表示如下： 1.1111111111111111111111111111111111111111111111111111 * 2^(2046 - 1023) = 1.1111111111111111111111111111111111111111111111111111 * 2^1023 = (2^53 - 1) * 2^971 我们可以在浏览器调试窗口中验证： 12(Math.pow(2, 53) - 1) * Math.pow(2, 971) // 1.7976931348623157e+308(Math.pow(2, 53) - 1) * Math.pow(2, 971) === Number.MAX_VALUE // true 2. Number.MAX_SAFE_INTEGER 现在就可以解释为什么 JS 的最大整数为 +2^53-1 ~ -2^53-1。 因为 IEEE754 浮点数中整数位最大表示的数为: 1111111111111111111111111111111111111111111111111111 = 2^53-1 比这还大一位的数字的表示为: 100000000000000000000000000000000000000000000000000000 = 2^53 在计算机中表示为: 0 10000110101 0000000000000000000000000000000000000000000000000000 0 注意到我们省去掉了一位，按照向偶舍入的规则，不会产生进位。所以这个数还是可以精确表示的，没有问题。 我们再来看看比 MAX_SAFE_INTEGER 大二的数： 100000000000000000000000000000000000000000000000000001 = 1.00000000000000000000000000000000000000000000000000001 * 2^53 在计算机中表示成: 0 10000110101 0000000000000000000000000000000000000000000000000000 1 注意到我们省去掉了一位，按照向偶舍入的规则，还是不会产生进位。这个时候就有问题了，这个数跟刚才那个数竟然是相等的，我们来验证下： 12const a = Number.MAX_SAFE_INTEGERconsole.log(a + 1 === a + 2) // true 所以 Number.MAX_SAFE_INTEGER 表示能够准确表示的整数。 进行大数运算时，如果涉及到的的数值超过了 Number.MAX_SAFE_INTEGER，运算就会有误差了，此时的运算最好采用 Bigint 类型。 3. Number.MIN_VALUE Number.MIN_VALUE 表达的意思是 JavaScript 能够表示最小的正数，及很接近于 0 的数字，数值为： 1console.log(Number.MIN_VALUE) // 5e-324 0.2 + 0.1 为什么不等于 0.3这其实是计算机表示浮点数的过程中，由于存储空间的显示，对于某一些浮点数服务精确地表示。 对于十进制转二进制，整数部分除二取余，倒序排列，小数部分乘二取整，顺序排列，所以： 0.1 转化为二进制0.0 0011 0011 0011 0011 0011 0011 … （0011循环） 0.2 转化为二进制0.0011 0011 0011 0011 0011 0011 0011 … （0011循环） 然后采用 IEEE754 标准表示： 0.1指数位： -4;整数位： 1.1001100110011001100110011001100110011001100110011010 (52位) 0.2指数位： -3;整数位： 1.1001100110011001100110011001100110011001100110011010 (52位) 0.1 + 0.2 0.1100110011001100110011001100110011001100110011001101 (52位) 指数位： -3 + 1.1001100110011001100110011001100110011001100110011010 (52位) 指数位： -3 = 10.0110011001100110011001100110011001100110011001100111 (52位) 指数位： -3 = 1.00110011001100110011001100110011001100110011001100111 (53位) 指数位： -2 此时整数位已经溢出了，最后一位为 1，所以进位： 1.0011001100110011001100110011001100110011001100110100 (52位) 指数位： -2 = 1.0011001100110011001100110011001100110011001100110100 * 2 ^ -2 = 0.010011001100110011001100110011001100110011001100110100 = 0.30000000000000004","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sunyunzeng.com/tags/JavaScript/"}]},{"title":"JS中的优化技巧","slug":"JS中的优化技巧","date":"2020-07-23","updated":"2022-11-05","comments":true,"path":"JS中的优化技巧/","link":"","permalink":"https://sunyunzeng.com/JS%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/","excerpt":"","text":"使用 Promise.all 同时触发多个不互相依赖的异步请求对于互不依赖的多个Promise任务，可以使用 Promise.all 方法使这些方法并行执行，而不是串行执行，这样可以大量的节省任务执行时间。 举例 123456789101112131415161718192021222324252627282930313233343536373839function getData1()&#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;resolve(1), 10000); &#125;)&#125;function getData2()&#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;resolve(2), 20000); &#125;)&#125;async function oneByOneAsyncFunc()&#123; const start_time = new Date(); const a = await getData1(); const b = await getData2(); console.log(&#123; a, b, &#125;); const end_time = new Date(); console.log(end_time.getSeconds()-start_time.getSeconds());&#125;async function twoAsyncFunc()&#123; const start_time = new Date(); let [a, b] = await Promise.all([getData1(), getData2()]); console.log(&#123; a, b, &#125;); const end_time = new Date(); console.log(end_time.getSeconds()-start_time.getSeconds())&#125;twoAsyncFunc() // 执行时间为 20 秒oneByOneAsyncFunc() // 执行时间为 30 秒 Promise 的一些知识","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sunyunzeng.com/tags/JavaScript/"}]},{"title":"JS中的设计模式（下）","slug":"JS中的设计模式（下）","date":"2020-06-10","updated":"2022-11-05","comments":true,"path":"JS中的设计模式（下）/","link":"","permalink":"https://sunyunzeng.com/JS%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"命令模式命令模式中的命令（command）指的是一个执行某些特定事情的指令。 命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。 例如前端开发分为界面开发以及代码逻辑开发两部分，界面开发的同学设计了一个刷新按钮，点击可以执行刷新操作。 1234&lt;button id=&quot;refreshBtn&quot;&gt;刷新&lt;/button&gt;&lt;script&gt;let refreshBth = document.getElementById(&#x27;refreshBtn&#x27;);&lt;/script&gt; 但是这时候负责开发实际代码逻辑的同学由于业务比较复杂，因此还没来得及开发完成，此时界面开发的同学不知道如何调用实际的刷新操作。 此时可以利用命令模式，统一规定了命令的执行需要调用 execute 方法。 12345let setCommand = function(button, command)&#123; button.onclick = function()&#123; command.execute(); &#125;&#125; 此时负责代码逻辑的同学直接实现带 execute 功能的对象或函数即可。 12345678910111213141516let ButtonRefresh = &#123; refresh: function()&#123; console.log(&#x27;按钮刷新&#x27;) &#125;&#125;let RefreshCommand = function(receiver)&#123; return function()&#123; receiver.refresh(); &#125;&#125;let refreshCommand = new RefreshCommand(ButtonRefresh);setCommand(refreshBth, refreshCommand); 宏命令 宏命令即执行一系列的名利，例如点外面时候的 下单 -&gt; 做餐 -&gt; 包装 -&gt; 配送 -&gt;取餐 一系列的命令。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758let OrderCommand = &#123; execute: function()&#123; console.log(&#x27;下单啦&#x27;) &#125;&#125;let CookCommand = &#123; execute: function()&#123; console.log(&#x27;做餐啦&#x27;) &#125;&#125;let PackCommand = &#123; execute: function()&#123; console.log(&#x27;包装啦&#x27;) &#125;&#125;let DeliveryCommand = &#123; execute: function()&#123; console.log(&#x27;配送啦&#x27;) &#125;&#125;let PickCommand = &#123; execute: function()&#123; console.log(&#x27;取餐啦&#x27;) &#125;&#125;let MacroCommand = function()&#123; return &#123; commandList: [], add: function(command)&#123; this.commandList.push(command) &#125;, execute: function()&#123; for(command of this.commandList)&#123; command.execute(); &#125; &#125; &#125;&#125;let macroCommand = MacroCommand()macroCommand.add(OrderCommand)macroCommand.add(CookCommand)macroCommand.add(PackCommand)macroCommand.add(DeliveryCommand)macroCommand.add(PickCommand)macroCommand.execute()// 下单啦// 做餐啦// 包装啦// 配送啦// 取餐啦 组合模式上述一系列的命令可以组合成一些复杂的命令，例如命令直接存在树状结构，此时可以采用组合模式进行命令的组合。 123456789101112131415161718192021222324let MacroCommand = function()&#123; return &#123; commandList: [], add: function(command)&#123; this.commandList.push(command) &#125;, execute: function()&#123; for(command of this.commandList)&#123; command.execute(); &#125; &#125; &#125;&#125;let macroCommand1 = MacroCommand()let macroCommand2 = MacroCommand()let macroCommand3 = MacroCommand()let macroCommand4 = MacroCommand()macroCommand1.add(macroCommand2)macroCommand2.add(macroCommand3)macroCommand2.add(macroCommand4)macroCommand1.execute() 文件扫描系统 文件系统时典型的树状结构，可以通过文件夹与文件的组合，模拟树状结构。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Folder&#123; constructor()&#123; this.files = [] &#125; add()&#123; this.files.push(...arguments) &#125; scan()&#123; for(let file of this.files)&#123; file.scan() &#125; &#125;&#125;class File&#123; constructor(name)&#123; this.name = name &#125; add()&#123; throw new Error(&#x27;文件不能添加文件&#x27;) &#125; scan()&#123; console.log(this.name) &#125;&#125;let folder1 = new Folder()let folder2 = new Folder()let folder3 = new Folder()let file1 = new File(&#x27;文件1&#x27;)let file2 = new File(&#x27;文件2&#x27;)let file3 = new File(&#x27;文件3&#x27;)let file4 = new File(&#x27;文件4&#x27;)folder1.add(folder2)folder2.add(folder3)folder2.add(file1, file2)folder3.add(file3, file4)folder1.scan()// 文件3// 文件4// 文件1// 文件2","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://sunyunzeng.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"JS中的设计模式（上）","slug":"JS中的设计模式","date":"2020-06-01","updated":"2022-11-05","comments":true,"path":"JS中的设计模式/","link":"","permalink":"https://sunyunzeng.com/JS%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式js 程序中很多情况下只需要创建一个对象，例如全局缓存、widows 对象、线程池、以及界面中具备唯一性的窗口，此时需要利用单例模式来保证对象的唯一性。 使用代理实现 单一职原则 ，将创建单例的 DIV 与管理代理的代码分开。 123456789101112131415161718// 创建 DIV 逻辑CreateDiv = function(html)&#123; this.html = html; this.init();&#125;CreateDiv.prototype.init = function()&#123; const div = document.createElement(&#x27;div&#x27;); div.innerHtml = this.html; document.body.appendChild(div);&#125;SingletonProxy = (function()&#123; let instance = null; return function(html)&#123; return instance || instance = new CreateDiv(html) &#125;&#125;)(); 策略模式很多公司的年终奖是根据员工的工资基数和年底绩效情况来发放的。例如，绩效为 S的人年终奖有 4倍工资，绩效为A的人年终奖有 3倍工资，而绩效为 B的人年终奖是 2倍工资。假设财 务部要求我们提供一段代码，来方便他们计算员工的年终奖。 我们可以采用策略模式，对于每个等级的奖金都创建一个策略，然后再一个计算环境中调用对应策略，得到相应结果。 123456789101112131415var strategies = &#123; &quot;S&quot;: function( salary )&#123; return salary * 4; &#125;, &quot;A&quot;: function( salary )&#123; return salary * 3; &#125;, &quot;B&quot;: function( salary )&#123; return salary * 2; &#125; &#125;;var calculateBonus = function( level, salary )&#123; return strategies[ level ]( salary );&#125;; console.log( calculateBonus( &#x27;S&#x27;, 20000 ) ); // 输出：80000 console.log( calculateBonus( &#x27;A&#x27;, 10000 ) ); // 输出：30000 例子2 在验证表单的过程中，可以对于不同的输入项设置不同的检查策略，例如手机号格式的检校等等，下面就采用粗略模式实现变化的抽离与不变的抽离。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;&quot; id=&#x27;registerForm&#x27; method=&quot;POST&quot;&gt; &lt;div&gt;请输入用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt;&lt;/div&gt; &lt;div&gt;请输入密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;/div&gt; &lt;div&gt;请输入手机号码：&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;button&gt;提交&lt;/button&gt;&lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;script&gt; var strategies = &#123; nonEmpty: function (value, errMsg) &#123; if (value == &#x27;&#x27;) &#123; return errMsg; &#125; &#125;, minLength: function (value, length, errMsg) &#123; if (value.length &lt; length) &#123; return errMsg; &#125; &#125;, isPhoneNumber: function (value, errMsg) &#123; if (!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123; return errMsg; &#125; &#125; &#125; var Validator = function () &#123; this.cache = []; &#125; Validator.prototype.add = function (dom, rules) &#123; let self = this; for (rule of rules) &#123; (function (rule) &#123; // 闭包保存中间变量 rule，防止多个函数应用同一个出问题 let errMsg = rule.errMsg; let strategy = rule.strategy.split(&#x27;:&#x27;); self.cache.push( function () &#123; let strategyKey = strategy.shift(); let value = dom.value; let args = [value, ...strategy, errMsg]; return strategies[strategyKey].apply(dom, args); &#125; ) &#125;)(rule) &#125; &#125; Validator.prototype.start = function () &#123; for (evalFuc of this.cache) &#123; let errMsg = evalFuc() console.log(errMsg) if (errMsg) &#123; return errMsg &#125; &#125; &#125; let registerForm = document.getElementById(&#x27;registerForm&#x27;); let ValidatorFunc = function () &#123; let validator = new Validator(); // 添加多个策略 validator.add(registerForm.userName, [&#123; &#x27;strategy&#x27;: &#x27;nonEmpty&#x27;, &#x27;errMsg&#x27;: &#x27;输入用户名不能为空&#x27; &#125;, &#123; &#x27;strategy&#x27;: &#x27;minLength:2&#x27;, &#x27;errMsg&#x27;: &#x27;用户名的最短长度不能小于2&#x27; &#125; ]); validator.add(registerForm.password, [&#123; &#x27;strategy&#x27;: &#x27;nonEmpty&#x27;, &#x27;errMsg&#x27;: &#x27;输入密码不能为空&#x27; &#125;, &#123; &#x27;strategy&#x27;: &#x27;minLength:6&#x27;, &#x27;errMsg&#x27;: &#x27;用户名的最短长度不能小于6&#x27; &#125; ]); validator.add(registerForm.phoneNumber, [&#123; &#x27;strategy&#x27;: &#x27;isPhoneNumber&#x27;, &#x27;errMsg&#x27;: &#x27;输入手机号码的格式不对&#x27; &#125; ]); return validator.start() &#125; registerForm.onsubmit = function () &#123; let errMsg = ValidatorFunc(); if (errMsg) &#123; alert(errMsg) &#125; &#125;&lt;/script&gt;&lt;/html&gt; 代理模式代理模式是由代理者作为中间请求的中转方，来代替客户完成对代理对象的控制。 这样可以实现代理对象与客户之间的解耦，方便代码的复用。 图片加载代理 场景：异步加载图片非常可能非常耗时，此时图片的位置是一片空白，非常影响美观，此时在加载过程中可以利用图片代理来控制图片加载中完与加载后的逻辑控制。 1234567891011121314151617181920212223242526// 加载图片的操作let myImage = (function()&#123; let imgNode = document.createElement(&#x27;img&#x27;); document.body.appendChild(imgNode); return &#123; setSrc: function(src)&#123; imgNode.src = src; &#125; &#125;&#125;)()// 图片加载代理let proxyImage = (function()&#123; let img = new Image; img.onload = function()&#123; myImage.setSrc(img.src); &#125; return &#123; setSrc: function(src)&#123; imgNode.setSrc(&#x27;http://myGif.gif&#x27;); img.src = src; &#125; &#125;&#125;)()proxyImage.setSrc(&#x27;http://realImg.png&#x27;); 缓存代理 利用缓存代理调用逻辑代码并执行，由缓存代理缓存计算结果。由于很多复杂耗时的计算结果可以由缓存代理缓存，下次计算可以直接调用缓存结果。 12345678910111213141516171819202122232425// 缓存代理let createProxyFactory = (function()&#123; let cache = &#123;&#125;; return function(fn)&#123; let storeKey = Array.prototype.join.call(arguments, &#x27;,&#x27;); if(storeKey in cache)&#123; return cache[storeKey] &#125; return cache[storeKey] = fn.apply(this, arguments); &#125;&#125;)()// 计算逻辑let mul = function()&#123; return [...arguments].reduce((prev, cur)=&gt;&#123; return prev*cur; &#125;)&#125;let mulProxy = createProxyFactory(mul);console.log(mulProxy(1,2,3,4)); // 24// 直接返回缓存结果console.log(mulProxy(1,2,3,4)); // 24 发布者-订阅者模式发布者-订阅者模式是一种很常见的设计模式，在我们为事件绑定监听事件时，其实就运用了该模式。 例如为页面的 body 可绑定多个点击事件监听，等于注册了多个订阅者。事件真实发生时，再通知各个监听函数，执行回调函数。 在 Vue 的双向绑定实现中，就利用了发布者-订阅者模式，实现了数据更新的消息通知到各个页面更新渲染的回调函数中，实现数据变化驱动视图更新。 在两个隔离的对象之间，也可以运用发布者-订阅者模式实现消息的互通，Angular的子组件之间的通信就是利用了发布者-订阅者模式来实现。 下面构建了一个订阅者工厂函数，可以构建多个订阅者。 1234567891011121314151617181920212223242526272829303132333435363738let getEvent = function()&#123; let client=&#123;&#125;, _listen, _trigger, _remove; _listen = function(key, fn)&#123; if(!(key in client))&#123; client[key] = [] &#125; client[key].push(fn) &#125; _trigger = function()&#123; let key = Array.prototype.shift.call(arguments) let fns = client[key] if(!fns) return false for(fn of fns)&#123; fn.apply(this, arguments) &#125; &#125; _remove = function(key, fn)&#123; if(!key in client) return false let fns = client[key] if(!fn)&#123; fns &amp;&amp; (fns.length=0) &#125; &#125; return &#123; listen: _listen, trigger: _trigger, remove: _remove &#125;&#125;let Event = getEvent();Event.listen(&#x27;手机降价&#x27;, (value)=&gt;console.log(`降价了 $&#123;value&#125; 元`))Event.trigger(&#x27;手机降价&#x27;, 1000)","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://sunyunzeng.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"自己实现 React-Redux (六)：去除 context 依赖，实现 provider","slug":"自己实现-React-Redux-六-：去除-context-依赖，实现-provider","date":"2020-05-20","updated":"2022-11-05","comments":true,"path":"自己实现-React-Redux-六-：去除-context-依赖，实现-provider/","link":"","permalink":"https://sunyunzeng.com/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-React-Redux-%E5%85%AD-%EF%BC%9A%E5%8E%BB%E9%99%A4-context-%E4%BE%9D%E8%B5%96%EF%BC%8C%E5%AE%9E%E7%8E%B0-provider/","excerpt":"","text":"Index 组件中的 context 依赖Content 组件、Header 组件以及 ThemeSwitch 组件都是依赖于 Index 父组件的 context 属性，而 context 属性在 Index 组件中存在会导致 Index 依赖于额外的属性，扩展性不强。 因此我们需要提炼出一个淡出的组件 provider 来当作 Index 的父组件，来存储全局的 context 属性，实现 Index 组件与 context 属性的解耦。 构建 Provider 组件在 src/react-redux.js 文件中添加如下代码： 12345678910111213141516171819202122232425class Provider extends Component &#123; static propTypes = &#123; store: PropTypes.object, children: PropTypes.any &#125; static childContextTypes = &#123; store: PropTypes.object &#125; getChildContext()&#123; return &#123;store: this.props.store&#125; &#125; render() &#123; return ( &lt;div&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125;export &#123;Provider&#125; 同时在我们的 Index 组件中就可以利用 Provider 组件包裹住 Index 组件，并向其传入 store 值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// src/index.jsimport React, &#123;Component&#125; from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;import &#x27;./index.css&#x27;import Header from &#x27;./Header&#x27;import Content from &#x27;./Content&#x27;import PropTypes from &#x27;prop-types&#x27;import &#123;Provider&#125; from &#x27;./react-redux&#x27;function createStore(reducer)&#123; // 初始状态 let state = null // 定义发布者 const listeners = [] // 绑定订阅者 const subscribe = (listener)=&gt;listeners.push(listener) // 获取 state const getState = () =&gt; state // 绑定处理函数 const dispatch = (action)=&gt;&#123; state = reducer(state, action) // 数据更新自动通知给订阅者 listeners.forEach(listener=&gt;listener()) &#125; // 初始化 dispatch(&#123;&#125;) // 返回状态管理对象 return &#123;getState, dispatch, subscribe&#125;&#125;const themeReducer = (state, action)=&gt;&#123; if(!state)&#123; return &#123; themeColor: &#x27;red&#x27; &#125; &#125; switch(action.type)&#123; case &#x27;CHANGE_COLOR&#x27;: return &#123;...state, themeColor: action.themeColor&#125; default: return state &#125;&#125;const store = createStore(themeReducer);class Index extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Header/&gt; &lt;Content/&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;Index/&gt; &lt;/Provider&gt;, document.getElementById(&#x27;root&#x27;)); 总结 我们首先利用 React 的“全局变量” context 实现了子组件按钮改变全局颜色样式的效果。 考虑到代码的重复以及组件的可扩展性，我们构建了一个 connect 函数实现了 context 属性及相关改变 state 方法 dispatch 的代理，并通过 props 由高阶组件传递给子组件。 考虑到 context 还在父组件中使其复用性底，因此又构建了代理父组件 Provider 负责存储全局变量管理对象 store，并通过 props 传递给 Index 组件。 项目地址","categories":[{"name":"教程","slug":"教程","permalink":"https://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"React","slug":"React","permalink":"https://sunyunzeng.com/tags/React/"}]},{"title":"自己实现 React-Redux (五)：实现 mapDispatch2Props","slug":"自己实现-React-Redux-五-：实现-mapDispatchToProps","date":"2020-05-17","updated":"2022-11-05","comments":true,"path":"自己实现-React-Redux-五-：实现-mapDispatchToProps/","link":"","permalink":"https://sunyunzeng.com/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-React-Redux-%E4%BA%94-%EF%BC%9A%E5%AE%9E%E7%8E%B0-mapDispatchToProps/","excerpt":"","text":"dispatch 的代理工作在 src/ThemeSwitch.js 中，ThemeSwitch 组件通过 store 的 dispatch 方法实现了数据的更改，这也导致了组件的强耦合。 我们的思路是让高阶组件 Connect 代替 ThemeSwitch 来实现 dispatch 功能，同时通过 props 将方法传递给 ThemeSwitch 组件。 修改 src/react-redux.js文件： 12345678910111213141516171819202122232425export const connect = (mapState2Props, mapDispatch2Props)=&gt;(OriginComponent)=&gt;&#123;class Connect extends Component &#123; componentWillMount()&#123; this._updateProps() &#125; _updateProps()&#123; const &#123;store&#125; = this.context let stateProps = mapState2Props? mapState2Props(store.getState(), this.props) : &#123;&#125; let dispatchProps = mapDispatch2Props? mapState2Props(store.dispatch, this.props) : &#123;&#125; this.setState(&#123; allProps: &#123; ...stateProps, ...dispatchProps, ...this.props &#125; &#125;) // 绑定订阅者监听函数 store.subscribe(this._updateProps.bind(this)) &#125;/*以下代码略*/&#125; 定义 mapDispatch2Props 函数在 src/ThemeSwitch.js 文件中定义 mapDispatch2Props 函数: 123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, &#123; Component &#125; from &#x27;react&#x27;import PropTypes from &#x27;prop-types&#x27;import &#123;connect&#125; from &#x27;./react-redux&#x27;class ThemeSwitch extends Component &#123; static propTypes = &#123; themeColor: PropTypes.string, handleThemeSwitchClick: PropTypes.func &#125; render() &#123; return ( &lt;div&gt; &lt;button style=&#123;&#123;color: this.props.themeColor&#125;&#125; onClick=&#123;this.props.handleThemeSwitchClick.bind(this, &#x27;red&#x27;)&#125; &gt;Red&lt;/button&gt; &lt;button style=&#123;&#123;color: this.props.themeColor&#125;&#125; onClick=&#123;this.props.handleThemeSwitchClick.bind(this, &#x27;blue&#x27;)&#125; &gt;Blue&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;const mapState2Props = (state)=&gt;&#123; return &#123; themeColor: state.themeColor &#125;&#125;const mapDispatch2Props = (dispatch)=&gt;&#123; return &#123; handleThemeSwitchClick : function(color)&#123; dispatch(&#123; type: &#x27;CHANGE_COLOR&#x27;, themeColor: color &#125;)&#125; &#125;&#125;ThemeSwitch = connect(mapState2Props, mapDispatch2Props)(ThemeSwitch)export default ThemeSwitch; 这样 ThemeSwitch 组件的代码就变得非常整洁，而且扩展性也大大提高。","categories":[{"name":"教程","slug":"教程","permalink":"https://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"React","slug":"React","permalink":"https://sunyunzeng.com/tags/React/"}]},{"title":"自己实现 React-Redux (四)：connect 和 mapState2Props","slug":"自己实现-React-Redux-四-：connect-和-mapStateToProps","date":"2020-05-17","updated":"2022-11-05","comments":true,"path":"自己实现-React-Redux-四-：connect-和-mapStateToProps/","link":"","permalink":"https://sunyunzeng.com/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-React-Redux-%E5%9B%9B-%EF%BC%9Aconnect-%E5%92%8C-mapStateToProps/","excerpt":"","text":"子组件直接利用 context 的问题第三节我们实现了子组件利用 context 属性，通过统一的修改方式对全局 state 进行修改，同时利用发布者-订阅者模式实现了数据更新的监听及界面重新渲染。 但是仍然存在两个问题： 子组件都是利用 context 属性来取得 store 对象，进而对全局状态 state 进行修改，这样会导致很多重复性代码。 每个子组件都依赖了 context 属性，导致子组件与父组件形成了强耦合，不利于组件的复用。例如，前面的 Context 组件需要父组件定义 context 属性，否则主题颜色将无法设置。 解决方法： 对于重复使用的代码，可以凝练提取出一个可复用的代码结构。这里可以通过高阶组件（或者装饰器模式）将 context 的控制与相关事件监听代理起来。 对于强耦合问题，可以通过设置 Pure Component，即在高阶组件内部的被装饰组件尽量设计成纯组件。纯组件是其状态仅依赖于父组件传入的 props 以及 自己的 state，对于外界依赖极低，因此复用性极高。 抽离出公共的逻辑代码我们可以设计一个 connect 函数，该函数的目标是创建一个高阶组件。connect 函数接收两个参数，一个是 mapState2Props 函数，一个是原始的被修饰组件 OriginComponent。 mapState2Props函数负责从父组件接收 state 并将其转化为 props 传递给被修饰组件 OriginComponent，实现 OriginComponent 与父组件 context 之间的解耦以及公共逻辑代码的抽离。 OriginComponent 是原始的子组件，例如 Context 组件。 新建 react-redux.js 文件，里面的内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// src/react-redux.jsimport React, &#123; Component &#125; from &#x27;react&#x27;import PropTypes from &#x27;prop-types&#x27;export const connect = (mapState2Props)=&gt;(OriginComponent)=&gt;&#123; class Connect extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor()&#123; this.state = &#123; allProps: &#123;&#125; &#125; &#125; componentWillMount()&#123; this._updateProps() &#125; _updateProps()&#123; const &#123;store&#125; = this.context.store const stateProps = mapState2Props(store.getState()) this.setState(&#123; allProps: &#123; ...stateProps, ...this.props &#125; &#125;) // 绑定订阅者监听函数 store.subscribe(this._updateProps.bind(this)) &#125; render() &#123; return ( &lt;div&gt; &lt;OriginComponent &#123;...this.state.allProps&#125;/&gt; &lt;/div&gt; ) &#125; &#125; return Connect&#125; 然后再 src/Content.js 及 src/Header 文件中利用 Connect 高阶函数实现全局变量管理： src/Header123456789101112131415161718192021222324252627282930import React, &#123; Component &#125; from &#x27;react&#x27;import PropTypes from &#x27;prop-types&#x27;import &#123;connect&#125; from &#x27;./react-redux&#x27;class Header extends Component &#123; static propTypes = &#123; themeColor: PropTypes.string &#125; render() &#123; return ( &lt;div&gt; &lt;h1 style=&#123;&#123;color: this.props.themeColor&#125;&#125;&gt;动手实现React-Redux&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;const mapState2Props = (state)=&gt;&#123; return &#123; themeColor: state.themeColor &#125;&#125;Header = connect(mapState2Props)(Header)export default Header; src/Content123456789101112131415161718192021222324252627282930import React, &#123; Component &#125; from &#x27;react&#x27;import PropTypes from &#x27;prop-types&#x27;import ThemeSwitch from &#x27;./ThemeSwitch&#x27;import &#123;connect&#125; from &#x27;./react-redux&#x27;class Content extends Component &#123; static propTypes = &#123; themeColor: PropTypes.string &#125; render() &#123; return ( &lt;div&gt; &lt;p style=&#123;&#123;color: this.props.themeColor&#125;&#125;&gt;React-Redux 的内容&lt;/p&gt; &lt;ThemeSwitch/&gt; &lt;/div&gt; ) &#125;&#125;const mapState2Props = (state)=&gt;&#123; return &#123; themeColor: state.themeColor &#125;&#125;Content = connect(mapState2Props)(Content)export default Content 下一节将对 ThemeSwitch 组件进行重构","categories":[{"name":"教程","slug":"教程","permalink":"https://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"React","slug":"React","permalink":"https://sunyunzeng.com/tags/React/"}]},{"title":"自己实现 React-Redux (三)：结合 context 和 store","slug":"自己实现-React-Redux-三-：结合-context-和-store","date":"2020-05-16","updated":"2022-11-05","comments":true,"path":"自己实现-React-Redux-三-：结合-context-和-store/","link":"","permalink":"https://sunyunzeng.com/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-React-Redux-%E4%B8%89-%EF%BC%9A%E7%BB%93%E5%90%88-context-%E5%92%8C-store/","excerpt":"","text":"构建 createStore 函数实现 Redux 架构原理: 构造一个函数 createStore，该函数可以对全局变量的状态进行统一的管理。该函数传入一个全局 state 以及状态修改纯函数 reducer, reducer 定义了改变状态的逻辑并返回一个新的状态，为后面的动态渲染优化做准备。 在 src/index.js 中加入 createStore 函数 12345678910111213141516171819202122232425262728293031323334353637function createStore(reducer)&#123; // 初始状态 let state = null // 定义发布者 const listeners = [] // 绑定订阅者 const subscribe = (listener)=&gt;listeners.push(listener) // 获取 state const getState = ()=&gt;state // 绑定处理函数 const dispatch = (action)=&gt;&#123; state = reducer(state, action) // 数据更新自动通知给订阅者 liSteners.forEach(listener=&gt;listener()) &#125; // 初始化 state dispatch(&#123;&#125;) // 初始化 // 返回状态管理对象 return &#123;getState, dispatch, subscribe&#125;&#125;const themeReducer = (state, action)=&gt;&#123; if(!state)&#123; return &#123; themeColor: &#x27;red&#x27; &#125; &#125; switch(action.type)&#123; case &#x27;CHANGE_COLOR&#x27;: return &#123;...state, themeColor: action.themeColor&#125; default: return state &#125;&#125;const store = createStore(themeReducer); 子组件调用 store 并修改 state首先父组件 src/index.js 中定义 store 上下文： 123456789101112131415161718class Index extends Component &#123; static childContextTypes = &#123; store: PropTypes.object &#125; getChildContext()&#123; return &#123;store&#125; &#125; render() &#123; return ( &lt;div&gt; &lt;Header/&gt; &lt;Content/&gt; &lt;/div&gt; ) &#125;&#125; 然后修改 src/Header.js，让它从 Index 的 context 里面获取 store，并且获取里面的 themeColor 状态来设置自己的颜色： 123456789101112131415161718192021222324252627282930313233343536import React, &#123; Component &#125; from &#x27;react&#x27;import PropTypes from &#x27;prop-types&#x27;class Header extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor()&#123; super() this.state = &#123; themeColor: &#x27;&#x27; &#125; &#125; componentWillMount()&#123; this._updateThemeColor() &#125; _updateThemeColor()&#123; const &#123;store&#125; = this.context const themeColor = store.getState().themeColor; this.setState(&#123;themeColor&#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;h1 style=&#123;&#123;color: this.state.themeColor&#125;&#125;&gt;动手实现React-Redux&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;export default Header; 然后界面的标题栏变成了红色： 如法炮制 Content.js： 1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from &#x27;react&#x27;import PropTypes from &#x27;prop-types&#x27;import ThemeSwitch from &#x27;./ThemeSwitch&#x27;class Content extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor()&#123; super() this.state = &#123; themeColor: &#x27;&#x27; &#125; &#125; componentWillMount()&#123; this._updateThemeColor() &#125; _updateThemeColor()&#123; const &#123;store&#125; = this.context const themeColor = store.getState().themeColor this.setState(&#123;themeColor&#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;p style=&#123;&#123;color: this.state.themeColor&#125;&#125;&gt;React-Redux 的内容&lt;/p&gt; &lt;ThemeSwitch/&gt; &lt;/div&gt; ) &#125;&#125;export default Content 还有 src/ThemeSwitch.js： 123456789101112131415161718192021222324252627282930313233343536import React, &#123; Component &#125; from &#x27;react&#x27;import PropTypes from &#x27;prop-types&#x27;class ThemeSwitch extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor()&#123; super() this.state = &#123; themeColor: &#x27;&#x27; &#125; &#125; componentWillMount()&#123; this._updateThemeColor() &#125; _updateThemeColor()&#123; const &#123;store&#125; = this.context const themeColor = store.getState().themeColor this.setState(&#123;themeColor&#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;button style=&#123;&#123;color: this.state.themeColor&#125;&#125;&gt;Red&lt;/button&gt; &lt;button style=&#123;&#123;color: this.state.themeColor&#125;&#125;&gt;Blue&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default ThemeSwitch; 效果图如下： 然后给按钮绑定 click 监听事件，使用 store 的 dispatch 方法触发指定事件，修改 state 的颜色。同时使用 store 的 subscript 方法绑定订阅者执行函数，执行颜色更新。 在 src/ThemeSwitch.js 文件中添加代码： 12345678910111213141516171819202122232425262728_updateThemeColor()&#123; const &#123;store&#125; = this.context const themeColor = store.getState().themeColor this.setState(&#123;themeColor&#125;) store.subscribe(this._updateThemeColor.bind(this))&#125;handleThemeSwitchClick(color)&#123; const &#123;store&#125; = this.context store.dispatch(&#123; type: &#x27;CHANGE_COLOR&#x27;, themeColor: color &#125;)&#125;render() &#123; return ( &lt;div&gt; &lt;button style=&#123;&#123;color: this.state.themeColor&#125;&#125; onClick=&#123;this.handleThemeSwitchClick.bind(this, &#x27;red&#x27;)&#125; &gt;Red&lt;/button&gt; &lt;button style=&#123;&#123;color: this.state.themeColor&#125;&#125; onClick=&#123;this.handleThemeSwitchClick.bind(this, &#x27;blue&#x27;)&#125; &gt;Blue&lt;/button&gt; &lt;/div&gt; )&#125; 给 Header.js、Content.js 文件中添加代码： 123456_updateThemeColor()&#123; const &#123;store&#125; = this.context const themeColor = store.getState().themeColor this.setState(&#123;themeColor&#125;) store.subscribe(this._updateThemeColor.bind(this))&#125; 现在点击按钮，就会执行修改颜色的动作 CHANGE_COLOR， 然后修改全局的主题颜色变量 themeColor，进而修改所有内容的颜色：","categories":[{"name":"教程","slug":"教程","permalink":"https://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"React","slug":"React","permalink":"https://sunyunzeng.com/tags/React/"}]},{"title":"自己实现 React-Redux (二)：初始化工程","slug":"自己实现-React-Redux-二-：初始化工程","date":"2020-05-16","updated":"2022-11-05","comments":true,"path":"自己实现-React-Redux-二-：初始化工程/","link":"","permalink":"https://sunyunzeng.com/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-React-Redux-%E4%BA%8C-%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"构建项目在命令行依次输入以下命令 12// 利用脚手架创建新项目npx create-react-app react-redux 12// 安装类型检查依赖npm install --save prop-types 创建文件安装好后在 src/ 目录下新增三个文件：Header.js、Content.js、ThemeSwitch.js。 修改 src/Header.js： 1234567891011121314import React, &#123; Component &#125; from &#x27;react&#x27;import PropTypes from &#x27;prop-types&#x27;class Header extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;动手实现React-Redux&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;export default Header; 修改 src/ThemeSwitch.js： 123456789101112131415import React, &#123; Component &#125; from &#x27;react&#x27;import PropTypes from &#x27;prop-types&#x27;class ThemeSwitch extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;button&gt;Red&lt;/button&gt; &lt;button&gt;Blue&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default ThemeSwitch; 修改 src/Content.js： 12345678910111213141516import React, &#123; Component &#125; from &#x27;react&#x27;import PropTypes from &#x27;prop-types&#x27;import ThemeSwitch from &#x27;./ThemeSwitch&#x27;class Content extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;p&gt;React-Redux 的内容&lt;/p&gt; &lt;ThemeSwitch/&gt; &lt;/div&gt; ) &#125;&#125;export default Content 修改 src/index.js： 12345678910111213141516171819202122import React, &#123;Component&#125; from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#x27;./index.css&#x27;;import Header from &#x27;./Header&#x27;;import Content from &#x27;./Content&#x27;;import PropTypes from &#x27;prop-types&#x27;;class Index extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Header/&gt; &lt;Content/&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Index/&gt;, document.getElementById(&#x27;root&#x27;)); 启动查看界面如下所示：","categories":[{"name":"教程","slug":"教程","permalink":"https://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"React","slug":"React","permalink":"https://sunyunzeng.com/tags/React/"}]},{"title":"自己实现 React-Redux (一)：React.js中的 context","slug":"自己实现-React-Redux-一-：React-js中的-context","date":"2020-05-15","updated":"2022-11-05","comments":true,"path":"自己实现-React-Redux-一-：React-js中的-context/","link":"","permalink":"https://sunyunzeng.com/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-React-Redux-%E4%B8%80-%EF%BC%9AReact-js%E4%B8%AD%E7%9A%84-context/","excerpt":"","text":"Redux架构Redux是一种前端架构，是由 Facebook 的 Flux 框架演变而来，但避开了 Flux 的复杂性。而 Flux 是一种模式而非正式框架，通过利用单项数据流补充React的组合视图组件。 Redux要解决的问题React的数据流是单项数据流，如果任何一个子组件依赖了父组件的状态，就需要将状态存储到父组件中进行状态提升。但假设该父组件又是另一组件的子组件且状态又由另一组件决定，那么状态又需提升至另一组件。层层的状态依赖非常麻烦。 React中可以通过设置 context属性实现全局变量的效果，任何该组件的子组件都可以读取到 context 属性；而一旦 context 属性改变，所有依赖 context 属性的组件都会更新。 并且所有能读取到 context 的组件都可以对该属性进行修改，如果在组件关系非常复杂，到处存在这种修改父组件 context 的逻辑，那么可能产生难以预测的后果。 因此 Redux 规范了修改全局属性 state 的方法，便于状态改变的维护与管理。 核心概念1. 单一数据源 整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 2. State 是只读的 唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。 3. 使用纯函数来执行修改 为了描述 action 如何改变 state tree ，你需要编写 reducers。 reducers是一个纯函数，纯函数是输出结果仅依赖于输入参数，且不会有副作用，即函数执行过程不会产生外部可观察的变化。 总结共享的状态如果可以被任意修改的话，那么程序的行为将非常不可预料，所以需要用一种模式 Redux 来统一对数据修改进行管理。 而将 Redux 架构应用到 React 中就是 React-Redux。 React 中的 context前面提到，context 的属性是 react 中的全局变量，不是通过单项数据流来实现数据传递，可以穿透子组件进行数据传递。 由于该属性直接利用或修改非常危险，所以尽量不要直接使用该属性，就像 Javascript 里尽量避免全局变量一样。 但该属性对于后面实现 React-Redux 很有帮助，所以先简单讲解一下基本使用。 定义组件树123456789101112131415161718192021222324252627282930class Parent extends Component &#123; render()&#123; return ( &lt;div&gt; &lt;Children/&gt;, &lt;/div&gt; ) &#125;&#125;class Children extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;p&gt;Children的颜色&lt;/p&gt;, &lt;GrandChildren/&gt; &lt;/div&gt; ) &#125;&#125;class GrandChildren extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;p&gt;GrandChildren的颜色&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 父组件定义 context 属性123456789101112131415161718192021222324class Parent extends Component &#123; static childContextTypes = &#123; textColor: PropTypes.string &#125; constructor()&#123; super() this.state = &#123;textColor: &#x27;red&#x27;&#125; &#125; getChildContext()&#123; return &#123;textColor: this.state.textColor&#125; &#125; render()&#123; return ( &lt;div&gt; &lt;Children/&gt;, &lt;GrandChildren/&gt; &lt;/div&gt; ) &#125;&#125; 父组件通过 getChildContext 方法返回对象传递 context。父组件要想 context 属性生效，必须定义 childContextTypes 属性，因为 context 是一个危险的特性，按照 React.js 团队的想法就是，把危险的事情搞复杂一些，提高使用门槛人们就不会去用了。如果你要给组件设置 context，那么 childContextTypes 是必写的。 子组件接收 context1234567891011121314class GrandChildren extends Component &#123; static contextTypes = &#123; textColor: PropTypes.string &#125; render() &#123; return ( &lt;div&gt; &lt;p style=&#123;&#123;color: this.context.textColor&#125;&#125;&gt;GrandChildren的颜色&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 子组件要想读取 context，必须定义 contextTypes 进行 context 输入属性验证，然后可以直接使用 this.context 读取父组件属性。 参考资料 React.js 小书 Flux架构讲解 Redux中文文档","categories":[{"name":"教程","slug":"教程","permalink":"https://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"React","slug":"React","permalink":"https://sunyunzeng.com/tags/React/"}]},{"title":"用JS写算法","slug":"用JS写算法","date":"2020-04-24","updated":"2022-11-05","comments":true,"path":"用JS写算法/","link":"","permalink":"https://sunyunzeng.com/%E7%94%A8JS%E5%86%99%E7%AE%97%E6%B3%95/","excerpt":"","text":"用JS去除字符串前后空格1234567891011121314151617181920212223242526272829function trim(str)&#123; if(!str) return &quot;&quot;; return trimRight(trimLeft(str));&#125;function trimLeft(str)&#123; // 判断字符串（去掉换行、tab等） const judgeStr = new String(&quot; \\t\\r\\n&quot;); if(judgeStr.indexOf(str.charAt(0))!==-1)&#123; let j = 1, len = str.length; while(j&lt;len &amp;&amp; judgeStr.indexOf(str.charAt(j))!==-1)&#123; j++; &#125; str = str.substring(j); &#125; return str;&#125;function trimRight(str)&#123; const judgeStr = new String(&quot; \\t\\r\\n&quot;); let i = str.length-1; if(judgeStr.indexOf(str.charAt(i))!==-1)&#123; while(i&gt;=0 &amp;&amp; judgeStr.indexOf(str.charAt(i))!==-1)&#123; i--; &#125; str = str.substring(0, i+1); &#125; return str;&#125; JS 面对经典的排序问题快速排序选择一个判断标准，然后根据这个标准将数组分割成大小两部分，然后对这两部分分别分割，直到排序完毕。 123456789101112131415161718192021222324252627282930313233function quickSort(arr)&#123; partition(arr, 0, arr.length-1); return arr;&#125;const partition = function(arr, left, right)&#123; let idx = subSort(arr, left, right); if(left &lt; idx-1)&#123; partition(arr, left, idx-1); &#125; if(right &gt; idx)&#123; partition(arr, idx, right); &#125;&#125;const subSort = function(arr, left, right)&#123; const target = arr[Math.floor((left+right)/2)]; let i=left, j=right; while(i&lt;=j)&#123; while(i&lt;arr.length &amp;&amp; arr[i]&lt;target)&#123; i++; &#125; while(j&gt;=0 &amp;&amp; arr[j]&gt;target)&#123; j--; &#125; if(i&lt;=j)&#123; [arr[i], arr[j]] = [arr[j], arr[i]]; i++; j--; &#125; &#125; return i;&#125; 时间负责度 如果每次选择的 target 都是中间大小的，则最优 O(nlogn) 如果每次选择都是最大的（对于升序排序），则退化为冒泡排序。 空间复杂度 O(1) 参考 归并排序分治思想，先划分数组，然后依次排序，归并。 12345678910111213141516171819202122232425function mergeSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125; let idx = Math.floor(arr.length/2); return merge(mergeSort(arr.slice(0,idx)), mergeSort(arr.slice(idx)));&#125;const merge = function(left, right)&#123; let i = 0, j = 0, res = []; while(i&lt;left.length &amp;&amp; j &lt; right.length)&#123; if(left[i]&lt;right[j])&#123; res.push(left[i++]); &#125;else&#123; res.push(right[j++]) &#125; &#125; while(i&lt;left.length)&#123; res.push(left[i++]); &#125; while(j&lt;right.length)&#123; res.push(right[j++]); &#125; return res;&#125; 时间复杂度 O(nlogn) 空间复杂度 O(n + logn) 也就是 O(n) 归并排序比较稳定，但是比较吃内存空间。快速排序不稳定，但是不消耗内存空间。 插入排序1234567891011function insertSort(arr)&#123; for(let i=1; i&lt;arr.length; i++)&#123; let temp = arr[i], j=i; while(j-1&gt;=0 &amp;&amp; arr[j-1]&gt;temp)&#123; arr[j] = arr[j-1]; j--; &#125; arr[j] = temp; &#125; return arr;&#125; 大数相加js 里面的 Number 用64位浮点数表示，数值范围为 -2^53 ——— 2^53 (包含边界)。如果数值相加后的结果超过这个范围，则会导致精度丢失。 大数相加原理是利用数组可以自动扩容来保存计算结果，并用字符串的形式输入与输出。 12345678910111213141516171819202122232425function addBigNum(num1, num2)&#123; [num1, num2] = [num1 + &#x27;&#x27;, num2 + &#x27;&#x27;]; let len1 = num1.length, len2 = num2.length; for(let i=0; i&lt;(Math.max(len1, len2)-Math.min(len1, len2)); i++)&#123; if(len1&lt;len2)&#123; num1 = &#x27;0&#x27; + num1; &#125;else&#123; num2 = &#x27;0&#x27; + num2; &#125; &#125; let res = []; num1 = num1.split(&#x27;&#x27;).reverse(); num2 = num2.split(&#x27;&#x27;).reverse(); for(let i=0; i&lt;num1.length; i++)&#123; res[i] = res[i]===1?res[i]:0; let s = res[i] + parseInt(num1[i]) + parseInt(num2[i]); if(s&lt;10)&#123; res[i] = s; &#125;else&#123; res[i] = s-10; res[i+1] = 1; &#125; &#125; return res.reverse().join(&#x27;&#x27;);&#125; 大数相乘思路与大数相加类似。 1234567891011121314151617181920212223242526272829303132333435function multiplyBigNUm(num1, num2)&#123; [num1, num2] = [num1 + &#x27;&#x27;, num2 + &#x27;&#x27;]; let [len1, len2] = [num1.length, num2.length]; let shortNum, longNum, shortLen, longLen if(len1 &lt; len2)&#123; [shortNum, longNum, shortLen, longLen] = [num1, num2, len1, len2]; &#125;else&#123; [shortNum, longNum, shortLen, longLen] = [num2, num1, len2, len1]; &#125; shortNum = shortNum.split(&#x27;&#x27;).reverse(); let res = &#x27;&#x27;; for(let i=0; i&lt;shortLen; i++)&#123; let temp = multiply(longNum, shortNum[i]); for(let j=0; j&lt;i; j++) temp += &#x27;0&#x27;; res = addBigNum(temp, res); &#125; return res;&#125;function multiply(num, n)&#123; num = num.split(&#x27;&#x27;).reverse(); n = parseInt(n); let res = []; for(let i=0; i&lt;num.length; i++)&#123; res[i] = res[i]?res[i]:0; let tmp = res[i] + parseInt(num[i])*n; if(tmp &lt; 10)&#123; res[i] = tmp; &#125;else&#123; res[i] = tmp%10; res[i+1] = Math.floor(tmp/10); &#125; &#125; return res.reverse().join(&#x27;&#x27;);&#125; 实现 add(1,2,3) == 6, add(1,2,3)() = 6, add(1)(2)(3) = 6, add(1)(2)(3)() = 61234567891011121314151617181920212223function add()&#123; let res = [...arguments].reduce((a, b)=&gt;&#123; return a+b; &#125;, 0); let innerAdd = function()&#123; if(arguments.length===0)&#123; return res; &#125;else&#123; res += [...arguments].reduce((a, b)=&gt;&#123; return a+b; &#125;, 0); return innerAdd; &#125; &#125; innerAdd.toString = function()&#123; return res; &#125; innerAdd.toValue = function()&#123; return res; &#125; return innerAdd;&#125; 实现 add(1)(2)(3)().res = 6, add(1,2)(3)().res = 612345678910111213141516171819202122232425function add()&#123; let res = [...arguments].reduce((a, b)=&gt;&#123; return a+b; &#125;, 0); let obj = &#123;res: res&#125;; let innerAdd = function()&#123; if(arguments.length===0)&#123; return obj; &#125;else&#123; res += [...arguments].slice(1).reduce((a, b)=&gt;&#123; return a+b; &#125;, 0); obj.res = res; return innerAdd; &#125; &#125; innerAdd.toString = function()&#123; return res; &#125; innerAdd.toValue = function()&#123; return res; &#125; return innerAdd;&#125; 实现superBaby一个superBaby 输入superBaby(“syz”) 输出：“I am syz” 输入superBaby(“syz”).eat(“banana”) 输出“I am syz”“Eating banana” 输入superBaby(“syz”).sleep(5000).eat(“banana”) 输出“I am syz”// 等待 5000ms 后输出“Eating banana” 输入superBaby(“syz”).eat(“banana”).sleep(5000).eat(“apple”).firstSleep(5000) 输出// 等待 5000ms 后输出“I am syz”“Eating banana”// 等待 5000ms 后输出“Eating apple” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function SuperBaby(name) &#123; return new _superBaby(name);&#125;function _superBaby(name) &#123; let that = this; let fn = function () &#123; console.log(`I am $&#123;name&#125;`); that.next(); &#125; this.task.push(fn); setTimeout(()=&gt;this.next(), 0);&#125;_superBaby.prototype = &#123; constructor: _superBaby, task: [], next: function () &#123; let fn = this.task.shift(); fn &amp;&amp; fn(); &#125;, eat: function (food) &#123; let that = this; let fn = function () &#123; console.log(`Eating $&#123;food&#125;`); that.next(); &#125; this.task.push(fn); return this; &#125;, sleep: function(time)&#123; let that = this; let fn = function()&#123; setTimeout(()=&gt;that.next(), time); &#125;; this.task.push(fn); return this; &#125;, sleepFirst: function(time)&#123; let that = this; let fn = function()&#123; setTimeout(()=&gt;that.next(), time); &#125;; this.task.unshift(fn); return this; &#125;&#125;SuperBaby(&quot;syz&quot;).sleep(5000).eat(&quot;banana&quot;).sleepFirst(5000); 手写 apply、call 及 bind12345678910111213141516171819202122232425262728293031323334353637// applyFunction.myApply = function(context, args)&#123; if( typeof this !== &#x27;function&#x27;)&#123; throw new TypeError(&#x27;Error&#x27;); &#125; context = context || window; args = args || []; context.fn = this; const res = context.fn(...args); delete context.fn; return res;&#125;// callFunction.myCall = function(context, ...args)&#123; if(typeof this !== &#x27;function&#x27;)&#123; throw new TypeError(&#x27;Error&#x27;); &#125; context = context || window; context.fn = this; const res = context.fn(...args); delete context.fn; return res;&#125;// bindFunction.muBind = function(context)&#123; if (typeof this !== &#x27;function&#x27;) &#123; throw new TypeError(&#x27;Error&#x27;) &#125; let that = this; let args = [...arguments].slice(1); context = context || window; return function()&#123; that.apply(context, args.concat([...arguments])) &#125;&#125; 判断一个对象是否是数组 判断是否为数组的实例 判断原型对象与数组的原型对象是否一致 判断对象的构造函数是否是 Array 调用 Array.isArray() 方法 12345678910111213141516function judgeArray(arr, pattern)&#123; switch(pattern)&#123; case 1: return Array.isArray(arr); break; case 2: return arr instanceof Array; break; case 3: return arr.constructor === Array; break; case 4: return Object.getPrototypeOf(arr) === Array.prototype; break; &#125;&#125; 实现 Promise.allPromise.all 允许定义的 Promise 按照数组传入，并依次执行 Promise 并将结果保存在一个列表中，返回一个Promise. 123456789101112131415161718192021222324let p1 = new Promise((resolve, reject)=&gt;&#123; resolve(&quot;只要有爱,&quot;);&#125;);let p2 = new Promise((resolve, reject)=&gt;&#123; resolve(&quot;在哪里都是天堂！&quot;)&#125;);let p3 = Promise.reject(&quot;不要让恨遮蔽了双眼！&quot;);Promise.all([p1, p2]).then(res=&gt;&#123; console.log(res)&#125;)Promise.all([p1, p2, p3]).then(res=&gt;&#123; console.log(res);&#125;).catch(err=&gt;&#123; console.log(err);&#125;)// output// [ &#x27;只要有爱,&#x27;, &#x27;在哪里都是天堂！&#x27; ]// 不要让恨遮蔽了双眼！ 自己实现. 12345678910111213141516171819202122232425Promise.myAll = function(promises)&#123; return new Promise((resolve, reject)=&gt;&#123; let res = []; promises.forEach((promise, index)=&gt;&#123; promise.then(data=&gt;&#123; res.push(data); if(index===promises.length-1)&#123; resolve(res); &#125; &#125;).catch(err=&gt;&#123; reject(err); &#125;) &#125;); &#125;)&#125;Promise.myAll([p1, p2]).then(res=&gt;&#123; console.log(res)&#125;)Promise.myAll([p1, p2, p3]).then(res=&gt;&#123; console.log(res);&#125;).catch(err=&gt;&#123; console.log(err);&#125;) 模拟 Node.js 的 Event 模块1234567891011121314151617181920212223242526272829303132333435class Event &#123; constructor()&#123; this.fns = &#123;&#125;; &#125; emit(name, value)&#123; if(!this.fns[name])&#123; throw Error(&quot;No such event&quot;); &#125; this.fns[name].forEach(fn=&gt;&#123; fn(value); &#125;) &#125; on(name, cb)&#123; if(!this.fns[name])&#123; this.fns[name] = []; &#125; this.fns[name].push(cb); &#125;&#125;let event = new Event();event.on(&#x27;sayName&#x27;, function(name)&#123; console.log(name);&#125;)event.on(&#x27;sayName&#x27;, function(name)&#123; console.log(`I am $&#123;name&#125;`);&#125;)event.emit(&#x27;sayName&#x27;, &#x27;syz&#x27;);// 输出// syz// I am syz 深克隆一般深度克隆可以采用 Json.Parse(Json.stringify())，但是克隆存在一些问题 123456789101112131415161718function deepClone(obj)&#123; if(obj instanceof Date)&#123; return new Date(obj); &#125; let res = obj instanceof Array?[]:&#123;&#125;; Object.keys(obj).forEach(key=&gt;&#123; res[key] = typeof obj[key] === &#x27;object&#x27;? deepClone(obj[key]):obj[key]; &#125;); return res;&#125;let rawObj = &#123;name:&#x27;syz&#x27;&#125;let testObj = deepClone(rawObj);testObj.name = &#x27;xz&#x27;;console.log(rawObj)console.log(testObj) 自己实现模版字符串12345678910111213const obj = &#123; name: &#x27;zj&#x27;, age: 18 &#125;const str = `我的名字叫$&#123; obj.name &#125;，今年$&#123;obj.age&#125;岁` function replace(str)&#123; return str.replace(/\\$\\&#123;([^&#125;]+)\\&#125;/, function(data)&#123; return data; &#125;); &#125;console.log(replace(str)) 实现展开任意深度的嵌套列表123456789101112131415// -1表示全部展开function flatten(arr, depth=-1)&#123; if(depth===-1)&#123; return [].concat( ...arr.map((item)=&gt;&#123; return Array.isArray(item)?flatten(item):item &#125;) ); &#125; if(depth===1)&#123; return arr.reduce((pre, cur)=&gt;pre.concat(cur),[]) &#125;else&#123; return arr.reduce((pre, cur)=&gt;pre.concat(Array.isArray(cur)?flatten(cur, depth-1):cur), []); &#125;&#125; 实现金钱的每三位划分1234567let arr = &#x27;1234567890&#x27;function trans(arr)&#123; return arr.split(&#x27;&#x27;).reverse().reduce((pre, cur, idx)=&gt;&#123; return ((idx%3)?cur:cur+&#x27;,&#x27;) + pre &#125;)&#125;console.log(trans(arr));// [1, 2, 3, 4] 分时函数对于需要频繁添加大量DOM结构的操作，如果不设计一定的策略，浏览器在短时间渲染这个多DOM结构，会造成浏览器的卡顿。 此时可以设计分时函数，在指定时间间隔内，执行指定次数的函数，添加指定数量的DOM结构。 例如有一个好友列表，需要动态渲染其中成百上千的列表，此时可以采用分时函数。 123456789101112131415161718192021222324252627282930313233let timeChunk = function(arr, fn, count, time)&#123; let start = function()&#123; for(let i=0; i&lt;Math.min(count || 1, arr.length); i++)&#123; let content = arr.shift(); fn(content); &#125; &#125; return function()&#123; let t = setInterval(function()&#123; if(arr.length===0)&#123; clearInterval(t); t=null; &#125;else&#123; start(); &#125; &#125;, time); &#125;&#125;let ls = [];for(let i=0; i&lt;100; i++)&#123; ls.push(i);&#125;let renderFriendList = timeChunk(ls, function(content)&#123; let div = document.createElement(&#x27;div&#x27;); div.innerHTML = content; document.body.appendChild(div);&#125;, 8, 200);renderFriendList();","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sunyunzeng.com/tags/JavaScript/"}]},{"title":"自己动手实现符合Promise/A+规范的Promise","slug":"自己动手实现符合Promise-A-规范的Promise","date":"2020-04-14","updated":"2022-11-05","comments":true,"path":"自己动手实现符合Promise-A-规范的Promise/","link":"","permalink":"https://sunyunzeng.com/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%AC%A6%E5%90%88Promise-A-%E8%A7%84%E8%8C%83%E7%9A%84Promise/","excerpt":"","text":"Promise异步实现之前在JS异步函数小结里面初步介绍了JS里面的一些异步操作与 Promise 的使用方法，我们要知其然也要知其所以然，所以让我们看一下如何动手实现自己的 MyPromise。 Promise/A+协议协议是实现的基础，Promise/A+协议的中文参考网站如下： https://www.ituring.com.cn/article/66566 英文网站如下： https://promisesaplus.com/ 实现最简单的构造函数，可以满足回调函数的调用 首先Promise构造参数只能接受函数，否则报错。 Promise内部变量包括： 值 value =&gt; 指任何 JavaScript 的合法值（包括 undefined , thenable 和 promise）。 拒因 reason =&gt; 值一个 promise 拒绝的原因。 状态 state =&gt; promise 执行所处的状态 Promise规范规定了Promise的状态一共有三种：Pending、Fulfilled 及 Rejected。状态之间的转换只能是 Pending =&gt; Fulfilled 或者 Pending =&gt; Rejected，状态的转换不可逆转。 初步实现： 1234567891011121314151617181920212223// MyPromise.jsclass MyPromise&#123; constructor(executor)&#123; // Promise的构造函数参数必须是函数，否则报错 if(typeof executor !== &quot;function&quot;)&#123; throw new TypeError(`Promise resolver $&#123;executor&#125; is not a function`); &#125; this.initValue(); &#125; // 内部参数初始化 initValue()&#123; this.value = null; // 值 this.reason = null; //据因 this.state = MyPromise.PENDING; // 初始状态 &#125;&#125;MyPromise.PENDING = &quot;Pending&quot;;MyPromise.FULFILLED = &quot;Fulfilled&quot;;MyPromise.REJECTED = &quot;Rejected&quot;; 同时 Promise 采用两个回调函数作为值 value 传递的方法，分别是 resolve 函数 及 reject 函数，分别对应 Fulfilled 状态及 Rejected 状态的函数回调，回调函数分别为 OnFulfilled 及 OnRejected。 123456789101112131415class MyPromise&#123; // ... then(OnFulfilled, OnRejected)&#123; // promise 执行成功后回调 if(this.state === MyPromise.FULFILLED)&#123; OnFulfilled(this.value); &#125; // promise 执行失败后回调 if(this.state === MyPromise.REJECTED)&#123; OnRejected(this.value); &#125; &#125;&#125; 测试 12345678let promise = new MyPromise(&#x27;1&#x27;); // 报错 TypeError: Promise resolver 1 is not a functionlet promise2 = new MyPromise((resolve, reject)=&gt;&#123; resolve(1);&#125;);promise2.then(data=&gt;console.log(data)); // 打印 1可以执行 问题 如果promise函数内存在异步，那么 state 状态仍为 Pending 但是 then 函数为同步执行，导致 value 没有同步传递，没有输出。 1234567let promise3 = new MyPromise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(1); &#125;) &#125;);promise3.then(data=&gt;console.log(data)) // 没有输出 解决 添加 state 为 Pending 状态时的处理，并用两个任务队列 OnFulfilledCallbacks 及 OnRejectedCallbacks 分别存储状态为 OnFulfilled 及 OnRejected 的异步执行回调函数，然后等 resolve 函数执行完毕再调用回调函数。 12345678910111213141516171819202122232425262728293031// MyPromise.js// resolve 函数执行，state 变为 FULFILLEDresolve(value) &#123; // ... this.OnFulfilledCallbacks.forEach(cb =&gt; cb(this.value));&#125;// reject 函数执行，state 变为 REJECTEDreject(reason) &#123; // ... this.OnRejectedCallbacks.forEach(cb =&gt; cb(this.reason));&#125;then(OnFulfilled, OnRejected) &#123; // ... // 异步执行函数状态为 Pending 时的处理 if (this.state === MyPromise.PENDING) &#123; this.OnFulfilledCallbacks.push( (value) =&gt; setTimeout(() =&gt; &#123; OnFulfilled(value); &#125;)); this.OnRejectedCallbacks.push( (reason) =&gt; setTimeout(() =&gt; &#123; OnRejected(reason); &#125;)); &#125; &#125; 1234567let promise3 = new MyPromise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(1); &#125;) &#125;);promise3.then(data=&gt;console.log(data)) // 输出 1 链式调用根据 Promise/A+ 的规范定义，Promise的 then 函数返回一个 promise2 以支持链式调用，因此对代码进行修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566then(OnFulfilled, OnRejected) &#123; if(typeof OnFulfilled !== &quot;function&quot;)&#123; // 如果 OnFulfilled 不是函数或者为空就支持链式调用 .then().then() OnFulfilled = function(value)&#123; return value; &#125; &#125; if(typeof OnRejected !== &quot;function&quot;)&#123; OnRejected = function(reason)&#123; throw reason; &#125; &#125; let promise2 = new MyPromise((resolve, reject) =&gt; &#123; // promise 执行成功后回调 if (this.state === MyPromise.FULFILLED) &#123; setTimeout(() =&gt; &#123; // 上一个 Promise回调函数返回的值交给下一个 Promise调用 try&#123; const x = OnFulfilled(this.value); resolve(x); &#125;catch(e)&#123; reject(e); &#125; &#125;) &#125; // promise 执行失败后回调 if (this.state === MyPromise.REJECTED) &#123; setTimeout(() =&gt; &#123; try&#123; const x = OnRejected(this.reason); resolve(x); &#125;catch(e)&#123; reject(e); &#125; &#125;) &#125; // 异步执行函数状态为 Pending 时的处理 if (this.state === MyPromise.PENDING) &#123; this.OnFulfilledCallbacks.push( (value) =&gt; setTimeout(() =&gt; &#123; try&#123; const x = OnFulfilled(value); resolve(x); &#125;catch(e)&#123; reject(e); &#125; &#125;)); this.OnRejectedCallbacks.push( (reason) =&gt; setTimeout(() =&gt; &#123; try&#123; const x = OnRejected(reason); resolve(x); &#125;catch(e)&#123; reject(e); &#125; &#125;)); &#125; &#125;); return promise2;&#125; 测试 1234567let promise4 = new MyPromise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(2); &#125;) &#125;);promise4.then().then().then(data=&gt;console.log(data)) // 2 支持链式调用 如果 resolve 函数返回 Promise 或者 带有 thenable 方法的类及 then 方法的处理首先定义一个 resolveMyPromise 的处理方法 1234567891011121314151617181920MyPromise.resolveMyPromise = function(promise2, x, resolve, reject)&#123; // 循环调用 thenable 方法时只调用一次 let called = false; // 如果返回的 x 等于 promise2，则报错，避免循环调用 if(x===promise2)&#123; return reject(new new TypeError(&quot;cannot return the same promise object from onfulfilled or on rejected callback.&quot;)) &#125; if(x instanceof MyPromise)&#123; &#125; // 避免null也为object else if( (x!==null &amp;&amp; typeof x === &quot;object&quot;) || typeof x ===&quot;function&quot;)&#123; &#125;else&#123; // 如果不是 MyPromise 或者不是具有 thenable 的类及方法，就直接传入 x 数据 resolve(x); &#125;&#125; 根据 Promise/A+ 的规范依次实现 resolveMyPromise 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657MyPromise.resolveMyPromise = function(promise2, x, resolve, reject)&#123; // 循环调用 thenable 方法时只调用一次 let called = false; // 如果 promise2 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise if(x===promise2)&#123; reject(new new TypeError(&quot;cannot return the same promise object from onfulfilled or on rejected callback.&quot;)) &#125; // x 为 Promise if(x instanceof MyPromise)&#123; // 如果 x 为 Promise ，则使 promise 接受 x 的状态 // 如果 x 处于执行态，用相同的值执行 promise // 如果 x 处于拒绝态，用相同的据因拒绝 promise x.then(y=&gt;&#123; MyPromise.resolveMyPromise(promise2, y, resolve, reject); &#125;, r=&gt;&#123; reject(r); &#125;) &#125; // 如果 x 为对象或者函数 (x !== null 避免null也为object) else if( (x!==null &amp;&amp; typeof x === &quot;object&quot;) || typeof x ===&quot;function&quot;)&#123; try&#123; // 防止调用 then 的 getter 方法调用抛出异常 // 把 x.then 赋值给 then const then = x.then; // 如果 then 是函数，将 x 作为函数的作用域 this 调用之。 // 传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise: if(typeof then === &quot;function&quot;)&#123; then.call(x, y=&gt;&#123; // 如果 resolvePromise 和 rejectPromise 均被调用， // 或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 if(called) return; called = true; MyPromise.resolveMyPromise(promise2, y, resolve, reject); &#125;, r=&gt;&#123; if(called) return; called = true; reject(r); &#125;) &#125;else&#123; if(called) return; called = true; resolve(x); &#125; // &#125;catch(e)&#123; if(called) return; called = true; reject(e); &#125; &#125;else&#123; // 如果不是 MyPromise 或者不是具有 thenable 的类及方法，就直接传入 x 数据 resolve(x); &#125;&#125; 再在 then 方法里面调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566then(OnFulfilled, OnRejected) &#123; if(typeof OnFulfilled !== &quot;function&quot;)&#123; // 如果 OnFulfilled 不是函数或者为空就支持链式调用 .then().then() OnFulfilled = function(value)&#123; return value; &#125; &#125; if(typeof OnRejected !== &quot;function&quot;)&#123; OnRejected = function(reason)&#123; throw reason; &#125; &#125; let promise2 = new MyPromise((resolve, reject) =&gt; &#123; // promise 执行成功后回调 if (this.state === MyPromise.FULFILLED) &#123; setTimeout(() =&gt; &#123; // 上一个 Promise回调函数返回的值交给下一个 Promise调用 try&#123; const x = OnFulfilled(this.value); MyPromise.resolveMyPromise(promise2, x, resolve, reject); &#125;catch(e)&#123; reject(e); &#125; &#125;) &#125; // promise 执行失败后回调 if (this.state === MyPromise.REJECTED) &#123; setTimeout(() =&gt; &#123; try&#123; const x = OnRejected(this.reason); MyPromise.resolveMyPromise(promise2, x, resolve, reject); &#125;catch(e)&#123; reject(e); &#125; &#125;) &#125; // 异步执行函数状态为 Pending 时的处理 if (this.state === MyPromise.PENDING) &#123; this.OnFulfilledCallbacks.push( (value) =&gt; setTimeout(() =&gt; &#123; try&#123; const x = OnFulfilled(value); MyPromise.resolveMyPromise(promise2, x, resolve, reject); &#125;catch(e)&#123; reject(e); &#125; &#125;)); this.OnRejectedCallbacks.push( (reason) =&gt; setTimeout(() =&gt; &#123; try&#123; const x = OnRejected(reason); MyPromise.resolveMyPromise(promise2, x, resolve, reject); &#125;catch(e)&#123; reject(e); &#125; &#125;)); &#125; &#125;); return promise2;&#125; 正确测试 安装 promises-aplus-tests 测试脚本 12npm install promises-aplus-tests -Dnpx promises-aplus-tests promise.js 在我们 MyPromise.js 文件夹末尾添加测试 deferred 钩子 12345678910MyPromise.deferred = function () &#123; const defer = &#123;&#125; defer.promise = new MyPromise((resolve, reject) =&gt; &#123; defer.resolve = resolve defer.reject = reject &#125;) return defer&#125;module.exports = MyPromise; 运行代码测试 1npx promises-aplus-tests MyPromise.js 结果","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sunyunzeng.com/tags/JavaScript/"}]},{"title":"D3实现多对多关联关系弧线图","slug":"D3实现多对多关联关系弧线图","date":"2020-03-22","updated":"2022-11-05","comments":true,"path":"D3实现多对多关联关系弧线图/","link":"","permalink":"https://sunyunzeng.com/D3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E5%BC%A7%E7%BA%BF%E5%9B%BE/","excerpt":"","text":"多对多关联关系基于D3实现的多对多关联关系：github地址 各人员之间的互动关系、各公司上下游企业的关联关系、各地之间的交互关系等等，都是多对多关联关系的表达，他们之间可以通过矩阵图的形式来表达, 如下图所示 (用python的heatmap： 而利用 D3库函数可以实现更为酷炫的弧线,如下图所示： 要画多方关系图，首先需要确定绘制的数据，是一个 N * N 的矩阵。 1234567891011121314matrix = [ const matrix = [ [1, 41, 0, 0, 8, 4, 2, 0, 5, 5], [6, 0, 1, 1, 1, 0, 4, 1, 0, 1], [1, 12, 0, 0, 3, 0, 1, 0, 1, 3], [0, 11, 3, 0, 4, 1, 1, 0, 0, 2], [1, 1, 0, 0, 1, 0, 0, 2, 2, 0], [4, 0, 4, 0, 0, 0, 0, 1, 0, 1], [0, 6, 0, 0, 1, 1, 0, 0, 1, 0], [1, 4, 2, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 1, 0], ]] 然后对 i 行 j 列对应的数据设计一个对象字典检索其对应的名字： 123456789101112131415161718192021222324const nameByIndex = &#123; 0: 332, 1: 229, 2: 333, 3: 343, 4: 313, 5: 357, 6: 344, 7: 318, 8: 312, 9: 329 &#125;; const indexByName = &#123; 332: 0, 229: 1, 333: 2, 343: 3, 313: 4, 357: 5, 344: 6, 318: 7, 312: 8, 329: 9 &#125;; 定义好 svg 图片的长和宽。 利用D3绘制svg，核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243if (!this.d3 || !this.config || !this.matrix || !this.nameByIndex || !this.indexByName) &#123; console.error(&#x27;initial error!&#x27;); &#125; let color = this.d3.scaleOrdinal(this.d3.schemeCategory10); let outerRadius = Math.min(this.width, this.height) * 0.5; let innerRadius = outerRadius - 124; let ribbon = this.d3.ribbon().radius(innerRadius); let arc = this.d3.arc().innerRadius(innerRadius).outerRadius(innerRadius + 20); let chord = this.d3.chord().padAngle(.04).sortSubgroups(this.d3.descending).sortChords(this.d3 .descending); let svg = this.d3.select(&quot;svg&quot;).attr(&quot;viewBox&quot;, [-this.width / 2, -this.height / 2, this.width, this .height ]) .attr(&quot;font-size&quot;, this.font_size); const chords = chord(this.matrix); const group = svg.append(&quot;g&quot;).selectAll(&quot;g&quot;).data(chords.groups).join(&quot;g&quot;); group.append(&quot;path&quot;).attr(&quot;fill&quot;, d =&gt; color(d.index)).attr(&quot;stroke&quot;, d =&gt; color(d.index)).attr(&quot;d&quot;, arc); group.append(&quot;text&quot;).each(d =&gt; &#123; d.angle = (d.startAngle + d.endAngle) / 2; &#125;) .attr(&quot;dy&quot;, &quot;.35em&quot;) .attr(&quot;transform&quot;, d =&gt; ` rotate($&#123;(d.angle * 180 / Math.PI - 90)&#125;) translate($&#123;innerRadius + 26&#125;) $&#123;d.angle &gt; Math.PI ? &quot;rotate(180)&quot; : &quot;&quot;&#125;`) .attr(&quot;text-anchor&quot;, d =&gt; d.angle &gt; Math.PI ? &quot;end&quot; : null) .text(d =&gt; this.nameByIndex[d.index]); svg.append(&quot;g&quot;) .attr(&quot;fill-opacity&quot;, 0.67) .selectAll(&quot;path&quot;) .data(chords) .join(&quot;path&quot;) .attr(&quot;stroke&quot;, d =&gt; this.d3.rgb(color(d.source.index)).darker()) .attr(&quot;fill&quot;, d =&gt; color(d.source.index)) .attr(&quot;d&quot;, ribbon); this.svg = svg; return svg; html代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;script src=&quot;https://d3js.org/d3.v5.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;ChordDependencyChart.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;body&gt; &lt;svg style=&quot;width: 1000px; height:1000px&quot;&gt;&lt;/svg&gt;&lt;/body&gt;&lt;script&gt; const matrix = [ [1, 41, 0, 0, 8, 4, 2, 0, 5, 5], [6, 0, 1, 1, 1, 0, 4, 1, 0, 1], [1, 12, 0, 0, 3, 0, 1, 0, 1, 3], [0, 11, 3, 0, 4, 1, 1, 0, 0, 2], [1, 1, 0, 0, 1, 0, 0, 2, 2, 0], [4, 0, 4, 0, 0, 0, 0, 1, 0, 1], [0, 6, 0, 0, 1, 1, 0, 0, 1, 0], [1, 4, 2, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 1, 0], ] const nameByIndex = &#123; 0: 332, 1: 229, 2: 333, 3: 343, 4: 313, 5: 357, 6: 344, 7: 318, 8: 312, 9: 329 &#125;; const indexByName = &#123; 332: 0, 229: 1, 333: 2, 343: 3, 313: 4, 357: 5, 344: 6, 318: 7, 312: 8, 329: 9 &#125;; let config = &#123; matrix: matrix, nameByIndex: nameByIndex, indexByName: indexByName, width: 1000, height: 1000 &#125; let chart = new Chart(d3, config); let svg = chart.draw(); chart.saveAsPng(svg, name = &quot;local&quot;);&lt;/script&gt;&lt;/html&gt; 其中 d3 是 D3 库函数依赖，可以使用离线包或者在线引用的方式。 ChordDependencyChart是我自定义的一个库函数，可以实现多对多关联关系弧线图绘制，并可以保存为 png 图片，效果如下： github地址","categories":[{"name":"Web可视化","slug":"Web可视化","permalink":"https://sunyunzeng.com/categories/Web%E5%8F%AF%E8%A7%86%E5%8C%96/"}],"tags":[{"name":"D3","slug":"D3","permalink":"https://sunyunzeng.com/tags/D3/"}]},{"title":"JS实现图片的懒加载","slug":"JS实现图片的懒加载","date":"2020-03-16","updated":"2022-11-05","comments":true,"path":"JS实现图片的懒加载/","link":"","permalink":"https://sunyunzeng.com/JS%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"场景需求在长博客、商品网站上经常见到大量的图片，而同时加载如此多的图片会导致服务器响应慢、页面卡顿，用户体验不佳。 而图片懒加载就是应对这个痛点。图片懒加载技术就是根据图片在可视区域的位置对图片进行逐步加载，利用 DOM对象元素属性、分流等技术实现。 实现原理步骤一 隐藏懒加载图片的 src 属性我们首先需要确定懒加载的图片资源，对于 img 标签，首先把src 属性用自定义的属性如 data-src 代替，等到图片需要加载时我们将 data-src 的网址赋予 src 属性即可。 1&lt;img data-src=&#x27;./dzq.jpg&#x27; alt=&quot;dzq&quot;&gt; 步骤二 判断待加载图片是否位于视窗范围内DOM 元素拥有一个方法 element.getBoundingClientRect()，可以获取该元素的大小及其相对于视口的位置，方法返回的是一个 DOMRect 对象，其 left, top, right, bottom 属性解释了相对于视口位置，如下所示。 然后利用 img.getBoundingClientRect().top &lt; document.documentElement.clientHeight 对图片位置进行判断。 步骤三 对加载到视口内的元素进行显示通过对 windows.scroll 进行监听，然后 img 元素新建 src 属性，并将 data-src 的地址赋予该属性。 优化而我们在监听windows.scroll 事件过程中，对于 img 元素的操作一致在进行，这就浪费了很多计算资源。为了绕开这个问题，我们使用节流技术手段。 节流对于高频事件，我们希望处理函数仅在固定的频率响应。例如，对于窗口滑动事件，可能每 20ms 就触发一次，而我们希望每 200ms 处理函数只响应一次，这样就节约了很多不必要的计算资源。 1234567891011121314151617// 节流函数定义function throttle(fn, wait)&#123; let timer; return function()&#123; let that = this; let args = arguments; if(!timer)&#123; timer = setTimeOut(function()&#123; fn.apply(that, args); timer = null; &#125;,wait) &#125; &#125;&#125;// 节流函数使用widow.addEventListener(&quot;scroll&quot;, throttle(showImg, 200)); 防抖另一个类似的技术手段就是防抖，是在高频事件触发后一定时间内使处理函数响应。它与节流函数的区别是，如果高频事件一直触发，那么处理函数一直得不到响应。 12345678910111213function debounce(fn, wait)&#123; let timer; return function()&#123; let that = this; let args = arguments; if(!timer)&#123; clearTimeOut(timer); &#125; timer = setTimeOut(function()&#123; fn.apply(that, args); &#125;, wait); &#125;&#125; demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; html, body&#123; height: 100%; width: 100%; padding: 0; margin: 0; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;upContext&quot; style=&quot;height: 100%; width: 100%; position: relative; background-color: aquamarine;&quot;&gt;?&lt;/div&gt; &lt;div style=&quot;display:flex; position: relative; align-items: center; justify-content: center;&quot;&gt; &lt;img d-src=&quot;./dzq.jpg&quot; alt=&quot;图片&quot; id=&quot;img1&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let img = document.getElementById(&#x27;img1&#x27;); let showImg = function()&#123; if(img.getBoundingClientRect().top &lt; document.documentElement.clientHeight)&#123; img.setAttribute(&#x27;src&#x27;, img.getAttribute(&#x27;d-src&#x27;)); &#125; &#125; function throttle(fn, wait)&#123; let timer; return function()&#123; let that = this; let args = arguments; if(!timer)&#123; timer = setTimeout(function()&#123; fn.apply(that, args); timer = null; &#125;, wait); &#125; &#125; &#125; window.addEventListener(&quot;scroll&quot;, throttle(showImg, 200)); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sunyunzeng.com/tags/JavaScript/"}]},{"title":"背包问题","slug":"背包问题","date":"2020-03-13","updated":"2022-11-05","comments":true,"path":"背包问题/","link":"","permalink":"https://sunyunzeng.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"01 背包有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 $v_i$，价值是 $w_i$。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 i 件物品的体积和价值。 输出格式输出一个整数，表示最大价值。 数据范围$0&lt; N,V ≤ 1000$$0&lt; v_i,w_i ≤ 1000$ 输入样例123454 51 22 43 44 5 输出样例：18 思路+方法f[i][j]表示面对第 i 件物品时，体积为 j 的背包的最大总价值。两种选择：1. 不放入第 i 件物品。 2. 放入第 i 件物品。 状态转移方程：f[i][j]=max(f[i−1][j],f[i−1][j−w[i]]+v[i]) 优化：f[j]=max(f[j],f[j−w[i]]+v[i])。此时 j 要从大到小遍历，保证第 i 件物品只能选择一次。否则 f[i][j] 会由 f[i][j−w[i]]+v[i]决定，与题意不符，而顺序遍历却是完全背包的解决方案。 1234567891011121314151617181920212223import java.util.Scanner;public class Main&#123; public static void main(String[] args) throws Exception&#123; Scanner reader = new Scanner(System.in); int N = reader.nextInt(); int V = reader.nextInt(); int[] v = new int[N]; int[] w = new int[N]; for(int i=0; i&lt;N; i++)&#123; v[i] = reader.nextInt(); w[i] = reader.nextInt(); &#125; reader.close(); int[] dp = new int[V+1]; for(int i=0; i&lt;N; i++)&#123; for(int j=V; j&gt;=v[i]; j--)&#123; dp[j] = Math.max(dp[j], dp[j-v[i]]+w[i]); &#125; &#125; System.out.println(dp[V]); &#125;&#125; 时间复杂度 O(VN) 完全背包完全背包题目与01背包大体相似，只不过每件物品可以无限选择。 思路 + 代码状态转移方程：f[i][j]=max(f[i−1][j],f[i−1][j−w[i]]+v[i])。 1234567891011121314151617181920212223import java.util.Scanner;class Main&#123; public static void main(String[] args) throws Exception&#123; Scanner in = new Scanner(System.in); int N = in.nextInt(); int V = in.nextInt(); int[] w = new int[N]; int[] v = new int[N]; for(int i=0; i&lt;N; i++)&#123; v[i] = in.nextInt(); w[i] = in.nextInt(); &#125; in.close(); int[] dp = new int[V+1]; for(int i=0; i&lt;N; i++)&#123; for(int j=v[i]; j&lt;=V; j++)&#123; dp[j] = Math.max(dp[j], dp[j-v[i]]+w[i]); &#125; &#125; System.out.println(dp[V]); &#125;&#125; 时间复杂度 O(VN) 多重背包多重背包是每个物品指定了数量。 有 N 种物品和一个容量是 V 的背包。 第 i 种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是 $w_i$。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 输入格式第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 i 种物品的体积、价值和数量。 输出格式输出一个整数，表示最大价值。 数据范围0&lt;N,V≤100$0&lt;v_i,w_i,s_i≤100$ 输入样例123454 51 2 32 4 13 4 34 5 2 输出样例：110 思路 + 代码将多重背包转化为 01背包问题，即将有限量的物品划分为互相独立的部分，每个独立的部分物品可以看作01背包问题，继续采用01背包的思想解决。 状态转移方程：f[i][j]=max(f[i−1][j],f[i−1][j−k*w[i]]+k*v[i])。 将第 i 种物品转化为 p[i]件物品，每件物品的系数分别为 $1，2, 4, …, 2^{k-1}, p[i]-2^k+1 &gt; 0$, k是满足 $p[i]-2^k+1 &gt; 0$ 的最大整数。 123456789101112131415161718192021222324252627282930import java.util.Scanner;class Main&#123; public static void main(String[] args) throws Exception&#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); int V = sc.nextInt(); int[] v = new int[N]; int[] w = new int[N]; int[] s = new int[N]; for(int i=0; i&lt;N; i++)&#123; v[i] = sc.nextInt(); w[i] = sc.nextInt(); s[i] = sc.nextInt(); &#125; sc.close(); int[]dp = new int[V+1]; for(int i=0; i&lt;N; i++)&#123; int num = Math.min(s[i], V/v[i]); for(int k=1; num&gt;0; k &lt;&lt;= 1)&#123; if(k&gt;num) k = num; num -= k; for(int j=V; j&gt;=k*v[i]; j--)&#123; dp[j] = Math.max(dp[j], dp[j-k*v[i]]+k*w[i]); &#125; &#125; &#125; System.out.println(dp[V]); &#125;&#125; 时间复杂度 O(V$\\sum{log(p(i))}$) 混合背包混合背包其实是 01背包、多重背包和完全背包的混合体。 有 N 种物品和一个容量是 V 的背包。 物品一共有三类： 第一类物品只能用1次（01背包）；第二类物品可以用无限次（完全背包）；第三类物品最多只能用 $s_i$ 次（多重背包）；每种体积是 $v_i$，价值是 $w_i$。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 输入格式第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 i 种物品的体积、价值和数量。 $s_i$=−1 表示第 i 种物品只能用1次；$s_i$=0 表示第 i 种物品可以用无限次；$s_i$&gt;0 表示第 i 种物品可以使用 $s_i$ 次； 输出格式输出一个整数，表示最大价值。 数据范围$ 0&lt;N,V≤1000 $$ 0&lt;v_i,w_i≤1000 $$ −1≤s_i≤1000 $ 输入样例123454 51 2 -12 4 13 4 04 5 2输出样例：18 思路 + 代码加入if-else判断。123456789// p[i]:每个物品的件数，0代表无穷个for (int i = 1; i &lt;= n; i++) if (p[i] == 0) for (int j = w[i]; j &lt;= V; j++) f[j] = max(f[j], f[j - w[i]] + v[i]); else for (int k = 1; k &lt;= p[i]; k++) for (int j = V; j &gt;= w[i]; j--) f[j] = max(f[j], f[j - w[i]] + v[i]); 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Scanner;class Main&#123; public static void main(String[] args) throws Exception&#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); int V = sc.nextInt(); int[] v = new int[N]; int[] w = new int[N]; int[] s = new int[N]; for(int i=0; i&lt;N; i++)&#123; v[i] = sc.nextInt(); w[i] = sc.nextInt(); s[i] = sc.nextInt(); &#125; sc.close(); int[] dp = new int[V+1]; for(int i=0; i&lt;N; i++)&#123; if(s[i] == -1)&#123; for(int j=V; j&gt;=v[i]; j--)&#123; dp[j] = Math.max(dp[j], dp[j-v[i]]+w[i]); &#125; &#125;else if(s[i]==0)&#123; for(int j=v[i]; j&lt;=V; j++)&#123; dp[j] = Math.max(dp[j], dp[j-v[i]]+w[i]); &#125; &#125;else&#123; int num = Math.min(s[i], V/v[i]); for(int k=1; num&gt;0; k &lt;&lt;=1)&#123; if(k&gt;num) k=num; num -= k; for(int j=V; j&gt;=k*v[i]; j--)&#123; dp[j] = Math.max(dp[j], dp[j-k*v[i]]+k*w[i]); &#125; &#125; &#125; &#125; System.out.println(dp[V]); &#125;&#125; 二维背包物品的约束条件除了体积外，增加了重量一维，其余跟01背包一样。 有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。 每件物品只能用一次。体积是 $v_i$，重量是 $m_i$，价值是 $w_i$。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。输出最大价值。 输入格式第一行两个整数，N，V,M，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。 接下来有 N 行，每行三个整数 $v_i,m_i,w_i$，用空格隔开，分别表示第 i 件物品的体积、重量和价值。 输出格式输出一个整数，表示最大价值。 数据范围$0&lt;N≤1000$$0&lt;V,M≤100$$0&lt;v_i,m_i≤100$$0&lt;w_i≤1000$ 输入样例123454 5 61 2 32 4 43 4 54 5 6 输出样例：18 思路 + 代码跟01背包类似，只不过两个状态。 状态转移方程：f[j][k]=max(f[j][k],f[j−w[i]][k-m[i]]+k*v[i])。 12345678910111213141516171819202122232425262728import java.util.Scanner;class Main&#123; public static void main(String[] args) throws Exception&#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); int V = sc.nextInt(); int M = sc.nextInt(); int[] v = new int[N]; int[] m = new int[N]; int[] w = new int[N]; for(int i=0; i&lt;N; i++)&#123; v[i] = sc.nextInt(); m[i] = sc.nextInt(); w[i] = sc.nextInt(); &#125; sc.close(); int[][] dp = new int[V+1][M+1]; for(int i=0; i&lt;N; i++)&#123; for(int j=V; j&gt;=v[i]; j--)&#123; for(int k=M; k&gt;=m[i]; k--)&#123; dp[j][k] = Math.max(dp[j][k], dp[j-v[i]][k-m[i]]+w[i]); &#125; &#125; &#125; System.out.println(dp[V][M]); &#125;&#125; 分组背包在01背包的基础上，对不同物品进行了分组，每组只能选取一件物品。 有 N 组物品和一个容量是 V 的背包。 每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是 $v_ij$，价值是 $w_ij$，其中 i 是组号，j 是组内编号。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。 输出最大价值。 输入格式第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。 接下来有 N 组数据： 每组数据第一行有一个整数 $S_i$，表示第 i 个物品组的物品数量；每组数据接下来有 $S_i$ 行，每行有两个整数 $v_ij,w_ij$，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值； 输出格式输出一个整数，表示最大价值。 数据范围$0&lt;N,V≤100$$0&lt;S_i≤100$$0&lt;v_ij,w_ij≤100$ 输入样例123456783 521 22 413 414 5 输出样例：18 思路 + 代码状态转移方程：1234for i in (每一种分组): for j in range(V,0,-1): for k in 分组[i]: dp[j] = max(dp[j], dp[j-分组[i][0]]+分组[i][1]) 12345678910111213141516171819202122232425262728293031323334353637import java.util.Scanner;import java.util.HashMap;import java.util.ArrayList;class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); int K = sc.nextInt(); int V = sc.nextInt(); int N = 0; HashMap&lt;Integer, ArrayList&lt;int[]&gt;&gt; map = new HashMap&lt;&gt;(); for(int i=0; i&lt;K; i++)&#123; int s = sc.nextInt(); N += s; ArrayList&lt;int[]&gt; arr = new ArrayList&lt;&gt;(); for(int j=0; j&lt;s;j++)&#123; int[] tmp = new int[2]; tmp[0] = sc.nextInt(); tmp[1] = sc.nextInt(); arr.add(tmp); map.put(i, arr); &#125; &#125; sc.close(); int[] dp = new int[V+1]; for(int i=0; i&lt;K; i++)&#123; ArrayList&lt;int[]&gt; arr = map.get(i); for(int j=V; j&gt;=0; j--)&#123; for(int k=0; k&lt;arr.size();k++)&#123; if(j&gt;=arr.get(k)[0]) dp[j] = Math.max(dp[j], dp[j-arr.get(k)[0]]+arr.get(k)[1]); &#125; &#125; &#125; System.out.println(dp[V]); &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"CSS 布局知识","slug":"CSS-布局知识","date":"2020-02-22","updated":"2022-11-05","comments":true,"path":"CSS-布局知识/","link":"","permalink":"https://sunyunzeng.com/CSS-%E5%B8%83%E5%B1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"CSS实现垂直水平居中对于父元素 parent 与 子元素 child，如何实现子元素在父元素内部的水平垂直居中？ 元素的 html 代码如下： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .parent&#123; width: 500px; height: 500px; background-color: aquamarine; &#125; .child&#123; width: 200px; height: 200px; background-color: coral; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; flex 布局123456789101112131415&lt;style&gt; .parent&#123; width: 500px; height: 500px; background-color: aquamarine; display: flex; align-items: center; justify-content: center; &#125; .child&#123; width: 200px; height: 200px; background-color: coral; &#125;&lt;/style&gt; 行内元素居中text-algin 与 vertical-algin 只对行内元素起作用，可以实现行内元素的的垂直于水平居中，此时可以利用 display: inline-block 使子元素具有行内元素的属性，实现子元素垂直水平居中 (需设置 line-height 使垂直居中有对齐的基准)。 12345678910111213141516&lt;style&gt; .parent&#123; width: 500px; height: 500px; background-color: aquamarine; vertical-algin: middle; text-algin: center; line-height: 300px; &#125; .child&#123; display: inline-block; width: 200px; height: 200px; background-color: coral; &#125;&lt;/style&gt; 绝对定位 + 元素自身移动通过 left: 50% 以及 top: 50% 只使得子元素的左上角位于父元素的中心，此时需要通过 transform: translate(-50%, -50%) 移动子元素。translate(x,y) 括号的百分比数据，会以本身的长宽做参考，比如，本身的长为100px，高为100px. 那填(50%,50%)就是向右，向下移动50px，添加负号就是向着相反的方向移动50% 1234567891011121314151617&lt;style&gt; .parent&#123; width: 500px; height: 500px; background-color: aquamarine; position: relative; &#125; .child&#123; position: absolute; width: 200px; height: 200px; left: 50%; top: 50%; background-color: coral; transform: translate(-50%, -50%); &#125;&lt;/style&gt; 1234567891011121314151617&lt;style&gt; .parent&#123; width: 500px; height: 500px; background-color: aquamarine; position: relative; &#125; .child&#123; position: absolute; width: 200px; height: 200px; left: 50%; top: 50%; background-color: coral; margin: -100px -100px; &#125;&lt;/style&gt; 利用 margin12345678910111213141516171819&lt;style&gt; .parent&#123; width: 500px; height: 500px; background-color: aquamarine; position: relative; &#125; .child&#123; position: absolute; width: 200px; height: 200px; background-color: coral; left: 0; top: 0; right: 0; bottom: 0; margin: auto; &#125;&lt;/style&gt; CSS实现三栏布局所谓的三栏布局，既是指左右两栏固定宽度，中间一栏宽度自适应的布局方式。下面列出五种实现三栏布局的方式，分别是绝对定位、float方式、flex布局、圣杯布局、双飞翼布局。 绝对定位利用绝对定位将左右两栏确定位置，中间一栏通过 margin 属性调整位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body, html, .parent&#123; height: 100%; &#125; .left&#123; position: absolute; height: 100%; width: 200px; left: 0; top: 0; background-color: coral; &#125; .middle&#123; height: 100%; margin: 0 200px 0 200px; background-color: blueviolet; &#125; .right&#123; position: absolute; height: 100%; width: 200px; right: 0; top: 0; background-color: crimson; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; float布局float定位实现三栏布局的思想是：利用float将左右两栏固定位置，并利用margin控制中间一栏的边距，从而使其宽度自适应。 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body, html, .parent&#123; height: 100%; &#125; .left&#123; height: 100%; width: 200px; float: left; background-color: coral; &#125; .right&#123; height: 100%; width: 200px; float: right; background-color: crimson; &#125; .middle&#123; height: 100%; margin: 0 200px 0 200px; background-color: blueviolet; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; flex布局flex布局实现三栏布局的思想是：利用flex:0 0 200px固定左右两栏的位置，同时确保其不随浏览器的高度和宽度而放大缩小。 flex参数参照:https://www.w3cschool.cn/cssref/css3-pr-flex.html 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body, html, .parent&#123; height: 100%; &#125; .parent&#123; display: flex; &#125; .left&#123; height: 100%; width: 200px; flex: 0 0 200px; background-color: coral; &#125; .right&#123; height: 100%; width: 200px; flex: 0 0 200px; background-color: crimson; &#125; .middle&#123; height: 100%; width: 100%; background-color: blueviolet; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 圣杯布局圣杯布局的原理是通过左、中、右列同向浮动，中间列宽度设置为100%实现宽度自适应，左右两列宽度宽度固定并通过位置控制实现分列左右两端。该布局可以实现中间布局的优先渲染，因为DOM结构上 middle 元素位于 left 和 right 元素的上层。 1. 首先父级元素设置内边距 1234.parent&#123; padding-left: 200px; padding-right: 200px;&#125; 2. 各自设置浮动方式及页面宽度 123456789101112.left&#123; width: 200px; float: left;&#125;.right&#123; width: 200px; float: left;&#125;.middle&#123; width: 100%; float: left;&#125; 3. 左栏控制位置 12345.left&#123; margin-left: -200px; position: relative; left: -100%;&#125; 4. 右栏控制位置 123.right&#123; margin-right: -200px;&#125; 5. 设置左右两栏的最小宽度 最小宽度并不是 200px + 200px = 400px，因为 left 元素采用了相对定位，其在 middle 元素上方还占有 200px 位置，所以页面的 min-width 参数为 400px + 200px = 600px。 123body&#123; min-width: 600px;&#125; 全部代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body, html, .parent&#123; height: 100%; min-width: 600px; &#125; .parent&#123; padding-left: 200px; padding-right: 200px; &#125; .left&#123; height: 100%; width: 200px; float: left; margin-left: -100%; position: relative; left: -200px; background-color: coral; &#125; .right&#123; height: 100%; width: 200px; float: left; margin-right: -200px; background-color: crimson; &#125; .middle&#123; height: 100%; width: 100%; float: left; background-color: blueviolet; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双飞翼布局双飞翼布局与圣杯布局的区别是：双飞翼布局的 parent 元素只包裹 middle 元素，left 元素与 right 元素通过控制与 parent的相对位置关系实现三栏布局。 1. 首先用 parent 仅包裹 middle 元素 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;&lt;/div&gt; 2. 所有元素设置宽度与浮动 123456789101112131415161718.parent&#123; width: 100%; float: left;&#125;.left&#123; height: 100%; width: 200px; float: left;&#125;.right&#123; height: 100%; width: 200px; float: left;&#125;.middle&#123; padding-left: 200px; padding-right: 200px;&#125; 3. 设置左栏位置 1margin-left: -100%; 4. 设置右栏位置 1margin-right: -200px; 5. 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body, html, .parent&#123; height: 100%; min-width: 600px; &#125; .parent&#123; width: 100%; float: left; background-color: blueviolet; &#125; .left&#123; height: 100%; width: 200px; float: left; margin-left: -100%; background-color: coral; &#125; .right&#123; height: 100%; width: 200px; float: left; margin-left: -200px; background-color: crimson; &#125; .middle&#123; padding-left: 200px; padding-right: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://sunyunzeng.com/tags/CSS/"}]},{"title":"CSS 知识要点","slug":"CSS-知识要点","date":"2020-02-18","updated":"2022-11-05","comments":true,"path":"CSS-知识要点/","link":"","permalink":"https://sunyunzeng.com/CSS-%E7%9F%A5%E8%AF%86%E8%A6%81%E7%82%B9/","excerpt":"","text":"选择元素 基本元素选择 12/* 把段落文本设置成红色，12像素大，粗体 */p &#123;color:red; font-size:12px; font-weight:bold;&#125; 上下文选择 12/* 选择祖先元素为 article 标签的所有段落 p 后代 */article p &#123;color:red; font-size:12px; font-weight:bold;&#125; 特殊上下文选择 子选择符12/* 将 section 的 h2 子元素的字体设置为 italic */section &gt; h2 &#123;font-style:italic;&#125; 紧邻同胞选择 12/* 将紧邻着 h2 的元素同胞 p 选择设置 */h2 + p &#123;font-style:italic;&#125; 一般同胞选择12/* 将 h2 与 p 之间的同胞全部选择 */h2 ~ p &#123;font-style:italic;&#125; 通用选择 1234/* 全文所有字体颜色（包括文本框）设置为黑色 */* &#123;color: black&#125;/* 只把 p 元素中所有元素文本设置为红色 */p *&#123;color: red&#125; 类选择 12/* 把属于 specialtext 类的元素设置字体类型 */.specialtext &#123;font-style:italic;&#125; 标签带类选择 12/* 把 p元素中属于 specialtext 类的元素设置字体类型 */p.specialtext &#123;font-style:italic;&#125; ID选择 12/*把 ID 为 mainmenu 元素中的 a 元素的字体颜色修改*/#mainmenu a &#123;color:orange;&#125; 属性名选择 12/*将带有 title 属性的 HTML img 元素显示 2 像素宽的蓝色边框*/img[title] &#123;&#123;border:2px solid blue;&#125;&#125; 伪类选择 伪类就是当 HTML 元素在某种状态时触发显示相应的 CSS 样式，伪类的用法是 元素名:状态 {属性名: 值} 例如：1a:link &#123;color:black;&#125; 主要的伪类状态有以下几种： 状态名 描述 link 链接初始状态 visited 链接被点击过状态 hover 鼠标悬浮上去状态 active 鼠标正在被点击的状态 focus 表单获取焦点时状态 target 对于设置为目标的元素被选择时的状态 first-child 一组同胞元素的第一个元素 last-child 一组同胞元素中最后一个元素 nth-child 一组同胞元素中第 n 个元素 伪元素选择 两个冒号后面加伪元素状态，常用的有 ::first-letter (首字母状态)、::first-line (首行状态)、::before与::after (特定元素前后添加特殊内容)。 1&lt;p class=&quot;age&quot;&gt;25&lt;/p&gt; 1234p.age::before &#123;content:&quot;Age: &quot;;&#125; p.age::after &#123;content:&quot; years.&quot;;&#125;/* 显示如下：Age: 25 years.*/ CSS样式叠加顺序CSS 样式叠加遵循以下四个规则： 1. 首先找到各元素所有的 CSS 声明。 2. 按照以下顺序层叠显示，越靠后的 CSS 定义方式显示级别越高。 浏览器默认样式 用户自定义样式 链接样式 （&lt;link href=&quot;style.css&quot; rel=stylesheet type=&quot;text/css&quot; /&gt;） 嵌入样式 1234567&lt;head&gt;&lt;!-- 其他 head 元素（如 meta、title）放在这里 --&gt; &lt;style type=&quot;text/css&quot;&gt; h1 &#123;font-size:16px;&#125; p &#123;color:blue;&#125; &lt;/style&gt; &lt;/head&gt; 行内样式 123&lt;p style=&quot;font-size: 12px; font-weight:bold; font-style:italic; color:red;&quot;&gt;By adding inline CSS styling to this paragraph, you override the default styles.&lt;/p&gt; 如果 css 里面的权重定义是 !important，则不考虑 CSS样式的优先级规则，优先使用。 3. 按照特指度确定显示优先级 特指度指的是说明元素信息的详细程度，例如 元素 p 的特指度就要低于某一 css 类的特指度。 计算规则：I-C-E I-C-E 表示 ID、Class、Element三个维度的得分三位数，初始为 0-0-0。 如果样式里指明一个 ID，I 代表的数字 +1。 如果样式里指明一个 类 class，C 代表的数字 +1。 如果样式里指明一个 元素 Element，E代表的数字 +1。 例如： 123456p 0-0-1 特指度=1 p.largetext 0-1-1 特指度=11 p#largetext 1-0-1 特指度=101body p#largetext 1-0-2 特指度=102body p#largetext ul.mylist 1-1-3 特指度=113 body p#largetext ul.mylist li 1-1-4 特指度=114 4. 特指度相同的情况下按照叠加顺序 盒模型令人困惑的盒子属性。 每个元素就是一个盒子，其有对应的形状，对应的属性有三组：边框（border）、内边距（padding）及外边距 （margin）。 1. 垂直方向的外边距取最大值。 如果有两个段落 p，其CSS样式如下： 1p &#123;height:50px; border:1px solid #000; backgroundcolor:#fff; margin-top:50px; margin-bottom:30px;&#125; 那么它们之间的距离为 50px，而不是 50px + 30px= 80px。 2. 水平方向外边距叠加。 3. 盒子的大小视 width 属性而定。 在 width 没有指定情况下，元素的宽度与父元素一致。 此时设置盒子的 border 及 padding 会向内拓展，不改变盒子大小。 设置 margin 会使元素宽度相对父元素的宽度减去两倍的外边距。 在指定了 width 宽度大小情况下，元素宽度会拓展。 此时设置盒子的 border 及 padding 会向外拓展，使盒子变大。 添加 box-sizing:border-box 属性，使盒子在指定宽度 width 同时，也能像未指定一样工作。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://sunyunzeng.com/tags/CSS/"}]},{"title":"自己实现简单版Vue--3. 实现数据的双向绑定和Proxy代理","slug":"自己实现简单版Vue-3-实现数据的双向绑定和Proxy代理","date":"2020-02-01","updated":"2022-11-05","comments":true,"path":"自己实现简单版Vue-3-实现数据的双向绑定和Proxy代理/","link":"","permalink":"https://sunyunzeng.com/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%89%88Vue-3-%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8CProxy%E4%BB%A3%E7%90%86/","excerpt":"","text":"数据的双向绑定之前我们已经实现数据影响视图，即数据更新调用setter()方法里绑定的方法，通过Dev通知Watcher更新视图。 然后我们需要实现视图影响数据进而再影响视图。 通过为input节点利用Object.addEventListener()绑定事件监听，再调用数据更新方法更新数据。 数据更改后由于之前已经实现了数据更改后页面的自动更新，由此数据自然驱动视图。 12345678910111213141516// 编译模版具体执行const compileUtil = &#123; // ... 省略 model(node, expr, vm) &#123; const value = this.getValue(expr, vm); // v-model绑定对应的 Watcher, 数据驱动视图 new Watcher(expr, vm, (newVal)=&gt;&#123; this.updater.modelUpdater(node, newVal); &#125;); // 视图 =&gt; 数据 =&gt; 视图 node.addEventListener(&#x27;input&#x27;, (e)=&gt;&#123; this.setVal(expr, vm, e.target.value); &#125;) this.updater.modelUpdater(node, value); &#125;&#125; this.$data的代理我们可以通过在vm对象中使用this.person.name直接修改数据，而不是通过this.$data.person.name实现。 利用this.$data的代理实现。 123456789101112131415161718192021&lt;script&gt; let vm = new MVue(&#123; el: &#x27;#app&#x27;, data: &#123; person: &#123; name: &#x27;海贼——王路飞&#x27;, age: 18, fav: &#x27;film&#x27; &#125;, msg: &#x27;最简单的插值&#x27;, htmlStr: &#x27;&lt;h3&gt;这是v-html&lt;/h3&gt;&#x27; &#125;, methods:&#123; handleClick: function()&#123; console.log(&#x27;这是一个处理点击事件的方法&#x27;); // 使用代理的方式可以直接这样修改数据 this.person.name = &#x27;海贼王——路飞&#x27; &#125; &#125; &#125;); &lt;/script&gt; 123456789101112131415161718192021222324252627class MVue &#123; constructor(options) &#123; // 初始元素与数据通过options对象绑定 this.$el = options.el; this.$data = options.data; this.$options = options; // 通过Compiler对象对模版进行编译，例如&#123;&#123;&#125;&#125;插值、v-text、v-html、v-model等Vue语法 if (this.$el) &#123; // ... 省略 // 通过数据代理实现 this.person.name = &#x27;海贼王——路飞&#x27;功能，而不是this.$data.person.name = &#x27;海贼王——路飞&#x27; this.proxyData(this.$data); &#125; &#125; //用vm代理vm.$data proxyData(data)&#123; for(let key in data)&#123; Object.defineProperty(this,key,&#123; get()&#123; return data[key]; &#125;, set(newVal)&#123; data[key] = newVal; &#125; &#125;) &#125; &#125;&#125; 项目地址https://github.com/SUNYunZeng/ImitateVue","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sunyunzeng.com/tags/Vue/"}]},{"title":"自己实现简单版Vue--2. 实现数据绑定视图","slug":"自己实现简单版Vue-2-定义Observer实现对象属性劫持","date":"2020-01-31","updated":"2022-11-05","comments":true,"path":"自己实现简单版Vue-2-定义Observer实现对象属性劫持/","link":"","permalink":"https://sunyunzeng.com/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%89%88Vue-2-%E5%AE%9A%E4%B9%89Observer%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%8A%AB%E6%8C%81/","excerpt":"","text":"利用Object.defineProperty()方法实现数据的监听Object.defineProperty()方法可以具体参考链接：http://sunyunzeng.com/JavaScript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/#%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7 该方法可以定义对象数据在访问操作时的一些约定。 定义 Observer 对象 123456789101112131415161718192021222324252627282930313233class Observer&#123; constructor(data)&#123; this.observe(data); &#125; // data是一个对象，可能嵌套其它对象，需要采用递归遍历的方式进行观察者绑定 observe(data)&#123; if(data &amp;&amp; typeof data === &#x27;object&#x27;)&#123; Object.keys(data).forEach(key =&gt;&#123; this.defineReactive(data, key, data[key]); &#125;) &#125; &#125; // 通过 object.defineProperty方法对对象属性进行劫持 defineReactive(obj, key, value)&#123; // 递归观察 this.observe(value); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: false, get()&#123; return value; &#125;, // 采用箭头函数在定义时绑定this的定义域 set: (newVal)=&gt;&#123; if(newVal !== value)&#123; this.observe(newVal); value = newVal; console.log(newVal); &#125; &#125; &#125;) &#125;&#125; 利用Observer对象对数据进行劫持 123456789101112131415class MVue &#123; constructor(options) &#123; // 初始元素与数据通过options对象绑定 this.$el = options.el; this.$data = options.data; this.$options = options; // 通过Compiler对象对模版进行编译，例如&#123;&#123;&#125;&#125;插值、v-text、v-html、v-model等Vue语法 if (this.$el) &#123; // 1. 编译模版 new Compiler(this.$el, this); // 2. 创建观察者，观察数据 new Observer(this.$data); &#125; &#125;&#125; 定义Dep容器及Watcher对象对数据变化进行监听 123456789101112131415161718192021222324252627282930313233343536373839404142class Watcher&#123; // 通过回调函数实现更新的数据通知到视图 constructor(expr, vm, cb)&#123; this.expr = expr; this.vm = vm; this.cb = cb; this.oldVal = this.getOldVal(); &#125; // 获取旧数据 getOldVal()&#123; // 在利用getValue获取数据调用getter()方法时先把当前观察者挂载 Dep.target = this; console.log(Dep.target); const oldVal = compileUtil.getValue(this.expr, this.vm); // 挂载完毕需要注销，防止重复挂载 (数据一更新就会挂载) Dep.target = null; return oldVal; &#125; // 通过回调函数更新数据 update()&#123; const newVal = compileUtil.getValue(this.expr, this.vm); if(newVal !== this.oldVal)&#123; this.cb(newVal); &#125; &#125;&#125;// Dep类存储watcher对象，并在数据变化时通知watcherclass Dep&#123; constructor()&#123; this.watcherCollector = []; &#125; // 添加watcher addWatcher(watcher)&#123; console.log(&#x27;观察者&#x27;, this.watcherCollector); this.watcherCollector.push(watcher); &#125; // 数据变化时通知watcher更新 notify()&#123; this.watcherCollector.forEach(w=&gt;w.update()); &#125;&#125; 在Observer中绑定Dev 123456789101112131415161718192021class Observer&#123; // ... 省略 defineReactive(obj, key, value)&#123; // ... 省略 const dep = new Dep(); Object.defineProperty(obj, key, &#123; // ... 省略 get()&#123; // 订阅数据变化时，往Dev中添加观察者 Dep.target &amp;&amp; dep.addWatcher(Dep.target); return value; &#125;, // 采用箭头函数在定义时绑定this的定义域 set: (newVal)=&gt;&#123; // ... 省略 // 通知watcher数据发生改变 dep.notify(); &#125; &#125;) &#125;&#125; 在编译工具中绑定Watcher 123456789101112131415161718192021222324252627282930313233const compileUtil = &#123; // ... 省略 getContent(expr, vm)&#123; // &#123;&#123;person.name&#125;&#125;--&#123;&#123;person.age&#125;&#125; // 防止修改person.name使得所有值全部被替换 return expr.replace(/\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g, (...args)=&gt;&#123; return this.getValue(args[1], vm); &#125;); &#125;, text(node, expr, vm) &#123; let value; if(expr.indexOf(&#x27;&#123;&#123;&#x27;)!==-1)&#123; value = expr.replace(/\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g, (...args)=&gt;&#123; // text的 Watcher应在此绑定，因为是对插值&#123;&#123;&#125;&#125;进行双向绑定 // Watcher的构造函数的 getOldVal()方法需要接受数据或者对象，而&#123;&#123;person.name&#125;&#125;不能接收 new Watcher(args[1], vm, ()=&gt;&#123; this.updater.textUpdater(node, this.getContent(expr, vm)); &#125;); return this.getValue(args[1], vm); &#125;); &#125;else&#123; value = this.getValue(expr, vm); &#125; this.updater.textUpdater(node, value); &#125;, html(node, expr, vm) &#123; let value = this.getValue(expr, vm); // html对应的 Watcher new Watcher(expr, vm, (newVal)=&gt;&#123; this.updater.htmlUpdater(node, newVal); &#125;) this.updater.htmlUpdater(node, value); &#125; 在MVue类的构造函数中绑定Observer 12345678910111213class MVue &#123; constructor(options) &#123; this.$el = options.el; this.$data = options.data; this.$options = options; if (this.$el) &#123; // 1. 创建观察者 new Observer(this.$data); // 2. 编译模版 new Compiler(this.$el, this); &#125; &#125;&#125; 项目地址https://github.com/SUNYunZeng/ImitateVue","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sunyunzeng.com/tags/Vue/"}]},{"title":"自己实现简单版Vue--1. 编译初始Vue模版","slug":"自己实现简单版Vue-1-编译初始Vue模版","date":"2020-01-29","updated":"2022-11-05","comments":true,"path":"自己实现简单版Vue-1-编译初始Vue模版/","link":"","permalink":"https://sunyunzeng.com/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%89%88Vue-1-%E7%BC%96%E8%AF%91%E5%88%9D%E5%A7%8BVue%E6%A8%A1%E7%89%88/","excerpt":"","text":"前言Vue的双向绑定效果如下： Vue的底层到底是怎么实现的呢？ 通过手写简单的示例来学习Vue框架的运行机制。 Vue是MVVM框架，其实就是MVC框架在前端的体现，其中的控制器(Controller)由View MOdel(VM)代替。 简单来说，数据更新视图，以及视图更新影响数据这两步操作或者是双向绑定的过程由VM来执行。 而Vue就是一个VM。 Vue的可以说是开箱即用，它的使用非常简单，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;person.name&#125;&#125; -- &#123;&#123;person.age&#125;&#125;&lt;/h2&gt; &lt;h3&gt;&#123;&#123;person.fav&#125;&#125;&lt;/h3&gt; &lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt; &lt;div v-text=&#x27;msg&#x27;&gt;&lt;/div&gt; &lt;div v-text=&#x27;person.name&#x27;&gt;&lt;/div&gt; &lt;div v-html=&#x27;htmlStr&#x27;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; v-model=&#x27;msg&#x27;&gt; &lt;button v-on:click=&quot;handleClick&quot;&gt;v-on:click&lt;/button&gt; &lt;button @click=&quot;handleClick&quot;&gt;@click&lt;/button&gt; &lt;a v-bind:href=&quot;https://www.bilibili.com/video/av80611222?p=3&quot;&gt;v-bind:href&lt;/a&gt; &lt;/div&gt; &lt;script src=&quot;./Vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; let vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; person: &#123; name: &#x27;海贼——王路飞&#x27;, age: 18, fav: &#x27;宝藏&#x27; &#125;, msg: &#x27;最简单的插值&#x27;, htmlStr: &#x27;这是v-html&#x27; &#125;, methods:&#123; handleClick: function()&#123; console.log(&#x27;这是一个处理点击事件的方法&#x27;); &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过 new Vue 新建一个Vue实例，并将元素节点与该实例通过 el 实现双向绑定，之后h5中的元素内容跟对象数据就融为一体，开发者的关注重点可以集中在代码逻辑的设计，而不是繁琐的页面与数据绑定问题。 我们的实现原理图如下所示： 需要实现一个Observer通过Object.defineProperty()劫持数据实现数据的监听。 实现一个Dep收集各数据的监听Watcher，负责通知Watcher数据发生变化。 实现Watcher对视图进行更新。 实现Complier对Vue指令（v-text等）进行解析初始化，以及订阅对应的watcher。 Vue模版的编译第一步是将H5中的Vue模版进行编译，使得浏览器能够正确展示对应数据。 其中包括这几部分的编译： 文本模版中插值表达式的编译 也就是双括号中的值能够正确表达出来，例如 元素节点中模版表达式的编译 例如 v-text、v-model、v-html、 v-on:click、 v-bind等 MVue入口类设计Mvue类接收一个参数对象作为初始输入，然后利用Compiler类对模版进行编译及渲染。 12345678910111213class MVue &#123; constructor(options) &#123; // 初始元素与数据通过options对象绑定 this.$el = options.el; this.$data = options.data; this.$options = options; // 通过Compiler对象对模版进行编译，例如&#123;&#123;&#125;&#125;插值、v-text、v-html、v-model等Vue语法 if (this.$el) &#123; new Compiler(this.$el, this); &#125; &#125;&#125; Complier编译类设计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131const compileUtil = &#123; getValue(expr, vm)&#123; // 处理 person.name 这种对象类型，取出真正的value return expr.split(&#x27;.&#x27;).reduce((data,currentVal)=&gt;&#123; return data[currentVal]; &#125;, vm.$data) &#125;, text(node, expr, vm) &#123; let value; if(expr.indexOf(&#x27;&#123;&#123;&#x27;)!==-1)&#123; value = expr.replace(/\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g, (...args)=&gt;&#123; return this.getValue(args[1], vm); &#125;); &#125;else&#123; value = this.getValue(expr, vm); &#125; this.updater.textUpdater(node, value); &#125;, html(node, expr, vm) &#123; const value = this.getValue(expr, vm); this.updater.htmlUpdater(node, value); &#125;, model(node, expr, vm) &#123; const value = this.getValue(expr, vm); this.updater.modelUpdater(node, value); &#125;, on(node, expr, vm, detailStr) &#123; let fn = vm.$options.methods &amp;&amp; vm.$options.methods[expr]; node.addEventListener(detailStr,fn.bind(vm), false); &#125;, bind(node, expr, vm, detailStr)&#123; // v-on:href=&#x27;...&#x27; =&gt; href=&#x27;...&#x27; node.setAttribute(detailStr, expr); &#125;, // 视图更新函数 updater: &#123; textUpdater(node, value) &#123; node.textContent = value; &#125;, htmlUpdater(node, value)&#123; node.innerHTML = value; &#125;, modelUpdater(node, value)&#123; node.value = value; &#125; &#125;&#125;// 编译HTML模版对象class Compiler &#123; constructor(el, vm) &#123; this.el = this.isElementNode(el) ? el : document.querySelector(el); this.vm = vm; // 1. 将预编译的元素节点放入文档碎片对象中，避免DOM频繁的回流与重绘，提高渲染性能 const fragments = this.node2fragments(this.el); // 2. 编译模版 this.compile(fragments); // 3. 追加子元素到根元素 this.el.appendChild(fragments); &#125; compile(fragments) &#123; // 1.获取子节点 const childNodes = fragments.childNodes; // 2.递归循环编译 [...childNodes].forEach(child =&gt; &#123; // 如果是元素节点 if (this.isElementNode(child)) &#123; this.compileElement(child); &#125; else &#123; // 文本节点 this.compileText(child); &#125; //递归遍历 if(child.childNodes &amp;&amp; child.childNodes.length)&#123; this.compile(child); &#125; &#125;) &#125; compileElement(node) &#123; let attributes = node.attributes; // 对于每个属性进行遍历编译 // attributes是类数组，因此需要先转数组 [...attributes].forEach(attr =&gt; &#123; let &#123;name,value&#125; = attr; // v-text=&quot;msg&quot; v-html=htmlStr type=&quot;text&quot; v-model=&quot;msg&quot; if (this.isDirector(name)) &#123; // v-text v-html v-mode v-bind v-on:click v-bind:href=&#x27;&#x27; let [, directive] = name.split(&#x27;-&#x27;); let [compileKey, detailStr] = directive.split(&#x27;:&#x27;); // 更新数据，数据驱动视图 compileUtil[compileKey](node, value, this.vm, detailStr); // 删除有指令的标签属性 v-text v-html等，普通的value等原生html标签不必删除 node.removeAttribute(&#x27;v-&#x27; + directive); &#125;else if(this.isEventName(name))&#123; // 如果是事件处理 @click=&#x27;handleClick&#x27; let [, detailStr] = name.split(&#x27;@&#x27;); compileUtil[&#x27;on&#x27;](node, value, this.vm, detailStr); node.removeAttribute(&#x27;@&#x27; + detailStr); &#125; &#125;) &#125; compileText(node) &#123; // 编译文本中的&#123;&#123;person.name&#125;&#125;--&#123;&#123;person.age&#125;&#125; const content = node.textContent; if(/\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/.test(content))&#123; compileUtil[&#x27;text&#x27;](node, content, this.vm); &#125; &#125; isEventName(attrName)&#123; // 判断是否@开头 return attrName.startsWith(&#x27;@&#x27;); &#125; isDirector(attrName) &#123; // 判断是否为Vue特性标签 return attrName.startsWith(&#x27;v-&#x27;); &#125; node2fragments(el) &#123; // 创建文档碎片对象 const f = document.createDocumentFragment(); let firstChild; while (firstChild = el.firstChild) &#123; f.appendChild(firstChild); &#125; return f; &#125; isElementNode(node) &#123; // 元素节点的nodeType属性为 1 return node.nodeType === 1; &#125;&#125; 项目地址https://github.com/SUNYunZeng/ImitateVue","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sunyunzeng.com/tags/Vue/"}]},{"title":"JS异步函数小结","slug":"JS异步函数小结","date":"2020-01-04","updated":"2022-11-05","comments":true,"path":"JS异步函数小结/","link":"","permalink":"https://sunyunzeng.com/JS%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E5%B0%8F%E7%BB%93/","excerpt":"","text":"JS的异步JavaScript的执行环境是单线程的，对于http事件触发线程、浏览器事件触发线程、浏览器定时器等浏览器会单独开辟出一个异步线程处理，处理完毕后，加入任务队列，等待JS主线程调用执行。 例如：12345678setTimeout(()=&gt;console.log(&#x27;触发了&#x27;),0);console.log(&#x27;我先触发&#x27;);// 输出/*我先触发触发了*/ 虽然setTimeout()被设置为马上触发，但是setTimeout触发的异步任务需先放在任务队列中，等主线程中console()函数执行完毕后，再能被触发。 JavaScript执行环境(浏览器)是从头到尾一行一行往下执行，但是遇到异步任务，先放入任务队列，等待主线程可以执行该任务，才被执行。 详细的JS代码执行顺序可查看 https://juejin.im/post/59e85eebf265da430d571f89 异步程序在JS代码中很常见，因为Web应用总归要与远方的服务器交互，请求数据，这个过程需要异步进行。否则，浏览器会一直卡住，直到结果请求完毕。 我们先看一下最简单的回调函数：setTimeout() 与 setsetInterval()，它们都是Windows对象的自带方法。 setTimeoutsetTimeout()表示指定一个异步程序，在规定的时间后执行，但不保证百分百执行。 123456789// 2000ms后执行 console.log()// 方法一setTimeout(()=&gt; console.log(&quot;执行啦！&quot;), 2000)// 方法二let innerFun = function(test)&#123; console.log(test);&#125;setTimeout(innerFun, 2000, &#x27;执行啦！&#x27;); 如果前面有耗时的密集计算，哪怕setTimeout()设定了在很短的时间后执行，也要等主线程执行完毕，所以说 setTimeout()的延迟时间为理想时间。 123456789101112// 预期1s后执行console.log()let s = Date.now();let innerFun = function()&#123; console.log((Date.now()-s)/1000);&#125;setTimeout(innerFun, 1000);let m = 0;for(let i=1; i&lt;100000;i++)&#123; for(let j =0; j&lt;i; j++) m += j;&#125;// 实际5.547后执行 clearTimeout() 方法可取消由 setTimeout() 方法设置的定时操作。 12let timeout = setTimeout(() =&gt; console.log(&quot;执行!&quot;), 1000);clearTimeout(timeout); setIntervalsetInterval()跟setTimeout用法类似，只不过不是执行一次，而是如果不停止就永远重复执行。 123// 每1000ms执行一次setIntervallet i =0;let interval = setInterval(()=&gt;console.log(i++), 1000) clearInterval()可以清除interval操作。 1clearInterval(interval); setInterval()指定的时间也是理想的时间，该时间包括程序本身的运行时间。如果程序本身运行时间大于指定时间，则setInterval()无法满足间隔时间定时运行。 123456789101112let s = Date.now();innerFun = function()&#123; let m = 0; for(let i=1; i&lt;100000;i++)&#123; for(let j =0; j&lt;i; j++) m += j; &#125; console.log((Date.now() - s)/1000)&#125;setInterval(innerFun, 1000)// 每次的运行时间都远远大于1s 如果你想无论程序执行多长时间，每间隔固定时间都触发程序，你可以利用setTimeout()递归实现： 12345let i = 1;let run = setTimeout(function recur()&#123; console.log(i++); setTimeout(recur, 1000);&#125;, 1000); 上面的程序可以保证每隔1000ms就执行console.log()方法，而不用管程序的执行时间。 setTimeout() 与 setInterval()都是系统自带的基础的异步程序添加方法，可以时间指定延迟时间触发程序。 旧版本JS的异步是依靠回调函数实现的，例如传统的AJAX： 12345678910111213$.get(&#x27;ajax/text.html&#x27;, function(data)&#123; // doSomeThing&#125;)request.onreadystatechange = function () &#123; if (request.readyState === 4) &#123; if (request.status === 200) &#123; return success(request.responseText); &#125; else &#123; return fail(request.status); &#125; &#125;&#125; 但是回调函数之间往往存在依赖关系，即下一次回调函数的执行依赖于上一次回调函数的执行结果，然后，当这种依赖变得越来越多，代码的可读性就变得很差，此时称为“回调地狱”。 12345678// callback hallchooseToppings(function(toppings) &#123; placeOrder(toppings, function(order) &#123; collectOrder(order, function(pizza) &#123; eatPizza(pizza); &#125;, failureCallback); &#125;, failureCallback);&#125;, failureCallback) 此时还有一个问题，就是对于每个回调函数，都要重复写一个对应的 catch 失败的函数，显然是非常冗余的，因此，ES6提出了Promise方法！ PromisePromise，英语单词，承诺，就像它的名称一样，Promise对象一定会实现它的诺言，也就是执行的结果无论成功与失败，都会给你一个答复。 Promise是一个构造器，可以生成Promise对象，是ES6异步编程的解决方案。 1234567let promise = new Promise(function(resolve, reject) &#123; if(/*异步执行成功*/)&#123; resolve(res); &#125;else&#123; reject(new Error(&#x27;error&#x27;)); &#125;&#125;) Promise在异步过程中一共有三个状态，pending等待结果状态,fullfilled的执行成功状态以及rejected拒绝状态。 三个状态之间转换关系为： pending状态 -&gt; fullfilled 状态pending状态 -&gt; rejected 状态 pending无论转向哪两个状态都是resloved(已完成)状态。 一般resolved状态表示fullfilled状态，这是习惯的写法。 Promise.then()then()方法是Promise原型对象的方法，Promise.prototype.then()。该方法接受两个参数， promise.then(onFulfilled, onRejected)，一个是异步函数执行成功的处理函数，一个是执行失败的处理函数。但是错误处理函数最好在处理语句的最后用Promise.catch()方法捕获（后面会讲到），因为可提高代码的可读性。 then()方法的onFulfilled传参要求如下： 必须是函数，不是函数被忽略。 12345let promise = new Promise((resolve, reject) =&gt;resolve(&#x27;你好&#x27;));promise.then(&#x27;JS&#x27;).then((result) =&gt;console.log(result));// 返回 你好，最开始的JS被忽略 其参数必须是上个then()或Promise函数所返回。 123456let promise = Promise.resolve(&#x27;Promise返回的&#x27;);let ordinal = ()=&gt;&#x27;仅仅函数返回的&#x27;;promise.then((result) =&gt;console.log(result)).then(ordinal).then((result) =&gt;console.log(result));// Promise返回的// 仅仅函数返回的 如果函数没有返回值，则返回 undefined 12345let ordinal = ()=&gt;&#x27;仅仅函数返回的&#x27;;Promise.resolve().then(function()&#123; ordinal();&#125;).then((result) =&gt;console.log(result));// undefined then()方法只执行一次。 由上规则的值，then()存在链式法则，一系列异步操作可以通过一系列的then()方法连接。 12345678chooseToppings().then(toppings =&gt; placeOrder(toppings)).then(order =&gt; collectOrder(order)).then(pizza =&gt; eatPizza(pizza)).catch(failureCallback);// 或者chooseToppings().then(placeOrder).then(collectOrder).then(eatPizza).catch(failureCallback); Promise.catchcatch()方法是Promise原型对象的方法，Promise.prototype.catch()，用来捕获错误。 最佳实战：永远在then()调用链的最后使用，可以捕获异步操作的任意步骤出现的错误。 1chooseToppings().then(placeOrder).then(collectOrder).then(eatPizza).catch(failureCallback); Promise.finallyfinally()方法是Promise原型对象的方法，Promise.prototype.finally()，用来最异步操作执行后（无论成功还是失败）都执行的代码。 1chooseToppings().then(placeOrder).then(collectOrder).then(eatPizza).catch(failureCallback).finally(server.stop); Promise.all可以令多个Pormise并行执行，等所有的Promise都执行完毕，然后按照Promise的顺序返回一个由结果构成的Array。 123456789101112131415161718192021let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;成功了&#x27;)&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;success&#x27;)&#125;)let p3 = Promse.reject(&#x27;失败&#x27;)Promise.all([p1, p2]).then((result) =&gt; &#123; console.log(result) //[&#x27;成功了&#x27;, &#x27;success&#x27;]&#125;).catch((error) =&gt; &#123; console.log(error)&#125;)Promise.all([p1,p3,p2]).then((result) =&gt; &#123; console.log(result)&#125;).catch((error) =&gt; &#123; console.log(error) // 失败了，打出 &#x27;失败&#x27;&#125;) Promise.resolvePromise.resolve()将现有对象转为Promise对象。 123Promise.resolve(&#x27;foo&#x27;)// 等价于new Promise(resolve =&gt; resolve(&#x27;foo&#x27;)) Promise的参数分为四种情况: 参数是Promise实例，则依旧返回Promise实例。 参数是一个 thenable 对象，则将该对象转为 Promise 对象，并立即执行。 12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;); 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。 123456const p = Promise.resolve(&#x27;Hello&#x27;);p.then(function (s)&#123; console.log(s)&#125;);// Hello 不带有任何参数 Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。12345678910111213setTimeout(function () &#123; console.log(&#x27;three&#x27;);&#125;, 0);Promise.resolve().then(function () &#123; console.log(&#x27;two&#x27;);&#125;);console.log(&#x27;one&#x27;);// one// two// three 注意 立即resolve的 Promise 对象是在事件循环中当前宏任务的后面添加微任务，因此需要等当前宏任务结束后再执行。 12Promise.resolve().then(() =&gt; console.log(2)).then(() =&gt; console.log(3));console.log(1); // 1, 2, 3","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sunyunzeng.com/tags/JavaScript/"}]},{"title":"LeetCode 72.编辑距离","slug":"LeetCode-72-编辑距离","date":"2020-01-02","updated":"2022-11-05","comments":true,"path":"LeetCode-72-编辑距离/","link":"","permalink":"https://sunyunzeng.com/LeetCode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/","excerpt":"","text":"编辑距离给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符删除一个字符替换一个字符示例 1:123456输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出: 3解释: horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)rorse -&gt; rose (删除 &#x27;r&#x27;)rose -&gt; ros (删除 &#x27;e&#x27;)示例 2:12345678输入: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出: 5解释: intention -&gt; inention (删除 &#x27;t&#x27;)inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)exection -&gt; execution (插入 &#x27;u&#x27;) 思路 + 代码 问题1：如果 word1[0..i-1] 到 word2[0..j-1] 的变换需要消耗 k 步，那 word1[0..i] 到 word2[0..j] 的变换需要几步呢？ 答：先使用 k 步，把 word1[0..i-1] 变换到 word2[0..j-1]，消耗 k 步。再把 word1[i] 改成 word2[j]，就行了。如果 word1[i] == word2[j]，什么也不用做，一共消耗 k 步，否则需要修改，一共消耗 k + 1 步。 问题2：如果 word1[0..i-1] 到 word2[0..j] 的变换需要消耗 k 步，那 word1[0..i] 到 word2[0..j] 的变换需要消耗几步呢？ 答：先经过 k 步，把 word1[0..i-1] 变换到 word2[0..j]，消耗掉 k 步，再把 word1[i] 删除，这样，word1[0..i] 就完全变成了 word2[0..j] 了。一共 k + 1 步。 问题3：如果 word1[0..i] 到 word2[0..j-1] 的变换需要消耗 k 步，那 word1[0..i] 到 word2[0..j] 的变换需要消耗几步呢？ 答：先经过 k 步，把 word1[0..i] 变换成 word2[0..j-1]，消耗掉 k 步，接下来，再插入一个字符 word2[j], word1[0..i] 就完全变成了 word2[0..j] 了。 从上面三个问题来看，word1[0..i] 变换成 word2[0..j] 主要有三种手段，用哪个消耗少，就用哪个。 123456789101112131415161718192021class Solution(object): def minDistance(self, word1, word2): &quot;&quot;&quot; :type word1: str :type word2: str :rtype: int &quot;&quot;&quot; m, n = len(word1), len(word2) dp = [[0]*(n+1) for _ in range(m+1)] for i in range(m+1): dp[i][0] = i for j in range(n+1): dp[0][j] = j for i in range(1, m+1): for j in range(1, n+1): # 如果当前的字符相等，则最小操作数与dp[i-1][j-1]相同 if word1[i-1]==word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]))+1 return dp[m][n] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/edit-distance著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 只有两个键的键盘最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作： Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。Paste (粘贴) : 你可以粘贴你上一次复制的字符。给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。输出能够打印出 n 个 ‘A’ 的最少操作次数。 示例 1:12345678910输入: 3输出: 3解释:最初, 我们只有一个字符 &#x27;A&#x27;。第 1 步, 我们使用 Copy All 操作。第 2 步, 我们使用 Paste 操作来获得 &#x27;AA&#x27;。第 3 步, 我们使用 Paste 操作来获得 &#x27;AAA&#x27;。说明:n 的取值范围是 [1, 1000] 。 思路 + 代码动态规划。例如 9 ，从数字 8 开始依次找其最大除数，例如是3.那么dp[9] = d[3] + 9/3 12345678910111213class Solution(object): def minSteps(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [0]*(n+1) for i in range(2,n+1): for j in range(i-1, 0, -1): if i % j == 0: dp[i] = dp[j] + i//j break return dp[n] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/2-keys-keyboard著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"LeetCode 474.一和零","slug":"LeetCode-474-一和零","date":"2019-12-28","updated":"2022-11-05","comments":true,"path":"LeetCode-474-一和零/","link":"","permalink":"https://sunyunzeng.com/LeetCode-474-%E4%B8%80%E5%92%8C%E9%9B%B6/","excerpt":"","text":"题目在计算机界中，我们总是追求用有限的资源获取最大的收益。 现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。 你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。 注意:12给定 0 和 1 的数量都不会超过 100。给定字符串数组的长度不会超过 600。 示例 1:1234输入: Array = &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m = 5, n = 3输出: 4解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 &quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot; 。 示例 2:12输入: Array = &#123;&quot;10&quot;, &quot;0&quot;, &quot;1&quot;&#125;, m = 1, n = 1输出: 2解释: 你可以拼出 “10”，但之后就没有剩余数字了。更好的选择是拼出 “0” 和 “1” 。 题解 多维背包，动态规划方程：dp[i][j]=max(dp[i][j], dp[i-conut_0][j-count_1]) 1234567891011121314151617class Solution(object): def findMaxForm(self, strs, m, n): &quot;&quot;&quot; :type strs: List[str] :type m: int :type n: int :rtype: int &quot;&quot;&quot; if len(strs)==0: return 0 dp = [[0]*(n+1) for _ in range(m+1)] for item in strs: count_0, count_1 = item.count(&#x27;0&#x27;), item.count(&#x27;1&#x27;) for i in range(m, count_0-1, -1): for j in range(n, count_1-1, -1): dp[i][j] = max(dp[i][j], dp[i-count_0][j-count_1]+1) return dp[-1][-1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/ones-and-zeroes著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 零钱兑换给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1:123输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1 示例 2:12输入: coins = [2], amount = 3输出: -1说明:你可以认为每种硬币的数量是无限的。 题解 背包问题，无限背包，从小到大遍历。 12345678910111213class Solution(object): def coinChange(self, coins, amount): &quot;&quot;&quot; :type coins: List[int] :type amount: int :rtype: int &quot;&quot;&quot; dp = [float(&#x27;inf&#x27;)]*(amount+1) dp[0] = [0] for coin in coins: for i in range(coin, amount+1): dp[i] = min(dp[i], dp[i-coin]+1) return dp[-1] if dp[-1] != float(&#x27;inf&#x27;) else -1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/coin-change著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 零钱兑换 II给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 示例 1:1234567输入: amount = 5, coins = [1, 2, 5]输出: 4解释: 有四种方式可以凑成总金额:5=55=2+2+15=2+1+1+15=1+1+1+1+1 示例 2:12输入: amount = 3, coins = [2]输出: 0解释: 只用面额2的硬币不能凑成总金额3。 示例 3:12输入: amount = 10, coins = [10] 输出: 1 注意: 你可以假设：0 &lt;= amount (总金额) &lt;= 50001 &lt;= coin (硬币面额) &lt;= 5000硬币种类不超过 500 种结果符合 32 位符号整数 题解 无限背包，注意递归条件是 dp[i] += dp[i-coin] 12345678910111213class Solution(object): def change(self, amount, coins): &quot;&quot;&quot; :type amount: int :type coins: List[int] :rtype: int &quot;&quot;&quot; dp = [0]*(amount+1) dp[0] = 1 for coin in coins: for i in range(coin, amount+1): dp[i] += dp[i-coin] return dp[-1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/coin-change-2著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 单词拆分给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。示例 1：123输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。 示例 2：12输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。 注意你可以重复使用字典中的单词。 示例 3：12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 题解 采用动态规划 dp[i]表示 截止 s 字符串的 i 位置的子字符串是否能被单词字典里的单词来表示。 dp[i]为真的条件为： dp[j]为真 dp[j:i]表示的字符串存在于字典中 12345678910111213141516171819202122class Solution(object): def wordBreak(self, s, wordDict): &quot;&quot;&quot; :type s: str :type wordDict: List[str] :rtype: bool &quot;&quot;&quot; # dp[i]表示s[i]是否可用wordDict里的元素表示 # dp[i]能够被表示的前提是dp[j]可用wordDict里元素表示，而且dp[j:i]存在于wordDict中 # 如果字典为空，字符串为空，则返回true，否则返回false if not wordDict: return not s size = len(s) dp = [False]*(size+1) wordDict = list(set(wordDict)) dp[0] = True for i in range(1, size+1): for j in range(i-1, -1, -1): if dp[j] and dp[j:i] in wordDict: dp[i] = True break return dp[-1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/word-break著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 组合总和给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例: nums = [1, 2, 3]target = 4 所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1) 请注意，顺序不同的序列被视作不同的组合。 因此输出为 7。进阶：如果给定的数组中含有负数会怎么样？问题会产生什么变化？我们需要在题目中添加什么限制来允许负数的出现？ 题解 思路与零钱兑换一模一样，代码甚至都一样 12345678910111213141516class Solution(object): def combinationSum4(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; if not nums: return 0 size = len(nums) dp = [0]*(target+1) dp[0] = 1 for i in range(1, target+1): for n in nums: if i&gt;=n: dp[i] += dp[i-n] return dp[-1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/combination-sum-iv著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"LeetCode 1143.最长公共子序列","slug":"LeetCode-1143-最长公共子序列","date":"2019-12-27","updated":"2022-11-05","comments":true,"path":"LeetCode-1143-最长公共子序列/","link":"","permalink":"https://sunyunzeng.com/LeetCode-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"最长公共子序列给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 若这两个字符串没有公共子序列，则返回 0。 示例 1:12输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3 解释：最长公共子序列是 “ace”，它的长度为 3。示例 2:12输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;输出：3解释：最长公共子序列是 “abc”，它的长度为 3。示例 3:12输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;输出：0解释：两个字符串没有公共子序列，返回 0。 提示:121 &lt;= text1.length &lt;= 10001 &lt;= text2.length &lt;= 1000输入的字符串只含有小写英文字符。 题解 动态规划，不过要设计一个二维数组dp，来统计dp[i][j]时对应 text1 在 i 位置与text2 在 j 位置时两子字符串对应的最长公共子序列。 1234567891011121314151617class Solution(object): def longestCommonSubsequence(self, text1, text2): &quot;&quot;&quot; :type text1: str :type text2: str :rtype: int &quot;&quot;&quot; l1, l2 = len(text1), len(text2) if l1==0 or l2==0: return 0 dp = [[0 for i in range(l2+1)] for i in range(l1+1)] for i in range(1,l1+1): for j in range(1,l2+1): if text1[i-1]==text2[j-1]: dp[i][j] = dp[i-1][j-1]+1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[l1][l2] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-common-subsequence著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 两个字符串的删除操作(最长公共子序列的变体)给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。 示例 1: 输入: “sea”, “eat”输出: 2解释: 第一步将”sea”变为”ea”，第二步将”eat”变为”ea”说明: 给定单词的长度不超过500。给定单词中的字符只含有小写字母。 思路 + 代码最长公共子序列的变体，其实就是求最长公共自序列。 12345678910111213141516class Solution(object): def minDistance(self, word1, word2): &quot;&quot;&quot; :type word1: str :type word2: str :rtype: int &quot;&quot;&quot; m, n = len(word1), len(word2) dp = [[0]*(n+1) for _ in range(m+1)] for i in range(1, m+1): for j in range(1,n+1): if word1[i-1]==word2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return m+n-2*dp[m][n] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/delete-operation-for-two-strings著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分割等和子集给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100数组的大小不会超过 200 示例 1:1234输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2:1234输入: [1, 2, 3, 5]输出: false解释: 数组不能分割成两个元素和相等的子集. 题解 这是一道以 0-1 背包问题为背景的算法练习题，我们把这个题目翻译一下： 给定一个只包含正整数的非空数组。是否可以从这个数组中挑选出一些正整数，每个数只能用一次，使得这些数的和等于整个数组元素的和的一半。 0-1 背包问题也是最基础的背包问题，它的特点是：待挑选的物品有且仅有一个，可以选择也可以不选择。下面我们定义状态，不妨就用问题的问法定义状态试试看。 dp[i][j]：表示从数组的 [0, i] 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和等于 j。 根据我们学习的 0-1 背包问题的状态转移推导过程，新来一个数，例如是 nums[i]，根据这个数可能选择也可能不被选择： 如果不选择 nums[i]，在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true；如果选择 nums[i]，在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i] ，我既然这样写出来了，你就应该知道，这里讨论的前提条件是 nums[i] &lt;= j。 以上二者成立一条都行。于是得到状态转移方程是： 1dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]], (nums[i] &lt;= j) 于是按照 0-1 背包问题的模板，我们不难写出以下代码。 1234567891011121314151617181920212223class Solution(object): def canPartition(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; size = len(nums) s = sum(nums) if s &amp; 1 == 1: return False target = s // 2 dp = [[False for _ in range(target+1)] for _ in range(size)] for i in range(target+1): if nums[0]==i: dp[0][i] = True for i in range(1,size): n = nums[i] for j in range(target+1): if j&gt;=n: dp[i][j] = dp[i-1][j] or dp[i][j-n] else: dp[i][j] = dp[i-1][j] return dp[-1][-1] 优化版：123456789101112131415161718192021class Solution(object): def canPartition(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; size = len(nums) s = sum(nums) if s &amp; 1 == 1: return False target = s // 2 dp = [False for _ in range(target+1)] for i in range(target+1): if nums[0]==i: dp[i] = True for i in range(1,size): n = nums[i] for j in range(target, n-1, -1): if j&gt;=n: dp[j] = dp[j] or dp[j-n] return dp[-1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/partition-equal-subset-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"LeetCode 300.最长上升子序列","slug":"LeetCode-300-最长上升子序列","date":"2019-12-26","updated":"2022-11-05","comments":true,"path":"LeetCode-300-最长上升子序列/","link":"","permalink":"https://sunyunzeng.com/LeetCode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"最长上升子序列给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例:123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 1234567891011121314class Solution(object): def lengthOfLIS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; l = len(nums) if l==0 or l==1: return l dp = [1]*l for i in range(1, l): for j in range(0, i): if nums[i]&gt;nums[j]: dp[i] = max(dp[i], dp[j]+1) return max(dp) 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-increasing-subsequence著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 最长数对链给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。 现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。 给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。 示例 :123输入: [[1,2], [2,3], [3,4]]输出: 2解释: 最长的数对链是 [1,2] -&gt; [3,4] 注意： 给出数对的个数在 [1, 1000] 范围内。 更上面一题类似，只不要是任意顺序的选择，可以先对列表进行排序，按照数对的第二个数值。 123456789101112131415class Solution(object): def findLongestChain(self, pairs): &quot;&quot;&quot; :type pairs: List[List[int]] :rtype: int &quot;&quot;&quot; l = len(pairs) if l==0 or l==1: return l pairs = sorted(pairs, key=lambda x: x[1]) dp = [1]*l for i in range(1,l): for j in range(0, i): if pairs[i][0]&gt;pairs[j][1]: dp[i] = max(dp[i], dp[j]+1); return max(dp) 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-length-of-pair-chain著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 摆动序列如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 示例 1:123输入: [1,7,4,9,2,5]输出: 6 解释: 整个序列均为摆动序列。 示例 2:123输入: [1,17,5,10,13,15,10,5,16,8]输出: 7解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。 示例 3:12输入: [1,2,3,4,5,6,7,8,9]输出: 2 算法 首先计算得到差值序列，例如：1[2,5,3, 1] -&gt; [1, -2, -2]然后去重：123[2,5,3, 1] -&gt; [1, -2]// 注意：全零序列的结果为1[0,0,0] -&gt; [0]动态规划计算，dp[i]保存的是截止位置i的最长摆动序列。1234567891011121314151617181920212223242526272829303132class Solution(object): # 判断i位置的元素可以添加到j元素的尾部，构成摆动序列 def isSuccess(self, nums, i, j): if nums[i] &gt; 0 &gt; nums[j] or nums[i] &lt; 0 &lt; nums[j]: return True else: return False def wiggleMaxLength(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; l = len(nums) if l == 0 or l == 1: return l if l == 2: return 1 dp, _nums = [1] * (l - 1), [1] * (l - 1) for i in range(1, l): _nums[i - 1] = nums[i] - nums[i - 1] # 差序列去重 nums = list(set(_nums)) nums.sort(key=_nums.index) # 防止全零序列的干扰 if len(nums) == 1 and nums[0] == 0: return 1 # 动态规划求解 dp = [1] * len(_nums) for i in range(1, len(_nums)): if _nums[i] == 0: continue for j in range(0, i): if self.isSuccess(_nums, i, j): dp[i] = max(dp[i], dp[j] + 1) return max(dp) + 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/wiggle-subsequence著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Leetcode 413.等差数列划分","slug":"Leetcode-413-等差数列划分","date":"2019-12-25","updated":"2022-11-05","comments":true,"path":"Leetcode-413-等差数列划分/","link":"","permalink":"https://sunyunzeng.com/Leetcode-413-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/","excerpt":"","text":"等差数列划分如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。 例如，以下数列为等差数列: 1, 3, 5, 7, 97, 7, 7, 73, -1, -5, -9 以下数列不是等差数列。 1, 1, 2, 5, 7 1数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。 如果满足以下条件，则称子数组(P, Q)为等差数组：1元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。函数要返回数组 A 中所有为等差数组的子数组个数。 示例: A = [1, 2, 3, 4] 返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。 思路 + 代码首先对于等差序列 B, 其元素数量为n，则其包含的连续自等差序列的总数为 1+2+…+n-2,因此，该题转化为寻找序列中，最长的连续子等差序列，然后根据其数量判断。 123456789101112131415class Solution: def numberOfArithmeticSlices(self, A: List[int]) -&gt; int: l = len(A) if l &lt; 3: return 0 res, count = 0, 0 for i in range(2,l): if A[i]-A[i-1] == A[i-1]-A[i-2]: count+=1 else: if count!=0: res += sum(range(count+1)) count=0 if count != 0: res += sum(range(count + 1)) return res 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/arithmetic-slices著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题目给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1:123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。示例 2:123输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 思路 + 代码动态规划，整数4的最大乘积为: dp[3] = max(max(dp[2], dp[1]2), 1 2) 12345678910class Solution: def integerBreak(self, n: int) -&gt; int: if n &lt; 2: return 0 dp = [1] * (n+1) for i in range(2, n + 1): for j in range(1, i): dp[i] = max(dp[j] * (i - j), dp[i]) # 很关键的一步，因为之前的dp[i]最大值可能比dp[i]小，例如2或者3 dp[i] = max(j*(i-j), dp[i]) return dp[-1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/integer-break著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 完全平方数动态规划， 与前一题类似 123456789101112131415161718192021222324import java.lang.Math;class Solution &#123; public int numSquares(int n) &#123; if(n&lt;=3) return n; int[] dp = new int[n+1]; for(int i=0;i&lt;n+1; i++)&#123; dp[i] = Integer.MAX_VALUE; &#125; for(int i=1; i&lt;=3;i++)&#123; dp[i] = i; &#125; for(int i=4; i&lt;n+1; i++)&#123; int max_n = (int)Math.sqrt(i); if(max_n*max_n==i)&#123; dp[i]=1; &#125; else&#123; for(int j=1; j&lt;=max_n; j++)&#123; dp[i] = Math.min(dp[i], dp[i-j*j]+dp[j*j]); &#125; &#125; &#125; return dp[n]; &#125;&#125; 12345678910111213141516171819class Solution(object): def numSquares(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n &lt;= 3: return n dp = [sys.maxsize] * (n + 1) for i in range(1, 4): dp[i] = i for i in range(4, n + 1): max_n = int(math.sqrt(i)) if max_n * max_n == i: dp[i] = 1 else: for j in range(1, max_n + 1): dp[i] = min(dp[i], dp[i - j * j] + dp[j*j]) return dp[-1] 123456789101112131415161718192021/** * @param &#123;number&#125; n * @return &#123;number&#125; */var numSquares = function(n) &#123; if(n&lt;=3) return n; let dp = new Array(n+1).fill(Number.MAX_VALUE); for(let i=1; i&lt;=3; i++)&#123; dp[i] = i; &#125; for(let i=4; i&lt;n+1; i++)&#123; max_n = Math.trunc(Math.sqrt(i)); if(max_n*max_n==i) dp[i]=1; else&#123; for(let j=1; j&lt;=max_n; j++)&#123; dp[i] = Math.min(dp[i], dp[i-j*j]+dp[j*j]); &#125; &#125; &#125; return dp[n];&#125;; 解码方法一条包含字母 A-Z 的消息通过以下方式进行了编码： ‘A’ -&gt; 1‘B’ -&gt; 2…‘Z’ -&gt; 26给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1: 输入: “12”输出: 2解释: 它可以解码为 “AB”（1 2）或者 “L”（12）。示例 2: 输入: “226”输出: 3解释: 它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。 思路：动态规划，需注意0的处理，1010的编码方式共有1种，而909编码方式为0种，202编码方式为1种。 12345678910111213141516class Solution(object): def numDecodings(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; l = len(s) if l==0 or s[0]==&#x27;0&#x27;: return 0 dp = [0]*(l+1) dp[0], dp[1] = 1, 1 for i in range(2, l+1): if s[i-1]!=&#x27;0&#x27;: dp[i] += dp[i-1] if 9&lt;int(s[i-2:i])&lt;=26: dp[i]+=dp[i-2] return dp[-1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/decode-ways著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"LeetCode 打家劫舍 II","slug":"LeetCode-打家劫舍 II一","date":"2019-12-23","updated":"2022-11-05","comments":true,"path":"LeetCode-打家劫舍 II一/","link":"","permalink":"https://sunyunzeng.com/LeetCode-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II%E4%B8%80/","excerpt":"","text":"题目你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1:123输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。示例 2:1234输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 思路 + 代码关键是环，可以通过 0~len-2, 1~len-1分别遍历规避掉环的问题。 1234567891011121314class Solution: def subRob(self, s, e, nums)-&gt;int: pre1, pre2, cur = 0, 0, 0 for i in range(s,e): cur = max(pre1, pre2+nums[i]) pre2 = pre1 pre1 = cur return cur def rob(self, nums: List[int]) -&gt; int: l = len(nums) if l==0: return 0 if l==1: return nums[0] if l==2: return max(nums[0], nums[1]) return max(self.subRob(0, l-1, nums), self.subRob(1, l, nums)) 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Vue + Express + MySQL驾驶行为分析全栈项目(六): ECharts实现轨迹动态可视化","slug":"Vue-Express-MySQL驾驶行为分析全栈项目-六-ECharts实现轨迹动态可视化","date":"2019-12-23","updated":"2022-11-05","comments":true,"path":"Vue-Express-MySQL驾驶行为分析全栈项目-六-ECharts实现轨迹动态可视化/","link":"","permalink":"https://sunyunzeng.com/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E5%85%AD-ECharts%E5%AE%9E%E7%8E%B0%E8%BD%A8%E8%BF%B9%E5%8A%A8%E6%80%81%E5%8F%AF%E8%A7%86%E5%8C%96/","excerpt":"","text":"背景自己做了一点点的小尝试：基于前馈神经网络 LSTM 的个体出行目的地预测模型，基于个体历史出行数据，模型可以实现出行目的地的实时动态预测功能。 模型其实具有实际应用功能，为了对其应用场景进行探索，拟开发一个全栈的项目，在Web客户端实现用户出行的动态预测效果，同时能够提供数据可视分析等功能。 项目地址 可视化效果 轨迹的动态可视化预期效果可以参考: https://www.echartsjs.com/examples/zh/editor.html?c=lines-bmap-effect ECharts准备首先安装EChart组件 1npm install echarts --save 然后在 Vue 的 main.js 文件中引入百度地图依赖 1require(&#x27;echarts/extension/bmap/bmap&#x27;); 封装百度地图轨迹可视化模块我们将百度地图轨迹可视化单独包装成一个模块 EChartsMap.vue，该模块作用是接收父模块传来的可视化数据及设置参数，实现对应的可视化效果。 首先创建界面模版： 1234567891011&lt;template&gt; &lt;div class=&quot;bmap&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.bmap&#123; width: 100%; height: calc(78vh); position: relative;&#125;&lt;/style&gt; 然后在 script 标签中引入逻辑代码 1234567891011121314151617181920212223242526272829303132import store from &#x27;@/store&#x27;;// 引入ECharts组件 let echarts = require(&#x27;echarts&#x27;); export default &#123; name: &#x27;EChartsMap&#x27;, props: [&#x27;option&#x27;], watch:&#123; option: function (option) &#123; this.myChart.setOption(option); &#125; &#125;, data()&#123; return &#123; myChart: null &#125; &#125;, mounted()&#123; this.draw(); &#125;, methods: &#123; draw () &#123; this.myChart = echarts.init(this.$el); this.myChart.setOption(&#123; bmap:&#123; center: [114.03, 22.32], zoom: 10, roam: true, mapStyle: store.state.mapStyle &#125;&#125;); &#125;, &#125; &#125;; 这样子，我们父组件通过子组件的 option 属性进行 ECharts 可视化的配置。 然后子模块通过设置watch监听，实现可视化效果的随父模块数据的动态更新。 我们的ECharts需要在模版渲染成HTML界面后引入，所以在 mounted() 函数中使用。 轨迹动态可视化首先我们通过样例：https://www.echartsjs.com/examples/zh/editor.html?c=lines-bmap-effect 知道轨迹动态可视化的数据组织形式: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 busLines = [&#123;coords: [[114,25],[115,26], [117,28]...[lng, lat]], lineStyle: &#123; normal: &#123; color: echarts.color.modifyHSL(&#x27;#5A94DF&#x27;) &#125; &#125;&#125;, &#123;coords: [[114,25],[115,26], [117,28]...[lng, lat]], lineStyle: &#123; normal: &#123; color: echarts.color.modifyHSL(&#x27;#5A94DF&#x27;) &#125; &#125;&#125;] myChart.setOption(option = &#123; // 百度底图设置 bmap: &#123; center: [116.46, 39.92], zoom: 10, roam: true, mapStyle: &#123; &#x27;styleJson&#x27;: [ ...] &#125; &#125;, series: [ // 基础线条设置 &#123; type: &#x27;lines&#x27;, coordinateSystem: &#x27;bmap&#x27;, polyline: true, data: busLines, silent: true, lineStyle: &#123; normal: &#123; opacity: 0.2, width: 1 &#125; &#125;, progressiveThreshold: 500, progressive: 200 &#125;, // 线上动态点效果设置 &#123; type: &#x27;lines&#x27;, coordinateSystem: &#x27;bmap&#x27;, polyline: true, data: busLines, lineStyle: &#123; normal: &#123; width: 0 &#125; &#125;, effect: &#123; constantSpeed: 20, show: true, trailLength: 0.1, symbolSize: 1.5 &#125;, zlevel: 1 &#125;] &#125;);&#125;); 通过数据分析发现，我们的轨迹数据只要组织成 busLines (其中设定了轨迹点序列、及轨迹颜色)，然后在ECharts 底图设定 bmap 及数据设定 series 里面将 基础线条设置 与 线上动态点效果设置 按照自己喜欢的样式设计好即可。 然后在父模块中先引入EChartMap.vue模块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;template&gt; &lt;div&gt; &lt;Button type=&quot;primary&quot; @click=&quot;handleSubmit&quot;&gt;展示&lt;/Button&gt; &lt;EChartsMap :option=&quot;option&quot;&gt;&lt;/EChartsMap&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import EChartsMap from &#x27;@/components/commom/EChartsMap&#x27;; export default &#123; name: &#x27;prediction&#x27;, data () &#123; return &#123; bmap: &#123; center: this.$store.state.mapconfig.center, boundingCoords: [], zoom: 15, roam: true, mapStyle: store.state.mapStyle &#125;, option: &#123; bmap: this.bmap, tooltip: &#123; trigger: &#x27;item&#x27; &#125;, series: [] &#125;, myChart: null, lines: &#123; coords: [], lineStyle: &#123; normal: &#123; color: &#x27;orange&#x27; &#125; &#125; &#125;, lines_option: &#123; type: &#x27;lines&#x27;, coordinateSystem: &#x27;bmap&#x27;, polyline: true, data: [], silent: true, lineStyle: &#123; normal: &#123; opacity: 0.75, width: 3 &#125; &#125;, progressiveThreshold: 500, progressive: 200 &#125;, lines_state: &#123; type: &#x27;lines&#x27;, coordinateSystem: &#x27;bmap&#x27;, polyline: true, data: [], lineStyle: &#123; normal: &#123; width: 0 &#125; &#125;, effect: &#123; constantSpeed: 40, show: true, trailLength: 0.3, symbolSize: 3.5 &#125;, zlevel: 1 &#125; &#125;, mounted () &#123; &#125;, methods: &#123; // 异步数据处理 handleSubmit () &#123; this.$axios.post().then((data) =&gt; &#123; draw(data); &#125;) &#125;, // 数据可视化函数 draw (trajectory) &#123; this.lines.coords = trajectory; this.lines_option.data = [this.lines]; this.lines_state.data = [this.lines]; let series = [this.lines_option, this.lines_state]; this.option = &#123; bmap: this.bmap, tooltip: &#123; trigger: &#x27;item&#x27; &#125;, series: series &#125;;; &#125;, &#125;, components: &#123; EChartsMap &#125; &#125;;&lt;/script&gt; 完整代码请查看：https://github.com/SUNYunZeng/AIforDriving/blob/master/src/views/Prediction.vue","categories":[{"name":"教程","slug":"教程","permalink":"https://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sunyunzeng.com/tags/Vue/"}]},{"title":"LeetCode 524.通过删除字母匹配到字典里最长单词","slug":"LeetCode-524-通过删除字母匹配到字典里最长单词","date":"2019-12-21","updated":"2022-11-05","comments":true,"path":"LeetCode-524-通过删除字母匹配到字典里最长单词/","link":"","permalink":"https://sunyunzeng.com/LeetCode-524-%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/","excerpt":"","text":"题目给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。 示例 1:12345输入:s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]输出: &quot;apple&quot;1234567示例 2:输入:s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]输出: &quot;a&quot; 说明:所有输入的字符串只包含小写字母。字典的大小不会超过 1000。所有输入的字符串长度不会超过 1000。 思路 + 代码快慢指针判断是否在字符串里面 12345678910111213141516171819202122232425262728293031class Solution: def isInWord(self, a, b) -&gt; bool: i, j = 0, len(b)-1 m, n = 0, len(a)-1 while i &lt;= j: if m &gt; n: return False if a[m]==b[i]: m+=1 i+=1 else: while m&lt;=n and a[m]!=b[i]: m+=1 if m &gt; n and i&lt;=j: return False if a[n]==b[j]: n-=1 j-=1 else: while m&lt;=n and a[n]!=b[j]: n-=1 if m &gt; n and i&lt;=j: return False return True def findLongestWord(self, s: str, d: List[str]) -&gt; str: if len(s)==0 or len(d)==0: return &quot;&quot; res=&quot;&quot; for i in range(len(d)): if self.isInWord(s, d[i]): if len(d[i])&gt;len(res): res = d[i] elif len(d[i])==len(res) and d[i]&lt;res: res = d[i] return res 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"LeetCode 763. 划分字母区间","slug":"LeetCode-763-划分字母区间","date":"2019-12-20","updated":"2022-11-05","comments":true,"path":"LeetCode-763-划分字母区间/","link":"","permalink":"https://sunyunzeng.com/LeetCode-763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/","excerpt":"","text":"题目字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。 示例1：123456输入: S = &quot;ababcbacadefegdehijhklij&quot;输出: [9,7,8]解释:划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。每个字母最多出现在一个片段中。像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。 注意：12S的长度在[1, 500]之间。S只包含小写字母&#x27;a&#x27;到&#x27;z&#x27;。 思路 + 代码贪心算法。 统计每个字母出现的最后位置，最优分割是该区间内任意一个字母的最大位置都包括在内。 1234567891011class Solution: def partitionLabels(self, S: str) -&gt; List[int]: dic = &#123;c:i for i, c in enumerate(S)&#125; j, anchor = 0, 0 res = [] for i, c in enumerate(S): j = max(j, dic[c]) if i==j: res.append(i-anchor+1) anchor = i+1 return res","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"贪心法","slug":"贪心法","permalink":"https://sunyunzeng.com/tags/%E8%B4%AA%E5%BF%83%E6%B3%95/"}]},{"title":"Vue + Express + MySQL驾驶行为分析全栈项目(五): Leftlet热力图实现","slug":"Vue-Express-MySQL驾驶行为分析全栈项目-五-Leftlet热力图实现","date":"2019-12-14","updated":"2022-11-05","comments":true,"path":"Vue-Express-MySQL驾驶行为分析全栈项目-五-Leftlet热力图实现/","link":"","permalink":"https://sunyunzeng.com/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E4%BA%94-Leftlet%E7%83%AD%E5%8A%9B%E5%9B%BE%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"背景自己做了一点点的小尝试：基于前馈神经网络 LSTM 的个体出行目的地预测模型，基于个体历史出行数据，模型可以实现出行目的地的实时动态预测功能。 模型其实具有实际应用功能，为了对其应用场景进行探索，拟开发一个全栈的项目，在Web客户端实现用户出行的动态预测效果，同时能够提供数据可视分析等功能。 项目地址 可视化效果 Leftlet底图模块构建需要安装的依赖库与样式查看Vue + Express + MySQL驾驶行为分析全栈项目(四): Leftlet组件与图层加载功能。 在 src/components/common 文件夹下添加 LeftletMap.vue文件，作为Leftlet地图的基础模块。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// LeftletMap.vue&lt;template&gt; &lt;div class=&quot;map&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &#x27;LeftletMap&#x27;, data: function () &#123; return &#123; L: null, map: null, map_config: this.store.state.map_config &#125;; &#125;, methods: &#123; initMap () &#123; this.L = L; let map = L.map(this.$el, &#123; center: this.map_config.center, zoom: this.map_config.zoom &#125;); this.map = map; let baseLayer = L.tileLayer(&#x27;https://api.tiles.mapbox.com/v4/&#123;id&#125;/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png?&#x27; + &#x27;access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw&#x27;, &#123; id: this.store.state.layerItems[&#x27;box_d&#x27;], minZoom: 3 &#125;); map.addLayer(baseLayer); &#125; &#125;, mounted () &#123; this.initMap(); &#125; &#125;;&lt;/script&gt;&lt;style scoped&gt; .map &#123; width: 100%; height: calc(88vh); position: relative; &#125;&lt;/style&gt; 其中 this.state 是用Vuex插件定义的全局状态变量，其本身是 src/store/index.js文件中定义的一个对象，在其中我们定义了各种地图的配置选项。具体内容可查看Vue + Express + MySQL驾驶行为分析全栈项目(四): Leftlet组件与图层加载功能。 热力图实现首先安装leftlet热力图插件 leaflet-heatmap。 1npm i leaflet-heatmap --save 然后在src/views/ 文件夹下创建 ODpoint.vue 文件，该组件是对轨迹的O-D(Origin-Destination)点进行热力图分析。 123456789101112131415161718192021222324252627282930&lt;!-- ODpoint.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;Form ref=&quot;formInline&quot; inline&gt; &lt;FormItem&gt; 测试用户: &lt;Select v-model=&quot;user&quot; clearable style=&quot;width:70px&quot;&gt; &lt;Option value=&quot;user1&quot;&gt;User1&lt;/Option&gt; &lt;Option value=&quot;user2&quot;&gt;User2&lt;/Option&gt; &lt;Option value=&quot;user3&quot;&gt;User3&lt;/Option&gt; &lt;Option value=&quot;user4&quot;&gt;User4&lt;/Option&gt; &lt;/Select&gt; &lt;/FormItem&gt; &lt;FormItem&gt;&lt;b&gt;出发时间:&lt;/b&gt;&lt;/FormItem&gt; &lt;FormItem&gt; &lt;DatePicker v-model=&quot;time_range&quot; :start-date=&quot;new Date(&#x27;2018-01-01 00:00:00&#x27;)&quot; type=&quot;datetimerange&quot; style=&quot;width: 300px&quot;&gt;&lt;/DatePicker&gt; &lt;/FormItem&gt; &lt;FormItem&gt; &lt;CheckboxGroup v-model=&quot;ODSelectoin&quot;&gt; &lt;Checkbox label=&quot;origin&quot;&gt;&lt;/Checkbox&gt; &lt;Checkbox label=&quot;destination&quot;&gt;&lt;/Checkbox&gt; &lt;/CheckboxGroup&gt; &lt;/FormItem&gt; &lt;FormItem&gt; &lt;Button type=&quot;primary&quot; @click=&quot;show&quot;&gt;展示&lt;/Button&gt; &lt;/FormItem&gt; &lt;/Form&gt; &lt;Map style=&quot;height: calc(78vh);&quot; ref=&quot;leftletMap&quot;&gt;&lt;/Map&gt; &lt;/div&gt;&lt;/template&gt; 然后定义展示的逻辑js代码。一些问题可以参考文章：https://blog.frytea.com/archives/41/。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 引入LeftletMap子模块import Map from &#x27;@/components/commom/LeftletMap&#x27;;import HeatmapOverlay from &#x27;heatmap.js/plugins/leaflet-heatmap&#x27;;import &#123;post, get&#125; from &#x27;@/utils/myAjax&#x27;;import &#123;points_factory&#125; from &#x27;@/utils/traj-handler&#x27;export default &#123; name: &#x27;od&#x27;, data () &#123; return &#123; user: &#x27;user1&#x27;, time_range: [&#x27;2018-01-01 00:00:00&#x27;, &#x27;2018-01-31:00:00:00&#x27;], ODSelectoin: [&#x27;origin&#x27;], heatmapLayer: null, cfg: &#123; &#x27;radius&#x27;: 0.005, &#x27;maxOpacity&#x27;: 0.8, &#x27;scaleRadius&#x27;: true, &#x27;useLocalExtrema&#x27;: true, latField: &#x27;lat&#x27;, lngField: &#x27;lng&#x27;, valueField: &#x27;eff&#x27; &#125; &#125;; &#125;, mounted () &#123; this.initHeatMap(); &#125;, components: &#123; Map &#125;, methods: &#123; show () &#123; if (this.ODSelectoin.length === 0 || this.user === undefined) &#123; this.$Message.info(&#x27;请配置参数&#x27;); return null; &#125; if (this.$isOnServer) &#123; post(&#x27;searchByRow&#x27;, &#123; rowName: [&#x27;origin&#x27;, &#x27;destination&#x27;, &#x27;norm_dict&#x27;, &#x27;o_eff&#x27;, &#x27;d_eff&#x27;], time: this.time_range, tableName: this.user &#125;).then(data =&gt; &#123; if (data.length &gt; 0) &#123; let res = points_factory(data, this.ODSelectoin); this.heatmapLayer.setData(res.data); this.$refs.leftletMap.map.setView(res.center, 10); &#125; else &#123; this.$Message.info(&#x27;空数据&#x27;); &#125; &#125;); &#125; else &#123; get(&#x27;../static/data/&#x27; + this.user + &#x27;.json&#x27;).then(data =&gt; &#123; if (data.RECORDS.length &gt; 0) &#123; let basket = []; let record = data.RECORDS; for (let item of record) &#123; let tmp_date = new Date(item[&#x27;time&#x27;]); if (tmp_date &gt;= this.time_range[0] &amp;&amp; tmp_date &lt;= this.time_range[1]) &#123; basket.push(item); &#125; &#125; let res = points_factory(basket, this.ODSelectoin); this.heatmapLayer.setData(res.data); this.$refs.leftletMap.map.setView(res.center, 10); &#125; else &#123; this.$Message.info(&#x27;空数据&#x27;); &#125; &#125;); &#125; &#125;, initHeatMap () &#123; this.heatmapLayer = new HeatmapOverlay(this.cfg); this.heatmapLayer.addTo(this.$refs.leftletMap.map); L.control.scale(&#123; maxWidth: 200, metric: true, imperial: false &#125;).addTo(this.$refs.leftletMap.map); &#125; &#125;&#125;; 最后，预览效果：http://geoai.sunyunzeng.com/#/od","categories":[{"name":"教程","slug":"教程","permalink":"https://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sunyunzeng.com/tags/Vue/"}]},{"title":"Vue + Express + MySQL驾驶行为分析全栈项目(四): Leftlet组件与图层加载功能","slug":"Vue-Express-MySQL驾驶行为分析全栈项目-四-Leftlet组件与图层加载功能","date":"2019-12-14","updated":"2022-11-05","comments":true,"path":"Vue-Express-MySQL驾驶行为分析全栈项目-四-Leftlet组件与图层加载功能/","link":"","permalink":"https://sunyunzeng.com/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E5%9B%9B-Leftlet%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%9B%BE%E5%B1%82%E5%8A%A0%E8%BD%BD%E5%8A%9F%E8%83%BD/","excerpt":"","text":"背景自己做了一点点的小尝试：基于前馈神经网络 LSTM 的个体出行目的地预测模型，基于个体历史出行数据，模型可以实现出行目的地的实时动态预测功能。 模型其实具有实际应用功能，为了对其应用场景进行探索，拟开发一个全栈的项目，在Web客户端实现用户出行的动态预测效果，同时能够提供数据可视分析等功能。 项目地址 可视化效果 准备工作 首先下载安装 leftlet。 1npm install leaflet --save 然后在全局入口 main.js 文件中引入leftlet，包括样式文件 123456// 引入插件与样式import * as L from &#x27;leaflet&#x27;;import &#x27;leaflet/dist/leaflet.css&#x27;;// 全局注册Vue.L = Vue.prototype.$L = L; 安装leftlet地图图层的加载插件— leaflet.chinatmsproviders 1npm i leaflet.chinatmsproviders --save 123import * as Provider from &#x27;leaflet.chinatmsproviders&#x27;;Vue.Provider = Vue.prototype.$Provider = Provider; 然后引入 1npm i leaflet.chinatmsproviders 再安装iView插件。 1npm install iview --save 然后在全局入口 main.js 文件中引入iview插件及样式 123import iView from &#x27;iview&#x27;;Vue.use(iView); main.js文件 1234567891011121314151617181920212223242526// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from &#x27;vue&#x27;;import App from &#x27;@/App&#x27;;import router from &#x27;@/router&#x27;;import iView from &#x27;iview&#x27;;import store from &#x27;@/store&#x27;;import &#x27;leaflet/dist/leaflet.css&#x27;;import &#x27;iview/dist/styles/iview.css&#x27;import &#x27;@/permission&#x27;;import * as L from &#x27;leaflet&#x27;;import * as Provider from &#x27;leaflet.chinatmsproviders&#x27;;// 全局注册Vue.use(iView);Vue.L = Vue.prototype.$L = L;Vue.Provider = Vue.prototype.$Provider = Provider;/* eslint-disable no-new */new Vue(&#123; el: &#x27;#app&#x27;, router, store, render: h =&gt; h(App) // 相当于 components: &#123; App &#125; vue1.0的写法&#125;); 界面展示逻辑然后定义我们的页面展示逻辑。 首先在 src/views/ 文件夹下创建 Home.vue 文件。然后定义界面组件，包括返回home按钮与下拉图层选择选项。 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- Home.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;div id=&quot;map&quot;&gt;&lt;/div&gt; &lt;Button id=&quot;map_home&quot; class=&quot;rightmenu&quot; @click=&quot;returnHome&quot; icon=&quot;ios-home&quot; type=&quot;primary&quot; shape=&quot;circle&quot; title=&quot;home&quot;&gt;&lt;/Button&gt; &lt;Dropdown class=&quot;rightmenu&quot; style=&quot;margin-left: 20px&quot; placement=&quot;bottom-end&quot;&gt; &lt;Button type=&quot;primary&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;Icon type=&quot;ios-arrow-down&quot;&gt;&lt;/Icon&gt; &lt;/Button&gt; &lt;DropdownMenu slot=&quot;list&quot;&gt; &lt;DropdownItem @click.native=&quot;mapSet(&#x27;gd&#x27;)&quot;&gt;高德地图&lt;/DropdownItem&gt; &lt;DropdownItem @click.native=&quot;mapSet(&#x27;glg&#x27;)&quot;&gt;谷歌地图&lt;/DropdownItem&gt; &lt;DropdownItem @click.native=&quot;mapSet(&#x27;box&#x27;)&quot;&gt;MapBox&lt;/DropdownItem&gt; &lt;DropdownItem @click.native=&quot;mapSet(&#x27;osm&#x27;)&quot;&gt;OSM地图&lt;/DropdownItem&gt; &lt;DropdownItem @click.native=&quot;mapSet(&#x27;geo&#x27;)&quot;&gt;智图&lt;/DropdownItem&gt; &lt;/DropdownMenu&gt; &lt;/Dropdown&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; #map &#123; width: 100%; height: calc(88vh); position: relative; &#125; .rightmenu&#123; position: absolute; top: 30px; right: 70px; z-index: 1000; &#125; #map_home&#123; right: 30px; &#125;&lt;/style&gt; 功能实现逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// Home.vue &lt;script&gt; import store from &#x27;@/store&#x27;; export default &#123; name: &#x27;home&#x27;, data () &#123; return &#123; map: null, L: null, baseLayer: null, msg: &#x27;高德地图&#x27;, map_config: &#123; zoom: 15, center: [30.541093, 114.360734], minZoom: 2, maxZoom: 18 // key: &quot;eb35dddb3aa33c7a8fb4218b39d1e424&quot; 天地图key &#125; &#125;; &#125;, mounted () &#123; this.initMap(); &#125;, methods: &#123; initMap () &#123; this.L = L; let map = L.map(&quot;map&quot;, &#123; center: this.map_config.center, zoom: this.map_config.zoom &#125;); this.map = map; this.addLayer(L, map, store.state.layerItems[&#x27;gd_n_a&#x27;],18, 3); &#125;, addLayer (L, map, layer_name, maxZoom, minZoom) &#123; if (this.baseLayer !== null) &#123; map.removeLayer(this.baseLayer); &#125; this.baseLayer = L.tileLayer.chinaProvider(layer_name, &#123; maxZoom: maxZoom === undefined ? this.map_config.maxZoom : maxZoom, minZoom: minZoom === undefined ? this.map_config.minZoom : minZoom &#125;); map.addLayer(this.baseLayer); &#125;, returnHome () &#123; this.map.setView(this.map_config.center, 15); &#125;, mapSet (map_name, L = this.L, map = this.map) &#123; switch (map_name) &#123; case &#x27;gd&#x27;: this.addLayer(L, map, store.state.layerItems[&#x27;gd_n_a&#x27;], 18, 3); this.msg = &#x27;高德地图 &#x27;; break; case &#x27;glg&#x27;: this.addLayer(L, map, store.state.layerItems[&#x27;glg_n&#x27;]); this.msg = &#x27;谷歌地图 &#x27;; break; case &#x27;geo&#x27;: this.addLayer(L, map, store.state.layerItems[&#x27;geo_n_g&#x27;], 16); this.msg = &#x27; 智图 &#x27;; break; case &#x27;osm&#x27;: this.addLayer(L, map, store.state.layerItems[&#x27;osm&#x27;]); this.msg = &#x27;OSM地图&#x27;; break; case &#x27;box&#x27;: if (this.baseLayer !== null) &#123; map.removeLayer(this.baseLayer); &#125; this.baseLayer = L.tileLayer(&#x27;https://api.tiles.mapbox.com/v4/&#123;id&#125;/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png?&#x27; + &#x27;access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw&#x27;, &#123; id: store.state.layerItems[&#x27;box&#x27;], minZoom: 3 &#125;); map.addLayer(this.baseLayer); this.msg = &#x27;Mapbox&#x27;; break; default: break; &#125; &#125;, &#125;, &#125;&lt;/script&gt; 其中 this.state 是用Vuex插件定义的全局状态变量，其本身是 src/store/index.js文件中定义的一个对象，在其中我们定义了各种地图的配置选项。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// src/store/index.jsimport Vue from &#x27;vue&#x27;;import Vuex from &#x27;vuex&#x27;;Vue.use(Vuex);const store = new Vuex.Store(&#123; state: &#123; // 底图数据 layerItems: &#123; &#x27;tdt_n&#x27;: &#x27;TianDiTu.Normal.Map&#x27;, &#x27;tdt_n_a&#x27;: &#x27;TianDiTu.Normal.Annotion&#x27;, &#x27;tdt_s&#x27;: &#x27;TianDiTu.Satellite.Map&#x27;, &#x27;tdt_s_a&#x27;: &#x27;Satellite.Annotion&#x27;, &#x27;gd_n_a&#x27;: &#x27;GaoDe.Normal.Map&#x27;, &#x27;gd_s&#x27;: &#x27;GaoDe.Satellite.Map&#x27;, &#x27;gd_s_a&#x27;: &#x27;GaoDe.Satellite.Annotion&#x27;, &#x27;glg_n&#x27;: &#x27;Google.Normal.Map&#x27;, &#x27;glg_s&#x27;: &#x27;Google.Satellite.Map&#x27;, &#x27;geo_n&#x27;: &#x27;Geoq.Normal.Map&#x27;, &#x27;geo_n_p&#x27;: &#x27;Geoq.Normal.PurplishBlue&#x27;, &#x27;geo_n_g&#x27;: &#x27;Geoq.Normal.Gray&#x27;, &#x27;geo_n_w&#x27;: &#x27;Geoq.Normal.Warm&#x27;, &#x27;geo_n_h&#x27;: &#x27;Geoq.Normal.Hydro&#x27;, &#x27;osm&#x27;: &#x27;OSM.Normal.Map&#x27;, &#x27;box_d&#x27;: &#x27;mapbox.dark&#x27;, &#x27;box_l&#x27;: &#x27;mapbox.light&#x27;, &#x27;box&#x27;: &#x27;mapbox.streets&#x27; &#125;, //地图配置 mapconfig: &#123; zoom: 15, center: [30.541093, 114.360734], minZoom: 2, maxZoom: 18 &#125; &#125;, mutations: &#123; setMap(state, key, value) &#123; state.mapconfig[key] = value; &#125; &#125;&#125;);export default store; 然后基于Leftlet的图层切换与返回指定位置功能就实现啦，预览：http://geoai.sunyunzeng.com/#/home","categories":[{"name":"教程","slug":"教程","permalink":"https://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sunyunzeng.com/tags/Vue/"}]},{"title":"Vue + Express + MySQL驾驶行为分析全栈项目(三): 前端设计","slug":"Vue-Express-MySQL驾驶行为分析全栈项目-三-前端设计","date":"2019-12-12","updated":"2022-11-05","comments":true,"path":"Vue-Express-MySQL驾驶行为分析全栈项目-三-前端设计/","link":"","permalink":"https://sunyunzeng.com/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E4%B8%89-%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"背景自己做了一点点的小尝试：基于前馈神经网络 LSTM 的个体出行目的地预测模型，基于个体历史出行数据，模型可以实现出行目的地的实时动态预测功能。 模型其实具有实际应用功能，为了对其应用场景进行探索，拟开发一个全栈的项目，在Web客户端实现用户出行的动态预测效果，同时能够提供数据可视分析等功能。 项目地址 可视化效果 前端结构设计下图是整个项目的结构，也就是采用Vue-cli脚手架搭建的前端项目结构 buile 文件夹存放项目构建脚本。config 文件夹存放项目的配置信息，包括webpack配置及端口转发等。dist/docs 文件夹存放的是项目构建后的内容，即编译出的项目代码。node_modules 这个目录存放的是项目的所有依赖，即 npm install 命令下载下来的文件。server 文件夹存放的是服务器相关代码与数据。src 存放前端项目的源码。static 存放项目的静态资源。index.html 项目的入口页，也是唯一的HTML页面。package.json 定义了项目的所有依赖，包括开发时依赖和发布时依赖。 其中前端开发的大多工作是在 src 文件夹下进行的，它的目录结构如下： assets 文件夹存放资产文件。components 文件夹存放项目公共的组件(.vue文件)。lib 文件夹存放的是第三方库暴露出来的接口。router 存放前端界面的路由逻辑js文件。store 文件夹存放的是全局共享的变量。utils 存放辅助函数脚本。view 存放项目各独立界面(.vue文件)。App.vue 一个vue组件，是第一个vue组件。main.js 定义了项目启动的入口。permission.js 界面初始化工作，包括动态界面的加载。 界面模版前端界面模版是基于 vue-admin-template修改的，去除了登录功能，精简了界面逻辑。 界面模版最大的特点可以实现菜单栏的个性定制。 首先在 src/components/Index.vue文件夹内，定义动态菜单栏。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248&lt;template&gt; &lt;div class=&quot;index-vue&quot;&gt; &lt;!-- 侧边栏 --&gt; &lt;aside :class=&quot;asideClassName&quot;&gt; &lt;!-- logo --&gt; &lt;div class=&quot;logo-c pointer&quot; @click=&quot;isShrinkAside&quot; title=&quot;收缩/展开&quot;&gt; &lt;img src=&quot;../assets/imgs/logo.png&quot; alt=&quot;logo&quot; class=&quot;logo&quot;&gt; &lt;span v-show=&quot;isShowAsideTitle&quot;&gt;驾驶分析系统&lt;/span&gt; &lt;/div&gt; &lt;!-- 菜单栏 --&gt; &lt;Menu class=&quot;menu&quot; ref=&quot;asideMenu&quot; theme=&quot;dark&quot; width=&quot;100%&quot; @on-select=&quot;gotoPage&quot; accordion :open-names=&quot;openMenus&quot; :active-name=&quot;currentPage&quot; @on-open-change=&quot;menuChange&quot;&gt; &lt;!-- 动态菜单 --&gt; &lt;div v-for=&quot;(item, index) in menuItems&quot; :key=&quot;index&quot;&gt; &lt;Submenu v-if=&quot;item.children&quot; :name=&quot;index&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;Icon :size=&quot;item.size&quot; :type=&quot;item.type&quot;/&gt; &lt;span v-show=&quot;isShowAsideTitle&quot;&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;div v-for=&quot;(subItem, i) in item.children&quot; :key=&quot;index + i&quot;&gt; &lt;Submenu v-if=&quot;subItem.children&quot; :name=&quot;index + &#x27;-&#x27; + i&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;Icon :size=&quot;subItem.size&quot; :type=&quot;subItem.type&quot;/&gt; &lt;span v-show=&quot;isShowAsideTitle&quot;&gt;&#123;&#123;subItem.text&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;MenuItem class=&quot;menu-level-3&quot; v-for=&quot;(threeItem, k) in subItem.children&quot; v-if=&quot;!threeItem.hidden&quot; :name=&quot;threeItem.name&quot; :key=&quot;index + i + k&quot;&gt; &lt;Icon :size=&quot;threeItem.size&quot; :type=&quot;threeItem.type&quot;/&gt; &lt;span v-show=&quot;isShowAsideTitle&quot;&gt;&#123;&#123;threeItem.text&#125;&#125;&lt;/span&gt; &lt;/MenuItem&gt; &lt;/Submenu&gt; &lt;MenuItem v-else-if=&quot;!subItem.hidden&quot; :name=&quot;subItem.name&quot;&gt; &lt;Icon :size=&quot;subItem.size&quot; :type=&quot;subItem.type&quot;/&gt; &lt;span v-show=&quot;isShowAsideTitle&quot;&gt;&#123;&#123;subItem.text&#125;&#125;&lt;/span&gt; &lt;/MenuItem&gt; &lt;/div&gt; &lt;/Submenu&gt; &lt;MenuItem v-else-if=&quot;!item.hidden&quot; :name=&quot;item.name&quot;&gt; &lt;Icon :size=&quot;item.size&quot; :type=&quot;item.type&quot;/&gt; &lt;span v-show=&quot;isShowAsideTitle&quot;&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt; &lt;/MenuItem&gt; &lt;/div&gt; &lt;/Menu&gt; &lt;/aside&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &#x27;index&#x27;, data () &#123; return &#123; // 用于储存页面路径 paths: &#123;&#125;, // 当前显示页面 currentPage: &#x27;&#x27;, openMenus: [], // 要打开的菜单名字 name属性 menuCache: [], // 缓存已经打开的菜单 showLoading: false, // 是否显示loading isShowRouter: true, isShowAsideTitle: true, // 是否展示侧边栏内容 main: null, // 页面主要内容区域 asideClassName: &#x27;aside-big&#x27;, // 控制侧边栏宽度变化 asideArrowIcons: [], // 缓存侧边栏箭头图标 收缩时用 &#125;; &#125;, created () &#123; // 已经为ajax请求设置了loading 请求前自动调用 请求完成自动结束 // 添加请求拦截器 this.$axios.interceptors.request.use(config =&gt; &#123; this.showLoading = false; // 在发送请求之前做些什么 return config; &#125;, error =&gt; &#123; this.showLoading = false; // 对请求错误做些什么 return Promise.reject(error); &#125;); // 添加响应拦截器 this.$axios.interceptors.response.use(response =&gt; &#123; // 可以在这里对返回的数据进行错误处理 如果返回的 code 不对 直接报错或退出登陆 // 就可以省去在业务代码里重复判断 // 例子 // if (res.code != 0) &#123; // this.$Message.error(res.msg) // return Promise.reject() // &#125; this.showLoading = false; const res = response.data; return res; &#125;, error =&gt; &#123; this.showLoading = false; // 对响应错误做点什么 return Promise.reject(error); &#125;); &#125;, mounted () &#123; // 第一个标签 const name = this.$route.name; this.currentPage = name; // 根据路由打开对应的菜单栏 this.openMenus = this.getMenus(name); this.$nextTick(() =&gt; &#123; this.$refs.asideMenu.updateOpened(); &#125;); this.main = document.querySelector(&#x27;.sec-right&#x27;); this.asideArrowIcons = document.querySelectorAll(&#x27;aside .ivu-icon-ios-arrow-down&#x27;); // 监听窗口大小 自动收缩侧边栏 this.monitorWindowSize(); &#125;, watch: &#123; $route (to) &#123; const name = to.name; this.currentPage = name; &#125; &#125;, computed: &#123; // 菜单栏 menuItems () &#123; return this.$store.state.menuItems; &#125;, // 由于iView的导航菜单比较坑 只能设定一个name参数 // 所以需要在这定义组件名称和标签栏标题的映射表 有多少个页面就有多少个映射条数 nameToTitle () &#123; const obj = &#123;&#125;; this.menuItems.forEach(e =&gt; &#123; this.processNameToTitle(obj, e); &#125;); return obj; &#125;, &#125;, methods: &#123; getMenus (name) &#123; let menus; const tagTitle = this.nameToTitle[name]; for (let i = 0, l = this.menuItems.length; i &lt; l; i++) &#123; const item = this.menuItems[i]; menus = []; menus[0] = i; if (item.text == tagTitle) &#123; return menus; &#125; if (item.children) &#123; for (let j = 0, ll = item.children.length; j &lt; ll; j++) &#123; const child = item.children[j]; menus[1] = i + &#x27;-&#x27; + j; menus.length = 2; if (child.text == tagTitle) &#123; return menus; &#125; if (child.children) &#123; for (let k = 0, lll = child.children.length; k &lt; lll; k++) &#123; const grandson = child.children[k]; menus[2] = i + &#x27;-&#x27; + j + &#x27;-&#x27; + k; if (grandson.text == tagTitle) &#123; return menus; &#125; &#125; &#125; &#125; &#125; &#125; &#125;, monitorWindowSize () &#123; let w = document.documentElement.clientWidth || document.body.clientWidth; if (w &lt; 1300) &#123; this.shrinkAside(); &#125; window.onresize = () =&gt; &#123; // 可视窗口宽度太小 自动收缩侧边栏 if (w &lt; 1300 &amp;&amp; this.isShowAsideTitle &amp;&amp; w &gt; (document.documentElement.clientWidth || document.body.clientWidth)) &#123; this.shrinkAside(); &#125; w = document.documentElement.clientWidth || document.body.clientWidth; &#125;; &#125;, // 判断当前标签页是否激活状态 isActive (name) &#123; return this.$route.name === name; &#125;, // 判断 isShrinkAside () &#123; this.isShowAsideTitle ? this.shrinkAside() : this.expandAside(); &#125;, // 收缩 shrinkAside () &#123; this.asideArrowIcons.forEach(e =&gt; &#123; e.style.display = &#x27;none&#x27;; &#125;); this.isShowAsideTitle = false; this.openMenus = []; this.$nextTick(() =&gt; &#123; this.$refs.asideMenu.updateOpened(); &#125;); setTimeout(() =&gt; &#123; this.asideClassName = &#x27;&#x27;; this.main.style.width = &#x27;calc(100% - 80px)&#x27;; &#125;, 0); &#125;, // 展开 expandAside () &#123; setTimeout(() =&gt; &#123; this.isShowAsideTitle = true; this.asideArrowIcons.forEach(e =&gt; &#123; e.style.display = &#x27;block&#x27;; &#125;); this.openMenus = this.menuCache; this.$nextTick(() =&gt; &#123; this.$refs.asideMenu.updateOpened(); &#125;); &#125;, 200); this.asideClassName = &#x27;aside-big&#x27;; this.main.style.width = &#x27;calc(100% - 220px)&#x27;; &#125;, // 菜单栏改变事件 menuChange (data) &#123; this.menuCache = data; &#125;, processNameToTitle (obj, data, text) &#123; if (data.name) &#123; obj[data.name] = data.text; this.paths[data.name] = text ? `$&#123;text&#125; / $&#123;data.text&#125;` : data.text; &#125; if (data.children) &#123; data.children.forEach(e =&gt; &#123; this.processNameToTitle(obj, e, text ? `$&#123;text&#125; / $&#123;data.text&#125;` : data.text); &#125;); &#125; &#125; &#125; &#125;;&lt;/script&gt; 任务栏是根据 this.$store.state.menuItems 定义的内容循环更新，包括子任务栏，其定义在src/store/index.js文件内，需利用Vuex状态管理插件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import Vue from &#x27;vue&#x27;;import Vuex from &#x27;vuex&#x27;;Vue.use(Vuex);const store = new Vuex.Store(&#123; state: &#123; // 左侧菜单栏数据 menuItems: [ &#123; name: &#x27;home&#x27;, // 要跳转的路由名称 不是路径 size: 22, // icon大小 type: &#x27;md-home&#x27;, // icon类型 text: &#x27;主页&#x27;, // 文本内容 &#125; &#123; text: &#x27;数据视图&#x27;, type: &#x27;md-globe&#x27;, size: 22, children: [ &#123; text: &#x27;可视化&#x27;, type: &#x27;ios-eye&#x27;, size: 20, children: [ &#123; type: &#x27;logo-steam&#x27;, name: &#x27;trajectory&#x27;, text: &#x27;轨迹&#x27; &#125; ] &#125; ] &#125; ], &#125;, mutations: &#123; setMenus (state, items) &#123; state.menuItems = [...items]; &#125; &#125;&#125;);export default store; 然后在src/router/index.js文件中定义每个组件的路由规则。 12345678910111213141516171819202122232425262728293031323334353637import Vue from &#x27;vue&#x27;;import Router from &#x27;vue-router&#x27;;Vue.use(Router);export const commonRouters = [ &#123; path: &#x27;/&#x27;, redirect: &#x27;home&#x27; &#125;];// 需要动态定制的任务栏，包括子任务栏export const asyncRouters = &#123; &#x27;home&#x27;: &#123; path: &#x27;home&#x27;, name: &#x27;home&#x27;, component: () =&gt; import(&#x27;@/views/Home.vue&#x27;) &#125;, &#x27;trajectory&#x27;: &#123; path: &#x27;trajectory&#x27;, name: &#x27;trajectory&#x27;, component: () =&gt; import(&#x27;@/views/Trajectory.vue&#x27;) &#125;&#125;;const createRouter = () =&gt; new Router(&#123; routes: commonRouters&#125;);export function resetRouter () &#123; const newRouter = createRouter(); router.matcher = newRouter.matcher;&#125;const router = createRouter();export default router; 然后在 src/views 文件夹下定义对应路口的界面vue组件。 1234567891011121314151617181920212223242526272829// Home.vue&lt;template&gt; ...&lt;/template&gt;&lt;script&gt; export default &#123; name: &#x27;home&#x27; &#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;// Trajectory.vue&lt;template&gt; ...&lt;/template&gt;&lt;script&gt; export default &#123; name: &#x27;home&#x27; &#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 之后，在src/permission.js文件中，定义界面初始化逻辑： 12345678910111213141516171819202122232425import router from &#x27;@/router&#x27;import store from &#x27;@/store&#x27;import &#123;menusToRouters&#125; from &#x27;@/utils&#x27;;import &#123;LoadingBar&#125; from &#x27;iview&#x27;let hasMenus = false;router.beforeEach(async (to, from, next)=&gt;&#123; LoadingBar.start(); if(hasMenus)&#123; next() &#125;else&#123; try&#123; const routers = menusToRouters(store.state.menuItems); router.addRoutes(routers); hasMenus = true; next(&#123;path: to.path || &#x27;/&#x27;&#125;); &#125;catch (e) &#123; console.log(e.toString()); &#125; &#125;&#125;);router.afterEach(()=&gt;&#123; LoadingBar.finish()&#125;); 其中 menusToRouters 方法是将定义的任务栏转化为对应的router对象： 12345678910111213141516171819202122232425262728293031323334import &#123;asyncRouters&#125; from &#x27;@/router&#x27;;export function menusToRouters (data) &#123; const res = []; const children = []; res.push(&#123; path: &#x27;/&#x27;, component: () =&gt; import(&#x27;@/components/Index.vue&#x27;), children, &#125;); data.forEach(item =&gt; &#123; generateRouters(children, item); &#125;); children.push(&#123; path: &#x27;error&#x27;, name: &#x27;error&#x27;, component: () =&gt; import(&#x27;@/components/Error.vue&#x27;) &#125;); return res;&#125;function generateRouters (children, item) &#123; if (item.name) &#123; children.push(asyncRouters[item.name]); &#125; else if (item.children) &#123; item.children.forEach(e =&gt; &#123; generateRouters(children, e); &#125;); &#125;&#125; 最后，在入口文件 src/main.js 文件中导入permission.js文件： 1234567891011121314151617181920212223// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from &#x27;vue&#x27;;import App from &#x27;@/App&#x27;;import router from &#x27;@/router&#x27;;import iView from &#x27;iview&#x27;;import axios from &#x27;axios&#x27;;import store from &#x27;@/store&#x27;;import &#x27;iview/dist/styles/iview.css&#x27;import &#x27;@/permission&#x27;;// 全局注册Vue.config.productionTip = false;Vue.prototype.$axios = axios;Vue.use(iView);/* eslint-disable no-new */new Vue(&#123; el: &#x27;#app&#x27;, router, store, render: h =&gt; h(App) // 相当于 components: &#123; App &#125; vue1.0的写法&#125;); 初始化的菜单栏就定义完成了。","categories":[{"name":"教程","slug":"教程","permalink":"https://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sunyunzeng.com/tags/Vue/"}]},{"title":"Vue + Express + MySQL驾驶行为分析全栈项目(二): 服务器搭建","slug":"Vue-Express-MySQL驾驶行为分析全栈项目-二-服务器搭建","date":"2019-12-10","updated":"2022-11-05","comments":true,"path":"Vue-Express-MySQL驾驶行为分析全栈项目-二-服务器搭建/","link":"","permalink":"https://sunyunzeng.com/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E4%BA%8C-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/","excerpt":"","text":"背景自己做了一点点的小尝试：基于前馈神经网络 LSTM 的个体出行目的地预测模型，基于个体历史出行数据，模型可以实现出行目的地的实时动态预测功能。 模型其实具有实际应用功能，为了对其应用场景进行探索，拟开发一个全栈的项目，在Web客户端实现用户出行的动态预测效果，同时能够提供数据可视分析等功能。 项目地址 可视化效果 服务端结构设计结构设计如下图所示： api 文件夹存放的是网页路由查询逻辑的实现代码。py-script 存放的是python的脚本及训练好的深度学习模型。tables 是基于Sequlize的数据库表模型。config-default 定义了数据库连接信息。db.js 定义了Sequlize对象模型。func.js 定义了一些函数接口。index.js 是服务器的启动入口，定义了路口链接的运行文件。table.js 将tables文件中的表模型统一用模块接口暴露出来。 服务器搭建服务端采用了基于Node.js运行的Web应用框架——Express，首选需要安装Express框架。(前提是电脑安装了Node.js，如需安装，请参考其它网上教程) 12// 进入在server目录，执行下面命令安装Expressnpm install express 数据库采用了MySQL数据库，首先需要安装连接数据库的库函数 1npm install --save mysql 然后我们采用了Sequlize库函数方便管理SQL查询，接着安装Sequlize。 1npm install --save sequelize 我们再安装Express的中间件 body-parser 帮助我们解析JSON、Raw、文本、URL-encoded格式的请求体。 1npm install --save body-parser 然后再index.js编写我们的服务端启动入口。 1234567891011121314151617181920212223242526272829303132// node server// use ES6require(&#x27;babel-register&#x27;)(&#123; presets: [&#x27;env&#x27;]&#125;);const bodyParser = require(&#x27;body-parser&#x27;);const express = require(&#x27;express&#x27;);const app = express();app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123;extended: false&#125;));// 允许跨域访问app.all(&#x27;*&#x27;, function (req, res, next) &#123; res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); res.header(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Content-Type&#x27;); res.header(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;PUT,POST,GET,DELETE,OPTIONS&#x27;); res.header(&#x27;X-Powered-By&#x27;, &#x27; 3.2.1&#x27;); res.header(&#x27;Content-Type&#x27;, &#x27;application/json;charset=utf-8&#x27;); next();&#125;);app.get(&#x27;/&#x27;, (req, res, next) =&gt; res.send(&#x27;Express Server&#x27;));app.get(&#x27;/api&#x27;, (req, res, next) =&gt; res.send(&#x27;API Pages&#x27;));// 监听端口app.listen(3000, () =&gt; console.log(&#x27;success listen at port:3000......&#x27;)); 在server文件夹下用node.js启动程序，node index, 命令窗口会显示 ‘success listen at port:3000……’ 字样，证明服务器启动成功！这时在浏览器中输入 localhost:3000/api发现浏览器输出 API Pages。 连接数据库访问数据首先在 config-default 文件内定义数据库连接信息，如下： 12345678module.exports = &#123; host: &#x27;localhost&#x27;, user: &#x27;root&#x27;, password: &#x27;**********&#x27;, database: &#x27;your_database&#x27;, port: &#x27;3306&#x27;, dialect: &#x27;mysql&#x27;&#125;; 然后 在db.js 文件中定义Sequlize模型： 12345678910111213141516171819202122232425262728293031323334353637383940const Sequelize = require(&#x27;sequelize&#x27;);const config = require(&#x27;./config-default&#x27;);let sequelize = new Sequelize(config.database, config.user, config.password, &#123; host: config.host, dialect: config.dialect, pool: &#123; max: 5, min: 0, idle: 10000 &#125;&#125;);let defineModel = function (name, attributes) &#123; let attrs = &#123;&#125;; for (let key in attributes) &#123; let value = attributes[key]; // if the value is the mainKey if (typeof value === &#x27;object&#x27; &amp;&amp; value[&#x27;type&#x27;]) &#123; value.allowNull = value.allowNull || false; attrs[key] = value; &#125; else &#123; attrs[key] = &#123; type: value, allowNull: false &#125;; &#125; &#125; return sequelize.define(name, attrs, &#123; tableName: name, timestamps: false, freezeTableName: true &#125;);&#125;;let exp = &#123; defineModel: defineModel&#125;;module.exports = exp; Sequlize 是一个基于Node.js的对象关系映射（Object Relational Mapping，ORM）实现，通过对SQL语言的封装，实现model与SQL的映射，让开发者可以用OOP的方式操作数据库，优雅的生成安全、可维护的SQL代码。 这里我们把Sequlize模型的定义做成了一个的模块接口，只要指定Sequlize参数，就可以生成一个Sequlize模型，这样针对一个数据库中不同的表就可以生成不同的Sequlize对象。 之后根据自己的数据库表设计定义对应的表模型，如项目中 tables 文件夹内的 User1 文件。 12345678910111213141516171819202122232425const Sequelize = require(&#x27;sequelize&#x27;);const db = require(&#x27;../db&#x27;);module.exports = db.defineModel(&#x27;user_1&#x27;,&#123; id: &#123; type: Sequelize.INTEGER, primaryKey: true, allowNull: false &#125;, weekday: Sequelize.INTEGER, start_time: Sequelize.INTEGER, dis_total: Sequelize.FLOAT, sem_O: Sequelize.TEXT, sem_D: Sequelize.TEXT, destination: Sequelize.TEXT, lngs: Sequelize.TEXT, lats: Sequelize.TEXT, travel_dis: Sequelize.TEXT, spd: Sequelize.TEXT, azimuth: Sequelize.TEXT, norm_dict: Sequelize.TEXT, key_point: Sequelize.TEXT, sem_pt: Sequelize.TEXT, time: Sequelize.TEXT&#125;); 因为随着项目不断深入，数据表模型也不断增多。为了统一管理，建立 tables 模块将所有表模型统一打包，用户可按需导入。 1234567891011121314// tables.js 文件// scan all models defined in models:const fs = require(&#x27;fs&#x27;);const user1 = require(&#x27;./tables/User1&#x27;);const user2 = require(&#x27;./tables/User2&#x27;);const user3 = require(&#x27;./tables/User3&#x27;);const user4 = require(&#x27;./tables/User4&#x27;);module.exports = &#123; &#x27;user1&#x27;: user1, &#x27;user2&#x27;: user2, &#x27;user3&#x27;: user3, &#x27;user4&#x27;: user4,&#125;; 之后再 api 文件夹中定义不同路由的处理逻辑，这里主要是对数据库的访问。 例如 searchAll.js 文件是对整张表进行访问，其内容如下： 12345678910111213141516171819const table = require(&#x27;../table&#x27;);const express = require(&#x27;express&#x27;);const router = express.Router();import &#123;jsonWrite&#125; from &#x27;../func&#x27;;router.post(&#x27;/&#x27;, (req, res) =&gt; &#123; let params = req.body; if(params[&#x27;tableName&#x27;] === undefined)&#123; jsonWrite(res, undefined); return; &#125; let user = table[params.tableName]; (async () =&gt; &#123; let traj = await user.findAll(); jsonWrite(res, traj); &#125;)();&#125;);module.exports = router; 其中 jsonWrite 是我们在fun.js定义的根据请求结果返回res的函数，如下： 123456789101112const jsonWrite = function (res, ret) &#123; if (typeof ret === &#x27;undefined&#x27;) &#123; res.json(&#123; code: &#x27;1&#x27;, msg: &#x27;操作失败&#x27; &#125;); &#125; else &#123; res.json(ret); &#125;&#125;;export &#123;jsonWrite&#125;; 然后，前端发送post请求，请求体中输入待查询数据表名就可以实现整张表的查询。 这里的服务器代码不能实时更新效果，最后可以采用 nodemon 包检测服务器代码变化，实现代码的实时监测更新。 1npm install -g nodemon 然后利用 nodemon 启动 index.js入口文件，就可以实现服务器根据代码更新的自动重启， 1nodemon index","categories":[{"name":"教程","slug":"教程","permalink":"https://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sunyunzeng.com/tags/Vue/"}]},{"title":"Vue + Express + MySQL驾驶行为分析全栈项目(一): 项目初始化","slug":"Vue-Express-MySQL驾驶行为分析全栈项目-一-项目初始化","date":"2019-12-04","updated":"2022-11-05","comments":true,"path":"Vue-Express-MySQL驾驶行为分析全栈项目-一-项目初始化/","link":"","permalink":"https://sunyunzeng.com/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E4%B8%80-%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/","excerpt":"","text":"背景自己做了一点点的小尝试：基于前馈神经网络 LSTM 的个体出行目的地预测模型，基于个体历史出行数据，模型可以实现出行目的地的实时动态预测功能。 模型其实具有实际应用功能，为了对其应用场景进行探索，拟开发一个全栈的项目，在Web客户端实现用户出行的动态预测效果，同时能够提供数据可视分析等功能。 项目地址 可视化效果 动态预测效果 技术栈1. 前端界面：Vue框架 + iView组件库 + ES6标准 + Webpack资源打包工具 + Leftlet地图交互JS库 + ECharts图表可视化库。 Vue是一个渐进式的前端开发框架。它只关注图层界面(不像Angular一样提供全家桶)，通过数据的双向绑定解放开发者，让开发者可以专注于业务逻辑的代码。同时，Vue简单易上手，初学者完全不需要学习任何的新知识。基于Vue搭建前端界面的逻辑，包括界面模块层级关系、路由、操作逻辑等等。iView组件库是一个基于Vue.js的可视化组件库，提供高质量的前端组件，例如按钮、表格、任务栏等等，基于该组件库提供用户交互的入口。ES6标准是JavaScript的新一代标准，规范了类的继承，增加了模块的定义与引入、变量的解析赋值、以及 let、const命令语法等等。虽然很多是ES5的语法糖，但使得JS更加严谨与灵活。然而很多项目都是用ES6前版本实现的，以及很多浏览器并没完全支持ES6语法，为了向下兼容，采用babel编译器对ES6代码编译。Webpack一种模块化的解决方案，通过模块化提高js代码的复用性，降低项目的耦合性，提高可维护性。利用Webpack使我们的项目模块化，并进行项目的打包。Leftlet与ECharts是两个优秀的前端可视化库，利用它们，项目实现地图轨迹的可视化。 2. 服务器：Express框架 + Sequelize数据库查询管理库。 Express框架：基于Node.js的Web开发框架，可以快速地搭建一个完整功能的网站。本项目基于Express实现了路由的管理与处理、数据库的CRUD操作、深度学习模型的python脚本调用。Sequelize是一个基于Node.js的对象关系映射（Object Relational Mapping，ORM）实现，通过对SQL语言的封装，实现model与SQL的映射，让开发者可以用OOP的方式操作数据库，优雅的生成安全、可维护的SQL代码。 3. 数据库： MySQL关系型数据库。 本教程的食用准则 需要有一定的前端基础，包括JS、H5、CSS3基础知识的掌握。 对npm等包管理器有所了解。 具有一定的面向对象的开发经验，具有模块化编程思想。 对于数据库的SQL有初步掌握。 了解Vue等前端框架。 项目总框架如下图所示，项目框架是基于Vue项目框架实现，首先通过Vue-cli搭建Vue项目(此处网上教程很多，略过)，然后再框架下创建Server文件夹，用来存放服务器端代码。 其中绿色标出的部分并是我自己创建的，可以忽略。","categories":[{"name":"教程","slug":"教程","permalink":"https://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sunyunzeng.com/tags/Vue/"}]},{"title":"LeetCode 75.颜色分类","slug":"LeetCode-75-颜色分类","date":"2019-11-26","updated":"2022-11-05","comments":true,"path":"LeetCode-75-颜色分类/","link":"","permalink":"https://sunyunzeng.com/LeetCode-75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/","excerpt":"","text":"题目给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例:12输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 思路 + 代码先统计0,1,2分别出现的次数，然后按照各自数量依次赋予数组新数值。 时间复杂度: O(N^2)空间复杂度: O(1) 1234567891011121314151617181920class Solution &#123; public void sortColors(int[] nums) &#123; if(nums==null || nums.length==0) return; int[] counts = new int[3]; for(int i=0; i&lt;nums.length; i++)&#123; counts[nums[i]]++; &#125; for(int i=0;i&lt;nums.length; i++)&#123; if(counts[0]&gt;0)&#123; nums[i] = 0; counts[0]--; &#125;else if(counts[1]&gt;0)&#123; nums[i] = 1; counts[1]--; &#125;else&#123; nums[i] = 2; &#125; &#125; &#125;&#125; 或者三指针方法，左指针负责交换0， 右指针负责交换2，中间指针负责扫描。时间复杂度: O(N)空间复杂度: O(1) 123456789101112131415161718class Solution: def sortColors(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; p0 = cur = 0 p1 = len(nums) - 1 while cur &lt;= p1: if nums[cur] == 0: nums[cur], nums[p0] = nums[p0], nums[cur] # 这里左边遍历当前位置加一，因为左边的确定全部扫描过，而右边交换过的未进行判断 cur += 1 p0 += 1 elif nums[cur] == 1: cur +=1 else: nums[cur], nums[p1] = nums[p1], nums[cur] p1 -=1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sort-colors著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"文档对象模型DOM","slug":"文档对象模型DOM","date":"2019-11-22","updated":"2022-11-05","comments":true,"path":"文档对象模型DOM/","link":"","permalink":"https://sunyunzeng.com/%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8BDOM/","excerpt":"","text":"DOM是什么？DOM，即Document Object Model，文档对象模型，用于操作HTML的编程接口。 它描绘了一个层次化的节点树，允许编程人员进行节点的添加、修改与删除等操作。 DOM节点DOM 1级定义了一个Node接口，由DOM中所有的节点实现。 一共有12中节点类型，其中包括Document、Element节点类型等，可通过node.nodeType查询每个节点的类型，例如，Element的节点类型返回数值为1。 每一个节点都有childNodes、parentNode、previousSibling、nextSibling、firstChild、lastChild等节点查询方法。 还有appendChild、insertBefore、replaceChild、removeChild、cloneNode等操作节点的方法。 DocumentDocument节点表示整个文档。浏览器中的document是一个全局对象，表示HTML页面，是HTMLDocument对象的实例。 document.documentElement：快速取得对html的引用。document对象只有一个子节点，也就是&lt; html &gt;对象，没必要使用节点操作方法。document的title、URL、domain、referrer等方法可以访问网页的标题、URL地址、域名及连接当前URL的前一URL。document.getElementById()：获取指定id的元素。ducument.getElementsByTagName()：获取指定标签名的元素，例如var img = ducument.getElementsByTagName(&quot;img&quot;)，返回一个HTMLCollection类型的实例，其中img.namedItem(&quot;imgName&quot;)可以返回执行name的元素。ducument.getElementsByName()：获取指定name的元素集合。ducument.write()与ducument.writeln()写入文档。getElementsByClassName()：获取同一类的元素列表，返回NodeList。document.activeElement()：获得当前焦点所在的元素，例如页面加载中，焦点所在的元素是document.body，之后变成null。document.hasFocus()：判断当前文档是否获取了焦点。document.readyState：”loading”正在加载文档，”complete”加载完毕。document.compatMode：”CSS1Compat”渲染模式为标准，”BackCompat”渲染模式为混杂模式。document.charset：查看与设置文档字符集，默认”UTF-16”。 ElementElement类型表现为HTML元素，每个HMTML元素都存在id、title、dir、className、lang属性。 getAttribute() setAttribute()和 removeAttribute()操作属性值。 123456var div = document.getElementById(&quot;myDiv&quot;); alert(div.getAttribute(&quot;id&quot;)); //&quot;myDiv&quot;div.setAttribute(&quot;id&quot;, &quot;someOtherId&quot;);div.removeAttribute(&quot;class&quot;); attributes属性，是表示一个元素属性的动态的集合，可通过nodeValue获取标签值。 1var id = div.attributes.getNamedItem(&quot;id&quot;).nodeValue; document.createElement()创建元素。1var div = document.createElement(&quot;div&quot;); Text类型Text，文本节点，用于表示不含HTML标签的纯文本。包含在element类型中。  appendData(text)：将 text 添加到节点的末尾。 deleteData(offset, count)：从 offset 指定的位置开始删除 count 个字符。 insertData(offset, text)：在 offset 指定的位置插入 text。 replaceData(offset, count, text)：用 text 替换从 offset 指定的位置开始到 offset+ count 为止处的文本。 splitText(offset)：从 offset 指定的位置将当前文本节点分成两个文本节点。 substringData(offset, count)：提取从 offset 指定的位置开始到 offset+count 为止处的字符串。 123456789&lt;!-- 没有内容，也就没有文本节点 --&gt; &lt;div&gt;&lt;/div&gt;&lt;!-- 有空格，因而有一个文本节点 --&gt; &lt;div&gt; &lt;/div&gt;&lt;!-- 有内容，因而有一个文本节点 --&gt; &lt;div&gt;Hello World!&lt;/div&gt;// 取得div的文本节点，并修改其值div.firstChild.nodeValue = &quot;Some other message&quot;; document.createTextNode()创建新文本节点。 12345var element = document.createElement(&quot;div&quot;); element.className = &quot;message&quot;;var textNode = document.createTextNode(&quot;Hello world!&quot;); element.appendChild(textNode);document.body.appendChild(element); DOM操作技术动态脚本可以通过doucument.createElement()方法实现动态script代码的引入或创建。1234var script = document.createElement(&quot;javascript&quot;);script.type = &quot;text/javascript&quot;;script.src = &quot;client.js&quot;;document.body.appendChild(script); 或者可以通过自定义代码的方式调用 1234567891011function loadScriptString(code)&#123; var script = document.createElement(&quot;script&quot;); script.type = &quot;text javascript&quot;; try &#123; script.appendChild(document.createTextNode(code)); &#125; catch (ex)&#123; script.text = code; &#125; document.body.appendChild(script); &#125;loadScriptString(&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;); 动态样式CSS样式可以通过style属性或元素嵌入样式，或者可以通过&lt; link &gt;引入CSS外部文件。 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;index.css&quot;&gt; 与动态script一样的原理，可以通过实现样式的动态添加。 123456var link = document.createElement(&quot;link&quot;); link.rel = &quot;stylesheet&quot;; link.type = &quot;text/css&quot;; link.href = &quot;style.css&quot;;var head = document.getElementsByTagName(&quot;head&quot;)[0]; head.appendChild(link); 或者可以通过自定义代码的方式调用 123456789var style = document.createElement(&quot;style&quot;); style.type = &quot;text/css&quot;; try&#123; style.appendChild(document.createTextNode(&quot;body&#123;background-color:red&#125;&quot;)); &#125; catch (ex)&#123; style.styleSheet.cssText = &quot;body&#123;background-color:red&#125;&quot;; &#125;var head = document.getElementsByTagName(&quot;head&quot;)[0];head.appendChild(style); DOM扩展选择符 querySelector()与querySelectorAll()方法。 querySelector()12345678//取得 body 元素var body = document.querySelector(&quot;body&quot;); //取得 ID 为&quot;myDiv&quot;的元素var myDiv = document.querySelector(&quot;#myDiv&quot;); //取得类为&quot;selected&quot;的第一个元素var selected = document.querySelector(&quot;.selected&quot;); //取得类为&quot;button&quot;的第一个图像元素var img = document.body.querySelector(&quot;img.button&quot;); querySelectorAll()123456//取得某&lt;div&gt;中的所有&lt;em&gt;元素（类似于 getElementsByTagName(&quot;em&quot;)） var ems = document.getElementById(&quot;myDiv&quot;).querySelectorAll(&quot;em&quot;); //取得类为&quot;selected&quot;的所有元素var selecteds = document.querySelectorAll(&quot;.selected&quot;); //取得所有&lt;p&gt;元素中的所有&lt;strong&gt;元素var strongs = document.querySelectorAll(&quot;p strong&quot;);","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sunyunzeng.com/tags/JavaScript/"}]},{"title":"JavaScript中的函数表达式","slug":"JavaScript中的函数表达式","date":"2019-11-19","updated":"2022-11-05","comments":true,"path":"JavaScript中的函数表达式/","link":"","permalink":"https://sunyunzeng.com/JavaScript%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"函数表达式函数表达式是定义函数的一种方式，如下： 12345678// 函数表达式var add = function(v1, v2)&#123; return v1 + v2;&#125;// 函数声明function add(v1, v2) &#123; return v1 + v2;&#125; 函数表达式可以创建一个匿名函数，它与JS的很多特性与模式有关，包括闭包、私有变量创建等等。 闭包闭包指一个函数，该函数有权访问其他函数作用域中的变量。 123456789101112131415161718192021function createComparisonFunction(propertyName)&#123; // 闭包 return function(object1, object2)&#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if(value1 &lt; value2)&#123; return -1; &#125;else if(value1 &gt; value2)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;&#125;var compare = createComparisonFunction(&quot;name&quot;);console.log(compare(&#123;name: &quot;syz&quot;&#125;, &#123;name: &quot;xj&quot;&#125;));// 释放内存compare = null; 放回的匿名函数引用了外包函数createComparisonFunction()的变量propertyName。 需要注意的是，在createComparisonFunction()执行完毕产生比较函数compare()时，其作用域链被销毁，但是其活动对象(此处指propertyName)仍被compare()函数引用，并没有销毁。 闭包实现的具体原理是： 首先，每一个执行环境都有一个变量对象表示。全局执行环境的变量对象始终存在，而函数内部的变量对象在执行过程中创建，执行完毕销毁。createComparisonFunction()函数执行过程，首先创建一个包含全局变量对象的作用域链，并被内部属性[[Scope]]引用，其中的参数、变量与方法都作为活动对象(该函数的变量对象)被推入作用域链的顶端，构成该函数的作用域链。作用域链提供一个变量对象的引用链，通过它可以访问链上的变量。 然后，内部函数的创建，首先创建一个包含全局变量对象的作用域链。如果内部函数引用了外部函数的变量，即闭包，那么内部函数的作用域链会添加外部函数的活动对象，最后再将本函数的活动对象推入作用域链顶端。 最后，外部函数createComparisonFunction()执行完毕，本来所有作用域链与活动对象全部销毁，但由于内部函数的引用，导致只销毁作用域链，而活动对象继续被内部函数引用，直到内部函数被销毁。 匿名函数中的this对象要熟知函数的this对象指向其对应的执行环境。 12345678910111213141516171819202122232425262728// 例子1var object = &#123; name: &quot;this indicator&quot;, getName: function()&#123; return function()&#123; return this.name; &#125; &#125;&#125;/* 因为调用函数getName()返回一个内部函数，而此内部函数的执行环境为全局执行环境,尽管其作用域链存在外部函数的this对象，但是作用域链的顶端this对象指向全局执行环境,所以返回 windows*/console.log(object.getName()()); // windows// 例子2var object = &#123; name: &quot;this indicator&quot;, getName: function()&#123; var that = this; return function()&#123; return that.name; &#125; &#125;&#125;// 指定匿名函数的this对象就是指向外部函数的this对象，因此返回 this indicatorconsole.log(object.getName()()); // this indicator 模拟块级作用域由于JS不存在块级作用域，因此if、for语句中声明的变量存在于全局变量中，会导致内存的溢出及命名的冲突。 可以通过匿名函数的方式模拟模拟块级作用域，将生命的变量随匿名函数的生命周期绑定。 12345(function() &#123; for(var i = 0; i &lt;10; i++)&#123; console.log(i); &#125;&#125;)(); // 表示立即执行该函数，如果匿名函数没有被()包裹，则报错。 自定义类型的私有变量JS的所有属性没有私有概念。但是函数内的变量是局部的，外部不可访问的。可在构造函数或私有作用域中声明私有变量与方法，在匿名函数中引用外部函数的私有变量，并提供可访问这些方法的特权函数，实现自定义类型的私有变量。 构造函数中创建私有变量123456789101112function Person()&#123; // 私有变量与方法 var name = &quot;syz&quot;; function getGender()&#123; return &quot;man&quot;; &#125; // 特权方法获取私有变量 this.getInfo = function()&#123; name = &quot;xj&quot;; return getGender(); &#125;&#125; 还可以通过匿名函数实现私有变量的不可修改与直接读取的设定。 12345678910function Person(name)&#123; // 保护私有变量，此时Person构造函数的变量name通过闭包访问，形成了每个成员的保护变量 this.getName = function()&#123; return name; &#125; this.setName = function(value)&#123; name = value; &#125;&#125; 静态私有变量采用构造函数声明私有变量对每个实例都是唯一的，会造成代码的重复。 对属于类的公共的属性与方法，可以通过静态私有变量的方式私有化。 12345678910111213141516171819202122232425// 通过私有作用域实现私有变量的保存(function()&#123; // 私有变量 var name = &quot;&quot;; // 全局构造函数 Person = function(value)&#123; name = value; &#125; // 通过原型实现静态私有变量 Person.prototype.getName = function()&#123; return name; &#125; Person.prototype.setName = function(value)&#123; name = value; &#125;&#125;)();var person1 = new Person(&quot;syz&quot;);console.log(person1.getName()); // syzvar person2 = new Person(&quot;xj&quot;);console.log(person1.getName()); // xjconsole.log(person2.getName()); // xj 单例的私有变量JS中的单例很简单。123var singleton = &#123; description: &quot;I am a singleton&quot;;&#125; 模块模式单例可以通过模块模式的方式实现变量的私有化。基本思想是通过将私有变量与方法保存在外部匿名函数的活动对象中，然后返回一个具有特权访问函数的匿名对象。 123456789101112131415161718var application = function() &#123; // 私有变量 var components = new Array(); // 初始化 components.push(new BaseComponent()); // 放回单例，单例内通过特权方法访问私有变量 return &#123; getComponentCount : function()&#123; return components.length; &#125;, registerComponent : function(component)&#123; if (typeof component == &quot;object&quot;)&#123; components.push(component); &#125; &#125; &#125;&#125;(); // 立即执行函数 增强模块模式如果想创建指定类型的单例，并为其添加私有变量及增加属性与方法，可采用增强模块模式。基本思想与模块模式差不多，只不多不返回匿名对象，而是先创建指定类型的单例对象，然后为该对象添加特权访问函数、增强属性与方法，然后返回。 123456789101112131415161718var application = function()&#123; //私有变量和函数 var components = new Array(); //初始化 components.push(new BaseComponent()); //创建 application 的一个局部副本 var app = new BaseComponent(); //公共接口 app.getComponentCount = function()&#123; return components.length; &#125;; app.registerComponent = function(component)&#123; if (typeof component == &quot;object&quot;)&#123; components.push(component); &#125; &#125;; //返回这个副本 return app;&#125;();","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sunyunzeng.com/tags/JavaScript/"}]},{"title":"JavaScript中的继承","slug":"JavaScript中的继承","date":"2019-11-18","updated":"2022-11-05","comments":true,"path":"JavaScript中的继承/","link":"","permalink":"https://sunyunzeng.com/JavaScript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/","excerpt":"","text":"浅述JS继承JS作为一门不是很严谨的OO语言，由于其函数没有签名，因此不能实现签名继承的接口形式，却可实现属性与方法的完全继承。 JS的继承方式有六种：原型链继承、构造函数继承、组合继承、原型式继承、寄生式继承及寄生组合继承。 原型链继承在JS对象一章讲到了构造函数的原型对象，如果一个构造函数的原型对象是另一个构造函数的实例，那么通过该构造函数创建的实例就继承了原型对象对应构造函数的全部属性与方法。 123456789101112131415161718192021222324function SuperType(name)&#123; this.name= name; this.color = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];&#125;SuperType.prototype.sayHello = function()&#123; console.log(&quot;Hello &quot; + this.name);&#125;function SubType(name,age)&#123; this.name=name; this.age=age;&#125;// 原型链继承SubType.prototype = new SuperType();var sub = new SubType(&quot;sg&quot;, 26);sub.sayHello(); // Hello sgvar sub1 = new SubType(&quot;syz&quot;, 24);var sub2 = new SubType(&quot;xj&quot;, 22);sub1.color.push(&quot;black&quot;);console.log(sub2.color); // [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;black&#x27; ] 不足：1. 对于父类的引用类型，在子类中是共享的，因为子类原型对象指向同一父类实例，无法实现与子类的单独绑定。 2. 没有办法在不影响子类的情况下为父类构造函数赋予初始值。 构造函数继承在子类构造函数中，调用父类构造函数方法，可以实现父类属性（尤其是引用类型）与子类的单独绑定。 1234567891011121314151617181920212223242526function SuperType(name)&#123; this.name= name; this.color = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];&#125;SuperType.prototype.sayHello = function()&#123; console.log(&quot;Hello &quot; + this.name);&#125;// 构造函数继承function SubType(name,age)&#123; // 在SubType执行环境作用域执行父类构造函数的初始化函数 SuperType.call(this, name); this.age=age;&#125;var sub = new SubType(&quot;sg&quot;, 26);// 原型对象是通过内部指针访问，通过执行函数的方式无法访问sub.sayHello() //TypeError: subType.sayHello is not a functionvar sub1 = new SubType(&quot;syz&quot;, 24);var sub2 = new SubType(&quot;xj&quot;, 22);sub1.color.push(&quot;black&quot;);sub2.color.push(&quot;yellow&quot;);console.log(sub1.color); //[ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;black&#x27; ]console.log(sub2.color); //[ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;yellow&#x27; ] 不足：无法复用父类原型对象中公共的属性与方法。 组合继承组合继承就是综合原型链与构造函数的继承方式，结合二者各自的优点，可以继承父类构造函数与原型对象中的属性与方法，且可以实现父类引用类型数据与子类的单独绑定。 12345678910111213141516171819202122function SuperType(name)&#123; this.name= name; this.color = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];&#125;SuperType.prototype.sayHello = function()&#123; console.log(&quot;Hello &quot; + this.name);&#125;function SubType(name,age)&#123; // 在SubType执行环境作用域执行父类构造函数的初始化函数 SuperType.call(this, name); // 第二次调用 this.age=age;&#125;SubType.prototype = new SuperType(); //第一次调用// 防止指向父类的构造器SubType.prototype.constructor = SubType;var sub = new SubType(&quot;sg&quot;, 26);// 原型对象是通过内部指针访问，通过执行函数的方式无法访问sub.sayHello() // Hello sg 不足： 重复调用了两次的父类的构造函数，导致子类原型对象中存储了重复的无用的数据。 原型式继承如果只想使得某些类表现得像某个类，可以采用原型式继承。即使这些类的原型对象指向同一个对象。1234567891011121314151617181920212223var Person = &#123; name: &quot;syz&quot;, friends: [&quot;mzp&quot;, &quot;wjh&quot;]&#125;// 原型继承函数function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F;&#125;var person1 = object(Person);person1.name = &quot;John&quot;;person1.friend.push(&quot;lili&quot;);var person2 = object(Person);person1.name = &quot;gad&quot;;person1.friend.push(&quot;uzi&quot;);console.log(person1.name); // Johnconsole.log(person2.name); // gadconsole.log(person1.friends); // [ &#x27;mzp&#x27;, &#x27;wjh&#x27;, &#x27;lili&#x27;, &#x27;uzi&#x27; ]console.log(person2.friends); // [ &#x27;mzp&#x27;, &#x27;wjh&#x27;, &#x27;lili&#x27;, &#x27;uzi&#x27; ] ECMAScript5规范了原型式继承的方式，即采用Object.create()方法，参数数即要继承的包含共用的属性与方法的对象，第二个参数为可选参数Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。 Object.create()作用与object()方法相同。 1234567891011var Person = &#123; name: &quot;syz&quot;, friends: [&quot;mzp&quot;, &quot;wjh&quot;]&#125;var person1 = Object.create(Person, &#123; name: &#123; value: &quot;xj&quot; &#125;&#125;);console.log(person1.name); // xjconsole.log(person1.friends); // [ &#x27;mzp&#x27;, &#x27;wjh&#x27; ] 寄生继承寄生继承组合了原型式继承与工厂方法，或者是装饰器模式，可以对原型示例添加装饰方法。 1234567891011121314151617181920var Person = &#123; name: &quot;syz&quot;, friends: [&quot;mzp&quot;, &quot;wjh&quot;]&#125;function createPerson(_name_)&#123; var person = Object.create(Person, &#123; name: &#123; value: _name_ &#125; &#125;); person.sayHi = function()&#123; console.log(&quot;Hi&quot;); &#125; return person;&#125;var person = createPerson(&quot;xj&quot;);person.sayHi(); // Hiconsole.log(person.name); // xj 寄生组合继承是JS继承的最优解，通过寄生继承减少了组合继承中多余的父类构造函数调用产生的子类原型对象属性重复的问题。 对于子类的原型对象，采用寄生继承方式继承自父类的原型对象。1234567891011121314151617181920212223242526function SuperType(name)&#123; this.name= name; this.color = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];&#125;SuperType.prototype.sayHello = function()&#123; console.log(&quot;Hello &quot; + this.name);&#125;function inheritPrototype(subType, superType)&#123; subType.prototype = Object.create(superType.prototype); subType.prototype.constructor = subType;&#125;function SubType(name,age)&#123; SuperType.call(this,name); this.age=age;&#125;inheritPrototype(SubType,SubType);var sub = new SubType(&quot;syz&quot;, 12);console.log(sub.name); // syzconsole.log(sub.age); // 12console.log(sub.color); // [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27; ]sub.sayHello(); // Hello syz 完美！","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sunyunzeng.com/tags/JavaScript/"}]},{"title":"JavaScript中的对象","slug":"JavaScript中的对象","date":"2019-11-16","updated":"2022-11-05","comments":true,"path":"JavaScript中的对象/","link":"","permalink":"https://sunyunzeng.com/JavaScript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"对象的概念JS 中的对象其实是无序属性的集合，属性包括基本数据、函数与对象，每个属性有属性名，属性名与属性值以键值对的形式保存在对象内部。12345678// JS中的一个对象var person = &#123; name: &quot;syz&quot;, job: &quot;Software Engineer&quot;, sayHello: function()&#123; console.log(&quot;Hello&quot;); &#125; &#125; 对象的属性为了JavaScript引擎可以操作对象中的属性，每个属性定义了对应的两种属性类型： 1. 数据属性。 2. 访问器属性。 数据属性是对一个对象属性值的操作说明，共有四类说明：configurable、enumerable、writable及value。 可通过Object.defineProperty实现不同属性的值操作限定，接收三个参数，第一个是操作对象、第二个是操作对象的属性第三个是对该属性的操作限定。 12345678910111213141516171819202122232425262728293031var person = &#123; name: &quot;syz&quot;, job: &quot;Software Engineer&quot;, age: 24&#125;Object.defineProperty(person, &quot;age&quot;, &#123; /* 默认true。 设置为false，则该属性不能被删除，configurable、enumerable、writable(true还可设定为false)不能再设定； 该属性不能在通过Object.defineProperty()方法修改为访问器属性。 */ configurable: true, /* 默认true。 设置为false，则不能通过for-each方式遍历该属性。 for(var item in person)&#123; console.log(item) // 不会输出person的age属性 &#125; */ enumerable: true, /*默认true。 设置为false，则属性值为可读的，严格模式强行修改会报错，一般模式修改无效。 */ writable: true, // 设置该属性的值 value: 25&#125;); 访问器属性访问器属性是对访问对象属性值的操作的说明，共四类：configurable、enumerable、get及set。 可通过Object.defineProperty实现不同属性的值操作限定，接收三个参数，第一个是操作对象、第二个是操作对象的属性第三个是对该属性的操作限定。 12345678910111213141516171819202122232425262728293031323334353637383940var person = &#123; name: &quot;syz&quot;, job: &quot;Software Engineer&quot;, _age: 24&#125;Object.defineProperty(person, &quot;age&quot;, &#123; /* 默认为true。 设置为false，则该属性不能被删除，该属性不能在通过Object.defineProperty()方法修改为数据属性。 */ configurable: true, /* 默认为true。 设置为false，则不能通过for-each方式遍历该属性。 for(var item in person)&#123; console.log(item) // 不会输出person的age属性 &#125; */ enumerable: true, /*设置读取该属性时的返回值。 注意_age前面有 _ 下划线，表示该属性值只能通过对象的方法访问到，也就是get()方法，如果没有定义相应的方法， 采用person._age访问会返回undefined。 如果_age前面不加下划线，而又通过get()函数访问this.age的话，会导致函数调用栈溢出. 因为person.age -&gt; get.call(person) -&gt;this.age -&gt; person.age -&gt; ... */ get: function()&#123; return this._age; &#125;, // 改属性赋值时的操作 set: function(value)&#123; this._age = value; if(value &gt; 50)&#123; this.job = &quot;rubbish&quot;; &#125; &#125;&#125;); 数据属性其它知识 通过Object.defineProperties()方法一次性为对象的多个属性设置属性类型。 1234567891011121314151617181920212223var book = &#123;&#125;;Object.defineProperies(book, &#123; name: &#123; value: &quot;machine learning&quot; &#125;, _year: &#123; value: 2019 &#125;, edition&#123; value: 1 &#125; year: &#123; get: function() &#123; return this._year; &#125;, set: function(value) &#123; if(value&gt;2019)&#123; this._year = value; this.edition += value - this._year; &#125; &#125; &#125;&#125;) 通过Object.getOwnPropertyDescriptor()方法获得指定对象指定属性的属性类型说明对象。第一个参数接收查询对象，第二个参数接收对应对象的查询属性的字符串表示。该方法只能获取实例对象的属性类型描述对象，对于原型对象，需要调用Person.prototype。 12345var descriptor = Object.getOwnPropertyDescriptor(book, &quot;year&quot;);console.log(descriptor.enumrable); //如果是访问器属性，则返回undefinedconsole.log(descriptor.value);console.log(descriptor.writable); //如果是访问器属性，则返回undefinedconsole.log(descriptor.configurable); 创建对象JavaScript中自定义的对象又是怎么创建来的呢？从前面知识，我们了解到，可以通过构造函数或者对象字面量的形式创建，如下：123456789// 默认的Object构造函数var person = new Object(&#123; name : &quot;syz&quot;&#125;);// 对象字面量形式var person = &#123; name : &quot;syz&quot;&#125; 首先，通过对象字面量形式创建的对象只能是Obejct类型实例，无法满足特定实例的要求。 然后，再看通过构造函数创建的方式。 构造函数构造函数其实就是函数的一种，任何函数都可以是构造函数，只要在函数前面使用 new 关键字，就使该函数成为了构造函数。 123456789// 构造函数通常大写function Person(name, age) &#123; this.age = age; this.name = name; this.sayHello = function ()&#123; console.log(&quot;Hello&quot;); &#125;&#125;var person = new Person(&quot;syz&quot;, 12); 前面提到，函数其实也是一种Funcation类型的实例对象，加入了new关键字后，函数执行四个步骤: 创建一个新对象。 将构造函数的作用域赋给对象，即this的主体换为新对象。 执行构造函数的语句，对新对象执行初始化操作。 返回该对象。 构造函数也可以当做普通函数使用，如下：12345// 此时函数的作用域是全局执行环境，因此也就是给windows对象赋予了name及age属性Person(&quot;syz&quot;, 12);//通过调用call()方法在指定作用域执行,相当于为person对象赋予了姓名与年龄属性var person = &#123;&#125;;Person.call(person, &quot;syz&quot;, 12); 通过构造函数创建的对象实例可以通过关键字 instanceof来判断其是否为某自定义引用类型的对象。1person instanceof Person; // =&gt; true 原型对象然而，仅通过构造函数创建对象存在弊端。即一些属于类公共部分的属性（尤其是引用类型值）仍需要在每个实例创建过程中重新创建一份副本。1234567891011function Person(name) &#123; this.name = name; this.sayHello = function ()&#123; console.log(&quot;Hello&quot;); &#125;&#125;var person1 = new Person(&quot;syz&quot;);var person2 = new Person(&quot;xj&quot;);console.log(person1.sayHello===person2.sayHello); // =&gt;false 因为 sayHello() 方法是 Function 类型的实例，尽管其作用在每个对象实例中是相同的，但是在每个对象创建过程中，每个sayHello() 都重新创建一份副本，导致内存资源的浪费。 JS通过构造函数的原型对象来解决。 原型对象其实是构造函数的属性之一，可以通过 Person.prototype 访问 Person 构造函数原型对象，其中保存了 Person 类共享的属性与方法。 原型对象在每个函数的创建过程中自动生成，即每个函数自动生成一个 prototype 属性，指向一个原型对象，该原型对象自动生成一个 constructor属性，指向构造函数，其属性类型是不可枚举的。 1234567891011121314151617181920212223242526272829303132333435function Person()&#123;&#125;// 为原型兑现赋值Person.prototype.name = &quot;Nicholas&quot;; Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;; Person.prototype.sayName = function()&#123; alert(this.name);&#125;;/* 还可以用简便的方法为原型对象赋值Person.prototype = &#123; name: &quot;Nicholas&quot;, age: 29, job: &quot;Software Engineer&quot;, sayName: function()&#123; alert(this.name); &#125; /*由于此时完全重写了系统自动生成的的原型对象，所以constroctor属性不再指向Person，而是Object 此时再用person.constroctor == Person 就返回false,需要重新定义constroctor的指向 */ // constructor: Person, 但是此时的constructor属性时可枚举的，可用下列语句修改属性类型 Obeject.defineProperty(Person.prototype, &quot;constroctor&quot;&#123; enumerable: false, value: Person &#125;);&#125;;var person1 = new Person(); var person2 = new Person(); person1.sayName(); //&quot;Nicholas&quot;var person2 = new Person(); person2.sayName(); //&quot;Nicholas&quot; alert(person1.sayName == person2.sayName); //true 各对象之间的关系 在一个实例中访问某个属性，首先在实例本身搜索，如果没找到，再通过内部属性[[Property]]找到指向的原型对象，再在其内部寻找。 如果实例内部定义了与原型对象中重名的属性，则读取到该属性即停止搜索。 12345678910function Person()&#123;&#125;Person.prototype.name = &quot;Nicholas&quot;; Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;; Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person = new Person();person.height = 30; 相关函数 isPrototypeOf(): 判断某个原型对象是否是某个实例对应的原型对象1Person.prototype.isPrototypeOf(person); // =&gt; ture Object.getPrototypeOf(): 获得某个实例的原型对象1var proto = Object.getPrototypeOf(person); hasOwnProperty(): 判断某个属性是来自实例还是原型对象，来自实例返回true1console.log(persom.hasOwnProperty(&quot;height&quot;)); //=&gt; true in: 判断某个实例是否包含某个属性，无论是位于实例本身还是原型对象12console.log(&quot;job&quot; in person); //=&gt; trueconsole.log(&quot;height&quot; in person); // =&gt; true for in: 遍历所有可枚举属性，无论是位于实例本身还是原型对象123for(var item in person)&#123; console.log(item); // name,height,age,job,sayName&#125; Object.keys(): 以字符串数组形式返回实例本身可枚举的属性12console.log(Object.keys(Person.prototype)); //[ &#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;, &#x27;sayName&#x27; ]console.log(Object.keys(person)); //[ &#x27;name&#x27;, &#x27;height&#x27; ] getOwnPropertyNames(): 以字符串数组形式返回实例本身所有的属性（包括不可枚举）12console.log(Object.getOwnPropertyNames(Person.prototype)); //[ &#x27;constructor&#x27;, &#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;, &#x27;sayName&#x27; ]console.log(Object.getOwnPropertyNames(person)); //[ &#x27;name&#x27;, &#x27;height&#x27; ] 混合模式创建对象通过原型模式可以设置共享的对象类型，通过构造器模式可以为对象的创建赋予初始值，结合二者的混合模式是最常见的创建对象的方法。 1234567891011121314151617181920212223function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype = &#123; constroctor: Person, sex: &quot;man&quot;&#125;if(typeof Person.sayName != &quot;function&quot;)&#123; Person.prototype.sayName = function()&#123; console.log(&quot;Hello, my name is &quot; + this.name); &#125;;&#125;person1 = new Person(&quot;syz&quot;, 24);person2 = new Person(&quot;xj&quot;, 23);console.log(person1.name); // &quot;syz&quot;console.log(person2.name); // &quot;xj&quot;console.log(person1.sex); // &quot;man&quot;console.log(person2.sex); // &quot;man&quot;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sunyunzeng.com/tags/JavaScript/"}]},{"title":"JavaScript基础知识点","slug":"JavaScript基础知识点","date":"2019-11-13","updated":"2022-11-05","comments":true,"path":"JavaScript基础知识点/","link":"","permalink":"https://sunyunzeng.com/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"为啥“又”学JavaScript？那年头发还多，正是大四上学期。提前联系了导师，由于项目原因，第一次接触到JS。 然后，看了两周左右的入门书籍，入了前端的坑。 结果，自己觉得前端没啥技术含量，跑回去学后端开发，也就是Java开发的一套东西。 看到数据库、并行化编程部分，心态崩了。 自己还是喜欢前端开发。 又滚回来重新学习。 看到网页在自己面前展示，真TM有意思。 JavaScript这门语言JavaScript很有趣，比Java有趣多了。 Java好比是一个严谨的大叔，什么都严格要求，准确但无趣。 JavaScript好比是一个热血青年，喜欢打篮球，生动有趣。 不过JavaScript也不老了，1995年诞生。当时叫这个名字还是蹭Java的热度。。。 JavaScript由三剑客组成：ECMAScript、DOM、BOM。 ECMAScriptECMAScript是ECMA-262标准定义的一种语言规范，规定了一门语言的5类部分：类型、语句、关键字、保留字、操作符及对象。 ECMAScript没有定义任何语言运行的环境要求，只是说明，你按照我这个规范，可以实现一种编程语言。不像Java，规定了虚拟机作为它的运行环境。 浏览器可以作为ECMAScript语言的运行环境，当然Node、Abode Flash也都是。 JavaScript就是一种实现了该标准的语言，同样的Adobe ActionScript也实现了ECMAScript。 因此，JavaScript就是按照 ECMAScript 规定的脚手架搭建起来的房子，所以掌握JavaScript必须要掌握ECMAScript规范。 最新的ECMAScript标准是2015年6月颁布的《ECMAScript2015标准》简称ES2015，由于比前面版本有了重大改进，因此又被称为ES6.0。每年6月份ES标准委员会会颁布最新的ES标准，而2016年颁布的《ECMAScript2016标准》相比较2015标准改进不大，因此又被称为ES6.1. 具体ES6标准的讲解后面博客中再讲。 DOMDOM, Document Object Model, 文档对象模型，这里指针对HTML的可编程接口。将网页通过层次性节点来表示，如下所示： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 其实DOM可针对任何XML类语言进行实现，包括 SVG（Scalable Vector Graphic，可伸缩矢量图）1.0等。 BOMBOM, Browser Object Model, 浏览器对象模型，使开发人员可以控制浏览器网页页面之外的部分。 比如：弹出新浏览器、移动缩放与关闭浏览器窗口、提供用户显示器分辨率详细信息的screen对象、对cookies支持等。 总结 ECMAScript 标准为JavaScript提供核心语言功能； DOM 提供访问与操作网页内容的方法和接口； BOM 提供操作浏览器的方法和接口。 JS知识点在H5中使用JS 引入位置：JS的\\标签放在\\标签内最下方，使浏览器先加载页面再加载JS代码，保证界面流畅。 嵌入外部文件：尽量不要再 HTML 文件中嵌入JS代码，而是引入JS外部文件的方式。提高可维护性与缓存效率。 严格模式：在整个脚本顶部或者函数内部上方加上语句“use strict”。 1234function()&#123; &quot;use strict&quot;; //函数体，在函数内部执行严格模式&#125; 数据类型 数据类型：JS一共6中数据类型，5中基本数据类型：String、Number、Boolean、Null、Undefined 及一种复杂类型 Object。基本数据类型占据固定的内存大小，存储在栈内存中。引用类型的变量名保存在栈空间中。 JS的变量只是转递数据的载体，其本身是松散类型，一个变量即可存储字符串又可存储数组。此时需要用typeof操作符检查数据类型。 简单数据类型变量与值都存储在栈内存(stack)中。 浏览器从电脑内存中开辟一块栈内存，再分配一个主线程自上而下执行程序。 栈内存分为变量存储空间与值存储空间。 赋值语句将两个空间对应的变量与值关联起来。 1234567// let a = 12的赋值过程：// 1. 首先新建变量a(如没有)，将其存入变量存储空间// 2. 再新建数值12(如没有)，将其存入值存储空间。// 3. 再执行赋值操作 = ，将变量a与值12关联。 let a = 12; let b = a; b = 13; 引用数据类型的变量名存储在栈内存中，值存储在堆内存(heap)中。 浏览器从电脑内存中开辟一块栈内存，再分配一个主线程自上而下执行程序。 由于引用数据类型的值非常复杂，因此开辟一块堆内存，每块内存对应一个唯一的内存地址。 赋值操作 = 将变量与堆内存的内存地址关联起来。123456let c = &#123; name: &quot;syz&quot;, age: 24 &#125;;let d = c;d.age = 256; 基本数据类型 String类型 不同于Java,它是简单数据类型，但相同点是它是不可变的。 任何数据都可转为String类型。通过调用对象的toString方法或者对于Null及Undefined直接返回”null”与”undefined”。 通过 a.toString()转换。 通过String(a, n)转换。n为可选项，当a为数值类型时，n可以指定转换的进制数。 Number类型 分为浮点值和整型值。浮点值小数点后面必须有数字，否则认为值整型。 浮点值最高精度是17位，因此不要测试某个具体的浮点值，例如0.3==0.1+0.2。 Number最大值为Number.MAX_VALUE，最小值是Number.MIN_VALUE，超出范围则根据正负情况得到正负Infinity。 用isFinite()函数判断一个数是不是无穷。 0 / 0 的结果是NaN。它不与任何数相等，包括自身。 可用isNaN()判断一个数据是不是数。 parseInt(a, n) 与 parseFloat()可以解析数值。如果字符串前面有数值的话也能被解析出来。 Boolean类型 可用Boolean()来对任意数值进行转换。 非零及非NaN的数值(包括无限大)为真。 非空的字符串为真。 任何非null的对象为真。 undefined 始终为假。 Null与Undefined null表示空指针，即声明了对象指针，但没实例化。 undefined表示没有初始化。 undefined 派生自 null，所以null==undefined,返回true。 所有的类型复制都是值传递。 对于基本类型的复制结果的修改不影响原数据，因为再拷贝了一份。 复杂类型的复制结果是对其指针的复制，复制结果的修改会影响原数据。 方法内部传递的复杂类型也是复制后的指针。 所有基本数据类型都是不可变的，即使对相同名字的变量赋值，也是先销毁原先变量再生成新变量。 ==与=== == 是相等，即判断两者不同时，先进行类型转换。 true转为数值 1， false转为0。 字符串与数值比较，先转为数值。 对象与其它类型数据比较，先调用valueOf()方法将对象转为字符串，再按照上面规则判定。 NaN与任何数据比较都是false。 对象的比较是他们是否指向同一个对象。 null==undefined返回ture。 === 是全等。如果比较的两者类型不同，则直接返回false。 方法的形参：命名只是为了操作方便，内部实现不管形参定义，而是利用数组依次存储数据。 可调用内部数组arguments读取传入的参数。 JS的方法不存在重载。123456789function add()&#123; if(arguments.length==1) return argument[0]; if(arguments.length==2) return arguments[0] + argument[1];&#125;add(1) //输出1add(1,2) //输出3 执行环境与作用域链 执行环境：ECMAScript代码运行的环境 执行环境用一个与之关联的变量对象表示，环境中所有的变量与函数都保存在该对象内部。环境对象的生命周期也就是内部变量与函数的声明周期。 全局执行环境是最外围的执行环境，根据宿主环境不同，变量对象也不同。例如Web浏览器中的全局执行环境的变量对象为windows，浏览器关闭就相当于 windows 变量对象死亡，内部代码也消亡。 每个函数也有自己的执行环境，进入函数内，函数环境推入环境栈，运行完毕弹出环境栈，类似于Java的虚拟机栈，会存在栈溢出错误。 作用域链：定义了可访问变量的顺序。 全局执行环境变量在最外围。 函数内部变量在最前端，例如arguments。 由前端向根部查找，找到便不再往后查找，哪怕存在重名变量。 没有块级作用域 与Java等C类语言不同， if或for等块级作用域声明的变量会被加入到全局执行环境中作为全局变量。 1234for(var i=0; i&lt;10; i++) &#123; doSomeThing(i);&#125;alert(i); //输出10 引用数据类型对象其实是某个特定引用类型的实例，由一组键值对组成 &#123;[key]:[value]&#125;，属性名：属性值。 Onject类型 所有JS的对象类型都基于Object类，因此含有它一切的方法。 hasOwnProperty(“propertyName”): 检查对象实例中属性是存在实例自身还是存在于原型对象中。 isPrototypeOf(Object): 检查传入对象是否是传入对象的原型。 toLocalString(): 返回本地环境的对象字符串表示。 toString(): 返回对象的字符串表示。 valueOf(): 返回对象的数值、字符串即布尔表示，一般与toString()返回相同。 创建方法有两种。 通过构造函数创建。 1234// 用Object构造函数创建对象var obj = new Object();// 定义属性obj.name = &quot;syz&quot;; 通过对象字面量表示法 12345678// 通过花括号将要赋值内容用的键值对表示// 空花括号与new Object()作用相当； var obj = &#123;&#125;;// 属性名可以是字符串、数字var obj = &#123; name : &quot;syz&quot;, &quot;age&quot;: 12, 12: 0&#125; 对象属性访问方式也有两种 通过对象加 .方式引用，但不能引用数字及会导致引用语法错误的字符。 123456789var person = &#123; name: &quot;syz&quot;, age: 12, 12: 0&#125;// 访问name及agr属性alert(person.name);alert(person.age);// 但不能访问属性 12， person.12是语法错误 通过中括号+属性字符串方式引用，可通过变量访问属性。 123456789101112var person = &#123; name: &quot;syz&quot;, age: 12, 12: 0&#125;// 访问name属性alert(person[&quot;name&quot;]);// 访问age属性var propertyName = &quot;age&quot;;alert(person[propertyName]);//访问12属性alert(person[&quot;12&quot;]); Array类型JS的数组比Java的强大太多，不仅可以支持类似于Python的切片功能，而且还可以模拟队列、栈等数据结构，还能够很方便的实现数组的迭代、拼接、插入、删除等功能。 新建Array有两种方式。 通过Array构造函数创建，可省略new关键字。 123var arr0 = new Array(); // 构建数组var arr1 = Array(5); // 预定义长度为5的数组，每一项为 undefinedvar arr2 = Array(&quot;1&quot;,2,&quot;test&quot;); // 可以存储任何类型的数据，且长度是动态扩展的 通过数组字面量表示法 1var arr = [1, &quot;test&quot;]; 数组的length属性 数组的length属性不是可读的，可以控制它实现数据的删除与扩展操作。 1234var arr = [1,2,3];arr.length = 2;alert(arr[2]); // 返回unfefinedarr.length = 99; // 2-98位置都为undefined 检查数组 由于全局执行环境可能有多种（框架多种），不同环境的Array定义不同，所以采用 instanceOf Array可能有错误。 采用Array.isArray()方法来判断。 打印数组 调用toString()打印（默认采用）; 采用join(“||”)打印，里面接收分隔符。 12var a = [1,2,3];alert(a.join(&quot;||&quot;)); //打印 1||2||3 数组的类栈操作 push()方法入栈，返回数组长度 pop()方法出栈，移除并返回数组最后一个元素 数组的类队列操作 push()方法入队列 shift()方法出队列，即移除并返回数组第一个元素 unshift()方法反向入队列，即在数据第一个位置插入，并返回数组长度 pop()方法反向出队列，移除并返回数组最后一个元素 数组拼接、切片、插入与删除 concat()函数实现拼接新元素，并返回新数组123var arr = [1,2,3];var arr2 = arr.concat(&quot;3&quot;,[&quot;string&quot;, 4, 5]);console.log(arr2); //打印 1,2,3,3,string,4,5 -slice(startIndex, endIndex)函数实现数组切片,返回新数组123456789101112var arr = [1,2,3,4,5];var arr2 = arr.slice(1,3); console.log(arr2); // 输出[2,3]arr2 = arr.slice(3);console.log(arr2); // 输出[4,5],默认从位置3开始切片到末尾arr2 = arr.slice(-1);console.log(arr2); // 输出[5],从最后的位置开始切片arr2 = arr.slice(-3,-1);console.log(arr2); // 输出[3, 4],从倒数第3位置开始切分，不包括倒数第一位置的数 splice(startIndex, removeNum, insertElement)方法插入与删除元素，返回删除的数据123456789101112var arr = [1,2,3,4,5];arr.splice(0, 0, [1,2,3]);console.log(arr); //输出[ [ 1, 2, 3 ], 1, 2, 3, 4, 5 ]， 即在首位插入[1,2,3]var arr = [1,2,3,4,5];var deleteEle = arr.splice(1, 4);console.log(arr); // 输出 [1]，即从第二个位置删除4项console.log(deleteEle); // 输出[2,3,4,5]，即删除的数据var arr = [1,2,3,4,5];arr.splice(1,2,&quot;insertEle&quot;);console.log(arr); // 输出[ 1,&#x27;insertEle&#x27;, 4, 5 ]，即从第位置1删除两项并在位置1开始插入&quot;insertEle&quot; 数组的排序 reverse()函数，颠倒数组12var a = [1,2,3];console.log(a.reverse()); //输出[3,2,1] sort()函数，排序数组，默认是先把元素转为字符串，然后排序1234567891011121314// 默认字符串排序var a = [1,5, 10, 15, 20];console.log(a.sort()); //输出[ 1, 10, 15, 20, 5 ]//传入比较函数，实现自定义排序/*比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等 则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。*/function compare(v1, v2)&#123; // 逆序 return v2-v1;&#125;console.log(a.sort(compare)); //输出[[ 20, 15, 10, 5, 1 ]] 数组元素位置查询 indexOf(searchLocation)，从指定位置顺序查询 lastIndexOf(searchLocation)，从指定位置逆序查询 数组迭代每个迭代方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响 this 的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。 every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。 filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。 forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。 map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。1234567891011121314151617181920212223242526// everyvar numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;); alert(everyResult); // false// somevar someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;); alert(someResult); //true// filtervar numbers = [1,2,3,4,5,4,3,2,1];var filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;); alert(filterResult); //[3,4,5,4,3]// mapvar numbers = [1,2,3,4,5,4,3,2,1];var mapResult = numbers.map(function(item, index, array)&#123; return item * 2;&#125;); alert(mapResult); //[2,4,6,8,10,8,6,4,2] 数组归并两个归并数组的方法：reduce()和 reduceRight()。归并元素生成一个值。两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给 reduce()和 reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;); alert(sum); //15 Function类型所有的函数都是Function类型的实例，因此函数名也就是实例的指针，函数可以拥有方法和属性，函数也可以作为参数传入另一个函数或对象中，就跟一个对象没区别。 创建函数123456789101112131415161718192021222324/* 使用函数声明定义函数,此时存在函数声明提升的过程。即在代码还没运行前，将函数声明的函数解析并放到代码树的顶端，以供后面的代码使用。*/alert(sum1(1,2)); //可以执行，因为sum1已经被提升到最前端// 函数声明方式创建function sum1(d1, d2)&#123; return d1 + d2;&#125;// 函数表达式创建// alert(sum(1, 2)) 报错，因为函数表达式不会有函数提升过程var sum = function(d1, d2)&#123; return d1 + d2;&#125;; //有分号// 函数可以作为 对象/参数 传入函数function apply(fc, num1, num2)&#123; return fc(num1, num2);&#125;function sum(d1, d2)&#123; return d1 + d2;&#125;alert(apply(sum,1,2)); // 输出3 apply()与call()方法两个都是Function除Object对象自带函数外内置的另外两个函数，作用是在指定的环境中运行某函数，两个方法接收两个参数，第一个表示当前环境的指针，另一个表示传入的参数。区别是，apply第二个可以是参数属性arguments或者是数组，而call()必须是参数依次列出。1234567891011121314151617181920212223242526272829303132// apply应用场景function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum1(num1, num2)&#123; return sum.apply(this, arguments);&#125;function callSum2(num1, num2)&#123; return sum.apply(this, [num1, num2]);&#125;alert(callSum1(10,10)); alert(callSum2(10,10));// call应用场景function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum(num1, num2)&#123; return sum.call(this, num1, num2);&#125; alert(callSum(10,10));// apply在指定环境运行函数var color = &quot;red&quot;;var o = &#123;color:&quot;blue&quot;&#125;;function sayColor()&#123; return this.color;&#125;alert(sayColor()); //redalert(sayColor.call(this)); // red 全局执行环境，即windowsalert(sayColor.call(whidows)); // red 全局执行环境alert(sayColor.call(o)); // blue 执行环境为对象o arguments对象与this对象 arguments表示传入的参数数组，该对象具有属性length及callee。 lenght属性查看传入参数的数量。 callee，获得包含arguments的函数指针123456789// 阶乘函数function factorial(num)&#123; if(num&lt;=1) return num; // 与函数名解耦 return arguments.callee(num-1)*num;&#125;var fc2 = factorial;alert(fc2(10)); this对象指向表示函数的执行环境的对象。 length与prototype属性 length表示函数希望接收的参数个数。 prototype保存函数的所有实例方法。 基本包装类型 JS在生成一个基本类型数据时，同时产生一个基本包装类型，为读取基本数据的一些操作提供执行方法的入口。1234var str = &quot;Hello JS&quot;；str.substring(0,5)；str.name = &quot;str&quot;;alert(str.name); //输出undefined，因为执行完毕后立即销毁该包装类型对象上面的例子生成一个string类型的基本数据，但是调用substring()方法时，是调用的同时生成的基本包装类型String对象内的方法。在执行完毕后该对象立马销毁。 基本包装类型有Boolean、Number和String，都有Object内置的toString()、toLocalString()以及valueOf()等方法。 String包装类型内置方法 三种切片方法substring、slice及substr，返回新的字符串 substring(startIndex, endIndex):在索引都是正数时，与slice()一样，但是遇到负数取零。 slice(startIndex, endIndex):与数组切片方法一致。 substr(startIndex, cut_length): 第一个切片起点，第二个切片长度，长度为负数时返回空字符串””。 charAt()与charCodeAt(): 分别返回所在位置的字符及字符编码。 length: 放回字符数量。 concat(): 拼接字符串，返回新字符串。 split(): 用指定字符切割字符串，第一个参数是切割字符，第二个可选参数为返回数组的长度。 match()与search(): 子字符串的查找。 Number包装类型 toFixed(n): 精确到小数点后n位。 toExponential(n): 用指数表示法表示，n为精确的小数点位数。 toPrecision(n): n为显示数值的位数，根据情况调用toFixed()或toExponential()方法。 Boolean包装类型不推荐使用。 Global对象与Math对象 全局对象Global是JS最终的“兜底”对象，所有对象包含在其内部，不属于其它方法(如isNaN()、isFinite())与属性(如NaN、undifined)都属于它的方法与属性。例如windows对象就是一个全局对象。 **Global对象的属性** Math对象是为数学运算设计的，包括常用的max()、min()、ceil()、floor()、round()及random()方法等。其中，max()与min()与java不同的是，可以比较获得所有数据的最大值与最小值。 总结 JavaScript是按照ECMAScript语言标准设计，可操作DOM、BOM接口与方法的一门前端语言。 JavaScript数据类型分为五种基本数据类型与引用数据类型。 基本数据类型存储在栈内存中，且是final的，即不可修改。 引用数据类型的变量名存储在栈内存中存储实例的指针，内容存储在堆内存中，以键值对方式保存。 JavaScript语言的类型都是松散型的，且为顺序执行。 让我们拥抱JS，一起迎接大前端时代吧！","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sunyunzeng.com/tags/JavaScript/"}]},{"title":"LeetCode 96.不同的二叉搜索树","slug":"LeetCode-96-不同的二叉搜索树","date":"2019-11-12","updated":"2022-11-05","comments":true,"path":"LeetCode-96-不同的二叉搜索树/","link":"","permalink":"https://sunyunzeng.com/LeetCode-96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"题目给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例:12345678910输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 思路 + 代码动态规划。 假设 整数 n对应的二叉搜索树数量为 G(n)。 每个节点 i ∈ (0,n] 为根节点对应的二叉搜索树数量为 F(i)。 则， G(n) = F(1) + F(2) + F(3) + … + F(n)。 而 节点i 为根节点的二叉搜索树，可以分为 i-1 个左子树 跟 n-i个右子树，F(i) = G(i-1)*G(n-i); 因此 G(n) = G(0)G(n-1) + G(1)G(n-2) + G(2)G(n-3) + … + G(n-1)G(0) 因此 1234567891011121314class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n+1]; dp[0]=1; // 边界条件 dp[1]=1; for(int i=2; i&lt;=n; i++)&#123; for(int j=1; j&lt;=i; j++)&#123; // 节点i为根节点对应的二叉搜索树数量 dp[i] += dp[j-1]*dp[i-j]; &#125; &#125; return dp[n]; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-binary-search-trees著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"LeetCode 208.实现Trie(前缀树)","slug":"LeetCode-208-实现Trie-前缀树","date":"2019-11-11","updated":"2022-11-05","comments":true,"path":"LeetCode-208-实现Trie-前缀树/","link":"","permalink":"https://sunyunzeng.com/LeetCode-208-%E5%AE%9E%E7%8E%B0Trie-%E5%89%8D%E7%BC%80%E6%A0%91/","excerpt":"","text":"题目实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例:12345678Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // 返回 truetrie.search(&quot;app&quot;); // 返回 falsetrie.startsWith(&quot;app&quot;); // 返回 truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // 返回 true 说明: 你可以假设所有的输入都是由小写字母 a-z 构成的。保证所有输入均为非空字符串。 思路 + 代码题解 实现一个链表，每一个链表节点存储的是数组，数组包含所有可能的键（这里指26个字符）。 类似于HashMap的entry结构。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Trie &#123; private class TrieNode&#123; private TrieNode[] links; private boolean isEnd; TrieNode()&#123; links = new TrieNode[26]; &#125; public boolean containsKey(char c)&#123; return links[c-&#x27;a&#x27;]!=null; &#125; public TrieNode get(char c)&#123; return links[c-&#x27;a&#x27;]; &#125; public void set(char c, TrieNode node)&#123; links[c-&#x27;a&#x27;] = node; &#125; public void setEnd()&#123; this.isEnd = true; &#125; public boolean isEnd()&#123; return this.isEnd; &#125; &#125; private TrieNode root; /** Initialize your data structure here. */ public Trie() &#123; root = new TrieNode(); &#125; /** Inserts a word into the trie. */ public void insert(String word) &#123; TrieNode node = root; for(int i=0; i&lt;word.length(); i++)&#123; char c = word.charAt(i); if(!node.containsKey(c))&#123; node.set(c, new TrieNode()); &#125; node = node.get(c); &#125; node.setEnd(); &#125; private TrieNode searchPrefix(String word)&#123; TrieNode node = root; for(int i=0; i&lt;word.length(); i++)&#123; char c = word.charAt(i); if(node.containsKey(c)) node = node.get(c); else return null; &#125; return node; &#125; /** Returns if the word is in the trie. */ public boolean search(String word) &#123; TrieNode node = searchPrefix(word); return node!=null &amp;&amp; node.isEnd(); &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) &#123; TrieNode node = searchPrefix(prefix); return node!=null; &#125; &#125;/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"LeetCode 221.最大正方形","slug":"LeetCode-221-最大正方形","date":"2019-11-09","updated":"2022-11-05","comments":true,"path":"LeetCode-221-最大正方形/","link":"","permalink":"https://sunyunzeng.com/LeetCode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/","excerpt":"","text":"题目在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例： 12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 思路 + 代码是动态规划的题目。 关键在于问题的转化。 问题转化为最长边长。 然后截止当前位置的最长边长是左边、上边及右上三者中的最小值 + 1。 12345678910111213141516171819class Solution &#123; public int maximalSquare(char[][] matrix) &#123; if(matrix.length==0 || matrix[0].length==0) return 0; int row = matrix.length; int col = matrix[0].length; int[][] dp = new int[row+1][col+1]; int max_side = 0; for(int i=1; i&lt;=row; i++)&#123; for(int j=1; j&lt;=col; j++)&#123; if(matrix[i-1][j-1]==&#x27;1&#x27;)&#123; dp[i][j] = Math.min(Math.min(dp[i][j-1], dp[i-1][j]), dp[i-1][j-1])+1; max_side = Math.max(max_side, dp[i][j]); &#125; &#125; &#125; return max_side*max_side; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"LeetCode 62.不同路径","slug":"LeetCode-62-不同路径","date":"2019-11-08","updated":"2022-11-05","comments":true,"path":"LeetCode-62-不同路径/","link":"","permalink":"https://sunyunzeng.com/LeetCode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/","excerpt":"","text":"题目一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 思路 + 代码动态规划。。用回溯竟然做不出来 123456789101112131415161718class Solution &#123; public int uniquePaths(int m, int n) &#123; if(m&lt;=0 || n&lt;=0) return 0; int[][] dp = new int [m][n]; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(i==0) dp[i][j] = 1; else if(j==0) dp[i][j] = 1; else dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-paths著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"LeetCode 238.除自身以外数组的乘积","slug":"LeetCode-238-除自身以外数组的乘积","date":"2019-11-07","updated":"2022-11-05","comments":true,"path":"LeetCode-238-除自身以外数组的乘积/","link":"","permalink":"https://sunyunzeng.com/LeetCode-238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/","excerpt":"","text":"题目给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例：12输入: [1,2,3,4]输出: [24,12,8,6] 说明：请不要使用除法，且在 O(n) 时间复杂度内完成此题。 思路 + 代码不能常规的循环暴力解决，因为时间限制在O(n)内。 考虑上三角/下三角的乘法。 123456789101112131415161718class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int len = nums.length; int[] res = new int[len]; Arrays.fill(res, 1); int left = 1, right=1; for(int i=0; i&lt;len; i++) &#123; // 只经过左指针操作，res[0] = 1, res[1] = 1, res[2] = 1*2, res[3] = 1*2*3 res[i] *= left; left *= nums[i]; // 只经过右指针操作，res[0] = 2*3*4, res[1] = 3*4, res[2] = 4 res[3] = 1 res[len-1-i] *= right; right *= nums[len-1-i]; // 上下相乘得到结果 &#125; return res; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/product-of-array-except-self著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"LeetCode 114.二叉树展开为链表","slug":"LeetCode-114-二叉树展开为链表","date":"2019-11-06","updated":"2022-11-05","comments":true,"path":"LeetCode-114-二叉树展开为链表/","link":"","permalink":"https://sunyunzeng.com/LeetCode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目给定一个二叉树，原地将它展开为链表。 例如，给定二叉树： 12345 1 / \\ 2 5 / \\ \\3 4 6 将其展开为： 12345678910111 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 题解 + 思路一开始想的是递归，但是递归是由底向顶递归生成，而这道题是由顶到底生成，虽然存在子问题，但是仍难以求解。 其实可以看做如下步骤： 找到左子树的最右节点。 12345 1 / \\ 2 5 / \\ \\3 4 6 将右子树移到左子树的最右节点。 123456789 1 / 2 / \\ 3 4 \\ 5 \\ 6 右子树换为左子树，左子树置为 null 1234567891 \\ 2 / \\ 3 4 \\ 5 \\ 6 从右节点开始，继续该操作 12345678910111 \\ 2 \\ 4 \\ 5 \\ 6 \\ 3 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void flatten(TreeNode root) &#123; while(root!=null)&#123; if(root.left==null)&#123; root=root.right; &#125;else&#123; TreeNode pre = root.left; while(pre.right!=null)&#123; pre = pre.right; &#125; pre.right = root.right; root.right = root.left; root.left = null; root = root.right; &#125; &#125; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sunyunzeng.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"LeetCode 22.括号生成","slug":"LeetCode-22-括号生成","date":"2019-11-05","updated":"2022-11-05","comments":true,"path":"LeetCode-22-括号生成/","link":"","permalink":"https://sunyunzeng.com/LeetCode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/","excerpt":"","text":"题目给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 思路 + 代码回溯法，通过两个整数统计“（”与“）”的数量。 1234567891011121314151617181920class Solution &#123; private List&lt;String&gt; res = new ArrayList&lt;&gt;(); public List&lt;String&gt; generateParenthesis(int n) &#123; if(n&lt;1) return res; backtracing(&quot;&quot;, 0, 0, n); return res; &#125; private void backtracing(String s, int open, int close, int n)&#123; if(close&gt;open || open&gt;n || close&gt;n) return; if(s.length()==2*n)&#123; res.add(s); return; &#125; String str = new String(s); backtracing(str+&quot;(&quot;, open+1, close, n); backtracing(str+&quot;)&quot;, open, close+1, n); &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"LeetCode 437.路径总和 III","slug":"LeetCode-437-路径总和","date":"2019-11-05","updated":"2022-11-05","comments":true,"path":"LeetCode-437-路径总和/","link":"","permalink":"https://sunyunzeng.com/LeetCode-437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/","excerpt":"","text":"题目给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 示例1：123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\3 -2 1返回 3。和等于 8 的路径有:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 思路 + 代码双重递归。 首先建立一个递归寻找以每个节点为根节点的路径查找。 再建立一个递归遍历每一个节点，并以该节点为根节点。 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private int cnt = 0; public int pathSum(TreeNode root, int sum) &#123; helper(root, sum); return cnt; &#125; private void helper(TreeNode root, int sum)&#123; if(root==null) return; search(root, sum, root.val); helper(root.left, sum); helper(root.right, sum); &#125; private void search(TreeNode root, int sum, int tmp)&#123; if(sum==tmp)&#123; cnt++; &#125; if(root.left!=null) search(root.left, sum, tmp+root.left.val); if(root.right!=null) search(root.right, sum, tmp+root.right.val); &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum-iii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sunyunzeng.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"LeetCode 494.目标和","slug":"LeetCode-494-目标和","date":"2019-11-04","updated":"2022-11-05","comments":true,"path":"LeetCode-494-目标和/","link":"","permalink":"https://sunyunzeng.com/LeetCode-494-%E7%9B%AE%E6%A0%87%E5%92%8C/","excerpt":"","text":"题目给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 示例1：1234567891011输入: nums: [1, 1, 1, 1, 1], S: 3输出: 5解释: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3一共有5种方法让最终目标和为3。 注意： 数组非空，且长度不会超过20。 初始的数组的和不会超过1000。 保证返回的最终结果能被32位整数存下。 思路 + 代码首先是回溯方法。 12345678910111213141516class Solution &#123; private int cnt = 0; public int findTargetSumWays(int[] nums, int S) &#123; dfs(nums, S, 0, 0); return cnt; &#125; private void dfs(int[]nums, int S, int tmpS, int location)&#123; if(location==nums.length)&#123; if(S==tmpS) cnt++; return; &#125; dfs(nums, S, tmpS + nums[location], location+1); dfs(nums, S, tmpS - nums[location], location+1); &#125;&#125; 然后是动态规划 一个数组可分为两个子集和 X 跟 Y，然后 X-Y=S，X+Y=Sum，由此得到 X=(Sum+S)/2。 也就是寻找一个子集和X，满足 X=(Sum+S)/2，此和且为整数。 123456789101112131415161718192021class Solution &#123; public int findTargetSumWays(int[] nums, int S) &#123; int sum = 0; for(int n: nums)&#123; sum += n; &#125; if(sum &lt; S || (sum+S)%2!=0)&#123; return 0; &#125; int s = (sum+S)/2; int[] dp = new dp[s+1]; dp[0] = 1; for(int n: nums)&#123; for(int i=s; i&gt;=n; i--)&#123; // 如果考虑数n，结果数为dp[i]，否则为dp[i-n] dp[i] += dp[i-n]; &#125; &#125; return dp[s]; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/target-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"LeetCode 160.相交链表","slug":"LeetCode-160相交链表","date":"2019-11-04","updated":"2022-11-05","comments":true,"path":"LeetCode-160相交链表/","link":"","permalink":"https://sunyunzeng.com/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目编写一个程序，找到两个单链表相交的起始节点。 思路 + 代码1. 最容易想到的，两层遍历求解。 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null || headB==null) return null; ListNode tmp; while(headA!=null)&#123; tmp = headB; while(tmp!=null)&#123; if(tmp!=headA) return tmp; tmp = tmp.next; &#125; headA = headA.next; &#125; return null; &#125;&#125; 时间复杂度O(M*N)空间复杂度O(1) 2. 利用Map记录一个链表的每个节点，第二个链表寻找第一次出现的节点。 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null || headB==null) return null; Map&lt;ListNode,Integer&gt; map = new HashMap&lt;ListNode,Integer&gt;(); while(headA!=null)&#123; map.put(headA,1); headA = headA.next; &#125; while(headB!=null)&#123; if(map.containsKey(headB)) return headB; headB = headB.next; &#125; return null; &#125;&#125; 时间复杂度O(M+N)空间复杂度O(M)或O(N) 3. 或者两个指针，分别从两个链表的头结点开始，当一个节点遍历到尾部时换到另一个链表头部。 即利用 a+all+b = b+all+a，也就是两个指针走的路程一样。 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null || headB==null) return null; ListNode tmpA = headA; ListNode tmpB = headB; while(tmpA!=tmpB)&#123; tmpA = tmpA==null?headB:tmpA.next; tmpB = tmpB==null?headA:tmpB.next; &#125; return tmpA; return tmpA; &#125;&#125; 时间复杂度O(M+N)空间复杂度O(1)","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"LeetCode 23.合并K个排序链表","slug":"LeetCode-23-合并K个排序链表","date":"2019-11-03","updated":"2022-11-05","comments":true,"path":"LeetCode-23-合并K个排序链表/","link":"","permalink":"https://sunyunzeng.com/LeetCode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例：1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 思路 + 代码合并两个有序链表的翻版。 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if(lists==null || lists.length==0) return null; if(lists.length==1) return lists[0]; ListNode res = lists[0]; for(int i=1; i&lt;lists.length; i++)&#123; res = mergeTwoLists(res, lists[i]); &#125; return res; &#125; // 合并两个有序链表的操作 public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; if(l2==null) return l1; ListNode prehead = new ListNode(0); ListNode node = prehead; while(l1!=null &amp;&amp; l2!=null)&#123; if(l1.val&lt;=l2.val)&#123; node.next = l1; l1=l1.next; &#125;else&#123; node.next = l2; l2=l2.next; &#125; node = node.next; &#125; node.next=l1==null?l2:l1; return prehead.next; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"LeetCode 543.二叉树的直径","slug":"LeetCode-543-二叉树的直径","date":"2019-11-03","updated":"2022-11-05","comments":true,"path":"LeetCode-543-二叉树的直径/","link":"","permalink":"https://sunyunzeng.com/LeetCode-543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/","excerpt":"","text":"题目给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 示例：给定二叉树12345 1 / \\ 2 3 / \\ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 注意：两结点之间的路径长度是以它们之间边的数目表示。 思路 + 代码路径长度一定是以某个节点为根节点，左右子树的最大深度和。 与题目求二叉树的最大深度类似 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private int sum; public int diameterOfBinaryTree(TreeNode root) &#123; if(root==null) return 0; getDepth(root); return sum; &#125; private int getDepth(TreeNode root)&#123; if(root==null) return 0; int left = getDepth(root.left); int right = getDepth(root.right); sum = Math.max(sum, left+right ); return Math.max(left, right)+1; &#125;&#125; 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sunyunzeng.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"LeetCode 560.和为K的子数组","slug":"LeetCode-560-和为K的子数组","date":"2019-11-03","updated":"2022-11-05","comments":true,"path":"LeetCode-560-和为K的子数组/","link":"","permalink":"https://sunyunzeng.com/LeetCode-560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","excerpt":"","text":"题目给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例1：12输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明： 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 思路1先固定数组的左侧位置，然后依次移动右侧指针，如何数组和为 k，结果加一。 数组和置为零，更新左侧位置。 1234567891011121314class Solution &#123; public int subarraySum(int[] nums, int k) &#123; int res=0; for(int left=0; left&lt;nums.length; left++)&#123; int sum=0; for(int right = left; right&lt;nums.length; right++)&#123; sum += nums[right]; if(sum==k) res++; &#125; &#125; return res; &#125;&#125; 此时空间复杂度为 1， 时间复杂度为 O(n)。 思路2只需要遍历一次，统计到各个位置的累积和。 如果至 j 位置的和与至 i 位置的和差为k，那么位于 i~j 的子序列和为 k。 用一个Map统计不同累积和出现的次数。 12345678910111213class Solution &#123; public int subarraySum(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); int sum = 0, res = 0; for(int n: nums)&#123; sum += n; if(map.containsKey(sum-k)) res += map.get(sum-k); // map.getOrDefault(key, default)--如果存在键K就取出对应的V，否则值为default map.put(sum, map.getOrDefault(sum, 0)+1); &#125; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"LeetCode 621.任务调度器","slug":"LeetCode-621-任务调度器","date":"2019-11-02","updated":"2022-11-05","comments":true,"path":"LeetCode-621-任务调度器/","link":"","permalink":"https://sunyunzeng.com/LeetCode-621-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/","excerpt":"","text":"题目给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。 然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的最短时间。 示例1： 123输入: tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2输出: 8执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B. 注: 121. 任务的总个数为 [1, 10000]。2. n 的取值范围为 [0, 100]。 思路 + 代码方法1规定 n + 1 个任务为一轮，这样的好处是同一轮中一个任务最多只能被安排一次。在每一轮中，我们将当前的任务按照它们剩余的次数降序排序，并选择剩余次数最多的 n + 1 个任务依次执行。如果任务的种类 t 少于 n + 1 个，就只选择全部的 t 种任务，其余的时间空闲。这样做的正确性在于，由于冷却时间的存在，出现次数较多的那些任务如果不尽早安排，将会导致大量空闲时间的出现，因此贪心地将出现次数较多的任务安排在前面是合理的。同时我们可以保证，这一轮的第 k 个任务距离上一次执行至少有 n 个单位的冷却时间。我们可以使用逆向思维来证明：假设第 r 轮中某个任务在第 k 个执行，那么说明它在第 r 轮时为数量第 k 多的任务。在第 r 轮结束后，第 1 多到第 k 多的任务的数量都会减少 1，因此在第 r + 1 轮，这个任务最多也只能是数量第 k 多，因此它如果被执行，一定满足冷却时间的要求。 12345678910111213141516171819202122public class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; int[] map = new int[26]; for (char c: tasks) map[c - &#x27;A&#x27;]++; Arrays.sort(map); int time = 0; while (map[25] &gt; 0) &#123; int i = 0; while (i &lt;= n) &#123; if (map[25] == 0) break; if (i &lt; 26 &amp;&amp; map[25 - i] &gt; 0) map[25 - i]--; time++; i++; &#125; Arrays.sort(map); &#125; return time; &#125;&#125; 方法2(count[25] - 1) * (n + 1) + maxCount 假设数组 [“A”,”A”,”A”,”B”,”B”,”C”]，n = 2，A的频率最高，记为count = 3，所以两个A之间必须间隔2个任务，才能满足题意并且是最短时间（两个A的间隔大于2的总时间必然不是最短），因此执行顺序为： A-&gt;X-&gt;X-&gt;A-&gt;X-&gt;X-&gt;A，这里的X表示除了A以外其他字母，或者是待命，不用关心具体是什么，反正用来填充两个A的间隔的。上面执行顺序的规律是： 有count - 1个A，其中每个A需要搭配n个X，再加上最后一个A，所以总时间为 (count - 1) * (n + 1) + 1要注意可能会出现多个频率相同且都是最高的任务，比如 [“A”,”A”,”A”,”B”,”B”,”B”,”C”,”C”]，所以最后会剩下一个A和一个B，因此最后要加上频率最高的不同任务的个数 maxCount公式算出的值可能会比数组的长度小，如[“A”,”A”,”B”,”B”]，n = 0，此时要取数组的长度 1234567891011121314151617181920class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; if(tasks==null || tasks.length==0 || n&lt;0) return 0; int len = tasks.length; int[] counts = new int[26]; // 统计数量 for(char c: tasks)&#123; counts[c-&#x27;A&#x27;]++; &#125; int maxCount = 0; Arrays.sort(counts); for(int i=0; i&lt;26; i++) if(counts[i]==counts[25]) maxCount++; int res = (counts[25]-1)*(n+1)+maxCount; return res&lt;len?len:res; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/task-scheduler著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Leetcode 581.最短无序连续子数组","slug":"Leetcode-581-最短无序连续子数组","date":"2019-11-02","updated":"2022-11-05","comments":true,"path":"Leetcode-581-最短无序连续子数组/","link":"","permalink":"https://sunyunzeng.com/Leetcode-581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/","excerpt":"","text":"题目给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 你找到的子数组应是最短的，请输出它的长度。 示例1： 123输入: [2, 6, 4, 8, 10, 9, 15]输出: 5解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 说明： 输入的数组长度范围在 [1, 10,000]。 输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。 思路 + 代码首先用左右两个指针分别探测左右各自逆序的起点。此时序列对应的数值是局部最小值与局部最大值。 然后在逆序序列(左边逆序开始与右边逆序开始位置之间)中寻找全局最小值与全局最大值。 然后从左边开始遍历寻找小于等于全局最小值的边界；从右边寻找大于等于全局最大值的边界。 左右边界构成数组的长度即为所求。 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int findUnsortedSubarray(int[] nums) &#123; // 异常值处理 if(nums==null||nums.length&lt;=1) return 0; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; int len = nums.length; int i = 0, j = len-1; // 寻找左右逆序的边界 while(i+1&lt;len) if(nums[i+1]&lt;nums[i++]) break; while(j-1&gt;=0) if(nums[j-1]&gt;nums[j--]) break; // 如果i+1&gt;len，证明数组本身是升序的，返回0 if(i+1&gt;len) return 0; // 寻找全局最小值与全局最大值 do&#123; if(nums[i]&lt;min) min = nums[i]; &#125;while(++i&lt;len); do&#123; if(nums[j]&gt;max) max = nums[j]; &#125;while(--j&gt;=0); // 从左右分别开始遍历，找到逆序数组真实左右边界 i = 0; j = len-1; while(i&lt;len &amp;&amp; nums[] &lt;=min) i++; while(j&gt;=0 &amp;&amp; nums[j] &gt;=max) j--; return j-i+1&gt;0?j-i+1:0; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"归并排序 | 插入排序 | 希尔排序","slug":"Algorithm：归并排序","date":"2019-11-01","updated":"2022-11-05","comments":true,"path":"Algorithm：归并排序/","link":"","permalink":"https://sunyunzeng.com/Algorithm%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","excerpt":"","text":"插入排序每次遍历都将对应位置的数字插入到合适的位置，当前位置之前的数据保持排序。 代码12345678910111213141516public class InsertionSort &#123; public static int[] sort(int[] arr)&#123; int len = arr.length; int[] A = new int[len]; System.arraycopy(arr, 0, A, 0, len); int i,j; for (i = 1; i &lt; len; i++) &#123; int temp = A[i]; for (j = i; j &gt; 0 &amp;&amp; A[j - 1] &gt; temp; j--) &#123; A[j] = A[j-1]; &#125; A[j] = temp; &#125; return A; &#125;&#125; 希尔排序是插入排序的变种，通过根据步长对原数组切分，加大了视野范围。 步长一直到1，此时交换的数量少，运行时间少。 12345678910111213141516171819public class ShellSort&#123; public static int[] sort(int[] nums)&#123; if(nums==null || nums.length==0) return null; int len = nums.length; int[] A = new int[len]; System.arraycopy(nums,0,A,0,len); for(int step = len/2; step &gt; 0; step/=2)&#123; for(int i=step; i&lt;len; i++)&#123; int tmp = A[i]; int j; for(j=i; j&gt;=step &amp;&amp; A[j-step] &gt; tmp; j-=step) A[j] = A[j-step]; A[j] = tmp; &#125; &#125; return A; &#125;&#125; 归并排序分而治之的思想。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MergeSort &#123; public static int[] sort(int[] nums)&#123; if(nums==null || nums.length==0) return null; int len = nums.length; int[] A = new int[len]; System.arraycopy(nums, 0, A, 0, len); mergeSort(A, 0, A.length-1); return A; &#125; private static void mergeSort(int[] nums, int i, int j)&#123; if(i&gt;=j) return; int m = i + (j-i)/2; mergeSort(nums,i, m); mergeSort(nums, m+1, j); // m位置属于左数组 merge(nums, i, m, j); &#125; private static void merge(int[] nums, int i, int m, int j)&#123; int[] leftArr = new int[m-i+1]; int[] rightArr = new int[j-m]; // 辅助数组填充 for(int l=i; l&lt;=m; l++)&#123; leftArr[l-i] = nums[l]; &#125; for(int r=m+1; r&lt;=j; r++)&#123; rightArr[r-m-1] = nums[r]; &#125; int l = 0, r = 0, k=i; while(l&lt;leftArr.length &amp;&amp; r&lt;rightArr.length)&#123; if(leftArr[l]&lt;rightArr[r])&#123; nums[k++]=leftArr[l++]; &#125;else&#123; nums[k++] = rightArr[r++]; &#125; &#125; while(l&lt;leftArr.length) nums[k++] = leftArr[l++]; while (r&lt;rightArr.length) nums[k++] = rightArr[r++]; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"https://sunyunzeng.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"MySQL：入门","slug":"MySQL：入门","date":"2019-10-31","updated":"2022-11-05","comments":true,"path":"MySQL：入门/","link":"","permalink":"https://sunyunzeng.com/MySQL%EF%BC%9A%E5%85%A5%E9%97%A8/","excerpt":"","text":"MySQL 简介MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 MySQL具有以下优点：  成本——MySQL是开放源代码的，一般可以免费使用（甚至可以 免费修改）。  性能——MySQL执行很快（非常快）。  可信赖——某些非常重要和声望很高的公司、站点使用MySQL， 这些公司和站点都用MySQL来处理自己的重要数据。  简单——MySQL很容易安装和使用。 基础入门 启动服务 Windows： 1net start mysql ubuntu: 1sudo service mysql start 登录 12mysql -u root -p***** 查看已有数据库 1SHOW DATABASES; 创建数据库 1CREATE DATABASE; 使用数据库 1USE DATABASE; 显示所有表 1SHOW TABLES; 显示已有表的所有列 1SHOW COLUMNS FROM YOURDATABASE; 创建表 1CREATE TABLE book(name char(20), author char(20)); 在表中插入数据 123INSERT INTO book VALUES(&#x27;C++ Primer&#x27;, &#x27;Stanley B. Lippman&#x27;);INSERT INTO book VALUES(&#x27;Thinking in JAVA&#x27;, &#x27;Bruce Eckel&#x27;);INSERT INTO book VALUES(&#x27;Easy Python&#x27;, &#x27;Kukeel Borant&#x27;); 查看表中数据 1SELECT * FROM book; 选择数据 SELECT 选择单列 1SELECT name FROM book; 选择多列 1SELECT name, author FROM book; 选择所有列 1SELECT * FROM book; 检索不同行 1SELECT DISTINCT author FROM book; 限制检索的行数 从第一行开始，返回结果不超过3行 123SELECT author FROM bookLIMIT 3 从第3行（第一行为0）开始，只检索结果不超过3行123SELECT author FROM bookLIMIT 2，3 完全限定的表名 指定从表 book 中选择 author 列从数据库 library 中选择 book 表 12SELECT book.authorFROM library.book; 排序检索数据关系数据库设计理论认为，如果不明确规定排序顺序，则不应假设检索出得数据的顺序有意义。 SQL语句由字句(clause)构成，有的字句是必需的，而有的是可选的。 OREDR BY 关键字句排序 默认升序排序 123SELECT authorFROM bookOREDER BY name; 还可以显示多列，添加多列约束，约束规则是在优先级高的数据有重复时，再按低一级的约束列排序。 123SELECT author, nameFROM bookORDER BY price, name; 指定排序方向 DESC逆序排列。 只对价格逆序排列 123SELECT author, nameFROM bookORDER BY price DESC, name; 集合 LIMIT 与 ORDER 挑选最贵书籍 1234SELECT nameFROM bookORDER BY price DESCLIMIT 1; 过滤数据通过关键字 WHERE 进行数据过滤 操作符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &gt; 大于 &lt;= 小于等于 &gt;= 大于等于 BETWEEN 在指定两个值之间 过滤行 123SELECT nameFROM bookWHERE name = &#x27;Machine Learning&#x27;; 阈值过滤 123SELECT nameFROM bookWHERE price BETWEEN 5 AND 10; 空值检查 123SELECT idFROM bookWHERE price is NULL; LIKE 通配符搜索通配符是 WHERE 字句中具有特殊含义的字符 % 通配符 % 通配符表示匹配任意字符出现任意次 匹配 Mach 开头的书名 123SELECT nameFROM bookWHERE name LIKE &#x27;Mach%&#x27;; _ 通配符 _ 通配符表示任意字符出现一次 123SELECT nameFROM bookWHERE name LIKE &#x27;_ach%&#x27;; 插入数据 在首列插入新字段 123ALTER TABLE booksADD COLUMN price float(5,2) --总共5位，小数2位NOT NULL FRIST; 在某列后插入新字段 123ALTER TABLE booksADD COLUMN price float(5,2) --总共5位，小数2位NOT NULL AFTER author; 默认插入最后一列 123ALTER TABLE booksADD COLUMN price float(5,2) --总共5位，小数2位NOT NULL; 更新数据一定记得加 WHERE 字句限定 更新指定单行与单列 123UPDATE bookSET price = 10.23WHERE id = 0; 更新指定多列与单行 1234UPDATE bookSET price = 8.88, --多行之间逗号隔开 name = &#x27;Machine Learning&#x27;WHERE id = 0; 通过设置为NULL 删除某列的值 123UPDATE bookSET price = NULLWHERE id = 0; 删除数据一定记得加 WHERE 字句限定 删除某一行 12DELECT FROM bookWHERE id = 0; 删除某一列 属于重构表结构，谨慎选择 12ALTER TABLE bookDROP COLUMN price;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://sunyunzeng.com/categories/MySQL/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://sunyunzeng.com/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"剑指Offer：剪绳子","slug":"剑指Offer：剪绳子","date":"2019-10-31","updated":"2022-11-05","comments":true,"path":"剑指Offer：剪绳子/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%89%AA%E7%BB%B3%E5%AD%90/","excerpt":"","text":"题目给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 （2 &lt;= n &lt;= 60） 思路 + 代码动态规划 可以分解子问题，即剪一刀，产生两段绳子，长度分别是 i 与 n-i, 在这两条绳子上可以继续剪： 1f(n) = max(f(i), f(n-i)) 123456789101112131415public class Solution &#123; public int cutRope(int target) &#123; int[] dp = new int[target+1]; dp[1] = 1; for(int i=2; i&lt;=target; i++)&#123; for(int j=1; j&lt;i; j++)&#123; // 剪一刀长度为j，则产生长度为j与i-j长度的绳子 // 进而判断长度为j的绳子的大值，为max(j, dp[j]); // 最后去dp[j]的最大值 dp[i] = Math.max(dp[i], Math.max(j*(i-j), dp[j]*(i-j))); &#125; &#125; return dp[target]; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：机器人的运动范围","slug":"剑指Offer：机器人的运动范围","date":"2019-10-31","updated":"2022-11-05","comments":true,"path":"剑指Offer：机器人的运动范围/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/","excerpt":"","text":"题目地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 思路 + 代码回溯方法，类似题目1、题目2 12345678910111213141516171819202122232425262728293031323334public class Solution &#123; private int k; private int res; private int[][] next = new int[][]&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;; public int movingCount(int threshold, int rows, int cols) &#123; if(rows&lt;=0 || cols&lt;=0 || threshold&lt;0) return 0; k = threshold; res = 0; boolean[][] visit = new boolean[rows][cols]; dfs(0,0, visit); return res; &#125; private void dfs(int i, int j, boolean[][] visit)&#123; if(i&lt;0 || j&lt;0 || i&gt;=visit.length || j&gt;=visit[0].length || k&lt;calNum(i)+calNum(j) || visit[i][j] )&#123; return; &#125; res++; visit[i][j] = true; for(int[] step: next)&#123; dfs(i+step[0], j+step[1], visit); &#125; return; &#125; private int calNum(int num)&#123; int res = 0; while(num &gt; 0)&#123; res += num%10; num /= 10; &#125; return res; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"},{"name":"回溯法","slug":"回溯法","permalink":"https://sunyunzeng.com/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"}]},{"title":"剑指Offer：滑动窗口的最大值","slug":"剑指Offer：滑动窗口的最大值","date":"2019-10-31","updated":"2022-11-05","comments":true,"path":"剑指Offer：滑动窗口的最大值/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","excerpt":"","text":"题目给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 思路 + 代码用一个最大堆维护中间的判断结果，每次只需对顶元素调整即可。 1234567891011121314151617181920import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(size&lt;=0 || size&gt;num.length) return res; // 最大堆维护结果 PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;((o1, o2)-&gt;o2-o1); for(int i=0; i&lt;size; i++) queue.add(num[i]); res.add(queue.peek()); for(int i=size; i&lt;num.length; i++)&#123; queue.remove(num[i-size]); queue.add(num[i]); res.add(queue.peek()); &#125; return res; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：数据流中的中位数","slug":"剑指Offer：数据流中的中位数","date":"2019-10-31","updated":"2022-11-05","comments":true,"path":"剑指Offer：数据流中的中位数/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","excerpt":"","text":"题目如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 思路 + 代码参考CyC 12345678910111213141516171819202122232425import java.util.*;public class Solution &#123; // left-最大堆 right-最小堆 private PriorityQueue&lt;Integer&gt; left = new PriorityQueue&lt;Integer&gt;((o1, o2)-&gt;o2-o1); private PriorityQueue&lt;Integer&gt; right = new PriorityQueue&lt;Integer&gt;(); private int N = 0; public void Insert(Integer num) &#123; if(N%2==0)&#123; left.add(num); right.add(left.poll()); &#125;else&#123; right.add(num); left.add(right.poll()); &#125; // N是滞后计数，表示一数据流的长度是多少 N++; &#125; public Double GetMedian() &#123; if(N%2==0)&#123; return (left.peek()+right.peek())/2.0; &#125;else&#123; return (double)right.peek(); &#125; &#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：二叉搜索树的第k个结点","slug":"剑指Offer：二叉搜索树的第k个结点","date":"2019-10-30","updated":"2022-11-05","comments":true,"path":"剑指Offer：二叉搜索树的第k个结点/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/","excerpt":"","text":"题目给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 思路 + 代码其实就是二叉搜索树的中序遍历翻版。 1234567891011121314151617181920212223242526272829303132333435/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; private int cnt; private TreeNode node; TreeNode KthNode(TreeNode pRoot, int k) &#123; if(k&lt;1) return null; cnt = 0; inOrder(pRoot, k); return node; &#125; private void inOrder(TreeNode pRoot, int k)&#123; if(cnt&gt;=k || pRoot==null) return; inOrder(pRoot.left, k); cnt++; if(cnt==k)&#123; node = pRoot; &#125; inOrder(pRoot.right, k); &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sunyunzeng.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：序列化二叉树","slug":"剑指Offer：序列化二叉树","date":"2019-10-30","updated":"2022-11-05","comments":true,"path":"剑指Offer：序列化二叉树/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"题目请实现两个函数，分别用来序列化和反序列化二叉树 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。 二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。 思路 + 代码递归序列化与递归反序列化。 123456789101112131415161718192021222324252627282930313233343536373839/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; private String deserializeStr; String Serialize(TreeNode root) &#123; if(root==null) return &quot;#&quot;; return root.val + &quot; &quot; + Serialize(root.left) + &quot; &quot; + Serialize(root.right); &#125; TreeNode Deserialize(String str) &#123; deserializeStr = str; return Deserialize(); &#125; TreeNode Deserialize()&#123; if(deserializeStr.length()==0) return null; int index = deserializeStr.indexOf(&quot; &quot;); String node = index==-1?deserializeStr:deserializeStr.substring(0, index); deserializeStr = index==-1?&quot;&quot;:deserializeStr.substring(index+1); if(node.equals(&quot;#&quot;)) return null; int val = Integer.valueOf(node); TreeNode root = new TreeNode(val); root.left = Deserialize(); root.right = Deserialize(); return root; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sunyunzeng.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：按之字形顺序打印二叉树","slug":"剑指Offer：按之字形顺序打印二叉树","date":"2019-10-29","updated":"2022-11-05","comments":true,"path":"剑指Offer：按之字形顺序打印二叉树/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"题目请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 思路 + 代码其实就是二叉树层次遍历的变体。 遍历过程中，如果是二叉树的偶数层，就顺序遍历；否则逆序遍历。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.ArrayList;/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/import java.util.*;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); if(pRoot == null) return res; int layer = 0; int location = 0; queue.add(pRoot); while(!queue.isEmpty())&#123; int len = queue.size(); Integer[] nums = new Integer[len]; for(int i=0;i&lt;len; ++i)&#123; TreeNode tmp = queue.remove(); if(layer%2!=0) location = len-1-i; else location = i; nums[location]=tmp.val; if(tmp.left!=null) queue.add(tmp.left); if(tmp.right!=null) queue.add(tmp.right); &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Collections.addAll(list, nums); if(list.size()&gt;0) res.add(list); layer++; &#125; return res; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sunyunzeng.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：二叉树的下一个结点","slug":"剑指Offer：二叉树的下一个结点","date":"2019-10-28","updated":"2022-11-05","comments":true,"path":"剑指Offer：二叉树的下一个结点/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/","excerpt":"","text":"题目给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 思路 + 代码树的问题最容易想到的就是递归方法。 中序遍历顺序是左叶子节点、根节点、右叶子节点。 分为两种情况： 如果右子节点不为空，则递归寻找后面最左叶子节点。 如果右子节点为空，则递归在父级节点寻找。 2.1 如果父节点为空，则返回 null。 2.2 如果父节点左节点等于该节点，则返回父节点。 2.3 如果父节点右节点等于该节点，则继续递归寻找。 123456789101112131415161718192021222324252627282930313233343536373839/*public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if(pNode == null) return null; if(pNode.right!=null) return getRightNode(pNode.right); else return getParentNode(pNode); &#125; // 寻找最左节点 private TreeLinkNode getRightNode(TreeLinkNode pNode)&#123; if(pNode.left==null) return pNode; else return getRightNode(pNode.left); &#125; // 如果没有右节点，下一节点则是父级节点 private TreeLinkNode getParentNode(TreeLinkNode pNode)&#123; if(pNode.next==null) return null; if(pNode.next.left == pNode) return pNode.next; else return getParentNode(pNode.next); &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sunyunzeng.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：删除链表中重复的节点","slug":"剑指Offer：删除链表中重复的节点","date":"2019-10-27","updated":"2022-11-05","comments":true,"path":"剑指Offer：删除链表中重复的节点/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9/","excerpt":"","text":"题目在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 思路 + 代码利用递归求解，问题分解为去除下一个节点开始链表中重复的节点。 123456789101112131415161718192021222324252627/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/import java.util.*;public class Solution &#123; public ListNode deleteDuplication(ListNode pHead) &#123; if(pHead==null || pHead.next==null) return pHead; ListNode next = pHead.next; if(pHead.val==next.val)&#123; while(next!=null &amp;&amp; pHead.val == next.val) next = next.next; return deleteDuplication(next); &#125;else&#123; pHead.next = deleteDuplication(pHead.next); return pHead; &#125; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：字符流中第一个不重复的字符","slug":"剑指Offer：字符流中第一个不重复的字符","date":"2019-10-26","updated":"2022-11-05","comments":true,"path":"剑指Offer：字符流中第一个不重复的字符/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/","excerpt":"","text":"题目请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 如果当前字符流没有存在出现一次的字符，返回#字符。 思路 + 代码利用队列进行结果的存储，利用一个数组进行出现次数的统计。 队列对于其中所有出现超过两次的字符进行出栈。 123456789101112131415161718import java.util.*;public class Solution &#123; private char[] tmp = new char[256]; private Queue&lt;Character&gt; queue = new LinkedList&lt;Character&gt;(); //Insert one char from stringstream public void Insert(char ch) &#123; tmp[ch]++; queue.add(ch); while(!queue.isEmpty()&amp;&amp;tmp[queue.peek()]&gt;1) queue.poll(); &#125; //return the first appearence once char in current stringstream public char FirstAppearingOnce() &#123; return queue.isEmpty()?&#x27;#&#x27;:queue.peek(); &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：表示数值的字符串","slug":"剑指Offer：表示数值的字符串","date":"2019-10-25","updated":"2022-11-05","comments":true,"path":"剑指Offer：表示数值的字符串/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"题目请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 思路 + 代码方法1: 正则匹配123456789101112131415161718/*[] ： 字符集合() ： 分组? ： 重复 0 ~ 1 次+ ： 重复 1 ~ n 次* ： 重复 0 ~ n 次. ： 任意字符\\\\. ： 转义后的 .\\\\d ： 数字*/public class Solution &#123; public boolean isNumeric(char[] str) &#123; if(str == null || str.length == 0) return false; return new String(str).matches(&quot;[+-]?\\\\d*(\\\\.\\\\d+)?([Ee][+-]?\\\\d+)?&quot;); &#125;&#125; 方法2: 特殊情况排除 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public boolean isNumeric(char[] str) &#123; if(str == null || str.length == 0) return false; boolean hasE = false; boolean hasP = false; for(int i=0; i&lt;str.length; i++)&#123; // 首字母出现的正负号合法 if(i==0 &amp;&amp; (str[i]==&#x27;+&#x27; || str[i]==&#x27;-&#x27;)) continue; // 小数点判定（只出现一次，且不能在E（e）后面出现） if(str[i]==&#x27;.&#x27;)&#123; if(hasE || hasP) return false; hasP = true; &#125; // 指数判定，只出现一次，且不能在最后出现 else if(str[i]==&#x27;E&#x27; || str[i]==&#x27;e&#x27;)&#123; if(i==str.length-1 || hasE) return false; hasE = true; &#125; // 第二次出现只能在指数后面 else if(str[i]==&#x27;+&#x27; || str[i]==&#x27;-&#x27;)&#123; if(str[i-1]!=&#x27;E&#x27; &amp;&amp; str[i-1]!=&#x27;e&#x27;) return false; &#125; // 非法字符判定 else if(!isInteger(str[i])) return false; &#125; return true; &#125; private boolean isInteger(char c)&#123; return c &gt;=&#x27;0&#x27; &amp;&amp; c &lt;=&#x27;9&#x27;; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：正则表达式匹配","slug":"剑指Offer：正则表达式匹配","date":"2019-10-25","updated":"2022-11-05","comments":true,"path":"剑指Offer：正则表达式匹配/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","excerpt":"","text":"题目请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配。 思路 + 代码动态规划：利用一个dp(x, y)的数组表示原字符串 s[0, x) 与匹配字符串 p[0, y)是否匹配。 状态转移： 对于dp(x, y)： 如果 p(y) == ‘.’ || p(y) == s(x-1), dp(x, y)= dp(x-1, y-1)。 如果 p(y) == ‘*’ 2.1 如果 p(y-1) == s(x) || p(y-1) == ‘.’ 1) ‘‘ 复制多个：dp(x, y) = dp(x-1, y) 2) ‘‘ 复制一个：dp(x, y) = dp(x, j-1) 3) ‘*’ 复制零个：dp(x, y) = dp(x, j-2) 2.2 如果 s 为空且不满足 2.1，则 ‘*’ 复制零个：dp(x, y) = dp(x, j-2) 12345678910111213141516171819202122232425262728public class Solution &#123; public boolean match(char[] str, char[] pattern) &#123; int m = str.length+1; int n = pattern.length+1; boolean[][] dp = new boolean[m][n]; dp[0][0] = true; // 空字符串处理 for(int i=1; i&lt;n; i++) if(pattern[i-1]==&#x27;*&#x27;) dp[0][i] = dp[0][i-2]; for(int i=1; i&lt;m; i++)&#123; for(int j=1; j&lt;n; j++)&#123; if(str[i-1]==pattern[j-1] || pattern[j-1]==&#x27;.&#x27;) dp[i][j] = dp[i-1][j-1]; else if(pattern[j-1]==&#x27;*&#x27;)&#123; if(pattern[j-2]==str[i-1] || pattern[j-2]==&#x27;.&#x27;)&#123; dp[i][j] |= dp[i-1][j]; // 复制多个 dp[i][j] |= dp[i][j-1]; //复制一个 dp[i][j] |= dp[i][j-2]; // 删除一个 &#125;else dp[i][j] |= dp[i][j-2]; // 删除一个 &#125; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：扑克牌顺子","slug":"剑指Offer：扑克牌顺子","date":"2019-10-23","updated":"2022-11-05","comments":true,"path":"剑指Offer：扑克牌顺子/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/","excerpt":"","text":"题目LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 思路 + 代码首先用一个长度为13的数组统计每个数字出现的次数。 然后满足以下条件为顺子： 除大小王外所有数字出现一次。 最大值与最小值差值小于等于4，例如存在 1 跟 6 无法形成顺子。 四个癞子稳赢。 12345678910111213141516171819202122232425public class Solution &#123; public boolean isContinuous(int [] numbers) &#123; if(numbers==null || numbers.length==0) return false; int[] counts = new int[14]; for(int num: numbers) counts[num]++; int n = 0; int i=0, j=14; //四个癞子稳赢 if(counts[0]==4) return true; // 寻找最大值与最小值 while(counts[++i]==0); while(counts[--j]==0); // 例如：最小值1，最大值6肯定不行 if(Math.abs(j-i)&gt;4) return false; // 用癞子补全，如果癞子够，就可以 for(int k=i; k&lt;=j; k++) if(counts[k]&gt;1) return false; return true; &#125;&#125; 其它方法： 1234567891011121314151617181920212223import java.util.*;public class Solution &#123; public boolean isContinuous(int [] numbers) &#123; if(numbers==null || numbers.length&lt;5) return false; int count = 0; Arrays.sort(numbers); //统计癞子数量 for(int num: numbers)&#123; if(num==0) count++; else break; &#125; for(int i=count; i&lt;4; i++)&#123; // 存在重复的 if(numbers[i]==numbers[i+1]) return false; count -= numbers[i+1]-numbers[i]-1; &#125; return count&gt;=0; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：翻转单词顺序列","slug":"剑指Offer：翻转单词顺序列","date":"2019-10-22","updated":"2022-11-05","comments":true,"path":"剑指Offer：翻转单词顺序列/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97/","excerpt":"","text":"题目牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 思路 + 代码先翻转每个单词，再重头到尾进行翻转。 1234567891011121314151617181920212223242526272829public class Solution &#123; public String ReverseSentence(String str) &#123; if(str==null || str.length()==0) return str; char[] chs = str.toCharArray(); int len = chs.length; int i=0, j=0; while(j&lt;=len)&#123; // 反转单词 if(j==len || chs[j]==&#x27; &#x27;)&#123; reverse(chs, i, j-1); i=j+1; &#125; j++; &#125; // 反转整个句子 reverse(chs, 0, len-1); return new String(chs); &#125; private void reverse(char[] chs, int i, int j)&#123; while(i&lt;j) swap(chs, i++, j--); &#125; private void swap(char[] chs, int i, int j)&#123; char t = chs[i]; chs[i] = chs[j]; chs[j] = t; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：左旋字符串","slug":"剑指Offer：左旋字符串","date":"2019-10-22","updated":"2022-11-05","comments":true,"path":"剑指Offer：左旋字符串/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%B7%A6%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"题目汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 思路 + 代码先将 “abc” 和 “XYZdef” 分别翻转，得到 “cbafedZYX”，然后再把整个字符串翻转得到 “XYZdefabc”。 123456789101112131415161718192021222324public class Solution &#123; public String LeftRotateString(String str,int n) &#123; if(str==null || str.length()==0) return str; char[] chs = str.toCharArray(); int len = chs.length-1; inverse(chs, 0, n-1); inverse(chs, n ,len); inverse(chs, 0, len); return new String(chs); &#125; private void inverse(char[] chs, int i, int j)&#123; while(i&lt;j)&#123; swap(chs, i, j); i++; j--; &#125; &#125; private void swap(char[] chs, int i, int j)&#123; char t = chs[i]; chs[i] = chs[j]; chs[j] = t; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"Leetcode 2：两数相加","slug":"Leetcode-2：两数相加","date":"2019-10-21","updated":"2022-11-05","comments":true,"path":"Leetcode-2：两数相加/","link":"","permalink":"https://sunyunzeng.com/Leetcode-2%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 代码123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode pre = new ListNode(0); ListNode h = pre; int more = 0; while(l1!=null || l2!=null)&#123; int x = l1==null?0:l1.val; int y = l2==null?0:l2.val; int n = (x + y + more)%10; more = (x + y + more) / 10; h.next = new ListNode(n); if(l1!=null) l1=l1.next; if(l2!=null) l2=l2.next; h = h.next; &#125; if(more &gt;0) h.next = new ListNode(1); return pre.next; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-two-numbers著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"剑指Offer：数组中只出现一次的数字","slug":"剑指Offer：数组中只出现一次的数字","date":"2019-10-21","updated":"2022-11-05","comments":true,"path":"剑指Offer：数组中只出现一次的数字/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"题目一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 思路 + 代码思路1利用Map统计每个数字出现的次数。 123456789101112131415161718192021//num1,num2分别为长度为1的数组。传出参数//将num1[0],num2[0]设置为返回结果import java.util.*;public class Solution &#123; public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int num: array)&#123; if(!map.containsKey(num)) map.put(num, 1); else map.put(num, map.get(num)+1); &#125; for(Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet())&#123; if(entry.getValue()==1) list.add(entry.getKey()); &#125; num1[0] = list.get(0); num2[0] = list.get(1); &#125;&#125; 思路2与题目只出现一次的数字类似，利用异或的知识。 唯一不同是这次是找出两个只出现一次的数字，所以需要找到这两个不同数字的区别，然后分别异或。 123456789101112131415161718//num1,num2分别为长度为1的数组。传出参数//将num1[0],num2[0]设置为返回结果import java.util.*;public class Solution &#123; public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123; int dif=0; for(int num: array) dif ^= num; // dif=1100 -dif=0100, dif &amp;= -dif dif=0100,即只保存最右侧异或结果不同的那一位，分割数组 dif &amp;= -dif; for(int num: array)&#123; if((num &amp; dif)==0) num1[0] ^= num; else num2[0] ^= num; &#125; &#125;&#125; 类似题目","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：平衡二叉树","slug":"剑指Offer：平衡二叉树","date":"2019-10-21","updated":"2022-11-05","comments":true,"path":"剑指Offer：平衡二叉树/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"题目输入一棵二叉树，判断该二叉树是否是平衡二叉树。 思路 + 代码平衡二叉树的左右子树的高度差不大于 1。 12345678910111213141516public class Solution &#123; private boolean isBalanced = true; public boolean IsBalanced_Solution(TreeNode root) &#123; height(root); return isBalanced; &#125; private int height(TreeNode root)&#123; if(root==null || !isBalanced) return 0; int left = height(root.left); int right = height(root.right); if(1&lt;Math.abs(left-right)) isBalanced = false; return Math.max(left, right) + 1; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：数组在排序中出现的次数","slug":"剑指Offer：数组在排序中出现的次数","date":"2019-10-17","updated":"2022-11-05","comments":true,"path":"剑指Offer：数组在排序中出现的次数/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%95%B0%E7%BB%84%E5%9C%A8%E6%8E%92%E5%BA%8F%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/","excerpt":"","text":"题目统计一个数字在排序数组中出现的次数。 思路 + 代码不能遍历，否则时间超出。二分查找，寻找边界位置。 12345678910111213141516171819202122public class Solution &#123; public int GetNumberOfK(int [] array , int k) &#123; if(array==null||array.length==0) return 0; int l = binarySearch(array, k); int h = binarySearch(array, k+1); return (l&gt;array.length-1 || array[l]!=k)?0:h-l; &#125; private int binarySearch(int[] n, int k)&#123; int l = 0, r = n.length; int m; while(l&lt;r)&#123; m = (r+l)/2; if(n[m]&gt;=k) // 保证最后的位置等于或小于查找的元素 r=m; else l=m+1; &#125; return l; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：两个链表的第一个公共结点","slug":"剑指Offer：两个链表的第一个公共结点","date":"2019-10-17","updated":"2022-11-05","comments":true,"path":"剑指Offer：两个链表的第一个公共结点/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/","excerpt":"","text":"题目输入两个链表，找出它们的第一个公共结点。 思路 + 代码设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。 当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。 1234567891011121314151617181920/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; ListNode l1 = pHead1; ListNode l2 = pHead2; while(l1!=l2)&#123; l1 = l1==null?pHead2:l1.next; l2 = l2==null?pHead1:l2.next; &#125; return l1; &#125;&#125; 参考","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：数组中的逆序对","slug":"剑指Offer：数组中的逆序对","date":"2019-10-17","updated":"2022-11-05","comments":true,"path":"剑指Offer：数组中的逆序对/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/","excerpt":"","text":"题目在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 题目描述: 123456789题目保证输入的数组中没有的相同的数字数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 示例112345输入1,2,3,4,5,6,7,0输出7 思路归并排序，先拆分成单个的数字，然后向上归并同时统计逆数数量。 12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; private int count = 0; public int InversePairs(int [] array) &#123; if(array==null || array.length==0) return -1; mergeSort(array, 0, array.length-1); return count; &#125; private void mergeSort(int[] nums, int left, int right)&#123; if(left&gt;=right) return; int l = left, r = right, m = (left + right)/2; mergeSort(nums, l, m); mergeSort(nums, m+1, r); merge(nums, l, m, r); &#125; private void merge(int[] nums, int left, int mid, int right)&#123; int len = right-left; int[] tmp = new int[len+1]; int l = mid, r = right; while(l &gt;= left &amp;&amp; r &gt;= mid+1)&#123; if(nums[l]&gt;nums[r])&#123; count += (r-mid); tmp[len--] = nums[l--]; if(count &gt;= 1000000007) count %= 1000000007; &#125;else&#123; tmp[len--] = nums[r--]; &#125; &#125; // 上述判定并不能概括所有的情况，因此用两个循环继续完成辅助数组tmp while(l &gt;= left) tmp[len--] = nums[l--]; while(r &gt;= mid+1) tmp[len--] = nums[r--]; // 排序 for(int i=0; i&lt;tmp.length; i++) nums[left+i] = tmp[i]; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：第一个只出现一次的字符","slug":"剑指Offer：第一个只出现一次的字符","date":"2019-10-15","updated":"2022-11-05","comments":true,"path":"剑指Offer：第一个只出现一次的字符/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/","excerpt":"","text":"题目在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 思路 + 代码用一个LinkedHashMap统计每个字符出现的次数，同时保存顺序。然后String查找该字符第一次出现的位置。 12345678910111213141516171819202122import java.util.*;public class Solution &#123; public int FirstNotRepeatingChar(String str) &#123; if(str==null || str.length()==0) return -1; char[] chs = str.toCharArray(); LinkedHashMap&lt;Character, Integer&gt; map = new LinkedHashMap&lt;Character, Integer&gt;(); int len = chs.length; for(int i=0; i&lt;len; i++)&#123; if(!map.containsKey(chs[i]))&#123; map.put(chs[i], 1); &#125;else&#123; map.put(chs[i], map.get(chs[i])+1); &#125; &#125; for(Map.Entry&lt;Character, Integer&gt; entry: map.entrySet())&#123; if(entry.getValue()==1) return str.indexOf(entry.getKey()); &#125; return -1; &#125;&#125; 或者可以用一个数组来模拟Map。 1234567891011121314151617import java.util.*;public class Solution &#123; public int FirstNotRepeatingChar(String str) &#123; if(str==null || str.length()==0) return -1; int[] counts = new int[256]; int len = str.length(); for(int i=0; i&lt;len; i++)&#123; counts[str.charAt(i)]++; &#125; for(int i=0; i&lt;len; i++)&#123; if(counts[str.charAt(i)]==1) return i; &#125; return -1; &#125;&#125; 空间复杂度可以继续优化，用两个Bitset分别表示出现一次和出现一次及以上。 12345678910111213141516171819202122232425262728import java.util.*;public class Solution &#123; public int FirstNotRepeatingChar(String str) &#123; if(str==null || str.length()==0) return -1; int len = str.length(); char[] chs = str.toCharArray(); BitSet bs1 = new BitSet(256); BitSet bs2 = new BitSet(256); for(char c: chs)&#123; if(!bs1.get(c) &amp;&amp; !bs2.get(c))&#123; // 出现一次 bs1.set(c); &#125;else if(bs1.get(c) &amp;&amp; !bs2.get(c))&#123; // 出现一次以上 bs2.set(c); &#125; &#125; for(int i=0; i&lt;len; i++)&#123; char c = str.charAt(i); if(bs1.get(c) &amp;&amp; !bs2.get(c)) return i; &#125; return -1; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：丑数","slug":"剑指Offer：丑数","date":"2019-10-15","updated":"2022-11-05","comments":true,"path":"剑指Offer：丑数/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E4%B8%91%E6%95%B0/","excerpt":"","text":"题目把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 思路 ＋ 代码丑数只能是丑数乘以 2、３、５。 按照顺序存储丑数，也就是比较每次丑数的大小。 1234567891011121314151617181920public class Solution &#123; public int GetUglyNumber_Solution(int index) &#123; if(index &lt;= 0) return 0; int[] dp = new int[index]; dp[0] = 1; int i2 = 0, i3 = 0, i5 = 0; for(int i=1; i&lt;index; i++)&#123; dp[i] = Math.min(Math.min(dp[i2]*2, dp[i3]*3), dp[i5]*5); //-----here is three &quot;if&quot; judge，rather tha “if else”----- if(dp[i] == dp[i2]*2) i2++; if(dp[i] == dp[i3]*3) i3++; if(dp[i] == dp[i5]*5) i5++; &#125; return dp[index-1]; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：把数组排成最小的数","slug":"剑指Offer：把数组排成最小的数","date":"2019-10-14","updated":"2022-11-05","comments":true,"path":"剑指Offer：把数组排成最小的数/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/","excerpt":"","text":"题目输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 思路 + 代码字符串的排序。 123456789101112131415161718import java.util.*;public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123; if(numbers==null || numbers.length==0)&#123; return &quot;&quot;; &#125; int len = numbers.length; String[] strs = new String[len]; for(int i=0; i&lt;len; i++) strs[i] = numbers[i]+&quot;&quot;; Arrays.sort(strs, (a, b)-&gt;(a+b).compareTo(b+a)); StringBuilder sb = new StringBuilder(); for(String s: strs) sb.append(s); return sb.toString(); &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：整数中1出现的次数","slug":"剑指Offer：整数中1出现的次数","date":"2019-10-14","updated":"2022-11-05","comments":true,"path":"剑指Offer：整数中1出现的次数/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/","excerpt":"","text":"题目求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 思路 + 代码暴力穷举会超出时间，这道题的关键是找规律。 [图片来自LeetCode 233](https://leetcode-cn.com/problems/number-of-digit-one/solution/shu-zi-1-de-ge-shu-by-leetcode/) 一个数字，分解为十位、百位、千位…上来看。 因为数字由1~n组成，既有十位、百位、千位等组成。 首先，每十个数，个位数字出现一次。每百位数，个位数字出现十次… n/(i*10)*i, i=1, 10, 100, ... 其次，对于后面的数，例如1611，从百位数来看，前面的数字 1611/100*10=160, 后面数字为11，因此后面的个位数为 1+1=2， 而1620和1650后面的个位数字都是10个，因此后面个位数字： max(min(n%(i*10)-i+1,0),i) 12345678910import java.lang.Math;public class Solution &#123; public int NumberOf1Between1AndN_Solution(int n) &#123; int count = 0; for(int i=1; i&lt;=n; i*=10)&#123; count += n/(i*10)*i + Math.min(Math.max(n%(i*10)-i+1,0),i); &#125; return count; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：最小的K个数","slug":"剑指Offer：最小的K个数","date":"2019-10-13","updated":"2022-11-05","comments":true,"path":"剑指Offer：最小的K个数/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/","excerpt":"","text":"题目输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 思路1 + 代码维护一个最小堆，该最小堆即为所求。 类似题目 1234567891011121314import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; if(input==null || input.length==0 || k&gt;input.length) return new ArrayList&lt;Integer&gt;(); PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;Integer&gt;((o1, o2) -&gt; o2-o1); for(int num:input)&#123; pq.add(num); if(pq.size()&gt;k) pq.poll(); &#125; return new ArrayList&lt;Integer&gt;(pq); &#125;&#125; 思路2 + 代码该题完全可以先排序后取最小的K个数。 因此排序方法的选取很重要。 ## 冒泡方法 只用排k个最小值即可，因此最外圈循环K次。 1234567891011121314151617181920import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; if(input==null || input.length==0 || k&gt;input.length) return new ArrayList&lt;Integer&gt;(); int len = input.length; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); for(int i=1; i&lt;k+1; i++)&#123; for(int j=0; j&lt;len-i; j++)&#123; if(input[j]&lt;=input[j+1])&#123; int tmp = input[j]; input[j] = input[j+1]; input[j+1] = tmp; &#125; &#125; res.add(input[len-i]); &#125; return res; &#125;&#125; ## 快速排序 快排关键在于基准的选择，大于基准的数放于一边，小于基准的数放在另一边。 我们的标准是划分的位置刚好是在第k个位置，这样 k 位置之前的数组都为排序好的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; if(input==null || input.length==0 || k&gt;input.length) return new ArrayList&lt;Integer&gt;(); int len = input.length; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); sort(input, 0, input.length-1, k-1); for(int i=0; i&lt;k; i++)&#123; res.add(input[i]); &#125; return res; &#125; private void sort(int[] input, int low, int high, int k)&#123; int l = low; int h = high; while(l&lt;h)&#123; int tmp = partition(input, l, h); if(tmp==k) break; if(tmp&gt;k)&#123; h = tmp-1; &#125;else&#123; l = tmp+1; &#125; &#125; &#125; private int partition(int[] input, int l, int h)&#123; int criterion = input[h]; int i = l-1; int j = h; while(true)&#123; while(i&lt;j &amp;&amp; input[++i]&lt;criterion); while(i&lt;j &amp;&amp; input[--j]&gt;criterion); if(i&gt;=j) break; swap(input, i, j); &#125; swap(input,i, h); return i; &#125; private void swap(int[] arr, int a, int b)&#123; int tmp = arr[a]; arr[a] = arr[b]; arr[b] = tmp; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：字符串的排列","slug":"剑指Offer：字符串的排列","date":"2019-10-10","updated":"2022-11-05","comments":true,"path":"剑指Offer：字符串的排列/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/","excerpt":"","text":"题目输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 输入描述： 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 思路 + 代码典型回溯法，同 全排列 解法类似。 123456789101112131415161718192021222324252627import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;(); backtracking(res, str.toCharArray(), new StringBuilder(), new boolean[str.length()]); return res; &#125; private void backtracking(ArrayList&lt;String&gt; res, char[] chs, StringBuilder sbd, boolean[] used)&#123; if(chs==null || chs.length==0) return; else&#123; if(chs.length==sbd.length())&#123; res.add(new String(sbd.toString())); &#125;else&#123; for(int i=0; i&lt;chs.length; i++)&#123; if(used[i] || i&gt;0&amp;&amp;chs[i]==chs[i-1]&amp;&amp;!used[i-1]) continue; sbd.append(chs[i]); used[i] = true; backtracking(res, chs, sbd, used); sbd.deleteCharAt(sbd.length()-1); used[i] = false; &#125; &#125; &#125; &#125;&#125; 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"Leetcode 46.全排列","slug":"Leetcode-46-全排列","date":"2019-10-10","updated":"2022-11-05","comments":true,"path":"Leetcode-46-全排列/","link":"","permalink":"https://sunyunzeng.com/Leetcode-46-%E5%85%A8%E6%8E%92%E5%88%97/","excerpt":"","text":"题目给定一个没有重复数字的序列，返回其所有可能的全排列。 示例：12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 思路 + 代码回溯问题。 如果遇到一个问题，不用穷举所有情况找不出答案，就采用回溯。 回溯是DFS的一种，遍历完一条路径后，回退一步，继续寻找下一可能路径。 它与暴力法的区别在于，可以通过剪枝规避掉很多无意义的尝试，且不用每次都从头开始遍历到尾部。 讲解可以参考https://www.cis.upenn.edu/~matuszek/cit594-2012/Pages/backtracking.html 12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); backtracking(res, new ArrayList&lt;Integer&gt;(), nums, new boolean [nums.length]); return res; &#125; // used访问标志防止重复使用 private void backtracking(List&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; arr, int[] nums, boolean[] used)&#123; if(nums==null || nums.length==0)&#123; res.add(arr); return; &#125; if(arr.size()==nums.length)&#123; res.add(new ArrayList&lt;Integer&gt;(arr)); return; &#125;else&#123; for(int i=0; i&lt;nums.length; i++)&#123; if(used[i]) continue; arr.add(nums[i]); used[i] = true; backtracking(res, arr, nums, used); arr.remove(arr.size()-1); used[i] = false; &#125; &#125; &#125;&#125; 回溯例题参考 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/permutations著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"回溯法","slug":"回溯法","permalink":"https://sunyunzeng.com/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"}]},{"title":"剑指Offer：二叉搜索树与双向链表","slug":"剑指Offer：二叉搜索树与双向链表","date":"2019-10-10","updated":"2022-11-05","comments":true,"path":"剑指Offer：二叉搜索树与双向链表/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路 + 代码二叉搜索树的中序遍历即为一个排序的顺序，按照该顺序依次构建双向链表即可。 123456789101112131415161718192021222324252627282930313233343536/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; private TreeNode firstHead = null; private TreeNode preHead = null; public TreeNode Convert(TreeNode pRootOfTree) &#123; if(pRootOfTree==null) return null; // 整个遍历过程与中序遍历相同 // 遍历到最左侧叶子节点，即最小的叶子节点 Convert(pRootOfTree.left); // 第一次将头指针指向最小叶子节点（处理中间节点pRootOfTree） if(preHead==null)&#123; preHead = pRootOfTree; firstHead = pRootOfTree; &#125;else&#123; pRootOfTree.left=preHead; preHead.right = pRootOfTree; preHead = pRootOfTree; &#125; // 右节点 Convert(pRootOfTree.right); return firstHead; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sunyunzeng.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：复杂链表的复制","slug":"剑指Offer：复杂链表的复制","date":"2019-10-10","updated":"2022-11-05","comments":true,"path":"剑指Offer：复杂链表的复制/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/","excerpt":"","text":"题目输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 思路 + 代码参考 https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%2030~39.md#35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6 分为三步： 1. 在每个节点的后面插入复制的节点。 2. 每个复制的节点 random 赋值。 3. 拆分。 12345678910111213141516171819202122232425262728293031323334353637383940414243/*public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125;*/public class Solution &#123; public RandomListNode Clone(RandomListNode pHead) &#123; if(pHead == null) return null; RandomListNode cur = pHead; // 先在链表中间插入节点 while(cur!=null)&#123; RandomListNode tmp = new RandomListNode(cur.label); tmp.next = cur.next; cur.next = tmp; cur = tmp.next; &#125; // 然后中间节点的 random 指针赋值 cur = pHead; while(cur!=null)&#123; if(cur.random!=null) // 这里是当前节点 random 链接的下一个为复制节点的 random 链接 cur.next.random = cur.random.next; cur = cur.next.next; &#125; // 两个链表分离 cur = pHead; RandomListNode res = cur.next; while(cur.next!=null)&#123; RandomListNode tmp = cur.next; cur.next = tmp.next; cur = tmp; &#125; return res; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：二叉树和为某一值的路径","slug":"剑指Offer：二叉树和为某一值的路径","date":"2019-10-08","updated":"2022-11-05","comments":true,"path":"剑指Offer：二叉树和为某一值的路径/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/","excerpt":"","text":"题目输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 思路 + 代码递归求解，左右子树分别遍历（深度优先）。 遍历终止条件为节点为null或者是叶子节点且和为目标值。 否则回退列表，寻找更短的路径。 1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res; private ArrayList&lt;Integer&gt; list; public Solution()&#123; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); list = new ArrayList&lt;Integer&gt;(); &#125; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; if(root==null) return res; target = target - root.val; list.add(root.val); if(target==0&amp;&amp;root.right==null&amp;&amp;root.left==null)&#123; res.add(new ArrayList&lt;Integer&gt;(list)); &#125; FindPath(root.left, target); FindPath(root.right, target); list.remove(list.size()-1); return res; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sunyunzeng.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：二叉搜索树的后序遍历序列","slug":"剑指Offer：二叉搜索树的后序遍历序列","date":"2019-10-06","updated":"2022-11-05","comments":true,"path":"剑指Offer：二叉搜索树的后序遍历序列/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/","excerpt":"","text":"题目输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 思路 + 代码二叉搜索树的左子树所有节点小于根节点，右子树的所有节点大于根节点。 后序遍历是先访问左子树，后访问右子树。 因此，根节点永远在序列的最后位置。找到根节点数值后，根据前面节点数值与根节点的大小关系，找到左右子树的分割位置，递归求解。 123456789101112131415161718192021222324252627public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; // 初始条件判断 if(sequence==null || sequence.length==0) return false; // 调用重写的辅助函数 return VerifySquenceOfBST(sequence, 0, sequence.length-1); &#125; private boolean VerifySquenceOfBST(int[] sequence, int start, int end)&#123; // 递归截止条件 if(start &gt;= end) return true; // 寻找分割节点 int currentCutIndex = start; while(sequence[currentCutIndex]&lt;sequence[end])&#123; currentCutIndex++; &#125; // 如果右子树存在小于根节点的节点，则该序列不是二叉搜索树的后序遍历 for(int i=currentCutIndex; i&lt;end; i++)&#123; if(sequence[i]&lt;sequence[end]) return false; &#125; // 左右子树递归寻找 return VerifySquenceOfBST(sequence, start, currentCutIndex-1) &amp;&amp; VerifySquenceOfBST(sequence, currentCutIndex, end-1); &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sunyunzeng.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：从上往下打印二叉树","slug":"剑指Offer-从上往下打印二叉树","date":"2019-10-06","updated":"2022-11-05","comments":true,"path":"剑指Offer-从上往下打印二叉树/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"题目从上往下打印出二叉树的每个节点，同层节点从左至右打印。 思路 + 代码二叉树的层次遍历，用队列保存同一层次的树节点，然后依次遍历。 类似题目http://sunyunzeng.com/Leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/ 1234567891011121314151617181920212223242526272829303132333435import java.util.*;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if(root==null) return list; queue.add(root); while(!queue.isEmpty())&#123; int len = queue.size(); for(int i=0; i&lt;len; i++)&#123; root = queue.remove(); list.add(root.val); if(root.left!=null) queue.add(root.left); if(root.right!=null) queue.add(root.right); &#125; &#125; return list; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer：矩阵中的路径","slug":"矩阵中的路径","date":"2019-10-02","updated":"2022-11-05","comments":true,"path":"矩阵中的路径/","link":"","permalink":"https://sunyunzeng.com/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/","excerpt":"","text":"题目请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 思路 + 代码没有接触过类似的题型，因此看了讲解。 题目给出的是待查询的矩阵字符串与对应的行与列。 首先需要转化为矩阵。 然后利用回溯法，起始点依次选择矩阵中的每一个位置，上下左右进行遍历。 需要设置一个哨兵矩阵，记录已经访问的，防止重复访问产生无限循环。思想跟http://sunyunzeng.com/Leetcode-%E5%B2%9B%E5%B1%BF%E6%9C%80%E5%A4%A7%E7%9A%84%E9%9D%A2%E7%A7%AF/类似。 判定成功条件：回溯的路径长度与查询路径长度一致。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Solution &#123; private int[][] next = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; private int rows; private int cols; public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; if(rows&lt;=0 || cols&lt;=0) return false; this.rows = rows; this.cols = cols; char[][] m = getMatrix(matrix); boolean[][] visit = new boolean[rows][cols]; for(int i=0; i&lt;rows; i++) for(int j=0; j&lt;cols; j++) if(backtrace(m, str, i, j, 0, visit)) return true; return false; &#125; private boolean backtrace(char[][] matrix, char[] str, int r, int c, int pathLen, boolean[][] visit)&#123; // 边界判断 if(pathLen==str.length) return true; if(r&lt;0 || r&gt;rows-1 || c&lt;0 || c&gt;cols-1 || str[pathLen]!=matrix[r][c] || visit[r][c]) return false; // 当前格子设定为已访问，防止重复访问 visit[r][c] = true; for(int[] step: next)&#123; // 递归回溯，只要找到一个字符满足要求，就返回true if(backtrace(matrix, str, r+step[0], c+step[1], pathLen+1, visit)) return true; &#125; // 此路不通，格子回归初始状态，重新选择起始格子 visit[r][c] = false; return false; &#125; // 根据一维字符数组生成二维矩阵 private char[][] getMatrix(char[] matrix)&#123; char[][] res = new char[rows][cols]; int s = 0; for(int i=0; i&lt;rows; i++) for(int j=0; j&lt;cols; j++)&#123; res[i][j] = matrix[s]; s++; &#125; return res; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"},{"name":"回溯法","slug":"回溯法","permalink":"https://sunyunzeng.com/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"}]},{"title":"设计模式：Java枚举类与注解","slug":"设计模式：Java枚举类与注解","date":"2019-09-30","updated":"2022-11-05","comments":true,"path":"设计模式：Java枚举类与注解/","link":"","permalink":"https://sunyunzeng.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AJava%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"枚举类替代整形常量枚举类的基本形式如下：12public enum Apple &#123; FUJI, PIPPIN, GRANNY_SMITH &#125;public enum Orange &#123; NAVEL, TEMPLE, BLOOD &#125; enum关键字指明一个类继承 abstractEnum。 该类有两个重要的方法： ordinal(). 返回整形序列值（从0开始） 1234567public enum Season&#123; SPRING, SUMMER, FALL, WINTER&#125;System.out.println(Season.SPRING.ordinal())// 打印 0 Enum(). 只能被继承Enum的类调用的构造方法，枚举类中每个实例调用该方法实现赋值，每个实例的构造方法都是私有的。 1234protected Enum(String name, int ordinal) &#123; this.name = name; this.ordinal = ordinal; &#125; 枚举类的特征1. 不能被继承其它类也不能被其他类继承，但可以实现接口，对枚举类内部实例进行组织。12345678910111213141516171819202122interface Info&#123; public String getName();&#125;public enum Season implements Info&#123; SPRING(&quot;春天&quot;), SUMMER(&quot;夏天&quot;), FALL(&quot;秋天&quot;), WINTER(&quot;冬天&quot;); // 必须为private的构造器，因为枚举类本身是final的，其内部实例也是final，且在枚举类生成同时调用私有的构造器实现值的赋予 private String name; private Season()&#123;&#125; private Season(String name)&#123; this name = name; &#125; // 实现接口，每个实例都有该接口，可以返回对应的中文名称 public String getName( return name; ); @test System.out.println(Season.SPRING.getName()); // 打印 春天&#125; 2. 类中每个实例可以重写其中定义的抽象方法 12345678910111213141516171819public enum Season implements&#123; SPRING(public String getName(return &quot;春天&quot;), SUMMER(public String getName(return &quot;夏天&quot;)), FALL(public String getName(return &quot;秋天&quot;)), WINTER(public String getName(return &quot;冬天&quot;)); // 必须为每个实例都重写抽象方法，否则报错 private String name; private Season()&#123;&#125; private Season(String name)&#123; this name = name; &#125; // 实现接口，每个实例都有该接口，可以返回对应的中文名称 public abstract String getName(); @test System.out.println(Season.SPRING.getName()); // 打印 春天&#125; 3. 可利用枚举实现单例12345678910public enmu Sigleton&#123; SINGLETON; public String method()&#123; return &quot;method&quot;; &#125;&#125;@testSystem.out.println(Singleton.SINGLETON.method())// 打印 method 4. 调用values()方法遍历枚举类型中的每个实例123for(Season season: Season.values)&#123; System.out.println(season.getName());&#125; 嵌套枚举 12345678910111213141516171819202122232425262728293031323334353637// The strategy enum patternenum PayrollDay &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY(PayType.WEEKEND), SUNDAY(PayType.WEEKEND); private final PayType payType; PayrollDay(PayType payType) &#123; this.payType = payType; &#125; PayrollDay() &#123; this(PayType.WEEKDAY); &#125; // Default int pay(int minutesWorked, int payRate) &#123; return payType.pay(minutesWorked, payRate); &#125; // The strategy enum type private enum PayType &#123; WEEKDAY &#123; int overtimePay(int minsWorked, int payRate) &#123; return minsWorked &lt;= MINS_PER_SHIFT ? 0 : (minsWorked - MINS_PER_SHIFT) * payRate / 2; &#125; &#125;, WEEKEND &#123; int overtimePay(int minsWorked, int payRate) &#123; return minsWorked * payRate / 2; &#125; &#125;; abstract int overtimePay(int mins, int payRate); private static final int MINS_PER_SHIFT = 8 * 60; int pay(int minsWorked, int payRate) &#123; int basePay = minsWorked * payRate; return basePay + overtimePay(minsWorked, payRate); &#125; &#125;&#125; 实例属性代替内置序数内置序数会随枚举内部类位置而改变，通过在内部类的实例属性实现标记与类的一一对应。 12345678910public enum Ensemble &#123; SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5), SEXTET(6), SEPTET(7), OCTET(8), DOUBLE_QUARTET(8), NONET(9), DECTET(10), TRIPLE_QUARTET(12); private final int numberOfMusicians; Ensemble(int size) &#123; this.numberOfMusicians = size; &#125; public int numberOfMusicians() &#123; return numberOfMusicians; &#125;&#125; 按位属性替换为EnumSet替代前: 123456789class Test&#123; public static final int STYLE_BOLD = 1 &lt;&lt; 0; // 1 public static final int STYLE_ITALIC = 1 &lt;&lt; 1; // 2 public static final int STYLE_UNDERLINE = 1 &lt;&lt; 2; // 4 public static final int STYLE_STRIKETHROUGH = 1 &lt;&lt; 3; // 8 // Parameter is bitwise OR of zero or more STYLE_ constants public void applyStyles(int styles) &#123; ... &#125;&#125; 修改后： 1234567891011// EnumSet - a modern replacement for bit fieldspublic class Text &#123; public enum Style &#123; BOLD, ITALIC, UNDERLINE, STRIKETHROUGH &#125; // Any Set could be passed in, but EnumSet is clearly best public void applyStyles(Set&lt;Style&gt; styles) &#123; ... &#125;&#125;// ----------------------------------------------------------------text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC)); 使用EnumMap123456789101112131415161718192021222324252627class Plant &#123; enum LifeCycle &#123; ANNUAL, PERENNIAL, BIENNIAL &#125; final String name; final LifeCycle lifeCycle; Plant(String name, LifeCycle lifeCycle) &#123; this.name = name; this.lifeCycle = lifeCycle; &#125; @Override public String toString() &#123; return name; &#125;&#125;// Using an EnumMap to associate data with an enumMap&lt;Plant.LifeCycle, Set&lt;Plant&gt;&gt; plantsByLifeCycle = new EnumMap&lt;&gt;(Plant.LifeCycle.class);for (Plant.LifeCycle lc : Plant.LifeCycle.values()) plantsByLifeCycle.put(lc, new HashSet&lt;&gt;());for (Plant p : garden) plantsByLifeCycle.get(p.lifeCycle).add(p);System.out.println(plantsByLifeCycle);","categories":[{"name":"Java","slug":"Java","permalink":"https://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://sunyunzeng.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"剑指Offer: 顺时针打印矩阵","slug":"剑指Offer-顺时针打印矩阵","date":"2019-09-30","updated":"2022-11-05","comments":true,"path":"剑指Offer-顺时针打印矩阵/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/","excerpt":"","text":"题目输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 思路 + 代码制造一个子函数，用来打印每一层。函数接收的参数是需要打印的行数跟列数，以及起始打印的位置（都是 n * n）。 特殊情况处理：打印行列错误、数组为空、单行或单列数组 1234567891011121314151617181920212223242526272829303132333435363738import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); printArr(matrix.length, matrix[0].length, 0, matrix, res); return res; &#125; private void printArr(int I,int J,int s,int[][] arr, ArrayList&lt;Integer&gt; res)&#123; if(I&lt;=0 || J&lt;=0 || arr==null || arr.length==0 || arr[0].length==0) return; if(I==1)&#123; for(int i=0; i&lt;J;i++)&#123; res.add(arr[s][s+i]); &#125; return; &#125; if(J==1)&#123; for(int i=0; i&lt;I;i++)&#123; res.add(arr[s+i][s]); &#125; return; &#125; for(int i=0; i&lt;J;i++)&#123; res.add(arr[s][s+i]); &#125; for(int i=1;i&lt;I;i++)&#123; res.add(arr[s+i][s+J-1]); &#125; for(int i=J-1; i&gt;0; i--)&#123; res.add(arr[s+I-1][s+i-1]); &#125; for(int i=I-1; i&gt;1; i--)&#123; res.add(arr[s+i-1][s]); &#125; printArr(I-2,J-2,s+1,arr, res); return; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer 树的子结构","slug":"剑指Offer-树的子结构","date":"2019-09-29","updated":"2022-11-05","comments":true,"path":"剑指Offer-树的子结构/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/","excerpt":"","text":"树的子结构输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 思路 + 代码涉及到二叉树相关的问题，首先想到是剑指O剑指递归。 由于二叉树是否为子树的判断，涉及到是否为 null的判断，因此需要建立子判定函数，避免空树情况产生干扰。 判断条件： 如果当前树节点与待判断树节点数值相同，则继续进行左右树的数值判断。直到两树中某一树为空。 否则分别对当前树的子树与右树跟带判断子树进行判定。 123456789101112131415161718192021222324252627282930313233/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; if(root1==null || root2==null) return false; // 不能只判断当前第一个节点，如果首节点是伪相等，就是错误的 return isSubtree(root1, root2)|| isSubtree(root1.left, root2)||isSubtree(root1.right, root2); &#125; private boolean isSubtree(TreeNode root1,TreeNode root2)&#123; if(root2==null) return true; if(root1==null) return false; if(root1.val==root2.val)&#123; return (isSubtree(root1.left, root2.left) &amp;&amp; isSubtree(root1.right, root2.right)); &#125;else&#123; return (isSubtree(root1.left, root2) || isSubtree(root1.right, root2)); &#125; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"设计模式: Java泛型","slug":"设计模式-Java泛型","date":"2019-09-28","updated":"2022-11-05","comments":true,"path":"设计模式-Java泛型/","link":"","permalink":"https://sunyunzeng.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Java%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"不要使用原始类型原始类型是Java(5之前)的历史遗留问题，之前集合对于类型在编译期间不进行检查，而在运行期进行类型检查。 这导致问题的定位困难，降低效率。 此后采用泛型解决这个问题，保证在编译期间进行检查。 例如List 类型是原始类型，而List&lt; E &gt;是泛型类型，指定了参数化类型为 E 类型。 List表明可以存储任何类型的对象，List&lt; E &gt; 是它的子类型，可以转化为List类型，但是丧失了安全性检查；而List&lt; E &gt; 却不是List&lt; Object &gt; 的子类型。List&lt; Object &gt; 只能是List&lt; Object &gt; 。 如果想实现类似于List等存储任何类型的对象， 可以利用无限制通配符类型（unbounded wildcard types）表示泛型类型，即List&lt; ? &gt; 。 泛型的几个注意点： 1. 类字面常量不允许使用泛型 数组String[].class、基本类型int.class、不带参数化类型的类List.class可以使用。 2. instanceof 只能对无限制通配符类型的参数化类型的类或接口使用。 123if(o instanceof Set)&#123; Set&lt;?&gt; s = (Set&lt;?&gt;) o;&#125; 术语 中文含义 举例 Parameterized type 参数化类型 List&lt; String &gt; Actual type parameter 实际类型参数 String Generic type 泛型类型 List&lt; E &gt; Formal type parameter 形式类型参数 E Unbounded wildcard type 无限制通配符类型 List&lt;?&gt; Raw type 原始类型 List Bounded type parameter 限制类型参数 &lt; E extends Number&gt; Recursive type bound 递归类型限制 &lt; T extends Comparable&lt; T &gt;&gt; Bounded wildcard type 限制通配符类型 List&lt;? extends Number&gt; Generic method 泛型方法 static &lt; E &gt; List&lt; E &gt; asList(E[] a) Type token 类型令牌 String.class 列表优先于数组即List优先于数组。 因为数组是协变类型的，所以下面代码编译期间是合法的, 但是运行期间是违法的。 12Object[] o = new String[1];o[1] = 1; 尽量使用列表来在编译过程中就确保安全性，虽然会损失掉一定的性能与简洁性。 下面代码运行有警告，因为java程序中的泛型信息在编译后会进行擦除（这意味着它们只在编译时执行类型约束，并在运行时丢弃它们的元素类型信息），为了与Java5之前的代码共存。 因此实际在运行中虚拟机并不知道返回数组具体类型，返回的类型是顶层类 Object, 在强制转换为T[]时会有问题。 123public Chooser(Collection&lt;T&gt; choices) &#123; choiceArray = (T[]) choices.toArray();&#125; 因此最好采用List替代。 123public Chooser(Collection&lt;T&gt; choices) &#123; choiceList = new ArrayList&lt;&gt;(choices);&#125; 优先考虑泛型一个简单实现的栈，原始版本 vs 添加泛型版本。 原始版本12345678910111213141516171819202122232425262728293031class Stack&#123; // 存储数量 private int size = 0; // 默认长度 private static final int DEFAULT_INITIAL_CAPACITY; // 元素桶 private Object[] elements; public Stack&#123; elements = new Object[DEFAULT_INITIAL_CAPACITY]; &#125; public void push(Object e)&#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop()&#123; if(size==0) throw new EmptyStackException(); Object res = elements[--size]; // 清除无用的引用 elements[size] = null; return res; &#125; private ensureCapacity()&#123; if(elements.length==size) elements = Arrays.copyOf(elements, size*2+1); &#125;&#125;这样的版本Stack每次取出元素都要进行强制类型转换。 泛型版本 1234567891011121314151617181920212223242526272829303132333435363738class Stack&lt;E&gt;&#123; // 存储数量 private int size = 0; // 默认长度 private static final int DEFAULT_INITIAL_CAPACITY; // 元素桶 private E[] elements; // 确保强制转换是安全的。有问题的数组（元素）保存在一个私有属性中，永远不会返回给客户端或传递给任何其他方法。 保存在数组中的唯一元素是那些传递给 push 方法的元素，它们是 E 类型的，所以未经检查的强制转换不会造成任何伤害 @SuppressWarnings(&quot;unchecked&quot;) public Stack()&#123; // 强制类型转换，因为无法创建泛型数组 new E[DEFAULT_INITIAL_CAPACITY]; elements = (E)new Object[DEFAULT_INITIAL_CAPACITY]; &#125; public void push(E e)&#123; ensureCapacity(); elements[size++] = e; &#125; public E pop()&#123; if(size==0) throw new EmptyStackException(); E res = elements[--size]; // 清除无用的引用 elements[size] = null; return res; &#125; public isEmpty()&#123; return size==0; &#125; private ensureCapacity()&#123; if(elements.length==size) elements = Arrays.copyOf(elements, size*2+1); &#125;&#125; 考虑泛型方法声明类型参数的类型参数列表位于方法的修饰符和返回类型之间。 123456// Generic methodpublic static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2) &#123; Set&lt;E&gt; result = new HashSet&lt;&gt;(s1); result.addAll(s2); return result;&#125; 限定通配符增加API灵活性PECS代表： producer-extends，consumer-super。 如果一个参数化类型代表一个 T 生产者，使用 &lt;? extends T&gt;；如果它代表 T 消费者，则使用 &lt;? super T&gt;。 在我们的 Stack 示例中，pushAll 方法的 src 参数生成栈使用的 E 实例，因此 src 的合适类型为 Iterable&lt;? extends E&gt;；popAll 方法的 dst 参数消费 Stack 中的 E 实例，因此 dst 的合适类型是 Collection &lt;? super E&gt;。 所有 Comparable 和 Comparator 都是消费者。 可变参数与泛型可变参数: 类型 T 加…构成，例如： 12345public void test(String ... strs)&#123; for(String s: strs)&#123; System.out.println(s); &#125;&#125; Java用一个数组来保存变长的参数，但是可变参数的类型与泛型要注意混淆。 考虑一个例子： 123456public &lt;T&gt; T[] toArray(T ... t)&#123; return t;&#125;// testString[] strs = toArray(&quot;abc&quot;, &quot;def&quot;); 上面的会报错，因为泛型传递的是非具体类型，也就是编译时的类型信息要多与运行时信息（由于擦除），因此可变参数的数组用 Object类型存储，当Object转为String时，会报错ClassCastException。 另一个例子： 123456public void test(List&lt;String&gt;... stringList)&#123; Object[] obj = stringList; List&lt;Integer&gt; intList = List.of(15); // List.of生成一个不可变列表（不能用set设置数值） obj[0] = intList; // 发成堆污染 String s = obj[0].get(0); // 出现警告，编译没错，但是运行报错 ClassCastException。&#125; 可见，可变参数中混淆了泛型，还是很容易产生类型转换的不安全性，但是Java并没有因此抛弃，而在Arrays.asList(T… a)，Collections.addAll(Collection&lt;? super T&gt; c, T… elements)，EnumSet.of(E first, E… rest)中大量使用，说明只要保证可变参数中的泛型是安全的（以下三点），就可： 1. 可变参数数组不会存储跟修改。2. 可变参数数组的引用不会转义。3. 可变参数数组仅用来为方法传递可变参数。 当然，可变参数数组可以变为列表，但同时降低了一定性能与可读性。 123456public &lt;T&gt; List&lt;T&gt; toArray(List&lt;T&gt; t)&#123; return t;&#125;// testList&lt;String&gt; strs = toArray(&quot;abc&quot;, &quot;def&quot;); 可变参数的另一个用法 因为可变参数数组的产生都会产生性能损耗，因此当 95％ 的调用是三个或更少的参数的方法，那么声明该方法的五个重载。 123456789public void foo() &#123; &#125;public void foo(int a1) &#123; &#125;public void foo(int a1, int a2) &#123; &#125;public void foo(int a1, int a2, int a3) &#123; &#125;public void foo(int a1, int a2, int a3, int... rest) &#123; &#125; 异构容器泛型中规定的可变类型数量总是有限的，例如单个类型约束&lt; T &gt;以及Map的&lt; K , V&gt;。 异构容器可以通过参数化键的方式，实现泛型设定数量的灵活性。例如在数据库查询中任意列值。 下面是一个异构容器的示例： 1234567891011121314151617public class Favorites&#123; // 用Class&lt;T&gt;存放未知的键 Map&lt;Class&lt;?&gt;, T&gt; favorites = new HashMap&lt;&gt;(); public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance)&#123; favorites.put(Object.requireNonNull(type), type.cast(instance)); &#125; public &lt;T&gt; T get(Class&lt;T&gt; type)&#123; return type.cast(favorites.get(type)); &#125;&#125;public static void main(String[] args) &#123; Favorites f = new Favorites(); f.put(String.class, &quot;syz&quot;); f.put(Integer.class, 12); f,get(String.class);&#125; 可以使用 ColumnClass&lt;/font&gt; 对象作为此类型安全异构容器的键。 以这种方式使用的 Class 对象称为类型令牌。 也可以使用自定义键类型。 例如，可以有一个表示数据库行（容器）的 DatabaseRow 类型和一个泛型类型 Column&lt; T &gt; 作为其键。","categories":[{"name":"Java","slug":"Java","permalink":"https://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://sunyunzeng.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Class文件长什么样","slug":"Class文件长什么样","date":"2019-09-25","updated":"2022-11-05","comments":true,"path":"Class文件长什么样/","link":"","permalink":"https://sunyunzeng.com/Class%E6%96%87%E4%BB%B6%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7/","excerpt":"","text":"定义Class文件是Java语言实现跨平台的原材料，JVM(Java Vritual Machine)是实现跨平台的机器。 机器 + 原材料 = 跨平台。 不同的平台有自己的JVM，但是Class文件是一样的。 Class文件由java文件编译产生。 Class文件是由8位字节构成的二进制流，用类似于C语言结构体的伪结构来存储数据。 Class文件由无符号数和表组成。 无符号数用u1 u2 u4 u8来表示1 2 4 8个字节的无符号数。它用来表示数量值、数值、索引引用、按照UTF-8编码的字符串。 表是一种特殊的数据结构，它由表及无符号数组成，习惯表以_info结尾。 Class文件就是一张表，用来描述唯一确定的类或接口。 下面是从《深入了解JVM》中摘的Class文件的表结构。 图1 Class表结构 进入Class这张表首先我们写一个简单的类，叫做HelloClass。 1234567public class HelloClass &#123; private int name; public int addName() &#123; return name + 1; &#125;&#125; 然后编译生成 HelloClass.class文件，我们用文本编辑器打开它，如下： 图2 编译后的class文件 最复杂的结构，常量池由于Class本身就是一张表，而常量池是嵌套在Class中的表，其结构最复杂。 常量池用来存储类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。 如图2所示，前四个字节的无符号数 u4表示 Magic Number，是用来区分文件格式的，这样比文件名后缀更安全。 CAFE BABE是Java的Class文件的魔数，很魔性。 接着的u4是版本号，即图1中的 00 00 00 34。 然后就是常量池了，先看常量池的项目类型： 图3 常量池的项目类型 每个项目类型的第一位都是项目标志，唯一标识该类型。 常量池开始是容量说明，u2类型，及 00 16，表示容量为 16+6=22-1=21，因为常量池容量计算是从1开始，0表示为空。 之后一个u1类型是常量类型标志符，为 0A，为 10。查找图2表示该常量为 CONSTANT_Methodref_info，由两个u2无符号类型组成，第一个指向 00 04 即第4个常量，为 CONSTANT_Class_info 类型；第二个指向 00 12 即第 16+2=18 个常量， 为 CONSTANT_NameAndType 类型。 依次类推，直到翻译完常量池。 我们可以通过javap工具的 -verbose 输出字节码内容，如下： 访问标志访问标志(access_flags)用于识别类和接口的访问信息，诸如是否是public及抽象类等。 常量池后面是访问标志。 不同访问标志求 | 运算得到。 类索引、父类索引、接口索引分别是一个 u2、u2和一组u2，因为java单继承，可实现多个接口。 各自指向一个 CONSTANT_Class_info 的类描述常量。 字段表集合字段表(field_info)用来描述接口或类中声明的变量，字段包括类级别变量以及实例级别变量。但不包括方法内部声明的局部变量。 字段需要用访问标志描述，包括作用域(public、protected、default、private)、实例变量还是类变量(static)、是否为final、并发可见性(volatile)、是否可序列化(transient)、类型(基本类型、对象及数组)以及字段名称。 字段表的结果除了访问标志描述，还有字段的简单名称 name_index 及方法的描述符 discriptor_index、属性表统计 attributes_count 及属性表 attributes。 字段的简单名称及方法描述符都是对常量池引用。 描述符是用来描述字段与方法的类型与返回参数的。 由于这类信息不能跟访问标志描述一样，可以用固定长度来表示，所以需要在常量池中表示后然后引用。 基本数据类型用相应大写字母表示，对象类型用大写字母 L加对象全限定名表示。 其中数组类型用前面 [加类型表示，如 String[][],就表示为 [[Ljava/lang/String;。 描述方法时，先参数列表，后返回类型。如 int i(), 表示为 （）I 方法表集合与字段表类似,只不过并发可见性(volatile)、是否可序列化(transient)不能修饰方法。 方法中的代码描述，由编译器编译成字节指令后，存放在属性表attributes 的 Code属性里。 属性表属性表(attributes_info)在Class文件、属性表与方法表内都有出现，用于描述场景特殊信息。 属性表其它数据项目严格要求的顺序、长度和内容，它不再要求各个属性有严格的顺序，且只要不与已有属性名重复，任何实现的编译器都可向属性表中写入自己定义的属性信息；Java虚拟机在运行时会忽略掉不认识的属性。 《Java虚拟机规范(Java SE 7)》中，预定义的属性为： 其中每个属性表首先根据 attributes_name_index 去常量池引用 CONSTANT_Class_info 类型的名称，然后用一个 u4 长度的属性说明属性表占用的长度 attribute_length 即可。属性表中描述的信息单位是 u1，共attribute_length个。 属性表的结构如下： Code属性java程序方法体内的代码通过编译成字节码后，存在Code属性中。 Code属性存储在方法表的属性表集合中。 Code属性是Class文件中最重要的属性，是对代码的描述。其它信息可以看做是对元数据（类型、字段、方法及其他信息）的描述。 Code的属性表如下： 各部分的含义如下： 类型 名称 含义 u2 attributes_name_index 指向 CONSTANT_Class_info 常量索引，表示该属性表名称 u1 attribute_length 属性表长度。由于属性名称索引 u2 加长属性名长度 u4，所以属性表长度为整个属性表长度减去 6 字节。 u2 max_stack 栈的最大深度。Java虚拟机为该方法体分配栈针的操作栈深度。 u2 max_locals 局部变量的最大存储空间。方法参数、显示异常处理的参数及方法体中定义的局部变量都需用局部变量表表示。局部变量中统计单位是 Slot。小于32位(boolean、short、char、int、float、returnAddress)的变量用一个 Slot 表示，double与long两个64位的用两个Slot表示。 u4 code_length 字节码长度。实际是 u2 长度，即16个字节， 65535条字节码，超过改长度虚拟机将拒绝编译。 u1 code 一些类的字节码指令，用于描述编译后的方法体内方法。 u2 exception_table_lenght 显示异常处理表长度。 excessption_info exception_table 显示异常处理表 u2 attributes_count 属性表数量 attributes_info attributes 属性表 参考深入理解java虚拟机","categories":[{"name":"Java","slug":"Java","permalink":"https://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://sunyunzeng.com/tags/JVM/"}]},{"title":"剑指Offer 打印1到最大的n位数","slug":"剑指Offer-打印1到最大的n位数","date":"2019-09-24","updated":"2022-11-05","comments":true,"path":"剑指Offer-打印1到最大的n位数/","link":"","permalink":"https://sunyunzeng.com/%E5%89%91%E6%8C%87Offer-%E6%89%93%E5%8D%B01%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/","excerpt":"","text":"题目打印1到最大的n位数。 示例：123输入 n = 1打印 1 2 3 4 5 6 7 8 9 思路 + 代码常规操作是暴力循环打印 1 到 n 位数，但是大数问题，存在数值溢出。 采用字符串或者数组存储中间结果。 思路1用一个 长度为 n 的数组存储，然后分别在最后一位计算，每次加一，逢十进一。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class PrintToNNumber &#123; private static boolean increment(int[] nums) &#123; if(nums==null || nums.length==0) return false; // 相加是否大于10 int overflow = 0; int len = nums.length; for (int i = len - 1; i &gt;= 0; i--) &#123; int nSum = overflow + nums[i]; // 只在最后一位加 if(i==len-1)&#123; nSum++; &#125; if (nSum &lt; 10) &#123; nums[i] = nSum; return true; &#125; // &gt;= 10 // 超出范围 if(i==0)&#123; return false; &#125; nums[i] = 0; overflow = 1; &#125; return false; &#125; // 清楚掉数组前面的零 public static void printArray(int[] nums) &#123; int len = nums.length; boolean isZero = true; for (int i = 0; i &lt; len; i++) &#123; if(nums[i]!=0) isZero = false; if (!isZero) &#123; System.out.print(nums[i]); &#125; &#125; System.out.println(); &#125; public static void main(String[] args) &#123; int n = 3; int[] nums = new int[n]; while (increment(nums))&#123; printArray(nums); &#125; &#125;&#125; 思路2使用递归方法，递归到组后一位，然后依次往前打印。 12345678910111213141516private static void recursive(int[] nums, int index) &#123; if (nums.length == index) &#123; printArray(nums); return; &#125; for (int i = 0; i &lt; 10; i++) &#123; nums[index] = i; recursive(nums, index+1); &#125; &#125;public static void main(String[] args) &#123; int n = 3; int[] nums = new int[n]; recursive(nums, 0); &#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"LeetCode 15.三数之和","slug":"LeetCode-15-三数之和","date":"2019-09-24","updated":"2022-11-05","comments":true,"path":"LeetCode-15-三数之和/","link":"","permalink":"https://sunyunzeng.com/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"题目给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 思路+代码先排序，然后三数之和等于零必定有 1 到 2 个小于零， 1 到 2 个大于零。 然后我们采用双指针，先固定最小的一个数（负值）；然后双指针再后面区间寻找两个数，与前面数相加等于零。 注意：因为不能包含重复三元组，在遍历过程中注意去重。保证每次遍历的数字与前面不一样即可（因为排序了）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); // 排序求解 Arrays.sort(nums); // 循环求解 int len = nums.length; for(int i=0; i&lt;len; i++)&#123; // 此时没有满足条件的情况 if(nums[i]&gt;0) break; // 避免重复计算 if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) continue; int j=i+1; int k=len-1; while(j&lt;k)&#123; if(nums[j]+nums[k]==-nums[i])&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(nums[i]); list.add(nums[j]); list.add(nums[k]); res.add(list); // 跳过重复的数字 while(j&lt;k&amp;&amp;nums[j]==nums[j+1])&#123; j++; &#125; while(j&lt;k&amp;&amp;nums[k]==nums[k-1])&#123; k--; &#125; j++; k--; &#125;else if(nums[j]+nums[k]&lt;-nums[i])&#123; // 左边负值大了 j++; &#125;else&#123; // 右边正值大了 k--; &#125; &#125; &#125; return res; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/3sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Leetcode 674.最长连续子序列","slug":"Leetcode-674-最长连续子序列","date":"2019-09-23","updated":"2022-11-05","comments":true,"path":"Leetcode-674-最长连续子序列/","link":"","permalink":"https://sunyunzeng.com/Leetcode-674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"题目给定一个未经排序的整数数组，找到最长且连续的的递增序列。 示例1： 1234输入: [1,3,5,4,7]输出: 3解释: 最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 示例2： 123输入: [2,2,2,2,2]输出: 1解释: 最长连续递增序列是 [2], 长度为1。 注意：数组长度不会超过10000。 思路 + 代码思路1我的思路，用一个栈进行递增子序列长度的检查，用res缓存结果。 12345678910111213141516171819class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; if(nums==null || nums.length==0) return 0; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); int res = 1; int len = nums.length; s.push(nums[0]); for(int i=1; i&lt;len; i++)&#123; if(nums[i]&lt;=nums[i-1])&#123; res = Math.max(res, s.size()); s.clear(); &#125; s.push(nums[i]); &#125; res = Math.max(res, s.size()); return res; &#125;&#125; 思路2动态规划，用一个长度为n的数值维度维护每个位置的最大长度，然后取其中最大值。 123456789101112131415161718class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; if(nums==null || nums.length==0) return 0; int res = 1; int len = nums.length; int[] dp = new int[len]; Arrays.fill(dp, 1); for(int i=1; i&lt;len; ++i)&#123; if(nums[i]&gt;nums[i-1])&#123; dp[i] += dp[i-1]; res = Math.max(dp[i], res); &#125; &#125; return res; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"设计模式：Java类和接口","slug":"设计模式：Java类和接口","date":"2019-09-23","updated":"2022-11-05","comments":true,"path":"设计模式：Java类和接口/","link":"","permalink":"https://sunyunzeng.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AJava%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"使类与成员可访问性最小成员（类、接口、方法、字段）的访问级别 private —— 该成员只能在声明它的顶级类内访问。 package-private —— 成员可以从被声明的包中的任何类中访问。从技术上讲，如果没有指定访问修饰符（接口成员除外，它默认是公共的），这是默认访问级别。 protected —— 成员可以从被声明的类的子类中访问（会受一些限制 [JLS, 6.6.2]），以及它声明的包中的任何类。 public —— 该成员可以从任何地方被访问。 公共类的实例字段很少情况下采用 public 修饰如果需要调用私有成员，就写一个方法。 12345private static final Thing[] PRIVATE_VALUES = &#123; ... &#125;;public static final Thing[] values() &#123; return PRIVATE_VALUES.clone();&#125; 公共类中使用访问方法而不是访问属性虽然包内访问权限，如果只包内可见是可行的，也可以，同时可以避免视觉混乱，但是不提倡这样做。 12345// Degenerate classes like this should not be public!class Point &#123; public double x; public double y;&#125; 提供提供方法与设置方法12345678910111213141516171819// Encapsulation of data by accessor methods and mutatorsclass Point &#123; private double x; private double y; public Point(double x, double y) &#123; this.x = x; this.y = y; &#125; public double getX() &#123; return x; &#125; public double getY() &#123; return y; &#125; public void setX(double x) &#123; this.x = x; &#125; public void setY(double y) &#123; this.y = y; &#125;&#125; 不变类不变类中所有实例的信息在生命周期中都是固定的，因此是安全可靠的。 不变类的设计规则 不要提供修改对象状态的方法 （也称为 mutators）。 确保这个类不能被继承。 这可以防止粗心的或恶意的子类，假设对象的状态已经改变，从而破坏类的不可变行为。 防止子类化通常是通过 final 修饰类，但是我们稍后将讨论另一种方法。 把所有属性设置为 final。 通过系统强制执行，清楚地表达了你的意图。 另外，如果一个新创建的实例的引用从一个线程传递到另一个线程而没有同步，就必须保证正确的行为。 把所有的属性设置为 private。 这可以防止客户端获得对属性引用的可变对象的访问权限并直接修改这些对象。 虽然技术上允许不可变类具有包含基本类型数值的公共 final 属性或对不可变对象的引用，但不建议这样做，因为它不允许在以后的版本中更改内部表示。 确保对任何可变组件的互斥访问。 如果你的类有任何引用可变对象的属性，请确保该类的客户端无法获得对这些对象的引用。 切勿将这样的属性初始化为客户端提供的对象引用，或从访问方法返回属性。 在构造方法，访问方法和 readObject 方法中进行防御性拷贝。 多使用组合而不是继承如果父类不是为了继承而专门设计，那么后面父类的修改可能会导致子类产生严重的bug。 明智的方法是多使用组合composition。即在类内部使用其它类的引用。 一个新类由一系列现有类组成，新类的方法通过调用现有类的方法获取结果，成为转发 (farwarding)。 继承需要深思熟虑还要详细的设计文档测试为继承而设计的类的唯一方法是编写子类。 构造方法绝不能直接或间接调用可重写的方法。 For example:12345678910111213141516171819202122232425262728public class Super &#123; // Broken - constructor invokes an overridable method public Super() &#123; overrideMe(); &#125; public void overrideMe() &#123; &#125;&#125;public final class Sub extends Super &#123; // Blank final, set by constructor private final Instant instant; Sub() &#123; instant = Instant.now(); &#125; // Overriding method invoked by superclass constructor @Override public void overrideMe() &#123; System.out.println(instant); &#125; public static void main(String[] args) &#123; Sub sub = new Sub(); sub.overrideMe(); &#125;&#125;上述子类由于重写了方法，调用父类时 instant 成员没有指向任何一个对象，因此有问题。 专门为了继承而设计类是一件很辛苦的工作。你必须建立文档说明其所有的自用模式，并且一旦建立了文档，在这个类的整个生命周期中都必须遵守。如果没有做到，子类就会依赖父类的实现细节，如果父类的实现发生了变化，它就有可能遭到破坏。为了允许其他人能编写出高效的子类，还你必须导出一个或者多个受保护的方法。除非知道真正需要子类，否则最好通过将类声明为 final，或者确保没有可访问的构造器来禁止类被继承。 接口优先抽象类抽象类的实现只有继承，限制了混合类型的定义。 同时，对于非层次的类级关系，想要为类添加额外的功能，接口是一个很好的方法。 骨架抽象类，首先是一个抽象类，然后该抽象类实现了一个接口的基本方法，形成默认的方法实现，提供基础的功能。 用户可以自由的选择是选择继承该抽象类还是直接实现该抽象类实现的接口，从而保证灵活性。 骨架抽象类的例子：AbstractList、AbstractSet等。 例子： 12345678910111213141516171819202122232425262728293031323334// Skeletal implementation classpublic abstract class AbstractMapEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // Entries in a modifiable map must override this method @Override public V setValue(V value) &#123; throw new UnsupportedOperationException(); &#125; // Implements the general contract of Map.Entry.equals @Override public boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry) o; return Objects.equals(e.getKey(), getKey()) &amp;&amp; Objects.equals(e.getValue(), getValue()); &#125; // Implements the general contract of Map.Entry.hashCode @Override public int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; @Override public String toString() &#123; return getKey() + &quot;=&quot; + getValue(); &#125;&#125; 接口用户定义类型层次类优先于标签类标签类：是一个类，该类的实例根据构造方法传入标签的不同而不同。 问题：代码可读性差，扩展性差，且内存负担大，因为类实例保存很多不属于它本身的字段。 层次类：即在顶层实现一个抽象类，该抽象类将属于公共的方法、字段及依赖于标签值的方法包括起来，提供实现样板。然后根据需求依次实现不同的子类，每个子类实现各自的方法。 12345678910111213141516171819202122232425262728293031323334353637383940// 标签类// Tagged class - vastly inferior to a class hierarchy!class Figure &#123; enum Shape &#123; RECTANGLE, CIRCLE &#125;; // Tag field - the shape of this figure final Shape shape; // These fields are used only if shape is RECTANGLE double length; double width; // This field is used only if shape is CIRCLE double radius; // Constructor for circle Figure(double radius) &#123; shape = Shape.CIRCLE; this.radius = radius; &#125; // Constructor for rectangle Figure(double length, double width) &#123; shape = Shape.RECTANGLE; this.length = length; this.width = width; &#125; double area() &#123; switch(shape) &#123; case RECTANGLE: return length * width; case CIRCLE: return Math.PI * (radius * radius); default: throw new AssertionError(shape); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031// 层次类// Class hierarchy replacement for a tagged classabstract class Figure &#123; abstract double area();&#125;class Circle extends Figure &#123; final double radius; Circle(double radius) &#123; this.radius = radius; &#125; @Override double area() &#123; return Math.PI * (radius * radius); &#125;&#125;class Rectangle extends Figure &#123; final double length; final double width; Rectangle(double length, double width) &#123; this.length = length; this.width = width; &#125; @Override double area() &#123; return length * width; &#125;&#125;// 类之间的层次关系可读且灵活class Square extends Rectangle &#123; Square(double side) &#123; super(side, side); &#125;&#125; 嵌套类嵌套类最好只存在于宿主类 (enclosing class) 中, 否则，就应将其设计为顶层类。 四种嵌套类：静态内部类、非静态内部类、匿名类、局部类。 静态内部类：不与类的实例有关联，一个用法是提供类的帮助类。 非静态内部类：确定与实例有关联才用，否则其默认将引用传给宿主类的实例，会占用存储空间与时间。最常用方法就是 Adapter 模式，可将外部类的实例视为某个不相关类的实例。 例子：12345678910111213// Typical use of a nonstatic member classpublic class MySet&lt;E&gt; extends AbstractSet&lt;E&gt; &#123; ... // Bulk of the class omitted @Override public Iterator&lt;E&gt; iterator() &#123; return new MyIterator(); &#125; private class MyIterator implements Iterator&lt;E&gt; &#123; ... &#125;&#125; 匿名类： 只能在非静态上下文环境中使用时声明与实例化，在静态上下文环境，只能带有常量型变量（final修饰的基本类型及初始化为 String）。不能执行 instanceof 方法测试，不能在运行外实例化，不能实现多个接口或继承一个类同时实现一个接口。常用：创建小函数对象和处理对象的首选方法。 局部类：非静态上下文中定义它们时，它们才会包含实例，并且它们不能包含静态成员。 永远不要将多个顶级类或接口放在一个源文件中保证在编译时不能有多个定义。","categories":[{"name":"Java","slug":"Java","permalink":"https://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://sunyunzeng.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式：Java方法","slug":"设计模式：Java方法","date":"2019-09-22","updated":"2022-11-05","comments":true,"path":"设计模式：Java方法/","link":"","permalink":"https://sunyunzeng.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AJava%E6%96%B9%E6%B3%95/","excerpt":"","text":"使用 try-with-resources调用用完需关闭的方法。实现了 AutoCloseable接口（由一个返回为 void的close组成）的资源可以使用try-with-resources方法。 AutoCloseable接口在Java的类库和第三方类库中许多类和接口都有实现或继承，例如 BufferedReader、InputStream、OutputStream 等。 123456789101112// examplestatic void copy(String src, String dst) throws IOException &#123; try(InputStream in = new FileInputStream(src); OutputStream out = new FileOutputStream(dst))&#123; byte[] buf = new byte[BUFFER_SIZE]; int n; while((n = in.read(buf)) &gt;= 0)&#123; out.write(buf, 0, n); &#125; &#125; OutputStream &#125; 重写equals方法规则 使用 == 运算符检查参数是否为该对象的引用。如果是，返回 true。这只是一种性能优化，但是如果这种比较可能很昂贵的话，那就值得去做。 使用 instanceof 运算符来检查参数是否具有正确的类型。 如果不是，则返回 false。 通常，正确的类型是 equals 方法所在的那个类。 有时候，改类实现了一些接口。 如果类实现了一个接口，该接口可以改进 equals 约定以允许实现接口的类进行比较，那么使用接口。 集合接口（如 Set，List，Map 和 Map.Entry）具有此特性。 参数转换为正确的类型。因为转换操作在 instanceof 中已经处理过，所以它肯定会成功。 对于类中的每个「重要」的属性，请检查该参数属性是否与该对象对应的属性相匹配。如果所有这些测试成功，返回 true，否则返回 false。如果步骤 2 中的类型是一个接口，那么必须通过接口方法访问参数的属性;如果类型是类，则可以直接访问属性，这取决于属性的访问权限。 对于类型为非 float 或 double 的基本类型，使用 == 运算符进行比较；对于对象引用属性，递归地调用 equals 方法；对于 float 基本类型的属性，使用静态 Float.compare(float, float) 方法；对于 double 基本类型的属性，使用 Double.compare(double, double) 方法。由于存在 Float.NaN，-0.0f 和类似的 double 类型的值，所以需要对 float 和 double 属性进行特殊的处理；虽然你可以使用静态方法 Float.equals 和 Double.equals 方法对 float 和 double 基本类型的属性进行比较，这会导致每次比较时发生自动装箱，引发非常差的性能。 对于数组属性，将这些准则应用于每个元素。 如果数组属性中的每个元素都很重要，请使用其中一个重载的 Arrays.equals 方法。 某些对象引用的属性可能合法地包含 null。 为避免出现 NullPointerException 异常，请使用静态方法 Objects.equals(Object, Object) 检查这些属性是否相等。 重写equals方法时一定重写hashCode方法。基于Hash值的散列数据结构，例如hashMap、HashSet等，需要基于Hash值判断两个是否相等，其实是根据equals方法来判断。 equals方法改变，要想实例也能跟被基于hash的散列结构识别，需要将hashCode方法重写。 时刻重写toString方法。使用clone方法对于可变对象的克隆需要谨慎。克隆出来的对象的类型与原始对象的一致，并且x.clone != x返回true。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// HashTable的克隆方法，需要深度克隆，保证克隆出来的对象是原先对象的深层拷贝，桶或链都拷贝一份// Recursive clone method for class with complex mutable statepublic class HashTable implements Cloneable &#123; private Entry[] buckets = ...; private static class Entry &#123; final Object key; Object value; Entry next; Entry(Object key, Object value, Entry next) &#123; this.key = key; this.value = value; this.next = next; &#125; // Recursively copy the linked list headed by this Entry //Entry deepCopy() &#123; // return new Entry(key, value, // next == null ? null : next.deepCopy()); //&#125; // 避免链表过长导致栈溢出错误 Entry deepCopy()&#123; Entry result = new Entry(key, value, next); for(Entry p = result; p!=null; p=p.next)&#123; p.next = new Entry(p.next.key, p.next.value, p.next.next); &#125; return result; &#125; &#125; @Override public HashTable clone() &#123; try &#123; HashTable result = (HashTable) super.clone(); result.buckets = new Entry[buckets.length]; for (int i = 0; i &lt; buckets.length; i++) if (buckets[i] != null) result.buckets[i] = buckets[i].deepCopy(); return result; &#125; catch (CloneNotSupportedException e) &#123; throw new AssertionError(); &#125; &#125; ... // Remainder omitted&#125; 在可比较大小的类中考虑实验Comparable接口。123public interface Comparable&lt;T&gt;&#123; int compareTo(T t);&#125; 在conpareTo()中比较大小时，避免使用 &lt; 或者 &gt; ,应该使用包装类中的compare()方法或者自己实现Comparator接口中的compare()方法 1234567891011// Comparator based on static compare methodstatic Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() &#123; public int compare(Object o1, Object o2) &#123; return Integer.compare(o1.hashCode(), o2.hashCode()); &#125;&#125;;// Comparator based on Comparator construction methodstatic Comparator&lt;Object&gt; hashCodeOrder = Comparator.comparingInt(o -&gt; o.hashCode()); 参考： https://sjsdfg.github.io/effective-java-3rd-chinese/#/","categories":[{"name":"Java","slug":"Java","permalink":"https://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://sunyunzeng.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式：Java创建对象","slug":"Java创建对象设计模式","date":"2019-09-20","updated":"2022-11-05","comments":true,"path":"Java创建对象设计模式/","link":"","permalink":"https://sunyunzeng.com/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"使用静态工厂方法代替构造方法静态工厂方法是一个静态方法，用来生成实例。例如： 12345678910111213// 单例模式public class Dog&#123; // 私有方法防止在外调用创建实例 private Dog()&#123; &#125; private static class Inner()&#123; private static final Dog dog = new Dog(); &#125; public static getInstance()&#123; return Inner.dog; &#125;&#125; 因为构造方法每次调用都需要新建一个对象，有些情况下不能满我们的要求。 而静态工厂方法生成对象有以下几个好处： 1. 名字更有意义。 from —— 类型转换方法，它接受单个参数并返回此类型的相应实例，例如：Date d = Date.from(instant); of —— 聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起，例如：Set faceCards = EnumSet.of(JACK, QUEEN, KING); valueOf —— from 和 to 更为详细的替代 方式，例如：BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE); instance 或 getinstance —— 返回一个由其参数 (如果有的话) 描述的实例，但不能说它具有相同的值，例如：StackWalker luke = StackWalker.getInstance(options); create 或 newInstance —— 与 instance 或 getInstance 类似，除此之外该方法保证每次调用返回一个新的实例，例如：Object newArray = Array.newInstance(classObject, arrayLen); getType —— 与 getInstance 类似，但是在工厂方法处于不同的类中的时候使用。getType 中的 Type 是工厂方法返回的对象类型，例如：FileStore fs = Files.getFileStore(path); newType —— 与 newInstance 类似，但是在工厂方法处于不同的类中的时候使用。newType中的 Type 是工厂方法返回的对象类型，例如：BufferedReader br = Files.newBufferedReader(path); type —— getType 和 newType 简洁的替代方式，例如：List litany = Collections.list(legacyLitany); 2. 可以实现实例数量的控制。 例如单例、不可实例化类的实现。 3. 返回的对象可以根据参数不同而不同。 4. 返回的实例可以没有对应的对象类型。 例如服务者提供框架，就是用到静态工厂方法。 服务接口，表示实现；提供者注册API，选择实现；服务访问API，客户端调用。服务提供者接口，描述生成服务接口实例的工厂对象。 依赖注入框架可以被看作强大的服务提供者。 # 当构造函数多时使用**builder**模式 构造函数名字都与类名一样，区分不同构造函数依靠参数的顺序与数量。 当构造参数很多时，实例的生成非常麻烦，往往不知道调用哪个构造函数。 123456789101112131415161718192021222324252627282930313233343536public class NutritionFacts&#123; private final int servingSize; private final int calories; private final int fat; public static class Builder&#123; private final int servingSize; private int calories; private int fat; public Builder(int servingSize)&#123; this.servingSize = servingSize; &#125; public Builder calories(int calories)&#123; calories = calories; return this; &#125; public Builder fat(int fat)&#123; fat = fat; return this; &#125; public NutritionFacts build()&#123; return new NutritionFacts(this); &#125; &#125; private NutritionFacts(Builder builder)&#123; this.servingSize = builder.servingSize; this.calories = builder.calories; this.fat = builder.fat; &#125;&#125;NutritionFacts coca = NutritionFacts.Builder(10).calories(40).fat(0).build(); **使用场景：** 当设计类的构造方法或静态工厂的参数超过几个时，Builder 模式是一个不错的选择，特别是如果许多参数是可选的或相同类型的。 # 单例模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 懒汉模式，线程不安全，不是严格意义上单例模式public class Dog&#123; private static final Dog dog; private Dog()&#123; &#125; public static getInstance()&#123; if(dog==null) dog = new Dog(); return dog; &#125;&#125;// 饿汉模式，线程安全，但易产生垃圾public class Dog&#123; private static final Dog dog = new Dog(); private Dog()&#123; &#125; public static getInstance()&#123; return dog; &#125;&#125;// 内部类方式，线程安全，但是序列化要保证单例，需要重写 readResolve()public class Dog&#123; private Dog()&#123; &#125; private static class Inner()&#123; private static final Dog dog = new Dog(); &#125; public static getInstance()&#123; return Inner.dog; &#125; // 序列化也保证一个单类 Object readResolve() throws ObjectStreamException&#123; return dog; &#125;&#125;//枚举模式，最简单，但不常用。线程安全，且保证序列化唯一性public enum Dog&#123; INSTANCE; public static getInstance()&#123; return Dog.INSTANCE; &#125;&#125; # 使用私有构造方法非实例化 构造方法声明为私有方法，可以创建非实例化类。 该类存在的意义就是提供工具静态方法，例如 java.util.Arrays 工具类等。 # 简单依赖注入 通过构造方法把**类依赖**的**客户端资源**注入到类中，是依赖注入的一种方式。 123456789public class SpellChecker&#123; private final Chinese dictionary; public SpellChecker(Chinese dictionary)&#123; this.dictionary = Object.requireNonNull(dictionary); &#125; public boolean isValid(String word)&#123;...&#125;&#125; 可以通过依赖注入把同一子类的资源工厂当做参数。 工厂就是可以被重复调用生产实例的对象。 Java 8的函数式接口Supplier非常适合工厂。 12345@FunctionalInterfaceinterface Supplier&lt;T&gt;&#123; // 用来提供对象 T get();&#125; 1Mosaic create(Supplier&lt;T? extends Tile&gt; tileFactroy)&#123;..&#125; 避免创建不必要的对象例如 12345678910// 例子1Integer it = 0; for(int i=0; i&lt;1000000; i++)&#123; // 创建了1000000对象 it += i;&#125;// 例子2// 多创建了一个StringString s = new String(&quot;moreClass&quot;); 原则： 尽量使用基本类型而不使用装箱的基本类型，即使自动装箱也要考虑。 消除过期的对象引用。如果对象引用是隐式存在，如果不需要，则置为null。 例如编写stack类pop()方法： 12345public &lt;T&gt; pop()&#123; &lt;T&gt; result = bucket[--size]; bucket[size] = null; return ;&#125; 避免使用Finalizer和Cleaner机制！参考： https://sjsdfg.github.io/effective-java-3rd-chinese/#/","categories":[{"name":"Java","slug":"Java","permalink":"https://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://sunyunzeng.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Leetcode 33.搜索旋转排序数组","slug":"Leetcode搜索旋转排序数组","date":"2019-09-15","updated":"2022-11-05","comments":true,"path":"Leetcode搜索旋转排序数组/","link":"","permalink":"https://sunyunzeng.com/Leetcode%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"","text":"题目假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例1:12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例2:12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 思路+代码时间复杂度要求是O(log n)，也就是二分法。于是我写了一个最基础的二分法…还是用递归.. 1234567891011121314151617181920212223242526272829class Solution &#123; public int search(int[] nums, int target) &#123; if(nums.length==0 || nums==null) return -1; if(nums.length==1) return nums[0]==target?0:-1; return subSearch(nums, target, 0, nums.length-1); &#125; private int subSearch(int[] nums, int target, int left, int right)&#123; if(nums[left]==target) return left; if(nums[right]==target) return right; int mid = (left+right)/2; if(nums[mid]==target) return mid; if(right-left==1) return -1; int tmp=-1; tmp=subSearch(nums, target, left, mid); if(tmp!=-1) return tmp; tmp=subSearch(nums, target, mid, right); return tmp; &#125;&#125; 看了答案之后… 我想说:** 123456789101112131415161718192021222324252627class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0, right = nums.length-1; while(left&lt;=right)&#123; int mid=(left+right)/2; if(target==nums[mid]) return mid; // 左侧不包含旋转序列 if(nums[left]&lt;=nums[mid])&#123; if(target&gt;=nums[left]&amp;&amp;target&lt;nums[mid])&#123; right = mid-1; &#125;else&#123; left = mid+1; &#125; &#125; // 右侧不包含旋转序列 else&#123; if(target&gt;nums[mid]&amp;&amp;target&lt;=nums[right])&#123; left = mid+1; &#125;else&#123; right = mid-1; &#125; &#125; &#125; return -1; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Servlet技术","slug":"Servlet技术","date":"2019-09-11","updated":"2022-11-05","comments":true,"path":"Servlet技术/","link":"","permalink":"https://sunyunzeng.com/Servlet%E6%8A%80%E6%9C%AF/","excerpt":"","text":"什么是Servet?Servlet (Server Applet)，从字面上看，就是Java服务器小程序的意思。它确实就像字面意思一样，是在服务中用于处理网络请求的小程序。 在Web的世界中，客户端会提交各种请求到服务端，服务端如何处理客户端的请求呢？ 常规的Java编程方法，好像很难完成这项任务，但是没有事情是难倒程序猿的。 于是，他们设计了Servlet规范，用来处理网络的各种请求。 具体网络的请求呢，无非就是get、post等等，这在HTTP规范系列里面有讲到。 Servlet规范也没有想象中的那么高大上，其实它就是一个Java接口，里面一共就定义了五个方法，如图： 其中： init() 规定了Servet如何初始化。 getServletConfig() 获取Sevvlet的配置。 service(ServletRequest, ServletResponse) 接收到请求怎么处理。 getServletInfo() 提供有关servlet的信息，如作者、版本、版权等。 destroy() 销毁Servlet。 Servlet的运行任何合理实现了Servlet接口的类都具有处理HTTP请求的能力，但是就像java类的运行需要在JVM环境中一样，Servlet的运行也要环境，这里称为容器。 即Servlet的运行需要特定的容器，该容器负责实现对端口的监听，将请求内容解析，然后实例Servlet对象，给Servlet提供运行环境，然后将Servlet的处理结果发给客户端。 Tomcat就是一个开源的Servlet的容器，它也是一个Web服务器。 HttpServlet就是已经实现好的一个Servlet类，他对一些方法进行了详细的补充，我们通过doGet()、doPost()等方法很方便地实现处理HTTP请求功能。 它的一些源码如下： 1. service()实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取http request的method参数，其实就是html的form标签 //中method属性对应的字符串 String method = req.getMethod(); long errMsg; //判断请求方式 if(method.equals(&quot;GET&quot;)) &#123; //获取最后被修改时间 errMsg = this.getLastModified(req); if(errMsg == -1L) &#123; /**如果servlet不支持http request header的if-modified-since属性 * 则继续处理 **/ this.doGet(req, resp); &#125; else &#123; //如果支持这个属性 long ifModifiedSince; try &#123; ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;); &#125; catch (IllegalArgumentException var9) &#123; ifModifiedSince = -1L; &#125; /** * 如果客户端的文件最后修改时间和服务器端的文件最后修改时间一致则返回304不需要修改状态 * 这样服务器就不返回html，浏览器读取本地缓存文件，否则重新获取服务器端的对应html文件 **/ if(ifModifiedSince &lt; errMsg / 1000L * 1000L) &#123; this.maybeSetLastModified(resp, errMsg); this.doGet(req, resp); &#125; else &#123; resp.setStatus(304); &#125; &#125; &#125; else if(method.equals(&quot;HEAD&quot;)) &#123; errMsg = this.getLastModified(req); this.maybeSetLastModified(resp, errMsg); this.doHead(req, resp); &#125; else if(method.equals(&quot;POST&quot;)) &#123; this.doPost(req, resp); &#125; else if(method.equals(&quot;PUT&quot;)) &#123; this.doPut(req, resp); &#125; else if(method.equals(&quot;DELETE&quot;)) &#123; this.doDelete(req, resp); &#125; else if(method.equals(&quot;OPTIONS&quot;)) &#123; this.doOptions(req, resp); &#125; else if(method.equals(&quot;TRACE&quot;)) &#123; this.doTrace(req, resp); &#125; else &#123; //如果请求不是以上的所有请求方式，该方法就会响应501错误，也就是不支持这种请求 String errMsg1 = lStrings.getString(&quot;http.method_not_implemented&quot;); Object[] errArgs = new Object[]&#123;method&#125;; errMsg1 = MessageFormat.format(errMsg1, errArgs); resp.sendError(501, errMsg1); &#125; &#125; public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; HttpServletRequest request; HttpServletResponse response; try &#123; request = (HttpServletRequest)req; response = (HttpServletResponse)res; &#125; catch (ClassCastException var6) &#123; throw new ServletException(&quot;non-HTTP request or response&quot;); &#125; this.service(request, response);&#125; 2. doGet()实现： 1234567891011121314protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取协议 String protocol = req.getProtocol(); //获取http.method_get_not_supported的国际化字符串 String msg = lStrings.getString(&quot;http.method_get_not_supported&quot;); if(protocol.endsWith(&quot;1.1&quot;)) &#123; //如果是HTTP/1.1，返回405禁止访问方法错误 resp.sendError(405, msg); &#125; else &#123; //如果不是HTTP/1.1，返回400错误的请求错误 resp.sendError(400, msg); &#125; &#125; 2. doPost()实现： 12345678910protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String protocol = req.getProtocol(); String msg = lStrings.getString(&quot;http.method_post_not_supported&quot;); if(protocol.endsWith(&quot;1.1&quot;)) &#123; resp.sendError(405, msg); &#125; else &#123; resp.sendError(400, msg); &#125; &#125; **其实在工业界，几乎没有直接利用Servlet开发Web应用的了，但是它是一个基础，很多开源框架都是基于Servlet开发的，如大名鼎鼎的[Spring](https://spring.io/)** # 如何实现？ 1. 首先我写一个Servlet类,作用是得到get()请求，然后返回“Hello Servlet!”与打印当前时间。 12345678910111213public class HelloServlet extends HttpServlet&#123; public void doGet(HttpServletRequest request, HttpServletResponse response)&#123; try &#123; response.getWriter().println(&quot;&lt;h1&gt;Hello Servlet!&lt;/h1&gt;&quot;); response.getWriter().println(new Date().toLocaleString()); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; 2. 然后配置web.xml文件，建立URL与Servlet处理类 **HelloServlet** 之间的关联关系。 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 其中**servlet-name**是类名简写，**servlet-class** 是类名。 **servlet-mapping**实现URL与类的映射，这里实现了访问路径 http://127.0.0.1//hello 时调用HelloServlet类的相应方法。 http://127.0.0.1 是一个监听地址，需要服务器实现监听，此时就需要Tomcat。 然后修改Tomcat的conf/server.xml的路径配置。 1&lt;Context path=&quot;/&quot; docBase=&quot;F:\\\\eclipse-workspace\\\\j2ee\\\\web&quot; debug=&quot;0&quot; reloadable=&quot;false&quot; /&gt; # Servlet的特点 **1. Servlet是单实例多线程。** >1) 当Web服务器启动或者用户请求抵达服务器时，Servlet被实例化且只存在一个实例。 >2) 当请求抵达时，Servlet容器(如Tomcat)会调度线程 (Dispathchaer Thread)调度它管理下的线程池中等待执行的线程 (Worker Thread) 给请求者。 >3) 线程执行Servlet中的sercive方法。 >4) 请求结束，该线程放回线程池，等待被调用。 **2. Servet使用标准API，可被更多Web服务器调用。** ## 线程安全 由于Servlet是单实例多线程，当多个线程的用户同时访问共享资源时，就会出现线程安全的问题。 **解决方法:** 首先，定义在 doPost() 和 doGet()里的方法由于是**局部变量**，再每个用户调用实例方法时都会初始化，所以**不存在线程安全**。（一些属性尽量定义在实例的局部方法中） 实在需要共享的资源，只需加synchronized同步机制，在共享资源被某一线程占用后，该线程就拥有锁，其它线程只有等待该线程执行完毕才能使用该资源（抢占锁后一一执行）。 # Servlet的常用方法 在HttpServlet中sercive方法中，参数列表接受两个对象，一个是HttpServletResponse对象，一个是HttpServletRequest对象。 ## HttpServletRequest常用方法 **常见方法** 方法名 | 作用 :-: | :-: request.getRequestURL() | 浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)\" request.getRequestURI() | 浏览器发出请求的资源名部分，去掉了协议和主机名\" request.getQueryString() | 请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到 request.getRemoteAddr() | 浏览器所处于的客户机的IP地址 request.getRemoteHost() | 浏览器所处于的客户机的主机名 request.getRemotePort() | 浏览器所处于的客户机使用的网络端口 request.getLocalAddr() | 服务器的IP地址 request.getLocalName() | 服务器的主机名 request.getMethod() | 得到客户机请求方式一般是GET或者POST **获取参数** 方法名 | 作用 :-: | :-: request.getParameter() | 是常见的方法，用于获取单值的参数 request.getParameterValues() | 用于获取具有多值的参数，比如注册时候提交的 \"hobits\"，可以是多选的。 request.getParameterMap() | 用于遍历所有的参数，并返回Map类型。 **获取头信息** 方法名 | 作用 :-: | :-: request.getHeader() | 获取浏览器传递过来的头信息。 比如getHeader(\"user-agent\") | 可以获取浏览器的基本资料，这样就能判断是firefox、IE、chrome、或者是safari浏览器 request.getHeaderNames() | 获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息 头信息含义： >host: 主机地址 >user-agent: 浏览器基本资料 >accept: 表示浏览器接受的数据类型 >accept-language: 表示浏览器接受的语言 >accept-encoding: 表示浏览器接受的压缩方式，是压缩方式，并非编码 >connection: 是否保持连接 >cache-control: 缓存时限 ## HttpServletResponse常用方法 1. 设置相应内容 PrintWriter pw= response.getWriter(); 通过`response.getWriter();` 获取一个PrintWriter 对象 可以使用`println()`,`append()`,`write()`,`format()`等等方法设置返回给浏览器的html内容。 设置相应内容 response.setContentType(\"text/html\"); 设置相应编码 response.setContentType(&quot;text/html; charset=UTF-8&quot;);不仅发送到浏览器的内容会使用UTF-8编码，而且还通知浏览器使用UTF-8编码方式进行显示。所以总能正常显示中文 response.setCharacterEncoding(&quot;UTF-8&quot;);仅仅是发送的浏览器的内容是UTF-8编码的，至于浏览器是用哪种编码方式显示不管。 所以当浏览器的显示编码方式不是UTF-8的时候，就会看到乱码，需要手动再进行一次设置。 301或者302客户端跳转 客户端有两种跳转: 302 表示临时跳转 response.sendRedirect(&quot;fail.html&quot;); 301 表示永久性跳转 response.setStatus(301); response.setHeader(&quot;Location&quot;, &quot;fail.html&quot;); 设置不使用缓存 123response.setDateHeader(&quot;Expires&quot;,0 );response.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);response.setHeader(&quot;pragma&quot;,&quot;no-cache&quot;); 参考: http://how2j.cn/k/servlet/servlet-upload/587.html#nowhere","categories":[{"name":"Java","slug":"Java","permalink":"https://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://sunyunzeng.com/tags/Servlet/"}]},{"title":"Git 常用命令","slug":"Git-常用命令","date":"2019-09-11","updated":"2022-11-05","comments":true,"path":"Git-常用命令/","link":"","permalink":"https://sunyunzeng.com/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Git简介Git是世界上最先进的分布式版本控制系统。 当时是为了帮助管理 linux 内核开发而开发的一个开源码版本控制系统。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 Git 是分布式版本控制系统，每个人的电脑上都有完整的版本库。 常用命令列表常用1234567891011121314151617181920$ git remote add origin git@github.com:yeszao&#x2F;dofiler.git # 配置远程git版本库$ git pull origin master # 下载代码及快速合并 $ git add . # 跟踪所有改动过的文件$ git add &lt;file&gt; # 跟踪指定的文件$ git commit -m “commit message” # 提交所有更新过的文件$ git push origin master # 上传代码及快速合并$ git fetch origin # 从远程库获取代码$ git branch # 显示所有分支$ git checkout master # 切换到master分支$ git checkout -b dev # 创建并切换到dev分支$ git commit -m &quot;first version&quot; # 提交$ git status # 查看状态$ git log # 查看提交历史$ git config --global core.editor vim # 设置默认编辑器为vim（git默认用nano）$ git config core.ignorecase false # 设置大小写敏感$ git config --global user.name &quot;YOUR NAME&quot; # 设置用户名$ git config --global user.email &quot;YOUR EMAIL ADDRESS&quot; # 设置邮箱 别名Alias123456789$ git config --global alias.br&#x3D;&quot;branch&quot; # 创建&#x2F;查看本地分支$ git config --global alias.co&#x3D;&quot;checkout&quot; # 切换分支$ git config --global alias.cb&#x3D;&quot;checkout -b&quot; # 创建并切换到新分支$ git config --global alias.cm&#x3D;&quot;commit -m&quot; # 提交$ git config --global alias.st&#x3D;&quot;status&quot; # 查看状态$ git config --global alias.pullm&#x3D;&quot;pull origin master&quot; # 拉取分支$ git config --global alias.pushm&#x3D;&quot;push origin master&quot; # 提交分支$ git config --global alias.log&#x3D;&quot;git log --oneline --graph --decorate --color&#x3D;always&quot; # 单行、分颜色显示记录$ git config --global alias.logg&#x3D;&quot;git log --graph --all --format&#x3D;format:&#39;%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold white)— %an%C(reset)%C(bold yellow)%d%C(reset)&#39; --abbrev-commit --date&#x3D;relative&quot; # 复杂显示 创建版本库12$ git clone &lt;url&gt; # 克隆远程版本库$ git init # 初始化本地版本库 修改和提交123456789$ git status # 查看状态$ git diff # 查看变更内容$ git add . # 跟踪所有改动过的文件$ git add &lt;file&gt; # 跟踪指定的文件$ git mv &lt;old&gt; &lt;new&gt; # 文件改名$ git rm &lt;file&gt; # 删除文件$ git rm --cached &lt;file&gt; # 停止跟踪文件但不删除$ git commit -m “commit message” # 提交所有更新过的文件$ git commit --amend # 修改最后一次提交 查看提交历史123$ git log # 查看提交历史$ git log -p &lt;file&gt; # 查看指定文件的提交历史$ git blame &lt;file&gt; # 以列表方式查看指定文件的提交历史 撤销12345$ git reset --hard HEAD # 撤消工作目录中所有未提交文件的修改内容$ git reset --hard &lt;version&gt; # 撤销到某个特定版本$ git checkout HEAD &lt;file&gt; # 撤消指定的未提交文件的修改内容$ git checkout -- &lt;file&gt; # 同上一个命令$ git revert &lt;commit&gt; # 撤消指定的提交 分支与标签1234567891011$ git branch # 显示所有本地分支$ git checkout &lt;branch&#x2F;tag&gt; # 切换到指定分支或标签$ git branch &lt;new-branch&gt; # 创建新分支$ git branch -d &lt;branch&gt; # 删除本地分支$ git tag # 列出所有本地标签$ git tag &lt;tagname&gt; # 基于最新提交创建标签$ git tag -a &quot;v1.0&quot; -m &quot;一些说明&quot; # -a指定标签名称，-m指定标签说明$ git tag -d &lt;tagname&gt; # 删除标签$ git checkout dev # 合并特定的commit到dev分支上$ git cherry-pick 62ecb3 合并与衍合1234$ git merge &lt;branch&gt; # 合并指定分支到当前分支$ git merge --abort # 取消当前合并，重建合并前状态$ git merge dev -Xtheirs # 以合并dev分支到当前分支，有冲突则以dev分支为准$ git rebase &lt;branch&gt; # 衍合指定分支到当前分支 远程操作12345678910复制代码$ git remote -v # 查看远程版本库信息$ git remote show &lt;remote&gt; # 查看指定远程版本库信息$ git remote add &lt;remote&gt; &lt;url&gt; # 添加远程版本库$ git remote remove &lt;remote&gt; # 删除指定的远程版本库$ git fetch &lt;remote&gt; # 从远程库获取代码$ git pull &lt;remote&gt; &lt;branch&gt; # 下载代码及快速合并$ git push &lt;remote&gt; &lt;branch&gt; # 上传代码及快速合并$ git push &lt;remote&gt; :&lt;branch&#x2F;tag-name&gt; # 删除远程分支或标签$ git push --tags # 上传所有标签 打包123$ git archive --format&#x3D;zip --output ..&#x2F;file.zip master # 将master分支打包成file.zip文件，保存在上一级目录$ git archive --format&#x3D;zip --output ..&#x2F;v1.2.zip v1.2 # 打包v1.2标签的文件，保存在上一级目录v1.2.zip文件中$ git archive --format&#x3D;zip v1.2 &gt; ..&#x2F;v1.2.zip # 作用同上一条命令 远程与本地合并123456$ git init # 初始化本地代码仓$ git add . # 添加本地代码$ git commit -m &quot;add local source&quot; # 提交本地代码$ git pull origin master # 下载远程代码$ git merge master # 合并master分支$ git push -u origin master # 上传代码 参考资料：https://www.cnblogs.com/ldj3/p/9172804.html https://www.zhihu.com/question/41667536/answer/486640083","categories":[{"name":"Git","slug":"Git","permalink":"https://sunyunzeng.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://sunyunzeng.com/tags/Git/"},{"name":"语法","slug":"语法","permalink":"https://sunyunzeng.com/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"TCP/IP协议","slug":"TCP-IP协议","date":"2019-09-10","updated":"2022-11-05","comments":true,"path":"TCP-IP协议/","link":"","permalink":"https://sunyunzeng.com/TCP-IP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"起源HTTP的来历CERN(欧洲核子研究组织)的蒂姆 • 伯纳斯 - 李(Tim BernersLee)博士提出了一种能让远隔两地的研究者们共享知识的设想。 最初的设想是通过超文本(HyperText)标记,各地互联连接成可相互参阅的WWW(World Wide Web, 万维网)。 目前WWW构建的关键技术为： 基于SGML(Standard Generalized Markup Language,标准通用标记语言)的HTML （HyperText Markup Language, 超文本标记语言）。 指定文档所在的地址URL (Uniform Resource Locator, 统一资源定位符) 。 各个Web服务器通过万维网互相连接，以 HTML 标准编辑网页（存储信息），用 URL 实现信息的查找，最后通过Web浏览器实现界面的渲染。 如何控制信息的传输？然而，Web服务器有各种各样的类型及硬件接口，显示平台也有各种各样的类型，如何实现平台之间信息的互相交流呢？ —— 统一协议控制。答案是通过统一的协议 (Protocol)。 TCP/TP 协议簇TCP/IP 有说法是专指TCP和IP协议。 这里指互联网相关的各类协议簇的总称，例如：IP, PPPoE, TCP, FTP, HTTP, FDDI, IEEE 802.3, SNMP, UDP, DNS, ICMP 等等。 也就是说 HTTP 是 TCP/IP 协议的子集。 分层管理在逻辑上，TCP/IP分为四个层次：应用层、传输层、网络层和数据链路层。 名称 作用 应用层 客户端实现信息的封装与解析。该层使用的协议如 HTTP、DNS (Domain Name System, 域名系统)、FTP (File Transfer Protocol, 文件传输协议)等。 传输层 提供网络连接中两台计算机之间的数据传输。使用的协议：TCP (Transmission Control Protocol) 和 UDP (User Data Protocol, 用户数据协议)。 网络层 将网络中流动的数据包（网络传输最小数据单位）通过规定的路径（传输线路）到达对方的计算机，并把数据传给对方。 数据链路层 肉眼可见的硬件层，包括网卡、光纤等。 数据传输过程 用户根据HTTP协议发送一个数据请求（应用层）。 获得应用层数据后，传输层（TCP协议）为了方便，将数据（HTTP请求报文）进行分割，每个报文打上标记序号及端口号，然后转发给网络层。 网络层将通信目的地的DNS增加到数据中，然后转发给数据链路层。 数据链路层将数据发给目的地终端。 在解析数据时，按照数据包装的逆序层层解包（去除每一层打上的首部信息），最终获得请求的HTTP报头。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://sunyunzeng.com/tags/TCP-IP/"},{"name":"http","slug":"http","permalink":"https://sunyunzeng.com/tags/http/"}]},{"title":"Leetcode 岛屿最大的面积","slug":"Leetcode-岛屿最大的面积","date":"2019-09-07","updated":"2022-11-05","comments":true,"path":"Leetcode-岛屿最大的面积/","link":"","permalink":"https://sunyunzeng.com/Leetcode-%E5%B2%9B%E5%B1%BF%E6%9C%80%E5%A4%A7%E7%9A%84%E9%9D%A2%E7%A7%AF/","excerpt":"","text":"题目给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) 示例1:12345678[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] 对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。 示例2:1[[0,0,0,0,0,0,0,0]] 对于上面这个给定的矩阵, 返回 0。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 思路+代码一开始想的是动态规划，但是该题没有规律的求解方法，即岛屿的形状无法用统一的方法计算。 此题采用 DFS（深度优先遍历）的方法求解。 DFS一般解体模板（https://blog.csdn.net/weixin_43272781/article/details/82959089）。 123456789101112131415161718192021int check(参数)&#123; if(满足条件) return 1; return 0;&#125; void dfs(int step)&#123; 判断边界 &#123; 相应操作 &#125; 尝试每一种可能 &#123; 满足check条件 标记 继续下一步dfs(step+1) 恢复初始状态（回溯的时候要用到） &#125;&#125; 此题的解法： 边界条件是二维矩阵的边界。 尝试每一种可能是上、下、左、右四个方向进行遍历。 check是是否为陆地（数值是否为1）。 标记是将遍历过的陆地变成海洋（置为0）。 123456789101112131415161718192021222324252627282930313233class Solution &#123; private int row; private int col; public int maxAreaOfIsland(int[][] grid) &#123; row = grid.length; col = grid[0].length; if(row==0 || col==0) return 0; int res = 0; for(int i=0; i&lt;row; i++)&#123; for(int j=0; j&lt;col; j++)&#123; if(grid[i][j]&gt;0)&#123; res = Math.max(res, dfs(grid, i, j)); &#125; &#125; &#125; return res; &#125; private int dfs(int[][] g, int i, int j)&#123; int sum = 1, x=0, y=0; int[][] dir = new int[][]&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; //避免再次被选到 g[i][j] = 0; for(int s=0;s&lt;4;s++)&#123; x = i + dir[s][0]; y = j + dir[s][1]; if(x&gt;=0 &amp;&amp; x&lt;row &amp;&amp; y&gt;=0 &amp;&amp; y&lt;col &amp;&amp; g[x][y]&gt;0)&#123; sum += dfs(g, x ,y); &#125; &#125; return sum; &#125;&#125; 题目链接：https://leetcode-cn.com/explore/interview/card/bytedance/243/array-and-sorting/1034/","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"回溯法","slug":"回溯法","permalink":"https://sunyunzeng.com/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"}]},{"title":"Markdown文件中添加UML图","slug":"Markdown文件中添加UML图","date":"2019-09-04","updated":"2022-11-05","comments":true,"path":"Markdown文件中添加UML图/","link":"","permalink":"https://sunyunzeng.com/Markdown%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0UML%E5%9B%BE/","excerpt":"","text":"UML图简介UML(Unified Modeling Language)是统一建模语言的简写。 它可分为用例视图、设计视图、进程视图、实现视图和拓扑视图，又可以静动分为静态视图和动态视图。静态图分为：用例图，类图，对象图，包图，构件图，部署图。动态图分为：状态图，活动图，协作图，序列图。 其中类图 (Class Diagrams)是用来表示类的内部结构和类与类之间的关系的一种UML。常见的关系有：泛化 (Generalization)，实现 (Realization)，组合 (Composition)，聚合 (Aggregation)，关联 (Association)，依赖 (Dependency)。 各种关系的强弱顺序： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 参考教程 UML类图的绘制及插入我们利用在线的开源工具plantUML实现UML图绘制。 具体的绘制方法可以参考官网plantUML。 然后将网址中生成的UML图片地址插入到Markdown文件中。 参考教程","categories":[{"name":"教程","slug":"教程","permalink":"https://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://sunyunzeng.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Leetcode 字符串的排列 (String 练习 03)","slug":"Leetcode-字符串的排列-String-练习-03","date":"2019-09-01","updated":"2022-11-05","comments":true,"path":"Leetcode-字符串的排列-String-练习-03/","link":"","permalink":"https://sunyunzeng.com/Leetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97-String-%E7%BB%83%E4%B9%A0-03/","excerpt":"","text":"题目给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。 换句话说，第一个字符串的排列之一是第二个字符串的子串。 示例1:123输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;输出: True解释: s2 包含 s1 的排列之一 (&quot;ba&quot;). 示例2:12输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;输出: False 注意:121. 输入的字符串只包含小写字母2. 两个字符串的长度都在 [1, 10,000] 之间 思路 1暴力法，滑动窗口依次判定。 但是超出时间限制！ 1234567891011121314151617181920212223class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; int len1 = s1.length(); int len2 = s2.length(); if(len2&lt;len1) return false; for(int i=0; i+len1&lt;=len2; i++)&#123; if(checkSubString(s1, s2.substring(i, i+len1))) return true; &#125; return false; &#125; private boolean checkSubString(String subS1, String subS2)&#123; String s = new String(subS2); for(int i=0; i&lt;subS1.length(); i++)&#123; if(s.indexOf(subS1.charAt(i))!=-1)&#123; s = s.replaceFirst(String.valueOf(subS1.charAt(i)), &quot;&quot;); &#125; &#125; return s.isEmpty()?true:false; &#125;&#125; 时间复杂度：O((len2-len1) len1 len2 * len2) 空间复杂度：O(1) 思路 2也是滑动窗口法，不过不用内置的函数（使用过程中存在循环遍历），而利用数组存储各个字母出现的次数，进行子串是否匹配的判定依据。 123456789101112131415161718192021222324252627class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; int len1 = s1.length(); int len2 = s2.length(); if(len2&lt;len1) return false; int[] temp1 = new int[26]; for(int i=0; i&lt;len1; i++) temp1[s1.charAt(i)-&#x27;a&#x27;]++; for(int i=0; i+len1&lt;=len2; i++)&#123; int[] temp2 = new int[26]; for(int j=0; j&lt;s1.length(); j++)&#123; temp2[s2.charAt(i+j)-&#x27;a&#x27;]++; &#125; if(match(temp1, temp2)) return true; &#125; return false; &#125; private boolean match(int[] tmp1, int[] tmp2)&#123; for(int i=0; i&lt;tmp1.length; i++)&#123; if(tmp1[i]!=tmp2[i]) return false; &#125; return true; &#125;&#125; 时间复杂度：O(len1 + (len2-len1) len1 26) 空间复杂度: O(1) 思路 3基于思路2，继续进行优化。其实在滑动窗口中，每次只更新哈希表（数组）的第一个值及最后一个值，中间的不需要遍历。因此时间复杂度降低 len1 123456789101112131415161718192021222324252627282930class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; int len1 = s1.length(); int len2 = s2.length(); if(len2&lt;len1) return false; int[] temp1 = new int[26]; int[] temp2 = new int[26]; for(int i=0; i&lt;len1; i++)&#123; temp1[s1.charAt(i)-&#x27;a&#x27;]++; temp2[s2.charAt(i)-&#x27;a&#x27;]++; &#125; if(match(temp1, temp2)) return true; for(int i=0; i+len1&lt;len2; i++)&#123; temp2[s2.charAt(i+len1)-&#x27;a&#x27;]++; temp2[s2.charAt(i)-&#x27;a&#x27;]--; if(match(temp1, temp2)) return true; &#125; return false; &#125; private boolean match(int[] tmp1, int[] tmp2)&#123; for(int i=0; i&lt;tmp1.length; i++)&#123; if(tmp1[i]!=tmp2[i]) return false; &#125; return true; &#125;&#125; 时间复杂度：O(len1 + (len2-len1) * 26) 空间复杂度: O(1) 作者：LeetCode链接：https://leetcode-cn.com/problems/permutation-in-string/solution/zi-fu-chuan-de-pai-lie-by-leetcode/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Leetcode 最长公共前缀 (String 练习 01)","slug":"Leetcode-最长公共前缀","date":"2019-08-31","updated":"2022-11-05","comments":true,"path":"Leetcode-最长公共前缀/","link":"","permalink":"https://sunyunzeng.com/Leetcode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","excerpt":"","text":"题目编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例1:12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例2:123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明:1所有输入只包含小写字母 a-z 。 思路1暴力法，时间复杂度O(n^3)。 123456789101112131415161718192021class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; String ans = &quot;&quot;; if(strs.length==0) return ans; lable:&#123; for(int j=0; j&lt;strs[0].length(); j++)&#123; char c = strs[0].charAt(j); for(int i=1; i&lt;strs.length; i++)&#123; if(j&gt;=strs[i].length() || !isCharEqual(c, strs[i], j))&#123; break lable; &#125; &#125; ans += c; &#125; &#125; return ans; &#125; private boolean isCharEqual(char c, String s, int i)&#123; return c==s.charAt(i); &#125;&#125; 思路2巧用String提供的一些API，例如substring(),判定子串的位置。 123456789101112131415class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; String ans; if(strs.length==0) return &quot;&quot;; ans = strs[0]; for(int i=1; i&lt;strs.length; i++)&#123; while(strs[i].indexOf(ans)!=0)&#123; ans = ans.substring(0, ans.length()-1); if(ans.isEmpty()) return ans; &#125; &#125; return ans; &#125; &#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Java: Set API","slug":"Java-Set-API","date":"2019-08-31","updated":"2022-11-05","comments":true,"path":"Java-Set-API/","link":"","permalink":"https://sunyunzeng.com/Java-Set-API/","excerpt":"","text":"Java Set概述Set 继承自集合（Collection），该集合不能包含相同的元素。 Set 里面进行元素是否相同的判定是通过 Object 类自带的equals()实现。 Set 最多可存储一个 null 元素。 Set 只是一个抽象的接口，具体的使用还要用具体的实现，如HashSet、TreeSet等。 常用方法因为 Set 继承自集合 Collection，所以具有集合的方法。 方法 描述 int size() 返回Set里面存储的元素个数。 boolean isEmpty() 如果没有元素，返回true。 boolean add(E e) 如果Set里面没有包含元素e，就将其加入。 boolean addAll(Collection&lt;? extends E&gt;c) 如果指定集合中的元素不存在Set中，就将其加入Set。如果该Collection也是一个Set，相当于对这两个Set取并集。 boolean contains(Object o) 是否包含特定的元素 o。即对Set里面的任意元素e执行判定(o==null?e==null:o.equals(e))。 boolean containsAll(Collecton&lt; ? &gt;c) 该Set是否包含指定Collection的所有元素。 void clear() 清除所有元素。 boolean remove(Object o) 删除指定元素。 boolean removeAll(Collection&lt; ? &gt;c) 删除Set中存在于该Collection里的元素。 Object[ ] toArray() 将Set转化为数组。 &lt; T &gt; T[ ] toArray(T[ ] a) 返回所有的Set元素并存储在Array中。如果a的长度大于Set长度，则多余空间以null补全。 Iterator&lt; E &gt; iterator() 返回一个该Set的迭代器 default Spliterator&lt; E &gt; spliterator() 在该集合中创建拆分器。 常用Set实现HashSetHashSet的方法基本与Set一致，只不过多了一个Object clone()方法（浅复制，只复制地址）。 主要方法包括： add() clear() clone() contains() isEmpty() iterator() remove() size() spliterator() HashSet底层是基于HashMap实现的。即通过HashMap的键唯一性实现。 构造方法示例123456789101112131415161718public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125;public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); &#125;public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor); &#125;public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity); &#125;// 该构造方法为LinkedHashSet实现准备HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125; LinkedHashSetLinkedHashSet保存了元素的顺序，即插入时的顺序，再使用iterator遍历时会按顺序遍历。 LinkedHashSet底层也是根据LinkHashMap实现的。通过父类HashSet的构造方法，调用LinkHashMap。123HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125; 继承自 HashSet，实现了接口 Serializable 及 Cloneable。 Serializable是一个空接口，是一个序列化的标记，用来告诉JVM该类可以序列化。 序列化就是把对象的状态转化为可存储和传输的格式（如二进制流）；反序列化就是序列化的逆过程，根据序列化后的数据重新恢复对象及其状态。 TreeSet可实现排序的Set，排序规则可以是自带的或者通过Comparator实现。 基础操作（add,contains and remove）的耗时是log(n)。 实现了NavigableSet接口，该接口是基于TreeMap的。 TreeSet底层是基于TreeMap实现，所以对于系统内部类例如Integer、String等，由于实现了Comparable接口，可直接进行存储；对于自定义的类，必须实现Comparable接口并重写comparaTo（）方法，这样TreeSet才能根据排序规则进行排序。 TreeSet不能有重复元素。 TreeSet的存取不如HashSet快。 comparaTo()方法在被调用过程中，如果返回真值（或大于零的数），就认为新插入元素大于根元素，存入右节点，此时为顺序排列；反之存入左节点，为逆序排列。 构造函数： 序号 构造函数的说明 1 TreeSet()，此构造函数构造空树集，将在根据其元素的自然顺序按升序排序。 2 TreeSet (集合 c)，此构造函数生成树的集合，它包含的元素的集合 c。 3 TreeSet (比较器 comp)，此构造函数构造一个空树集，将根据给定的比较器进行排序。 4 TreeSet (SortedSet ss)，此构造函数生成包含给定 SortedSet 的元素 TreeSet 常用方法： 修饰符和类型 方法和描述 boolean add(E e)，将指定的元素添加到这套，如果它已不存在。 boolean addAll(Collection&lt;? extends E&gt; c)，在加入这一组指定的集合中添加的所有元素。 E ceiling(E e)，返回最小的元素在这一组大于或等于给定的元素，则null如果没有这样的元素。 void clear()，从这一组中移除所有元素。 Object clone()，返回此TreeSet实例浅表副本。 Comparator&lt;? super E&gt; comparator()，返回用于排序在这集，或空元素，如果这套使用自然排序其元素的比较。 boolean contains(Object o)，如果此集合包含指定的元素，则返回true 。 Iterator descendingIterator()，返回迭代器中这套降序排序的元素。 NavigableSet descendingSet()，返回逆序视图中包含的元素这一套。 E first()，返回第一个 （最低） 元素当前在这一套。 E floor(E e)，返回的最大元素在这一组小于或等于null如果没有这样的元素。 SortedSet headSet(E toElement)，返回其元素是严格小于toElement这套的部分视图. NavigableSet headSet(E toElement, boolean inclusive)，返回一个视图的这部分设置的元素都小于 （或等于，如果inclusive是真的） toElement. E higher(E e)，返回最小的元素在这套严格大于给定的元素，则null如果没有这样的元素。 boolean isEmpty()，如果此集不包含任何元素，则返回true 。 Iterator iterator()，返回迭代器中这套以升序排序的元素。 E last()，在这套目前返回的最后一个 （最高） 的元素。 E lower(E e)，在这一套严格的小于给定的元素，则null返回的最大元素，如果没有这样的元素。 E pollFirst()，检索和删除第一个 （最低） 元素，或如果此集合为空，则返回null 。 E pollLast()，检索和删除的最后一个 （最高） 的元素，或如果此集合为空，则返回null 。 boolean remove(Object o)，从这一组中移除指定的元素，如果它存在。 int size()，在这套 （其基数） 中返回的元素的数目。 NavigableSet subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)，返回此集的部分视图的元素范围从fromElement到toElement. SortedSet subSet(E fromElement, E toElement)，返回视图的部分的这一套的元素范围从fromElement，具有包容性，到toElement，独家。 SortedSet tailSet(E fromElement)，返回其元素是大于或等于fromElement这套的部分视图. NavigableSet tailSet(E fromElement, boolean inclusive)，返回其元素是大于 （或等于，如果inclusive是真的） 这套的部分视图fromElement. 实现原理 TreeSet底层依赖于TreeMap，通过TreeMap来作为存储TreeSet的容易，键值保证了元素的唯一性。 采用“红黑树”的排序二叉树保存Map中的每个Entry，每个Entry被当做“红黑树”的一个节点。 “红黑树”是一种平衡二叉查找树，树中节点都大于等于左子树所有节点，且小于等于右子树左右节点。 TreeSet部分源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245package java.util;public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123; // 使用NavigableMap对象的key来保存Set集合的元素 private transient NavigableMap&lt;E,Object&gt; m; //使用PRESENT作为Map集合中的value private static final Object PRESENT = new Object(); // 不带参数的构造函数。创建一个空的TreeMap //以自然排序方法创建一个新的TreeMap，再根据该TreeMap创建一个TreeSet //使用该TreeMap的key来保存Set集合的元素 public TreeSet() &#123; this(new TreeMap&lt;E,Object&gt;()); &#125; // 将TreeMap赋值给 &quot;NavigableMap对象m&quot; TreeSet(NavigableMap&lt;E,Object&gt; m) &#123; this.m = m; &#125; //以定制排序的方式创建一个新的TreeMap。根据该TreeMap创建一个TreeSet //使用该TreeMap的key来保存set集合的元素 public TreeSet(Comparator&lt;? super E&gt; comparator) &#123; this(new TreeMap&lt;E,Object&gt;(comparator)); &#125; // 创建TreeSet，并将集合c中的全部元素都添加到TreeSet中 public TreeSet(Collection&lt;? extends E&gt; c) &#123; this(); // 将集合c中的元素全部添加到TreeSet中 addAll(c); &#125; // 创建TreeSet，并将s中的全部元素都添加到TreeSet中 public TreeSet(SortedSet&lt;E&gt; s) &#123; this(s.comparator()); addAll(s); &#125; // 返回TreeSet的顺序排列的迭代器。 // 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器 public Iterator&lt;E&gt; iterator() &#123; return m.navigableKeySet().iterator(); &#125; // 返回TreeSet的逆序排列的迭代器。 // 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器 public Iterator&lt;E&gt; descendingIterator() &#123; return m.descendingKeySet().iterator(); &#125; // 返回TreeSet的大小 public int size() &#123; return m.size(); &#125; // 返回TreeSet是否为空 public boolean isEmpty() &#123; return m.isEmpty(); &#125; // 返回TreeSet是否包含对象(o) public boolean contains(Object o) &#123; return m.containsKey(o); &#125; // 添加e到TreeSet中 public boolean add(E e) &#123; return m.put(e, PRESENT)==null; &#125; // 删除TreeSet中的对象o public boolean remove(Object o) &#123; return m.remove(o)==PRESENT; &#125; // 清空TreeSet public void clear() &#123; m.clear(); &#125; // 将集合c中的全部元素添加到TreeSet中 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // Use linear-time version if applicable if (m.size()==0 &amp;&amp; c.size() &gt; 0 &amp;&amp; c instanceof SortedSet &amp;&amp; m instanceof TreeMap) &#123; //把C集合强制转换为SortedSet集合 SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c; //把m集合强制转换为TreeMap集合 TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m; Comparator&lt;? super E&gt; cc = (Comparator&lt;? super E&gt;) set.comparator(); Comparator&lt;? super E&gt; mc = map.comparator(); //如果cc和mc两个Comparator相等 if (cc==mc || (cc != null &amp;&amp; cc.equals(mc))) &#123; //把Collection中所有元素添加成TreeMap集合的key map.addAllForTreeSet(set, PRESENT); return true; &#125; &#125; return super.addAll(c); &#125; // 返回子Set，实际上是通过TreeMap的subMap()实现的。 public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) &#123; return new TreeSet&lt;E&gt;(m.subMap(fromElement, fromInclusive, toElement, toInclusive)); &#125; // 返回Set的头部，范围是：从头部到toElement。 // inclusive是是否包含toElement的标志 public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) &#123; return new TreeSet&lt;E&gt;(m.headMap(toElement, inclusive)); &#125; // 返回Set的尾部，范围是：从fromElement到结尾。 // inclusive是是否包含fromElement的标志 public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) &#123; return new TreeSet&lt;E&gt;(m.tailMap(fromElement, inclusive)); &#125; // 返回子Set。范围是：从fromElement(包括)到toElement(不包括)。 public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) &#123; return subSet(fromElement, true, toElement, false); &#125; // 返回Set的头部，范围是：从头部到toElement(不包括)。 public SortedSet&lt;E&gt; headSet(E toElement) &#123; return headSet(toElement, false); &#125; // 返回Set的尾部，范围是：从fromElement到结尾(不包括)。 public SortedSet&lt;E&gt; tailSet(E fromElement) &#123; return tailSet(fromElement, true); &#125; // 返回Set的比较器 public Comparator&lt;? super E&gt; comparator() &#123; return m.comparator(); &#125; // 返回Set的第一个元素 public E first() &#123; return m.firstKey(); &#125; // 返回Set的最后一个元素 public E first() &#123; public E last() &#123; return m.lastKey(); &#125; // 返回Set中小于e的最大元素 public E lower(E e) &#123; return m.lowerKey(e); &#125; // 返回Set中小于/等于e的最大元素 public E floor(E e) &#123; return m.floorKey(e); &#125; // 返回Set中大于/等于e的最小元素 public E ceiling(E e) &#123; return m.ceilingKey(e); &#125; // 返回Set中大于e的最小元素 public E higher(E e) &#123; return m.higherKey(e); &#125; // 获取第一个元素，并将该元素从TreeMap中删除。 public E pollFirst() &#123; Map.Entry&lt;E,?&gt; e = m.pollFirstEntry(); return (e == null)? null : e.getKey(); &#125; // 获取最后一个元素，并将该元素从TreeMap中删除。 public E pollLast() &#123; Map.Entry&lt;E,?&gt; e = m.pollLastEntry(); return (e == null)? null : e.getKey(); &#125; // 克隆一个TreeSet，并返回Object对象 public Object clone() &#123; TreeSet&lt;E&gt; clone = null; try &#123; clone = (TreeSet&lt;E&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; clone.m = new TreeMap&lt;E,Object&gt;(m); return clone; &#125; // java.io.Serializable的写入函数 // 将TreeSet的“比较器、容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; s.defaultWriteObject(); // 写入比较器 s.writeObject(m.comparator()); // 写入容量 s.writeInt(m.size()); // 写入“TreeSet中的每一个元素” for (Iterator i=m.keySet().iterator(); i.hasNext(); ) s.writeObject(i.next()); &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 先将TreeSet的“比较器、容量、所有的元素值”依次读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden stuff s.defaultReadObject(); // 从输入流中读取TreeSet的“比较器” Comparator&lt;? super E&gt; c = (Comparator&lt;? super E&gt;) s.readObject(); TreeMap&lt;E,Object&gt; tm; if (c==null) tm = new TreeMap&lt;E,Object&gt;(); else tm = new TreeMap&lt;E,Object&gt;(c); m = tm; // 从输入流中读取TreeSet的“容量” int size = s.readInt(); // 从输入流中读取TreeSet的“全部元素” tm.readTreeSet(size, s, PRESENT); &#125; // TreeSet的序列版本号 private static final long serialVersionUID = -2479143000061671589L;&#125; 我们发现，TreeSet底层是依靠TreeMap对key进行存储排序实现的，现在看一下TreeMap的部分源码。 TreeMap的put()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public V put(K key, V value) &#123; //定义一个t来保存根元素 Entry&lt;K,V&gt; t = root; //如果t==null，表明是一个空链表 if (t == null) &#123; //如果根节点为null，将传入的键值对构造成根节点（根节点没有父节点，所以传入的父节点为null） root = new Entry&lt;K,V&gt;(key, value, null); //设置该集合的size为1 size = 1; //修改此时+1 modCount++; return null; &#125; // 记录比较结果 int cmp; Entry&lt;K,V&gt; parent; // 分割比较器和可比较接口的处理 Comparator&lt;? super K&gt; cpr = comparator; // 有比较器的处理，即采用定制排序 if (cpr != null) &#123; // do while实现在root为根节点移动寻找传入键值对需要插入的位置 do &#123; //使用parent上次循环后的t所引用的Entry // 记录将要被掺入新的键值对将要节点(即新节点的父节点) parent = t; // 使用比较器比较父节点和插入键值对的key值的大小 cmp = cpr.compare(key, t.key); // 插入的key较大 if (cmp &lt; 0) t = t.left; // 插入的key较小 else if (cmp &gt; 0) t = t.right; // key值相等，替换并返回t节点的value(put方法结束) else return t.setValue(value); &#125; while (t != null); &#125; // 没有比较器的处理 else &#123; // key为null抛出NullPointerException异常 if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 与if中的do while类似，只是比较的方式不同 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; // 没有找到key相同的节点才会有下面的操作 // 根据传入的键值对和找到的“父节点”创建新节点 Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(key, value, parent); // 根据最后一次的判断结果确认新节点是“父节点”的左孩子还是又孩子 if (cmp &lt; 0) parent.left = e; else parent.right = e; // 对加入新节点的树进行调整 fixAfterInsertion(e); // 记录size和modCount size++; modCount++; // 因为是插入新节点，所以返回的是null return null; &#125; 发现在插入过程中，会进行二叉树排序的判定： 如果新增节点大于当前节点且当前节点的右子节点存在，则以右子节点作为当前节点。并继续循环 如果新增节点小于当前节点且当前节点的左子节点存在，则以左子节点作为当前节点。并继续循环 如果新增节点等于当前节点，则新增节点覆盖当前节点，并结束循环。 TreeMap的get()方法123456public V get(Object key) &#123; //根据key取出Entry Entry&lt;K,V&gt; p = getEntry(key); //取出Entry所包含的value return (p==null ? null : p.value); &#125;关键在于 getEntry()是怎么根据Comparable取出对应Entry的。1234567891011121314151617181920212223242526272829303132final Entry&lt;K,V&gt; getEntry(Object key) &#123; // 如果有比较器，返回getEntryUsingComparator(Object key)的结果 if (comparator != null) return getEntryUsingComparator(key); // 查找的key为null，抛出NullPointerException if (key == null) throw new NullPointerException(); // 如果没有比较器，而是实现了可比较接口 //将key强制转换为Comparable接口 Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 获取根节点 Entry&lt;K,V&gt; p = root; // 从根节点开始对树进行遍历查找节点 while (p != null) &#123; // 把key和当前节点的key进行比较 int cmp = k.compareTo(p.key); // key小于当前节点的key if (cmp &lt; 0) // p “移动”到左节点上 p = p.left; // key大于当前节点的key else if (cmp &gt; 0) // p “移动”到右节点上 p = p.right; // key值相等则当前节点就是要找的节点 else // 返回找到的节点 return p; &#125; // 没找到则返回null return null;&#125; 其实就是一个二叉查找，根据Comparable进行key大小的判断。如果采用定制比较器，则采用getEntryUsingComparator()方法。 1234567891011121314151617181920212223242526272829final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123; K k = (K) key; // 获取比较器 Comparator&lt;? super K&gt; cpr = comparator; // 其实在调用此方法的get(Object key)中已经对比较器为null的情况进行判断，这里是防御性的判断 if (cpr != null) &#123; // 获取根节点 Entry&lt;K,V&gt; p = root; // 遍历树 while (p != null) &#123; // 获取key和当前节点的key的比较结果 int cmp = cpr.compare(k, p.key); // 查找的key值较小 if (cmp &lt; 0) // p“移动”到左孩子 p = p.left; // 查找的key值较大 else if (cmp &gt; 0) // p“移动”到右节点 p = p.right; // key值相等 else // 返回找到的节点 return p; &#125; &#125; // 没找到key值对应的节点，返回null return null;&#125; 参考资料1 参考资料2","categories":[{"name":"Java","slug":"Java","permalink":"https://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://sunyunzeng.com/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"Leetcode 无重复字符的最长子串（String 练习 02）","slug":"Leetcode-无重复字符的最长子串","date":"2019-08-30","updated":"2022-11-05","comments":true,"path":"Leetcode-无重复字符的最长子串/","link":"","permalink":"https://sunyunzeng.com/Leetcode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"","text":"题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例1:123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例2:123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例3:1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 思路 1暴力法，用Set记录检查的无重复的最长子串。 123456789101112131415161718192021class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; char[] chars = s.toCharArray(); if(chars.length==1) return 1; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int result = 0; for(int i=0; i &lt; chars.length-1; i++)&#123; set.add(chars[i]); for(int j=i+1; j&lt;chars.length;j++)&#123; if(!set.contains(chars[j]))&#123; set.add(chars[j]); &#125;else&#123; break; &#125; &#125; result = Math.max(result, set.size()); set.clear(); &#125; return result; &#125;&#125; 思路 2滑动窗口法。 暴力法虽然容易想到，但是很多情况重复考虑了。例如假定在 i ~ j 子串为不重复子串，那么该子串内的子串都会不重复。 滑动窗口法 1：采用标记记录左侧窗口的索引值。 12345678910111213141516171819202122class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int result = 0; char[] chars = s.toCharArray(); int leftIndex = 0; // 滑动窗口的右边索引 for(int i=0; i&lt;chars.length; i++)&#123; // 对于当前的滑动窗口进行重复性字符检查 for(int checkIndex = leftIndex; checkIndex&lt;i; checkIndex++)&#123; // 如果存在相同字符串，就更新窗口左边索引 if(chars[checkIndex]==chars[i])&#123; // 更新结果 result = Math.max(result, i-leftIndex); leftIndex = checkIndex+1; break;a &#125; &#125; &#125; // 检查最后一次窗口的长度与result保留长度进行对比 return Math.max(chars.length-leftIndex, result); &#125;&#125; 滑动窗口 2：巧用 HashSet，利用HashSet维护范围为 [i,j) 的滑动窗口。 先滑动右边，j++。如果存在重复，记录此时长度，再滑动左边 i++。直到所有的 i 遍历完成。 12345678910111213141516class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int ans=0, i=0, j=0; int len = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); while(i &lt; len &amp;&amp; j &lt; len)&#123; if(!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j++)); ans = Math.max(ans, j-i); &#125;else&#123; set.remove(s.charAt(i++)); &#125; &#125; return ans; &#125;&#125; 滑动窗口 3：上面的优化。如果 j 存在重复，那么 i 不仅移动一位，而是移动到 j+1 的位置。 123456789101112131415class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int ans = 0; int len = s.length(); for(int i=0, j=0; j&lt;len; j++)&#123; if(map.containsKey(s.charAt(j)))&#123; i = Math.max(i, map.get(s.charAt(j))); &#125; ans = Math.max(ans, j-i+1); map.put(s.charAt(j), j+1); &#125; return ans; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Leetcode 969.煎饼排序","slug":"Leetcode-969-煎饼排序","date":"2019-08-28","updated":"2022-11-05","comments":true,"path":"Leetcode-969-煎饼排序/","link":"","permalink":"https://sunyunzeng.com/Leetcode-969-%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F/","excerpt":"","text":"题目给定数组 A，我们可以对其进行煎饼翻转：我们选择一些正整数 k &lt;= A.length，然后反转 A 的前 k 个元素的顺序。我们要执行零次或多次煎饼翻转（按顺序一次接一次地进行）以完成对数组 A 的排序。 返回能使 A 排序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * A.length 范围内的有效答案都将被判断为正确。 示例 1:123456789输入：[3,2,4,1]输出：[4,2,4,3]解释：我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。初始状态 A = [3, 2, 4, 1]第一次翻转后 (k=4): A = [1, 4, 2, 3]第二次翻转后 (k=2): A = [4, 1, 2, 3]第三次翻转后 (k=4): A = [3, 2, 1, 4]第四次翻转后 (k=3): A = [1, 2, 3, 4]，此时已完成排序。 示例 2:12345输入：[1,2,3]输出：[]解释：输入已经排序，因此不需要翻转任何内容。请注意，其他可能的答案，如[3，3]，也将被接受。 思路煎饼反转就是以数组中心索引位置为轴，两两数字交换。例如最后一个数字与第一个数字交换，倒数第二个与第二个交换。 要想实现排序效果，就是依次把最大的放入最后面，这需要以下几步： 找到未排序的数组里面最大的数，并记录索引。 以该索引为数组边界，进行一次煎饼反转，将该数转到第一个数字。 以未排序的子数组边界索引为边界，进行一次煎饼反转，将该数转到最后面。 循环进行。 代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public List&lt;Integer&gt; pancakeSort(int[] A) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int size = A.length-1; while(size&gt;0)&#123; if(findIndex(A, size) &lt; size)&#123; // 两次反转将未排序子数组中最大的数字移到后面 // result记录反转的索引位置 result.add(findIndex(A, size)+1); reverse(A, 0, findIndex(A, size)); result.add(size+1); reverse(A, 0, size); &#125; size--; &#125; return result; &#125; // 煎饼反转算法 private static void reverse(int[] A, int i, int j)&#123; for(;i&lt;j;i++,j--)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; &#125; // 寻找当前数组的最大值所在的索引位置 private static int findIndex(int[] A, int size)&#123; int max=0, k=0; for(int i=0; i&lt;=size; i++)&#123; if(A[i]&gt;max)&#123; max = A[i]; k = i; &#125; &#125; return k; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/pancake-sorting著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"JVM如何回收对象","slug":"JVM如何回收对象","date":"2019-08-14","updated":"2022-11-05","comments":true,"path":"JVM如何回收对象/","link":"","permalink":"https://sunyunzeng.com/JVM%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"如何判断对象是否要回收？对象回收的依据——是否被有效引用？引用的可分为强引用(Strong Reference)——指向new 对象的引用、软引用(Soft Reference)——有用但没必要的引用、弱引用(Weak Reference)——没有必要的引用、虚引用(Phantom Reference)——为了在对象被回收时获得系统通知。 强引用只要存在就不回收；软引用只有在内存即将不足的情况下才回收；弱引用及虚引用随便回收。 怎么判断对象是否被有效引用？ 引用计数法。如果对象的引用计数器为0，则表示该对象可以回收。但是存在互相引用无法清理的情况。 可达性分析法。通过创建一个成为“GC Root”的对象作为搜索根节点，向下搜索。如果对象到该对象之间没有引用链关联，则该对象可回收。 对象死亡的判决书再对象确定没有引用的情况下，还需要判断其finalize方法没有被覆盖或者已经被执行一次（该方法只能执行一次），满足这两个条件，GC才会回收该对象。 如果finalize方法被覆盖，则将该对象加入一个 “F-Queue”队列中，由虚拟机创建的、优先级低的Finalizer的线程去处理。 如果对象在finalize方法中建立了与”GC Root”对象的连接链，则对象成功逃离了死亡的命运。否则，对象就被判决了死刑。 垃圾回收算法标记-清理算法。根据对象是否被有效引用进行标记，然后清理无用对象。 优点：简洁有效。 缺点：存在空间碎片，不利于下次对象内存的分配及内存空间的合理利用。 复制算法。将内存划分为两大块，一块用于存储对象，另一块用于复制准备。第一步也是标记，第二步是把不需清理的对象复制到另一块内存区域，保持这些对象在内存空间上是连续排列。 优点：无碎片空间，且新对象内存空间分配便捷。 缺点：二分法对空间利用率不高，且复制过程中效率不高。由于新生代中无用对象多，需要复制移动的对象少，所以该法很适合。 改进版：内存划分为一块较大的Eden内存空间及两块较小的Survivor空间（默认8:1:1），一块Eden及Survivor用于分配对象，另一块用于复制准备。如果要复制的对象的内存超出了准备的Survivor，则需要其他内存（老生代）进行分配担保。 标记-整理。第一步标记。第二步将存活的对象都往前移动，在内存空间中紧密排列，然后对于边界外的内存空间进行清理。 分代收集算法。将内存空间分为新生代与老生代。新生代中每次垃圾回收时都会有大量对象死亡，需要复制的对象很少，因此采用复制算法。老生代对象的利用率高，存活时间长，因此采用标记-清理或者标记整理算法。 垃圾回收器新生代垃圾收集器1. Serial收集器 特点： Serial 收集器只能使用一条线程进行垃圾收集工作，并且在进行垃圾收集的时候，所有的工作线程都需要停止工作，等待垃圾收集线程完成以后，其他线程才可以继续工作。 使用算法：复制算法 2. ParNew收集器 特点： ParNew 垃圾收集器是Serial收集器的多线程版本。为了利用 CPU 多核多线程的优势，ParNew 收集器可以运行多个收集线程来进行垃圾收集工作。这样可以提高垃圾收集过程的效率。 使用算法：复制算法 3. Parallel Scavenge收集器 特点： Parallel Scavenge 收集器是一款多线程的垃圾收集器，但是它又和 ParNew 有很大的不同点。Parallel Scavenge 收集器和其他收集器的关注点不同。其他收集器，比如 ParNew 和 CMS 这些收集器，它们主要关注的是如何缩短垃圾收集的时间。而 Parallel Scavenge 收集器关注的是如何控制系统运行的吞吐量。这里说的吞吐量，指的是 CPU 用于运行应用程序的时间和 CPU 总时间的占比，吞吐量 = 代码运行时间 / （代码运行时间 + 垃圾收集时间）。如果虚拟机运行的总的 CPU 时间是 100 分钟，而用于执行垃圾收集的时间为 1 分钟，那么吞吐量就是 99%。 使用算法：复制算法 老年代垃圾收集器1. Serial Old收集器 特点： Serial Old 收集器是 Serial 收集器的老年代版本。这款收集器主要用于客户端应用程序中作为老年代的垃圾收集器，也可以作为服务端应用程序的垃圾收集器。 使用算法：标记-整理 2. Parallel Old收集器 特点： Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本这个收集器是在 JDK1.6 版本中出现的，所以在 JDK1.6 之前，新生代的 Parallel Scavenge 只能和 Serial Old 这款单线程的老年代收集器配合使用。Parallel Old 垃圾收集器和 Parallel Scavenge 收集器一样，也是一款关注吞吐量的垃圾收集器，和 Parallel Scavenge 收集器一起配合，可以实现对 Java 堆内存的吞吐量优先的垃圾收集策略。 使用算法：标记-整理 3. CMS收集器 特点： CMS 收集器是目前老年代收集器中比较优秀的垃圾收集器。CMS 是 Concurrent Mark Sweep，从名字可以看出，这是一款使用”标记-清除”算法的并发收集器。CMS 收集器的工作过程可以分为 4 个阶段：初始标记（CMS initial mark）阶段、并发标记（CMS concurrent mark）阶段、重新标记（CMS remark）阶段、并发清除(（CMS concurrent sweep）阶段。 使用算法：复制+标记清除 3. G1 垃圾收集器 特点： 主要步骤：初始标记，并发标记，重新标记，复制清除。使用算法：复制 + 标记整理 参考:深入理解java虚拟机 JVM面试突破","categories":[{"name":"Java","slug":"Java","permalink":"https://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://sunyunzeng.com/tags/JVM/"}]},{"title":"Leetcode 638.大礼包","slug":"Leetcode-638-大礼包","date":"2019-08-13","updated":"2022-11-05","comments":true,"path":"Leetcode-638-大礼包/","link":"","permalink":"https://sunyunzeng.com/Leetcode-638-%E5%A4%A7%E7%A4%BC%E5%8C%85/","excerpt":"","text":"题目在LeetCode商店中， 有许多在售的物品。 然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。 现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。 每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。 任意大礼包可无限次购买。 示例1:1234567输入: [2,5], [[3,0,5],[1,2,10]], [3,2]输出: 14解释: 有A和B两种物品，价格分别为¥2和¥5。大礼包1，你可以以¥5的价格购买3A和0B。大礼包2， 你可以以¥10的价格购买1A和2B。你需要购买3个A和2个B， 所以你付了¥10购买了1A和2B（大礼包2），以及¥4购买2A。 示例2:1234567输入: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]输出: 11解释: A，B，C的价格分别为¥2，¥3，¥4.你可以用¥4购买1A和1B，也可以用¥9购买2A，2B和1C。你需要买1A，2B和1C，所以你付了¥4买了1A和1B（大礼包1），以及¥3购买1B， ¥4购买1C。你不可以购买超出待购清单的物品，尽管购买大礼包2更加便宜。 思路 + 代码DFS + 剪枝 即使暴力法，然后提出一些不满足条件的情况，即购买数量超出 (大礼包数量不对) 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int shoppingOffers(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs) &#123; return subShoppingOffers(price, special, needs, 0); &#125; private int subShoppingOffers(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs, int index)&#123; // index标记，顺序开始计算，防止(1,2) 与 (2,1) 的重复计算 int minCost = originalCost(price, needs); for(int i=index; i&lt;special.size(); i++)&#123; // 统计当前还需要购买多少物品 List&lt;Integer&gt; currentNeeds = new ArrayList&lt;&gt;(); // 当前礼包信息 List&lt;Integer&gt; offer = special.get(i); for(int j=0; j&lt;needs.size(); j++)&#123; // 剪枝 if(offer.get(j) &gt; needs.get(j))&#123; currentNeeds = null; break; &#125; currentNeeds.add(needs.get(j)-offer.get(j)); &#125; // 如果礼包中物品的数量没有超,则加上该礼包金额，并且继续深度优先(DFS)遍历 if(currentNeeds!=null)&#123; minCost = Math.min(minCost, offer.get(offer.size()-1)+subShoppingOffers(price, special, currentNeeds, i)); &#125; &#125; return minCost; &#125; private int originalCost(List&lt;Integer&gt; price, List&lt;Integer&gt; needs)&#123; int sum = 0; for(int i=0; i&lt;needs.size(); i++)&#123; sum += price.get(i) * needs.get(i); &#125; return sum; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shopping-offers著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Java 运行时数据区域","slug":"Java-运行时数据区域","date":"2019-08-08","updated":"2022-11-05","comments":true,"path":"Java-运行时数据区域/","link":"","permalink":"https://sunyunzeng.com/Java-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/","excerpt":"","text":"定义Java虚拟机把所管理的内存划分为不同的区域，总称为运行时数据区域。 数据区域用途各不相同，有的随虚拟机启动而存在，有的随线程的生命周期存在。 根据《Java虚拟机规范（Java SE7版)》规定，Java虚拟机将数据区域划分为：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区（运行时常量池）。 程序计数器• 线程私有，每个线程都有一个用来记录字节码执行位置。 • 一块内存区域，java虚拟机规范中唯一没有规定OutOfMemoryError的区域。 • java字节码解释器通过改变计数器的值实现分支、跳转、循环、异常处理、线程恢复等操作。 • 如果执行的是Java方法，则存储的是虚拟机字节码指令地址；如果是Native方法，则存储为空。 Java虚拟机栈• 所谓的栈内存指的就是Java虚拟机栈。 • Java方法的运行，都会生成一个栈帧，用来存储执行Java方法的局部变量、操作数栈、动态链接、方法出口等信息。 • 一个Java方法的执行到结束，对应为一个栈帧的出栈与入栈。 • 虚拟机栈可以为固定内存，也可动态扩展。如果线程请求栈深度大于虚拟机深度，则会报StackOverflowError;如果动态扩展时无法申请到足够内存，则会报OutOfMemoryError。 本地方法栈• 与Java虚拟机栈类似，但是是为Native方法的执行提供服务。 • 也会抛出StackOverflowError与OutOfMemoryError。 Java堆• 各线程共享区域。 • 是java虚拟机管理的最大的一块内存区域。 • 是Java对象实例存储的空间。 • 是垃圾收集器主要工作区域。 • 存储空间逻辑上连续，物理上可以不连续。 • 可设置为固定大小或动态扩展，如果动态扩展时无法申请到足够内存，则会报OutOfMemoryError。 方法区• 各线程共享区域。 • 用于存储已被Java虚拟机加载的类信息，常量，静态变量、即时编译器编译后的代码等。 • 方法区无法内存分配需求时，会抛出OutOfMemoryError。 运行时常量池• 是方法区的一部分。 • Class类文件中有一项是常量池，用来存放编译期生成的字面量和符号引用。 • 类加载后常量池存储在方法区内的运行时常量池。 • 具有动态性，非编译期间的新的常量也可放入运行时常量池中。 直接内存• 不是Java虚拟机规范定义的内存区域。 • JDK1.4后新加入的NI/O（New Input/Output）类，引入了仅与通道（Channel）与缓存。(Buffer)的I/O方式，可以直接通过Native函数库分配堆外内存。 • 内存收到本机总内存及处理器寻址空间的限制。直接内存无法内存分配需求时，会抛出OutOfMemoryError。 参考:深入理解java虚拟机","categories":[{"name":"Java","slug":"Java","permalink":"https://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://sunyunzeng.com/tags/JVM/"}]},{"title":"Leetcode 1046.最后一块石头的重量","slug":"Leetcode-1046-最后一块石头的重量","date":"2019-07-30","updated":"2022-11-05","comments":true,"path":"Leetcode-1046-最后一块石头的重量/","link":"","permalink":"https://sunyunzeng.com/Leetcode-1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/","excerpt":"","text":"题目有一堆石头，每块石头的重量都是正整数。 每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎；如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。 提示121 &lt;= stones.length &lt;= 301 &lt;= stones[i] &lt;= 1000 思路（排序 -&gt; 选最大及第二大做差 -&gt; 更新数组 -&gt; 排序）（循环 length-1 次） -&gt;最大的为结果 代码1234567891011class Solution &#123; public int lastStoneWeight(int[] stones) &#123; int len = stones.length; for(int i=len-1; i&gt;=1; i--)&#123; Arrays.sort(stones); stones[len-1] = stones[len-1]-stones[len-2]; stones[len-2] = 0; &#125; return stones[len-1]; &#125;&#125; 或者采用优先堆栈的方法维护数据的先后顺序 123456789101112131415161718192021class Solution &#123; public int lastStoneWeight(int[] stones) &#123; int len = stones.length; Queue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(new Comparator&lt;Integer&gt;()&#123; public int compare(Integer a, Integer b)&#123; return (b - a); &#125; &#125;); for(int i=0; i&lt;len; i++)&#123; queue.add(stones[i]); &#125; while(queue.size()&gt;1)&#123; int a = queue.poll(); int b = queue.poll(); if(a-b != 0)&#123; queue.add(a-b); &#125; &#125; return queue.isEmpty()?0:queue.poll(); &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/last-stone-weight著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"贪心法","slug":"贪心法","permalink":"https://sunyunzeng.com/tags/%E8%B4%AA%E5%BF%83%E6%B3%95/"}]},{"title":"Leetcode 647.回文子串","slug":"Leetcode-647-回文子串","date":"2019-07-28","updated":"2022-11-05","comments":true,"path":"Leetcode-647-回文子串/","link":"","permalink":"https://sunyunzeng.com/Leetcode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","excerpt":"","text":"题目给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。 示例1：123输入: &quot;abc&quot;输出: 3解释: 三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;. 示例2：123输入: &quot;aaa&quot;输出: 6说明: 6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;. 注意：1输入的字符串长度不会超过1000。 思路 + 代码回文子串的内部一定是回文子串，因此关键在于重复利用回文子串已经统计过的数值。 可采用双指针由回文子串向两端同时检测的方法。 分为偶数回文子串与奇数回文子串。 123456789101112131415161718class Solution &#123; private int sum = 0; public int countSubstrings(String s) &#123; int len = s.length(); for(int i=0; i&lt;len; i++)&#123; count(s, i, i); // 统计奇数的回文子串数量 count(s, i, i+1); //统计偶数的回文子串数量 &#125; return sum; &#125; private void count(String s, int start, int end)&#123; while(start&gt;=0 &amp;&amp; end&lt;s.length() &amp;&amp; s.charAt(start)==s.charAt(end))&#123; sum++; start--; end++; &#125; &#125;&#125; 思路 + 代码采用动态规划，用一个二维数组 dp[i][j] 统计字符串从 i ~ j 是否是回文子串。 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int countSubstrings(String s) &#123; int sum = 0; int length = s.length(); // 用dp数组存储回文子串结果，第一维为长度（有哨兵），第二维为起始位置 boolean[][] dp = new boolean[length+1][length]; for(int i=1; i&lt;length+1; ++i)&#123; for(int j=0; j&lt;length; ++j)&#123; // 所有长度为1的子串都为回文子串 if(i==1)&#123; dp[j][j] = true; sum++; &#125; // 所有长度为2的子串情况 else if(i==2)&#123; if(j+1&lt;length &amp;&amp; s.charAt(j)==s.charAt(j+1))&#123; dp[j][j+1] = true; sum++; &#125; &#125; // 长度大于3的情况 else&#123; if(j+i-1&lt;length &amp;&amp; dp[j+1][j+i-2] &amp;&amp; s.charAt(j)==s.charAt(j+i-1))&#123; dp[j][j+i-1] = true; sum++; &#125; &#125; &#125; &#125; return sum; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Leetcode 983.最低票价","slug":"Leetcode-983-最低票价","date":"2019-07-18","updated":"2022-11-05","comments":true,"path":"Leetcode-983-最低票价/","link":"","permalink":"https://sunyunzeng.com/Leetcode-983-%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B7/","excerpt":"","text":"题目在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。 火车票有三种不同的销售方式： 一张为期一天的通行证售价为 costs[0] 美元；一张为期七天的通行证售价为 costs[1] 美元；一张为期三十天的通行证售价为 costs[2] 美元。通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。 返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。 示例1：12345678输入：days = [1,4,6,7,8,20], costs = [2,7,15]输出：11解释： 例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。你总共花了 $11，并完成了你计划的每一天旅行。 示例2：1234567输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]输出：17解释：例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 你总共花了 $17，并完成了你计划的每一天旅行。 提示：123451 &lt;= days.length &lt;= 3651 &lt;= days[i] &lt;= 365days 按顺序严格递增costs.length == 31 &lt;= costs[i] &lt;= 1000 思路动态规划。 ans[i] = min(ans[i-1]+costs[0] + ans[i-7]+costs[1] + ans[i-30]+costs[2]); 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int mincostTickets(int[] days, int[] costs) &#123; int len = days.length; int[] results = new int[len]; for(int i=0; i&lt;len; ++i)&#123; results[i] = Integer.MAX_VALUE; &#125; // 防止一周或者一月的火车票更便宜的情况出现 int minCost = Math.min(Math.min(costs[0],costs[1]),costs[2]); results[0] = costs[0]; // 动态规划寻找最优值，分三种情况，计划时间一周内，一周到一个月，一个月以上 for(int i=1; i&lt;len; ++i)&#123; if(days[i]&lt;=7)&#123; results[i] = Math.min(minCost+results[i-1],costs[1]); &#125;else if(7&lt;days[i]&amp;&amp;days[i]&lt;=30)&#123; // 遍历具今天最近的一周外的时间 int j=i; while(days[j]&gt;days[i]-7)&#123; j--; if(j&lt;0) break; &#125; // 这种情况是如果最开始的到当前时间都在一周内，例如[5,7,8,9] int tmp0 = j&lt;0?0:results[j]; results[i] = Math.min(Math.min(results[i-1]+minCost,costs[1]+tmp0),costs[2]); &#125;else if(30&lt;days[i])&#123; // 同上 int k=i; while(days[k]&gt;days[i]-30)&#123; k--; if(k&lt;0) break; &#125; int m=i; while(days[m]&gt;days[i]-7 &amp;&amp; m&gt;0)&#123; m--; if(m&lt;0) break; &#125; int tmp1 = k&lt;0?0:results[k]; int tmp2 = m&lt;0?0:results[m]; results[i] = Math.min(Math.min(results[i-1]+minCost,costs[2]+tmp1),costs[1]+tmp2); &#125; &#125; return results[len-1]; &#125;&#125; 大神的做法，扩充dp数组，实现算法的一致，即简化了代码，又提高了代码的运行效率。 1234567891011121314151617class Solution &#123; public int mincostTickets(int[] days, int[] costs) &#123; boolean[] rec = new boolean[365+1]; for(int day:days) rec[day] = true; int lastDay = days[days.length-1]+30; // 扩充一个月dp数组使得判定条件一致 int[] dp = new int[366+30]; for(int i=31; i&lt;=lastDay; ++i)&#123; if(rec[i-30]) dp[i] = Math.min(Math.min(dp[i-1]+costs[0],dp[i-7]+costs[1]),dp[i-30]+costs[2]); else dp[i]=dp[i-1]; &#125; return dp[lastDay]; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-cost-for-tickets著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Leetcode 11.盛最多水的容器","slug":"Leetcode-11-盛最多水的容器","date":"2019-07-17","updated":"2022-11-05","comments":true,"path":"Leetcode-11-盛最多水的容器/","link":"","permalink":"https://sunyunzeng.com/Leetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","excerpt":"","text":"题目给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明: 你不能倾斜容器，且 n 的值至少为 2。 思路 + 代码方法1：暴力破解法 即遍历所有情况，找到最优解。 123456789101112class Solution &#123; public int maxArea(int[] height) &#123; int len = height.length; int res = 0; for(int i=1; i&lt;len; i++)&#123; for(int j=0; j&lt;i; j++)&#123; res = Math.max((i-j)*Math.min(height[i], height[j]),res); &#125; &#125; return res; &#125;&#125; 时间复杂度O(n^2), 空间复杂度 1 方法2：双指针法 两个指针，一个指向数组首，一个指向数组尾。 指向数字小的往中间移动，并计算一次结果。 取最优即为最终结果。 原因请戳-algorithm) 1234567891011121314151617class Solution &#123; public int maxArea(int[] height) &#123; int last = height.length-1; int first = 0; int res = 0; while(first &lt; last)&#123; int tmp = (last-first)*Math.min(height[first], height[last]); if(height[first] &lt;= height[last])&#123; first++; &#125;else&#123; last--; &#125; res = Math.max(res,tmp); &#125; return res; &#125;&#125; 时间复杂度O(n), 空间复杂度 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/container-with-most-water著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Leetcode 347.前K个高频元素","slug":"Leetcode-347-前K个高频元素","date":"2019-07-15","updated":"2022-11-05","comments":true,"path":"Leetcode-347-前K个高频元素/","link":"","permalink":"https://sunyunzeng.com/Leetcode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/","excerpt":"","text":"题目给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例1:12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例2:12输入: nums = [1], k = 1输出: [1] 说明:12你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 思路首先用一个HashMap统计不同数字出现的次数。 然后用一个最小堆维护k大小的结果。 这里采用java的优先队列 PriorityQueue 去维护最小堆。 这里需要注意的一点是比较器的设计，部分源代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public boolean add(E e) &#123; return offer(e); &#125;public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length) grow(i + 1); size = i + 1; if (i == 0) queue[0] = e; else siftUp(i, e); return true; &#125;private void siftUp(int k, E x) &#123; if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x); &#125;private void siftUp(int k, E x) &#123; if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x); &#125;@SuppressWarnings(&quot;unchecked&quot;)private void siftUpComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (key.compareTo((E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = key;&#125;@SuppressWarnings(&quot;unchecked&quot;)private void siftUpUsingComparator(int k, E x) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; // 注意：这里的比较原则是当前的与栈顶元素比较，大的就进行替换，所以维护的是最小堆栈。 if (comparator.compare(x, (E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = x;&#125; PriorityQueue方法参考博文 代码1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;Integer&gt;(new Comparator&lt;Integer&gt;()&#123; public int compare(Integer a, Integer b)&#123; return map.get(a) - map.get(b); &#125; &#125;); int len = nums.length; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); // 统计各数字出现次数 for(int i=0; i&lt;len; ++i)&#123; if(map.containsKey(nums[i]))&#123; map.put(nums[i], map.get(nums[i])+1); &#125;else&#123; map.put(nums[i], 1); &#125; &#125; // 使用最小堆更新结果 for(int i:map.keySet())&#123; if(pq.size()&lt;k)&#123; pq.add(i); &#125;else&#123; if(map.get(i)&gt;map.get(pq.peek()))&#123; pq.remove(); pq.add(i); &#125; &#125; &#125; while(!pq.isEmpty())&#123; result.add(pr.poll()); &#125; return result; &#125;&#125;l","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Leetcode 739.每日温度","slug":"Leetcode-739-每日温度","date":"2019-07-12","updated":"2022-11-05","comments":true,"path":"Leetcode-739-每日温度/","link":"","permalink":"https://sunyunzeng.com/Leetcode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/","excerpt":"","text":"题目根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 思路+代码最简单的思路，两次循环。 1234567891011121314151617class Solution &#123; public int[] dailyTemperatures(int[] T) &#123; int len = T.length; int[] results = new int[len]; for(int i=0; i&lt;len-1; i++)&#123; int tmp = 0; for(int j=i+1; j&lt;len; j++)&#123; if(T[j]&gt;T[i])&#123; results[i]=tmp+1; break; &#125; tmp++; &#125; &#125; return results; &#125;&#125; 利用栈 栈的特性是先进后出，所以需要从后往前遍历。 维护一个递减数据的索引（天）序列。 如果当前数据（温度）大于等于栈顶索引（天）对应的数据（温度），则更新栈内数据，保持递减特性。 否则计算当前数据索引（天）与栈顶所索引（天）为结果值。 123456789101112131415161718class Solution &#123; public int[] dailyTemperatures(int[] T) &#123; int len = T.length; int[] results = new int[len]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int i=len-1; i&gt;=0; --i)&#123; while(!stack.isEmpty() &amp;&amp; T[i] &gt;= T[stack.peek()])&#123; stack.pop(); &#125; if(!stack.isEmpty()) // 更新结果值 results[i] = stack.peek() - i; // 维护递减序列 stack.push(i); &#125; return results; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/daily-temperatures著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Leetcode 287.寻找重复数","slug":"Leetcode-287-寻找重复数","date":"2019-07-06","updated":"2022-11-05","comments":true,"path":"Leetcode-287-寻找重复数/","link":"","permalink":"https://sunyunzeng.com/Leetcode-287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/","excerpt":"","text":"题目给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例1：12输入: [1,3,4,2,2]输出: 2示例2：12输入: [3,1,3,4,2]输出: 3说明：1234不能更改原数组（假设数组是只读的）。只能使用额外的 O(1) 的空间。时间复杂度小于 O(n2) 。数组中只有一个重复的数字，但它可能不止重复出现一次。 思路 + 代码易想到方法 不符合题目要求，因为需要额外的空间。 用链表或者HashMap存储数值，遇到相同的已存储的数就返回。空间复杂度最坏O(n)，时间复杂度最坏O(n)。 或者先排序，遇到相同的数返回。时间复杂度视排序方法而定，最好O(log(n))。 巧妙算法1 巧用快慢指针。 数组的索引与存储的数值之间形成了特殊链表。 如果存在重复的数，因为数组大小是 n+1，数字范围是1~n，所以该链表存在环。 环的入口即为结果。 答案的求解变成环入口的求解。思路 123456789101112131415161718class Solution &#123; public int findDuplicate(int[] nums) &#123; // 快慢指针 int fast = nums[0]; int low = nums[0]; do&#123; low = nums[low]; fast = nums[nums[fast]]; &#125;while(fast != low); int step = nums[0]; // 寻找环链表的入口，即为结果 while(step != low)&#123; step = nums[step]; low = nums[low]; &#125; return low; &#125;&#125; 巧妙算法2 二分法。 统计小于中间数 mid 的数值数量，如果大于，则在0~mid之间寻找。 反之，则在mid~high中寻找。 最终找到重复的数值。 123456789101112131415161718192021class Solution &#123; public int findDuplicate(int[] nums) &#123; // 二分法 int len = nums.length; int low = 0; int hight = len-1; while(low&lt;hight)&#123; int count = 0; int mid = low+(hight-low)/2; for(int i=0; i&lt;len; i++)&#123; if(nums[i]&lt;=mid) count++; &#125; if(count&lt;=mid) low = mid+1; else hight = mid; &#125; return low; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-the-duplicate-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Leetcode 746.使用最小花费爬楼梯","slug":"Leetcode-746-使用最小花费爬楼梯","date":"2019-07-05","updated":"2022-11-05","comments":true,"path":"Leetcode-746-使用最小花费爬楼梯/","link":"","permalink":"https://sunyunzeng.com/Leetcode-746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/","excerpt":"","text":"题目数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。 示例1：123输入: cost = [10, 15, 20]输出: 15解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。 示例2：123输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出: 6解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。 注意：121. cost 的长度将会在 [2, 1000]。2. 每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。 思路典型的动态规划问题，上楼梯问题。 注意的是，最后的结果是最后一阶楼梯与倒数第二个楼梯中取最小值。 代码class Solution &#123; public int minCostClimbingStairs(int[] cost) &#123; int len = cost.length; if(len==2) return(Math.min(cost[0], cost[1])); int[] result = new int[len]; result[0]=cost[0]; result[1]=cost[1]; for(int i=2; i&lt;len; i++)&#123; result[i] = Math.min(result[i-1], result[i-2])+cost[i]; &#125; // noted return Math.min(result[len-2], result[len-1]); &#125; &#125; ` 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Leetcode 102.二叉树的层次遍历","slug":"Leetcode-102-二叉树的层次遍历","date":"2019-07-04","updated":"2022-11-05","comments":true,"path":"Leetcode-102-二叉树的层次遍历/","link":"","permalink":"https://sunyunzeng.com/Leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/","excerpt":"","text":"题目给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7],12345 3 / \\9 20 / \\ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 思路 + 代码二叉树相关算法题两种解题思路：递归和迭代。 递归方法 用一个辅助函数，更新结果。 记录遍历的层数，并按照从左到右的顺序依次在相应层数List中记录数值。 返回结果。 代码1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public void helper(TreeNode root, int level)&#123; // 更新记录List if(results.size()==level) results.add(new ArrayList&lt;Integer&gt;()); // 从左到右记录数据 results.get(level).add(root.val); if(root.left!=null) helper(root.left, level+1); if(root.right!=null) helper(root.right, level+1); &#125; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; if(root==null) return results; helper(root, 0); return results; &#125;&#125; 迭代方法: 用队列辅助，先进的节点先出。 层层进队列，然后层层出队列，存入结果results中。 代码:12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); if(root==null) return results; queue.add(root); int level = 0; while(!queue.isEmpty())&#123; results.add(new ArrayList&lt;Integer&gt;()); int levelLength = queue.size(); // 将level层元素依次存入List，level+1层节点依次入队列 for(int i=0; i&lt;levelLength; ++i)&#123; // 改成节点出队列 root = queue.remove(); // 按层存入 results.get(level).add(root.val); // 下一层节点入队列 if(root.left!=null) queue.add(root.left); if(root.right!=null) queue.add(root.right); &#125; level++; &#125; return results; &#125;&#125; 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sunyunzeng.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Leetcode 94.二叉树的中序遍历","slug":"Leetcode-94-二叉树的中序遍历","date":"2019-07-03","updated":"2022-11-05","comments":true,"path":"Leetcode-94-二叉树的中序遍历/","link":"","permalink":"https://sunyunzeng.com/Leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"题目描述给定一个二叉树，返回它的中序 遍历。 示例:12345678输入: [1,null,2,3] 1 \\ 2 / 3输出: [1,3,2] 进阶:递归算法很简单，你可以通过迭代算法完成吗？ 思路 + 代码递归方法递归截止条件：root==null 递归执行条件： list.add(inorderTraversal(root.left)) list.add(root.val) list.add(inorderTraversal(root.right)) 代码 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List &lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List &lt;Integer&gt; res = new ArrayList &lt;&gt; (); helper(root, res); return res; &#125; public void helper(TreeNode root, List &lt;Integer&gt; res) &#123; if (root != null) &#123; if (root.left != null) &#123; helper(root.left, res); &#125; res.add(root.val); if (root.right != null) &#123; helper(root.right, res); &#125; &#125; &#125;&#125; 迭代方法用一个栈存储遍历过得父子节点，循环遍历。 代码 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); // 当树没有遍历完全 while(root!=null || !stack.isEmpty())&#123; // 找到当前树的最左侧叶子节点（父节点） while(root!=null)&#123; stack.push(root); root=root.left; &#125; // 中序遍历 root = stack.pop(); list.add(root.val); root = root.right; &#125; return list; &#125;&#125; 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sunyunzeng.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Leetcode 215.数组中第K个最大元素","slug":"Leetcode-215-数组中第K个最大元素","date":"2019-07-01","updated":"2022-11-05","comments":true,"path":"Leetcode-215-数组中第K个最大元素/","link":"","permalink":"https://sunyunzeng.com/Leetcode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/","excerpt":"","text":"题目在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1:12输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2::12输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 思路 + 代码简单办法，最容易想到的：用一个长度为 k 存储最大到第k大的数，然后返回数组最后一个元素，即为结果。 1234567891011121314151617181920212223class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; // 数组初始化 int[] results = new int[k]; for(int i=0; i&lt;k; i++)&#123; results[i] = Integer.MIN_VALUE; &#125; // 特殊情况处理 int len = nums.length; if(len&lt;2) return nums[0]; // 维护结果数组的值 for(int i=0; i&lt;len; i++)&#123; for(int j=0; j&lt;k; j++)&#123; if(nums[i]&gt;results[j])&#123; System.arraycopy(results,j,results,j+1,k-1-j); results[j] = nums[i]; break; &#125; &#125; &#125; return results[k-1]; &#125;&#125; 执行用时 :74 ms, 在所有 Java 提交中击败了18.90%的用户 内存消耗 :40.5 MB, 在所有 Java 提交中击败了35.28%的用户 答案里的方法：桶排序，非常好理解，先遍历一遍数组找出最大最小值。创建一个桶，长度为max-min+1，桶的 引对应于与Min的差值，桶中装的元素为该值出现次数。 1234567891011121314151617181920class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; int max=Integer.MIN_VALUE; int min=Integer.MAX_VALUE; for(int num:nums)&#123; max=Math.max(max,num); min=Math.min(min,num); &#125; int[] bucket=new int [max-min+1]; for(int num:nums)&#123; bucket[num-min]++; &#125; int count=0; for(int i=bucket.length-1;i&gt;=0;i--)&#123; count+=bucket[i]; if(count&gt;=k) return min+i; &#125; return -1; &#125;&#125; 执行用时 :2 ms, 在所有 Java 提交中击败了99.61%的用户 内存消耗 :37.8 MB, 在所有 Java 提交中击败了94.49%的用户","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Leetcode 105.从前序与中序遍历序列构造二叉树","slug":"Leetcode-105-从前序与中序遍历序列构造二叉树","date":"2019-07-01","updated":"2022-11-05","comments":true,"path":"Leetcode-105-从前序与中序遍历序列构造二叉树/","link":"","permalink":"https://sunyunzeng.com/Leetcode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"题目根据一棵树的前序遍历与中序遍历构造出二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 12345 3 / \\9 20 / \\ 15 7 思路先序遍历：先根节点 后左子树 最后右子树 中序遍历：先左子树 再根节点 最后右子树 所以先序遍历的第一个数值为根节点，在中序遍历中找到根节点位置，前面为左子树的中序遍历，后面为右子树的中序遍历。 Java代码如下:123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if(preorder==null || inorder==null) return null; if(preorder.length==0 || inorder.length==0)&#123; return null; &#125; if(preorder.length!=inorder.length)&#123; return null; &#125; TreeNode root = new TreeNode(preorder[0]); int len = preorder.length; for(int i=0; i&lt;len; i++)&#123; if(inorder[i]==preorder[0])&#123; root.left = buildTree(Arrays.copyOfRange(preorder,1,i+1), Arrays.copyOfRange(inorder,0,i)); root.right = buildTree(Arrays.copyOfRange(preorder,i+1,len),Arrays.copyOfRange(inorder,i+1,len)); &#125; &#125; return root; &#125;&#125; Python代码如下： 1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, preorder, inorder): &quot;&quot;&quot; :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode &quot;&quot;&quot; if not preorder: return None x = preorder.pop(0) node = TreeNode(x) idx = inorder.index(x) node.left = self.buildTree(preorder[:idx], inorder[:idx]) node.right = self.buildTree(preorder[idx:], inorder[idx+1:]) return node","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sunyunzeng.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Leetcode 101.对称二叉树","slug":"Leecode-101-对称二叉树","date":"2019-06-25","updated":"2022-11-05","comments":true,"path":"Leecode-101-对称二叉树/","link":"","permalink":"https://sunyunzeng.com/Leecode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"题目给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。12345 1 / \\ 2 2 / \\ / \\3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 / \\2 2 \\ \\ 3 3 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 思路二叉树的一个典型套路就是递归求解。左右树分别对待。 注意递归截止条件以及是否对称的判断条件。 代码123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root==null) return true; return tryTree(root.left, root.right); &#125; public boolean tryTree(TreeNode left, TreeNode right)&#123; // 递归截止条件 if(right==null&amp;&amp;left==null) return true; if(left==null||right==null) return false; // 对称判断条件 if(left.val==right.val) return tryTree(left.left, right.right)&amp;&amp;tryTree(left.right, right.left); return false; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sunyunzeng.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Leetcode 48.旋转图像","slug":"Leecode-48-旋转图像","date":"2019-06-24","updated":"2022-11-05","comments":true,"path":"Leecode-48-旋转图像/","link":"","permalink":"https://sunyunzeng.com/Leecode-48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/","excerpt":"","text":"题目给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例1：12345678910111213给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例2：123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], 原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 思路如果可以拷贝矩阵，则可以每一行与每一列同时旋转。 但是要求在原矩阵中操作，所以需要每一个元素进行位置旋转变换。 一个4*4的矩阵如下图所示： 顺时针旋转即相同颜色的元素进行依次替换。 对于四阶矩阵，先从最外圈i=0开始，到里圈i=1结束。n+1阶矩阵从最外圈i=0开始，i=n/2里圈结束。 每j圈依次从j行第i个元素开始，n-i个元素结束。 四个元素互换条件： tmp = matrix[j][n-i]; matrix[j][n-i] = matrix[i][j]; matrix[i][j] = matrix[n-j][i]; matrix[n-j][i] = matrix[n-i][n-j]; matrix[n-i][n-j] = tmp; 代码123456789101112131415161718class Solution &#123; public void rotate(int[][] matrix) &#123; int n = matrix.length-1; int tmp; // 循环几圈 for(int i=0; i&lt;=n/2;i++)&#123; // 每一圈要交换几轮 for(int j=i;j&lt;n-i;j++)&#123; // 四个元素依次交换 tmp = matrix[j][n-i]; matrix[j][n-i] = matrix[i][j]; matrix[i][j] = matrix[n-j][i]; matrix[n-j][i] = matrix[n-i][n-j]; matrix[n-i][n-j] = tmp; &#125; &#125; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/rotate-image著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Leetcode 155.最小栈","slug":"Leecode-155-最小栈","date":"2019-06-22","updated":"2022-11-05","comments":true,"path":"Leecode-155-最小栈/","link":"","permalink":"https://sunyunzeng.com/Leecode-155-%E6%9C%80%E5%B0%8F%E6%A0%88/","excerpt":"","text":"题目设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) — 将元素 x 推入栈中。pop() — 删除栈顶的元素。top() — 获取栈顶元素。getMin() — 检索栈中的最小元素。 示例:12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 思路1可以用两个栈，一个栈用来维护当前栈内最小的元素，一个栈用来维度当前栈内的元素。 属于投机取巧的方法。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445class MinStack &#123; private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; minStack; /** initialize your data structure here. */ public MinStack() &#123; stack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; stack.push(x); if(minStack.isEmpty() || x &lt;= minStack.peek())&#123; minStack.push(x); &#125; &#125; public void pop() &#123; // 注意，peek()方法返回的是Integer对象，而java在比较Integer时数据范围在-128~127用 == 比较是相等的，但是 // 超过这个范围就是不相等的。这是因为常量池范围内地Integer对象都是同一个，而 == 是比较对象是否为同一个对象 // 如果比较数值是否相等，应该采用Integer重写的equals()方法!!! if(stack.peek().equals(minStack.peek()))&#123; minStack.pop(); &#125; stack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return minStack.peek(); &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 思路2自己用数组实现元素栈与存储最小元素的栈。 要点，数组的自动扩容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class MinStack &#123; private int[] minValue; private int[] data; private int index; /** initialize your data structure here. */ public MinStack() &#123; minValue = new int[10]; data = new int[10]; index = -1; &#125; public void push(int x) &#123; // 扩容 if(++index&gt;data.length-1) resize(); data[index] = x; if(index==0 || x &lt;minValue[index-1])&#123; minValue[index]=x; &#125;else&#123; minValue[index] = minValue[index-1]; &#125; &#125; public void pop() &#123; index--; &#125; public int top() &#123; return data[index]; &#125; public int getMin() &#123; return minValue[index]; &#125; public void resize()&#123; int[] newdata = new int[data.length*2]; int[] newMinValue = new int[data.length*2]; System.arraycopy(data,0,newdata,0,data.length); System.arraycopy(minValue,0,newMinValue,0,minValue.length); data = newdata; minValue = newMinValue; &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 或者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class MinStack &#123; private int minValue; private int[] data; private int index; /** initialize your data structure here. */ public MinStack() &#123; minValue = Integer.MAX_VALUE; data = new int[10]; index = -1; &#125; public void push(int x) &#123; // 扩容 if(++index&gt;data.length-1) data = Arrays.copyOf(data, data.length*2); data[index] = x; if(x &lt; minValue)&#123; minValue = x; &#125; &#125; public void pop() &#123; index--; if(data[index+1]==minValue)&#123; minValue = Integer.MAX_VALUE; for(int i=0; i&lt;=index; i++)&#123; if(data[i]&lt;minValue)&#123; minValue = data[i]; &#125; &#125; &#125; &#125; public int top() &#123; return data[index]; &#125; public int getMin() &#123; return minValue; &#125; &#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/min-stack著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Leetcode 448.找到所有数组中消失的数字","slug":"Leecode-448-找到所有数组中消失的数字","date":"2019-06-20","updated":"2022-11-05","comments":true,"path":"Leecode-448-找到所有数组中消失的数字/","link":"","permalink":"https://sunyunzeng.com/Leecode-448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"题目给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 示例：12345输入:[4,3,2,7,8,2,3,1]输出:[5,6] 思路将出现数字位置的数置为负数。 关键点：置负数时一定取绝对值后取负数，否则会出现负负得正的情况。 例如： 1[2,1,2,4] 1[-2,-1,2,-1] 代码123456789101112131415class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int len = nums.length; for(int i=0; i&lt;len; i++)&#123; nums[Math.abs(nums[i])-1] = -Math.abs(nums[Math.abs(nums[i])-1]); &#125; for(int i=0;i&lt;len;i++)&#123; if(nums[i]&gt;0)&#123; list.add(i+1); &#125; &#125; return list; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Leetcode 234.回文链表","slug":"Leecode-234-回文链表","date":"2019-06-20","updated":"2022-11-05","comments":true,"path":"Leecode-234-回文链表/","link":"","permalink":"https://sunyunzeng.com/Leecode-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目请判断一个链表是否为回文链表。 示例1：12输入: 1-&gt;2输出: false 示例2：12输入: 1-&gt;2-&gt;2-&gt;1输出: true进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 思路用 栈+快慢指针 或者 快慢指针+反转链表 快慢指针是用来寻找中间节点。栈是用来反转链表。 代码 栈 + 快慢指针 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if(head==null||head.next==null) return true; // 栈用来反转链表 Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); ListNode fast = head; ListNode low = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; fast = fast.next.next; stack.push(low); low = low.next; // 奇数链表中间位置需要往后移动一位 if(fast!=null&amp;&amp;fast.next==null) low = low.next; &#125; // 循环遍历前后链表是否相等 while(!stack.empty())&#123; if(stack.pop().val!=low.val) return false; low = low.next; &#125; return true; &#125;&#125; 快慢指针 + 反转链表 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if(head==null||head.next==null) return true; ListNode fast = head; ListNode low = head; // 快慢指针找到中间点 while(fast!=null&amp;&amp;fast.next!=null)&#123; fast = fast.next.next; low = low.next; if(fast!=null&amp;&amp;fast.next==null) low = low.next; &#125; ListNode compNode = reverseLinkedList(low); // 链表前后判断 while(compNode!=null)&#123; if(compNode.val!=head.val) return false; compNode = compNode.next; head = head.next; &#125; return true; &#125; // 反转链表 public ListNode reverseLinkedList(ListNode head)&#123; ListNode preNode = null; ListNode curNode = head; while(curNode!=null)&#123; ListNode temp = curNode.next; curNode.next = preNode; preNode = curNode; curNode = temp; &#125; return preNode; &#125;&#125; 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Leetcode 70.爬楼梯","slug":"Leecode-70-爬楼梯","date":"2019-06-19","updated":"2022-11-05","comments":true,"path":"Leecode-70-爬楼梯/","link":"","permalink":"https://sunyunzeng.com/Leecode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/","excerpt":"","text":"题目假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例1:12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例2:123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 思路递归或者动态规划。 第n阶楼梯的走法 = 第n-1阶楼梯走法 + 第n阶楼梯走法。 边界条件，n&lt;=3。 代码1234567891011121314// 动态规划class Solution &#123; public int climbStairs(int n) &#123; if(n&lt;=3) return n; int[] dp = new int[n]; for(int i=0;i&lt;3;i++)&#123; dp[i] = i+1; &#125; for(int i=3; i&lt;n; i++)&#123; dp[i]=dp[i-2]+dp[i-1]; &#125; return dp[n-1]; &#125;&#125; 1234567// 递归class Solution &#123; public int climbStairs(int n) &#123; if(n&lt;=3) return n; return climbStairs(n-2) + climbStairs(n-1); &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Leetcode 198.打家劫舍","slug":"Leecode-198-打家劫舍","date":"2019-06-17","updated":"2022-11-05","comments":true,"path":"Leecode-198-打家劫舍/","link":"","permalink":"https://sunyunzeng.com/Leecode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/","excerpt":"","text":"题目你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例1：1234输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例2：1234输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 思路动态规划 用一个数组维护截止到当前偷窃的最大值。更新条件：dp[i]=max(nums[i]+dp[i-1], dp[i-1])。 代码123456789101112131415class Solution &#123; public int rob(int[] nums) &#123; int len = nums.length; if(len == 0) return 0; if(len == 1 ) return nums[0]; if(len == 2) return Math.max(nums[0], nums[1]); int[] dp = new int[len]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for(int i=2; i&lt;len; i++)&#123; dp[i] = Math.max(nums[i]+dp[i-2], dp[i-1]); &#125; return dp[len-1]; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Leetcode 53.最大子序和","slug":"Leecode-53-最大子序和","date":"2019-06-17","updated":"2022-11-05","comments":true,"path":"Leecode-53-最大子序和/","link":"","permalink":"https://sunyunzeng.com/Leecode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/","excerpt":"","text":"题目给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例： 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 思路动态规划。 用一个数组维护一个包含当前数字的最大子序列，取该数组的最大值即为结果。 代码12345678910111213class Solution &#123; public int maxSubArray(int[] nums) &#123; int len = nums.length; int result = nums[0]; int[] dp = new int[len]; dp[0] = nums[0]; for(int i=1; i&lt;len; i++)&#123; dp[i] = Math.max(dp[i-1]+nums[i], nums[i]); result = Math.max(dp[i], result); &#125; return result; &#125;&#125; 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"Leetcode 538.二叉搜索树转换为累加树","slug":"Leecode-538-二叉搜索树转换为累加树","date":"2019-06-17","updated":"2022-11-05","comments":true,"path":"Leecode-538-二叉搜索树转换为累加树/","link":"","permalink":"https://sunyunzeng.com/Leecode-538-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/","excerpt":"","text":"题目给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 二叉搜索树：它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树。 思路因为二叉搜索树左子树、根节点及右子树已经拍好顺序，所以只需遍历右子树计算累加值，然后对根节点与左子树分别累加。 可采用递归或遍历方法。首先累加右子树数值，然后依次修改根节点与左子树的数值。 代码1 递归1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private int sum = 0; public TreeNode convertBST(TreeNode root) &#123; if(root == null) return null; convertBST(root.right); root.val +=sum; sum = root.val; convertBST(root.left); return root; &#125;&#125; 代码2 遍历123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private int sum = 0; public TreeNode convertBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; rightNodeStack = new Stack&lt;TreeNode&gt;(); TreeNode node = root; while(node!=null || !rightNodeStack.isEmpty())&#123; while(node!=null)&#123; rightNodeStack.add(node); node = node.right; &#125; node = rightNodeStack.pop(); node.val += sum; sum = node.val; node = node.left; &#125; return root; &#125;&#125; 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sunyunzeng.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"算法题-移动零","slug":"算法题-移动零","date":"2019-06-14","updated":"2022-11-05","comments":true,"path":"算法题-移动零/","link":"","permalink":"https://sunyunzeng.com/%E7%AE%97%E6%B3%95%E9%A2%98-%E7%A7%BB%E5%8A%A8%E9%9B%B6/","excerpt":"","text":"题目给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例:12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 1. 必须在原数组上操作，不能拷贝额外的数组。 2. 尽量减少操作次数。 思路1采用双循环，当遇到零元素时，与后面序列中第一个非零元素交换。 时间复杂度: $O(n!)$ 结果:执行用时 : 16 ms内存消耗 :37.4 MB 代码12345678910111213141516class Solution &#123; public void moveZeroes(int[] nums) &#123; int len = nums.length; for(int i=0;i&lt;len-1;i++)&#123; if(nums[i]==0)&#123; int j =i+1; while(j&lt;len&amp;&amp;nums[j]==0)&#123; j++; &#125; if(j==len) break; nums[i]=nums[j]; nums[j]=0; &#125; &#125; &#125;&#125; 思路2评论中高赞方法是采用双指针的方式。 先将非零元素按照顺序紧密移动到前面，再按照零元素数量对数组后面元素补零。 代码2123456789101112131415class Solution &#123; public void moveZeroes(int[] nums) &#123; int i = 0; int len = nums.length; for(int j=0; j&lt;len; j++)&#123; if(nums[j]!=0)&#123; nums[i]=nums[j]; i++; &#125; &#125; for(; i&lt;len; i++)&#123; nums[i] = 0; &#125; &#125;&#125; 结果执行用时 : 1 ms内存消耗 :39.3 MB 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"算法题-合并两个有序链表","slug":"算法题-合并两个有序链表","date":"2019-06-13","updated":"2022-11-05","comments":true,"path":"算法题-合并两个有序链表/","link":"","permalink":"https://sunyunzeng.com/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例1：12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路1分为两步： 第一步： 记录所有的链表的数值并排序。因为链表的长度未知，所以需要用 List 来存储。 第二步： 按照排序后的链表数值，建立对应链表。 代码12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null&amp;&amp;l2==null) return null; if(l1!=null&amp;&amp;l2==null) return l1; if(l1==null&amp;&amp;l2!=null) return l2; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(l1!=null)&#123; list.add(l1.val); l1=l1.next; &#125; while(l2!=null)&#123; list.add(l2.val); l2=l2.next; &#125; Collections.sort(list); int size = list.size(); ListNode result = new ListNode(list.get(0).intValue()); ListNode pev = result; for(int i=1;i&lt;size;i++)&#123; ListNode tmp = new ListNode(list.get(i).intValue()); pev.next = tmp; pev = tmp; &#125; return result; &#125;&#125; 思路2官方题解：采用递归方法。 终止条件：l1 = null 或者 l2 = null。 判断条件： if(l1.val&lt;l2.val): mergeTwoLists(l1.next, l2) else: mergeTwoLists(l1, l2.next) 代码123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; if(l2==null) return l1; if(l1.val&lt;l2.val)&#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125;else&#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125; 思路3官方题解：采用递归。 时间复杂度与空间复杂度最优。 关键在于设计哨兵节点，记录前一个节点。 代码1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode preHead = new ListNode(-1); ListNode preNode = preHead; while(l1!=null&amp;&amp;l2!=null)&#123; if(l1.val&lt;l2.val)&#123; preNode.next = l1; l1 = l1.next; &#125;else&#123; preNode.next = l2; l2 = l2.next; &#125; preNode = preNode.next; &#125; preNode.next = l1==null?l2:l1; return preHead.next; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"算法题：计算众数","slug":"算法题-计算众数","date":"2019-06-05","updated":"2022-11-05","comments":true,"path":"算法题-计算众数/","link":"","permalink":"https://sunyunzeng.com/%E7%AE%97%E6%B3%95%E9%A2%98-%E8%AE%A1%E7%AE%97%E4%BC%97%E6%95%B0/","excerpt":"","text":"题目给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例1： 12输入: [3,2,3]输出: 3 示例2： 12输入: [2,2,1,1,1,2,2]输出: 2 思路 + 代码法1. 我的方法，超笨。用一个Map记录数字出现的次数，然后当次数大于n/2时返回。 代码 12345678910111213141516class Solution &#123; public int majorityElement(int[] nums) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int len = nums.length; for(int i=0; i&lt;len; i++)&#123; if(map.get(nums[i])!=null)&#123; Integer num = map.get(nums[i]); map.put(nums[i], num+1); &#125;else&#123; map.put(nums[i], 1); &#125; if(map.get(nums[i])&gt;len/2) return nums[i]; &#125; return 0; &#125;&#125; 法2. 先排序，后取中位数 代码略 法3. 用一个变量count计数，从0开始，遇到相同的+1，遇到不同的-1，变为零则重新计数。 代码 12345678910111213141516class Solution &#123; public int majorityElement(int[] nums) &#123; int count = 1; int len = nums.length; int num = nums[0]; for(int i=1; i&lt;len; i++)&#123; if(num==nums[i]) count++; else count--; if(count==0) &#123; num = nums[i]; count = 1; &#125; &#125; return num; &#125;&#125; 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"算法题：反转链表","slug":"算法题-反转链表","date":"2019-06-03","updated":"2022-11-05","comments":true,"path":"算法题-反转链表/","link":"","permalink":"https://sunyunzeng.com/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目描述 反转一个单链表。 示例:12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 思路方案1采用迭代方法，及循环迭代。用一个变量存储上一节点对象，一个变量存储当前节点对象，一个对象存储下一节点对象。 代码123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode prev = null; ListNode curr = head; while(curr!=null)&#123; ListNode next = curr.next; curr.next = prev; prev = curr; curr = next; &#125; return prev; &#125;&#125; 方案2采用递归，先递归找到原链表尾巴作为头节点，再依次反转链表。 head.next.next = head;head.next = null; 代码1234567891011121314151617/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode p = reverseList(head.next); head.next.next = head; head.next = null; return p; &#125;&#125; 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"算法题：子集","slug":"算法题-子集","date":"2019-05-31","updated":"2022-11-05","comments":true,"path":"算法题-子集/","link":"","permalink":"https://sunyunzeng.com/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%AD%90%E9%9B%86/","excerpt":"","text":"求一个数组的所有子集数组 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。 示例:123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 思路1从前往后遍历，新子集就是原子集加上新加的数。 代码1234567891011121314151617class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); int len = nums.length; List&lt;Integer&gt; inList = new ArrayList&lt;&gt;(); list.add(inList); for(int i=0; i&lt;len; i++)&#123; int size = list.size(); for(int j = 0; j&lt;size; j++)&#123; List&lt;Integer&gt; newList = new ArrayList&lt;&gt;(list.get(j)); newList.add(nums[i]); list.add(newList); &#125; &#125; return list; &#125;&#125; 思路2当成回溯问题求解。 代码12345678910111213141516171819202122class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); // 如果有重复数字，则需要 Arrays.sort(nums); backtracking(res, new ArrayList&lt;Integer&gt;(), nums, 0); return res; &#125; private void backtracking(ArrayList&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; arr, int[] nums, int location)&#123; if(nums==null || nums.length==0)&#123; res.add(arr); return; &#125;else&#123; res.add(new ArrayList&lt;Integer&gt;(arr)); for(int i=location; i&lt;nums.length; i++)&#123; // 如果有重复数字，则只调重复的第一个 if(i&gt;location &amp;&amp; nums[i]==nums[i-1]) continue; arr.add(nums[i]); backtracking(res, arr, nums, i+1); arr.remove(arr.size()-1); &#125; &#125; &#125;&#125; 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"回溯法","slug":"回溯法","permalink":"https://sunyunzeng.com/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"}]},{"title":"算法题：二叉树相关","slug":"算法题-二叉树相关","date":"2019-05-30","updated":"2022-11-05","comments":true,"path":"算法题-二叉树相关/","link":"","permalink":"https://sunyunzeng.com/%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3/","excerpt":"","text":"合并二叉树 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 示例 1: 1234567891011121314输入: Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 输出: 合并后的树: 3 / \\ 4 5 / \\ \\ 5 4 7 思路递归算法，每棵树都由子树构成，根节点融合可以通过递归拆分成子树进行。 代码12345678910111213141516171819/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if(t1==null) return t2; if(t2==null) return t1; t1.val += t2.val; t1.left = mergeTrees(t1.left,t2.left); t1.right = mergeTrees(t1.right, t2.right); return t1; &#125;&#125; 二叉树最大深度 给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例:给定二叉树 [3,9,20,null,null,15,7]，12345 3 / \\9 20 / \\ 15 7返回它的最大深度 3 。 思路同上，树划分成两棵树，递归求解。 代码12345678910111213141516/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root==null) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right))+1; &#125;&#125; 题目链接 N叉树的最大深度 给定一个 N 叉树，找到其最大深度。 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。 例如，给定一个 3叉树 : 我们应返回其最大深度，3。 说明: 树的深度不会超过 1000。树的节点总不会超过 5000。 思路+代码类比二叉树最大深度，迭代求解。 12345678910111213141516171819202122232425/*// Definition for a Node.class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123;&#125; public Node(int _val,List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123; public int maxDepth(Node root) &#123; if(root==null) return 0; int depth = 0; for(int i=0; i&lt;root.children.size(); i++)&#123; depth = Math.max(maxDepth(root.children.get(i)),depth); &#125; return depth+1; &#125;&#125; 翻转二叉树 翻转一棵二叉树。 示例：输入:12345 4 / \\ 2 7 / \\ / \\1 3 6 9 输出:12345 4 / \\ 7 2 / \\ / \\9 6 3 1 备注: 这个问题是受到 Max Howell 的 原问题 启发的 ： 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。 思路so easy! 递归完事了。 代码12345678910111213141516171819202122/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if(root==null) return null; TreeNode obj = root.left; root.left = root.right; root.right = obj; invertTree(root.right); invertTree(root.left); return root; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sunyunzeng.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"算法题：位运算相关","slug":"算法题-位运算相关","date":"2019-05-28","updated":"2022-11-05","comments":true,"path":"算法题-位运算相关/","link":"","permalink":"https://sunyunzeng.com/%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3/","excerpt":"","text":"只出现一次的数字题目描述 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例1:12输入: [2,2,1]输出: 1示例2:12输入: [4,1,2,1,2]输出: 4 思路由于时间复杂度与空间复杂度的限制，这道题目解决办法一定是很巧妙的。 答案是采用异或的方法。 Java的异或^是位运算的一种，含义是相同的位数置 0 ，相异的位数置 1 。数字本身(相同数字)的异或结果为 0 ，0 与任何数字的异或结果为其本身。 Hash Map中的hash码映射到数组位置就采用了异或的方法，(h=key.hashcode())^(h&gt;&gt;16); 例如:0000 0000 0000 1011 ^0000 0000 0000 11110000 0000 0000 0100 代码12345678910class Solution &#123; public int singleNumber(int[] nums) &#123; int result = 0; int len = nums.length; for(int i=0; i&lt;len; i++)&#123; result = result^nums[i]; &#125; return result; &#125;&#125; 汉明距离题目描述 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 x 和 y，计算它们之间的汉明距离。 注意：0 ≤ x, y &lt; 231. 示例：12345678910输入: x = 1, y = 4输出: 2解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑上面的箭头指出了对应二进制位不同的位置。 思路先异或运算 ^ 将相同位置不同数字的置为 1 。 再通过移位， 与 1 进行 与 &amp; 运算，计算出结果。 代码1234567891011121314class Solution &#123; public int hammingDistance(int x, int y) &#123; int z = x^y; int result = 0; // 计算二进制表示中 1 的数量 while(z&gt;0)&#123; if((z &amp; 1) == 1)&#123; result ++; &#125; z &gt;&gt;= 1; &#125; return result; &#125;&#125; 计算m的n次方例如 n = 13，则 n 的二进制表示为 1101, 那么 m 的 13 次方可以拆解为: m^1101 = m^0001 m^0100 m^1000。 代码12345678910111213141516public class Pow &#123; public static int pow(int m, int n) &#123; int sum = 1; int tmp = m; while (n != 0) &#123; if ((n &amp; 1) == 1) &#123; // 几个1乘几次 sum *= tmp; &#125; // 第二位乘两次，第三位乘四次... tmp *= tmp; n = n &gt;&gt; 1; &#125; return sum; &#125;&#125; 不用辅助变量交换两个数用异或运算 ^ ，相同的数异或为 0 ,且支持交换律与结合律。 伪代码123x = x^y;y = x^y;x = x^y; 比特位计数给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例1:12输入: 2输出: [0,1,1] 示例2:12输入: 5输出: [0,1,1,2,1,2] 进阶: 给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？要求算法的空间复杂度为O(n)。你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。 最容易想到方法 12345678910111213141516class Solution &#123; public int[] countBits(int num) &#123; int[] result = new int[num+1]; for(int i=0; i&lt;=num; i++)&#123; int count = 0; int t = i; while(t &gt; 0)&#123; if((t &amp; 1) == 1) count++; t &gt;&gt;= 1; &#125; result[i] = count; &#125; return result; &#125;&#125; 当前数字的比特位数量等于左移一位数字的比特位数量加上（当前数字&amp;1） 123456789class Solution &#123; public int[] countBits(int num) &#123; int[] result = new int[num+1]; for(int i=1; i&lt;=num; i++)&#123; result[i] = result[i&gt;&gt;1] + (i &amp; 1); &#125; return result; &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"快速排序 | 选择排序 | 冒泡排序","slug":"Algorithm-排序算法","date":"2019-05-27","updated":"2022-11-05","comments":true,"path":"Algorithm-排序算法/","link":"","permalink":"https://sunyunzeng.com/Algorithm-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"选择排序每次选择最小的元素放在第一个位置，再选第二小元素放到第二个位置… 以此类推，排序完成。 12345678910111213141516171819202122232425public class SelectSort &#123; public static int[] sort(int[] nums)&#123; if(nums==null || nums.length==0) return null; int len = nums.length; int[] A = new int[len]; System.arraycopy(nums, 0, A, 0, len); for(int i=0; i&lt;len-1; i++)&#123; int min = i; for(int j=i+1; j&lt;len; j++)&#123; if(A[min]&gt;A[j])&#123; min = j; &#125; &#125; swap(A, i, min); &#125; return A; &#125; private static void swap(int[] nums, int i, int j)&#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125;&#125; 冒泡排序每次将最大的(或最小的)沉入数组最底层。 代码123456789101112131415161718public class BubbleSort &#123; public static int[] sort(int[] arr) &#123; int len = arr.length; int[] A = new int[len]; System.arraycopy(arr,0, A, 0, len); for (int i = 1; i &lt; len; i++) &#123; for (int j = 0; j &lt; len-i; j++) &#123; if(A[j]&gt;A[j+1])&#123; // 无需中介的数值互换方法 A[j] += A[j+1]; A[j+1] = A[j] - A[j+1]; A[j] -= A[j+1]; &#125; &#125; &#125; return A; &#125;&#125; 转自知乎(插入、冒泡图片来源，侵删) 快速排序每次找出一个基准，作为划分标准。方法类似于二分法，每次都把小于基准的数放于基准数组的左边，把大于基准的数放于数组的右边。 算法不稳定，时间复杂度最好$O(nlog(n))$，最差$O(n^2)$ 当数组本来是排序好的，例如是顺序排列，此时要计算逆序排列，如果利用快排方法，则时间复杂度为$O(n^2)$，当然，此时的基准选取是头部或者尾部。 所以基准的选取很重要，常见得有随机选取、取首或末端的数及三数中值法（取首末及中间位置三个数的中值）。 理论上，选取的基准是所有数的中位数，则划分最均匀，用时最短。 选取末尾值作为基准1234567891011121314151617181920212223242526272829303132333435363738394041public class QuickSort &#123; public int[] sort(int[]arr)&#123; int len = arr.length; if(len==0) return arr; // 在新数组上进行排序而不影响原始数组 int[]A = new int[len]; System.arraycopy(arr, 0, A, 0, len); quickSort(A, 0, len-1); return A; &#125; private void quickSort(int[]A, int left, int right)&#123; if(left&gt;right) return; // 获取基准值 int pivot = partition(A, left, right); quickSort(A, left, pivot-1); quickSort(A, pivot+1, right); &#125; private int partition(int[]A, int left, int right)&#123; // 以末端的数字为基准 int criterion = A[right]; int i = left; int j = right; while(i&lt;j)&#123; // 必须左边的哨兵先走，否则交换数值会出错 while(i&lt;j &amp;&amp; A[i]&lt;=criterion)&#123; i++; &#125; while(i&lt;j &amp;&amp; A[j]&gt;=criterion)&#123; j--; &#125; if(i&lt;j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; &#125; A[right] = A[i]; A[i] = criterion; return i; &#125;&#125; 优化的快速排序采用三值法作为划分基准，并在数据量不大时采用插入排序，提高效率。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class QuickSort &#123; private int threshold = 4; QuickSort()&#123;&#125;; QuickSort(int i) &#123; this.threshold = i; &#125; public int[] sort(int[]arr)&#123; int len = arr.length; if(len==0) return arr; // 在新数组上进行排序而不影响原始数组 int[]A = new int[len]; System.arraycopy(arr, 0, A, 0, len); quickSort(A, 0, len-1); return A; &#125; private void quickSort(int[]A, int left, int right)&#123; if(left&gt;right) return; // 小数据情况下递归方法需要调用栈，效率较低，此时采用插入排序方法 if(right-left&gt;4)&#123; // 获取基准值 int pivot = partition(A, left, right); quickSort(A, left, pivot-1); quickSort(A, pivot+1, right); &#125;else &#123; insertionSort(A); &#125; &#125; private int partition(int[]A, int left, int right)&#123; // 以末端的数字为基准 int criterion = getMedianPivot(A, left, right); // 从第二个及倒数第二个开始，因为getMedianPivot已经对首末数值进行了排序 int i = left+1; int j = right-1; while(i&lt;j)&#123; // 必须左边的哨兵先走，否则交换数值会出错 while(i&lt;j &amp;&amp; A[i]&lt;=criterion)&#123; i++; &#125; while(i&lt;j &amp;&amp; A[j]&gt;=criterion)&#123; j--; &#125; if(i&lt;j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; &#125; A[right-1] = A[i]; A[i] = criterion; return i; &#125; private int getMedianPivot(int[]A, int left, int right)&#123; int center = (left+right)/2; // 对于首末及中间的数进行排序 if (A[left] &gt; A[center]) &#123; swap(A, left, center); &#125; if (A[center] &gt; A[right]) &#123; swap(A, center, right); &#125; if (A[left] &lt; A[right]) &#123; swap(A, left, right); &#125; //交换中间与倒数第二个数，因为经过排序，最后一个已经是最大 swap(A, center, right-1); return A[right-1]; &#125; private void swap(int[] A, int i, int j) &#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125; private void insertionSort(int[] A) &#123; int len = A.length; int i,j; for (i = 0; i &lt; len; i++) &#123; int temp = A[i]; for (j = i; j &gt; 0 &amp;&amp; A[j] &lt; A[j - 1]; j--) &#123; A[j] = A[j-1]; &#125; A[j] = temp; &#125; &#125;&#125; 学习资料: LeetCode 知乎回答排序算法 快速排序—CSDN讲解 十大排序算法讲解推荐—微信公众号(快排图片来源，侵删) 排序算法—CyC2018大神博客","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"https://sunyunzeng.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"Linux终端常用指令","slug":"Linux终端常用指令","date":"2019-05-27","updated":"2022-11-05","comments":true,"path":"Linux终端常用指令/","link":"","permalink":"https://sunyunzeng.com/Linux%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","excerpt":"","text":"常用指令集 指令 作用 pwd 打印当前工作目录 hostname 获取我的计算机的网络名称 mkdir 创建目录 cd 更改目录 ls 列出目录下的文件 rmdir 删除目录 pushd push directory popd pop directory cp 复制文件或目录 mv 移动/重命名文件或目录 less 按页查看文件 cat 输出整个文件 xargs 执行参数 find 查找文件 grep 查找文件里面的东西 man 阅读帮助手册 apropos find what man page is appropriate env 查看计算机环境 echo 输出一些参数 export 设置一个新的环境变量 exit 退出终端 sudo 危险! 拥有超级用户权限! sudo rm –rf /* 赶紧跑路吧！","categories":[{"name":"Linux","slug":"Linux","permalink":"https://sunyunzeng.com/categories/Linux/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://sunyunzeng.com/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"算法题--买卖股票的最佳时机","slug":"算法题-买卖股票的最佳时机","date":"2019-05-26","updated":"2022-11-05","comments":true,"path":"算法题-买卖股票的最佳时机/","link":"","permalink":"https://sunyunzeng.com/%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/","excerpt":"","text":"基础版 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例11234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例2 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例3123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路贪心算法，通过计算局部最优，综合多个局部最优结果得到全局最优结果 一次循环，只要第二天股票价格比当天高，就买入，否则不买入。 计算当天买入跟第二天卖出的利润和，即为结果。 并不一定要在最低值买入，在最高点卖出。因为每次低买高卖的累积和等于最低点与最高点之间的收益。 代码1234567891011class Solution &#123; public int maxProfit(int[] prices) &#123; int result = 0; for(int i=0; i&lt;=prices.length-2; i++)&#123; if(prices[i]&lt;prices[i+1])&#123; result += prices[i+1]-prices[i]; &#125; &#125; return result; &#125;&#125; 题目链接 有手续费版 给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。 示例 1：12345678输入: prices = [1, 3, 2, 8, 4, 9], fee = 2输出: 8解释: 能够达到的最大利润: 在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8. 注意 :1230 &lt; prices.length &lt;= 50000.0 &lt; prices[i] &lt; 50000.0 &lt;= fee &lt; 50000. 思路简单DP问题 当前的状态 i 共有两种，持有股票与不持有股票 持有股票状态可能是 前一状态买入 或者 当前买入: 收益方程：$buy{profit}^i=max(buy{profit}^{i-1}, sell_{profit}^{i-1}-prices[i])$ 不持有股票可能是 前一状态卖出 或者 当前卖出: 收益方程：$sell{profit}^i=max(sell{profit}^{i-1}, prices[i]+buy_{profit}^i-fee)$ 代码1234567891011121314151617181920class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; int len = prices.length; if(len&lt;2) return 0; //没有stock的收益 int sell_profit = 0; //拥有stock的收益 int buy_profit = -prices[0]; for(int i=1; i&lt;len; i++)&#123; //今天卖了或者之前卖了的收益 sell_profit = Math.max(sell_profit, prices[i]+buy_profit-fee); //今天买了或者之前买了的收益 buy_profit = Math.max(buy_profit, sell_profit-prices[i]); &#125; //卖了股票的收益肯定大于持有股票的收益，因为持有股票是负收益 return sell_profit; &#125;&#125; 题目链接 有冷冻期版给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 思路 + 代码与 题目2类似，不过要增加一个状态 ———— 冻结状态。 卖出状态只能由买入状态转来。 买入状态可由买入状态或者冻结状态转来。 冻结状态由冻结状态或者买入状态转来。 注意状态的依赖关系，不要再依赖前一状态之前先改变当前状态。 1234567891011121314151617class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices==null || prices.length==0) return 0; int hold = -prices[0]; int sold = 0; int freeze = 0; int len = prices.length; for(int i=1; i&lt;len; i++)&#123; int pre_sold = sold; sold = hold + prices[i]; hold = Math.max(hold,freeze-prices[i]); freeze = Math.max(freeze, pre_sold); &#125; return Math.max(sold, freeze); &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 只允许买卖一次版本给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例1：1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例2：123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路动态规划问题。 维护一个值，存储之前i-1天的最大利润，当前i天的最大利润为当前价格与前i-1天价格最小值的差值与i-1最大利润的较大值。 代码123456789101112131415class Solution &#123; public int maxProfit(int[] prices) &#123; int len = prices.length; if(len&lt;2) return 0; int result = -prices[0]; int min_price = prices[0]; for(int i=1; i&lt;len; i++)&#123; result = Math.max(result, prices[i]-min_price); if(prices[i]&lt;min_price) min_price = prices[i]; &#125; return result&lt;0?0:result; &#125;&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 只允许买卖两次版本给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:1234输入: [3,3,5,0,0,3,1,4]输出: 6解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。示例 2:12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:123输入: [7,6,4,3,1] 输出: 0 解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。 思路 + 代码四个状态，即第一次买入与卖出，第二次买入与卖出。 12345678910111213141516171819class Solution(object): def maxProfit(self, prices): &quot;&quot;&quot; :type prices: List[int] :rtype: int &quot;&quot;&quot; if not prices: return 0 first_buy, first_sell = float(&#x27;-inf&#x27;), 0 second_buy, second_sell = float(&#x27;-inf&#x27;), 0 for price in prices: if first_buy &lt; -price: first_buy = -price if first_buy+price &gt; first_sell: first_sell = first_buy+price if second_buy + price &lt; first_sell: second_buy = first_sell - price if second_buy + price &gt; second_sell: second_sell = second_buy + price return second_sell 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 允许买卖k次给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:123输入: [2,4,1], k = 2输出: 2解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。示例 2:1234输入: [3,2,6,5,0,3], k = 2输出: 7解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 思路 + 代码参考链接https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/ 12345678910111213141516171819202122232425262728class Solution(object): def maxProfitInf(self, prices): buy, sell = -prices[0], 0 for i in range(1, len(prices)): buy = max(buy, sell-prices[i]) sell = max(sell, buy+prices[i]) return sell def maxProfit(self, k, prices): &quot;&quot;&quot; :type k: int :type prices: List[int] :rtype: int &quot;&quot;&quot; if not prices or k&lt;=0: return 0 n = len(prices) # 此时相当于可以无限交易 if k &gt;= n//2: return self.maxProfitInf(prices) # 0表示不持有股票，1表示持有股票 dp = [[[0]*2 for _ in range(k+1)] for _ in range(n)] for i in range(n): for j in range(1,k+1): if i-1&lt;0: dp[i][j][0], dp[i][j][1] = 0, -prices[i] continue dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1]+prices[i]) # 表明交易是在k=1开始的 dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0]-prices[i]) return dp[-1][-1][0] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心法","slug":"贪心法","permalink":"https://sunyunzeng.com/tags/%E8%B4%AA%E5%BF%83%E6%B3%95/"}]},{"title":"Minimum-Falling-Path-Sum","slug":"Minimum-Falling-Path-Sum","date":"2019-05-25","updated":"2022-11-05","comments":true,"path":"Minimum-Falling-Path-Sum/","link":"","permalink":"https://sunyunzeng.com/Minimum-Falling-Path-Sum/","excerpt":"","text":"下降路径最小和题目细节 给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。 示例1123输入：[[1,2,3],[4,5,6],[7,8,9]]输出：12 解释：可能的下降路径有： 123[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9][2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9][3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]和最小的下降路径是 [1,4,7]，所以答案是 12。 提示121 &lt;= A.length == A[0].length &lt;= 100-100 &lt;= A[i][j] &lt;= 100 思路典型的二维动态数组题目。创建一个二维的数组A[row][column]存储结果，每一个位置存储的是第一行到该位置最小的下降路径。 一般情况1A[i][j] +=min(min(A[i-1][j-1],A[i-1][j]),A[i-1][j+1]); 前后两列情况12第一列: A[i][j] += min(A[i-1][j],A[i-1][j+1]);最后一列: A[i][j] += min(A[i-1][j-1],A[i-1][j]); Algorithm123456789101112131415161718192021222324252627282930313233class Solution &#123; public int minFallingPathSum(int[][] A) &#123; int row = A.length; int col = A[0].length; if(row==1)&#123; return A[0][0]; &#125; for(int i=1;i&lt;row;++i)&#123; for(int j=0;j&lt;col;++j)&#123; if(j-1&lt;0)&#123; A[i][j] += min(A[i-1][j],A[i-1][j+1]); &#125; else if(j+1&gt;col-1)&#123; A[i][j] += min(A[i-1][j-1],A[i-1][j]); &#125; else&#123; A[i][j] +=min(min(A[i-1][j-1],A[i-1][j]),A[i-1][j+1]); &#125; &#125; &#125; int result = Integer.MAX_VALUE; for(int i=0;i&lt;col;++i)&#123; if (A[row-1][i] &lt; result) &#123; result = A[row-1][i]; &#125; &#125; return result; &#125; public int min(int a, int b)&#123; return (a&lt;=b?a:b); &#125;&#125; 题目链接 类似题目","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Algorithm--Third Maximum Number","slug":"Algorithm-Third-Maximum-Number","date":"2019-05-23","updated":"2022-11-05","comments":true,"path":"Algorithm-Third-Maximum-Number/","link":"","permalink":"https://sunyunzeng.com/Algorithm-Third-Maximum-Number/","excerpt":"","text":"1. Third Maximum NumberTitle Detail Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). Example 1: 123Input: [3, 2, 1]Output: 1Explanation: The third maximum is 1. Example 2:123Input: [1, 2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead. Example 3: 12Input: [2, 2, 3, 1]Output: 1 Explanation:Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum. 思路因为要求算法的时间复杂度为O(n)，所以不能用排序的方法。因为只求第三大的数，跟求第一大的数原理类似，只不过注意边界条件。 Algorithm1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int thirdMax(int[] nums) &#123; if(nums.length==1) return nums[0]; if(nums.length==2) return Math.max(nums[0], nums[1]); int max1 = Integer.MIN_VALUE; int max2 = Integer.MIN_VALUE; int max3 = Integer.MIN_VALUE; int flag = 0; boolean f = true; for(int i=0; i&lt;nums.length; i++)&#123; if(nums[i]&gt;max1)&#123; max3=max2; max2=max1; max1=nums[i]; ++flag; continue; &#125; if(max1&gt;nums[i] &amp;&amp; nums[i]&gt;max2)&#123; max3=max2; max2=nums[i]; ++flag; continue; &#125; if(max2&gt;nums[i] &amp;&amp; nums[i]&gt;max3)&#123; max3=nums[i]; ++flag; continue; &#125; // 边界条件，如果有多个最小值，则只算一次 if(nums[i]==Integer.MIN_VALUE&amp;&amp;f)&#123; flag++; f = false; continue; &#125; &#125; return (flag&lt;3?max1:max3); &#125;&#125; 题目链接 2. Smallest Range ITitle Detail Given an array A of integers, for each integer A[i] we may choose any x with -K &lt;= x &lt;= K, and add x to A[i].After this process, we have some array B.Return the smallest possible difference between the maximum value of B and the minimum value of B. Example 1:123Input: A = [1], K = 0Output: 0Explanation: B = [1] Example 2:123Input: A = [0,10], K = 2Output: 6Explanation: B = [2,8] Example 3:123Input: A = [1,3,6], K = 3Output: 0Explanation: B = [3,3,3] or B = [4,4,4] Note:1231 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt;= 100000 &lt;= K &lt;= 10000 思路求出数组最大值与最小值的差值，比较差值与K/2的关系。 Algorithm1234567891011121314151617class Solution &#123; public int smallestRangeI(int[] A, int K) &#123; if(A.length==0) return 0; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for(int i=0; i&lt;A.length; i++)&#123; if(A[i]&lt;min) min = A[i]; if(A[i]&gt;=max) max = A[i]; &#125; int len = max-min; if(len&gt;2*K) return len-2*K; else return 0; &#125;&#125; 题目链接 3. 数组形式的整数加法题目细节 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。 示例1：123输入：A = [1,2,0,0], K = 34输出：[1,2,3,4]解释：1200 + 34 = 1234 示例2：123输入：A = [2,7,4], K = 181输出：[4,5,5]解释：274 + 181 = 455 示例3：123输入：A = [2,1,5], K = 806输出：[1,0,2,1]解释：215 + 806 = 1021 示例4：123输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1输出：[1,0,0,0,0,0,0,0,0,0,0]解释：9999999999 + 1 = 10000000000 提示：12341 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt;= 90 &lt;= K &lt;= 10000如果 A.length &gt; 1，那么 A[0] != 0 思路最初思路是字符串转数字，相加后转字符串。 但是最终没过，因为数据量太大，不允许。 后又通过进位方式实现，老太太的裹脚布。 Algorithm1234567891011121314151617181920212223242526class Solution &#123; public List&lt;Integer&gt; addToArrayForm(int[] A, int K) &#123; int len = A.length; for(int i=len-1; i&gt;=0; --i) &#123; int temp = A[i] + K; if (temp &gt;= 10) &#123; A[i] = temp % 10; K = temp / 10; &#125; else &#123; A[i] = temp; K = temp /10; break; &#125; &#125; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (K!=0)&#123; String s = String.valueOf(K); for(char c: s.toCharArray()) result.add(c-&#x27;0&#x27;); &#125; for (int i : A) &#123; result.add(i); &#125; return result; &#125;&#125; 官方答案 123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; addToArrayForm(int[] A, int K) &#123; int N = A.length; int cur = K; List&lt;Integer&gt; ans = new ArrayList(); int i = N; while (--i &gt;= 0 || cur &gt; 0) &#123; if (i &gt;= 0) cur += A[i]; ans.add(cur % 10); cur /= 10; &#125; Collections.reverse(ans); return ans; &#125;&#125; 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Java：List API","slug":"Java-ArrayList-API","date":"2019-05-21","updated":"2022-11-05","comments":true,"path":"Java-ArrayList-API/","link":"","permalink":"https://sunyunzeng.com/Java-ArrayList-API/","excerpt":"","text":"Java List常用类型 类型 特征 ArrayList 随机访问元素快；中间插入与删除元素较慢；操作不是线程安全的 LinkedList 中间插入与删除操作代价较低，提供优化的顺序访问；随机访问元素慢 ArrayListArrayList的UML类图如下所示： ArrayList 继承了 AbstractList, 直接实现了 Cloneable, Serializable，RandomAccess 类型标志接口。 AbstractList 作为列表的抽象实现，将元素的增删改查都交给了具体的子类去实现，在元素的迭代遍历的操作上提供了默认实现。 RandomAccess 接口实现，表示 ArrayList 里的元素可以被高效效率的随机访问，以下标数字的方式获取元素。实现 RandomAccess 接口的列表上在遍历时可直接使用普通的 for 循环方式，并且执行效率上给迭代器方式更高。 Cloneable 接口的实现，表示了 ArrayList 支持调用 Object 的 clone 方法，实现 ArrayList 的拷贝。 Serializable 接口实现，说明了 ArrayList 还支持序列化和反序列操作，具有固定的 serialVersionUID 属性值。 ArrayList 常用 API 方法 描述 boolean add(E object) 再 ArrayList 尾存入对象 void add(int location, E object) 在 location 添加对象 boolean addAll(Collection&lt;? extends E&gt; collection) 将一个 Collection 对象中存储全部的对象复制并存入 boolean addAll(int location, Collection&lt;? extends E&gt; collection) 将一个 Collection 对象中存储全部的对象复制并存入location boolean contains(Object object) 是否包对象 object boolean containsAll(Collection&lt;?&gt; collection) 是否包含一个 Collection 对象 boolean isEmpty() ArrayList 是否为空 E get(int location) 获取 location 的对象 E set(int location, E object) 将某个位置的元素替换成 object int indexOf(Object object) 获取某个对象的位置（顺序遍历第一个） int lastIndexOf(Object object) 获取某个对象的位置（逆序遍历第一个） int size() 返回 ArrayList 存储的对象数量 boolean remove(Object object) 删除存储的某个对象 E remove(int lcoation) 删除位于 location 的对象 boolean removeAll(Collection&lt;?&gt; collection) 删除存储的某个 Collection 对象 Object [] toArray() ArrayList 转数组 List&lt;’E’&gt; subList(int start, int end) 获取位于 start 与 end 之间的 List void clone() 克隆ArrayList void clear() 移除ArrayList中所有对象 Iterator&lt;’E’&gt; iterator() 获取该 ArrayList 对应的迭代器对象 ArrayList 应用示例1. ArrayList与数组之间的转换1234567891011121314151617181920// 转数组List&lt;String&gt; list = new ArrayList&lt;&gt;();String[] strings = new String[list.size()];list.toArray(strings);// 或者String[] strings = (String[])list.toArray(new String[list.size()]);// 数组转List// 法1 快速，但是以视图形式返回，无法对数据进行删除及添加操作；// 可用 set() 方法修改元素，但是原始List数据会随之改变String[] s = &#123;&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;&#125;;List&lt;String&gt; list = java.util.Arrays.asList(s);//法 2 慢，但是新生成一个ArrayList，可对List进行操作不会对原对象产生影响List&lt;String&gt; assertList = new ArrayList();Collections.addAll(assertList, strings);2. ArrayList遍历方式123456789101112131415161718192021222324List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1,2,3,4,5));// 第一种，通过迭代器遍历。即通过Iterator去遍历。Integer value = null;Iterator iter = list.iterator();while (iter.hasNext()) &#123;value = (Integer)iter.next();&#125;// 第二种，随机访问，通过索引值去遍历。Integer value = null;int size = list.size();for (int i=0; i &lt; size; i++) &#123;value = (Integer)list.get(i); &#125;// 第三种，for循环遍历。Integer value = null;for (Integer integer: list) &#123;value = integer;&#125;// 第四种，利用Stream API的 stream.forEach()方法依次获取。list.forEach(num -&gt; System.out.println(num)); 3. 初始化12345678910111213141516171819202122232425// 第一种方式 Arrays.asList()方法ArrayList&lt;Integer&gt; list = new Arraylist&lt;&gt;(Arrays.asList(1, 2, 3));// 第二种方法 常规方式ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(1);list.add(2);list.add(3);//或者List innerList = Arrays.asList(1, 2, 3);list.addAll(innerList);// 第三种方法 使用生成匿名内部类ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;()&#123; &#123; add(1); add(2); add(3); &#125;&#125;；// 第四种方式 使用Collection.nCopiesint element = 1;ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Collections.nCopies(2, element)); //复制伍分到list中。4. 打印信息 由于ArrayList内部实现了toString()方法，所以可以直接打印12ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));System.out.println(list); 对于数组信息的打印123456789int[] A = &#123;1, 2, 3&#125;;// 方法一for(Integer i: A)&#123; System.out.println(i);&#125;//方法二System.out.println(Arrays.toString(A)); 5. 大量头部的增删操作 ArrayList是数组实现的，使用的是连续的内存空间，当有在数组头部将元素添加或者删除的时候，需要对头部以后的数据进行复制并重新排序，效率很低。针对有大量类似操作的场景，出于性能考虑，我们应该使用 LinkedList 代替。由于LinkedList 是基于链表实现，当需要操作的元素位置位于List 前半段时，就从头开始遍历，马上找到后将把元素在相应的位置进行插入或者删除操作。 参考资料 ArrayList源码剖析: http://www.spring4all.com/article/16262","categories":[{"name":"Java","slug":"Java","permalink":"https://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://sunyunzeng.com/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"Algorithm：删除最外层的括号","slug":"Algorithm-删除最外层的括号","date":"2019-05-21","updated":"2022-11-05","comments":true,"path":"Algorithm-删除最外层的括号/","link":"","permalink":"https://sunyunzeng.com/Algorithm-%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7/","excerpt":"","text":"删除最外层括号题目 有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。 如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。 给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。 对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。 示例1 输入：”(()())(())”输出：”()()()”解释：输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。 示例2 输入：”(()())(())(()(()))”输出：”()()()()(())”解释：输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，删除每隔部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。 示例3 输入：”()()”输出：””解释：输入字符串为 “()()”，原语化分解得到 “()” + “()”，删除每个部分中的最外层括号后得到 “” + “” = “”。 提示 123S.length &lt;= 10000S[i] 为 &quot;(&quot; 或 &quot;)&quot;S 是一个有效括号字符串 思路用一个数组模拟栈，发现 “(“ 使其进栈，发现 “)” 时使 “(“ 出栈。 注意: 栈底的 “(“ 出栈不输出，当输出字符串中 “(“ 和 “)” 数量不相等时，才输出 “)” 。 代码12345678910111213141516171819202122232425262728class Solution &#123; public String removeOuterParentheses(String S) &#123; // list作为栈，记录(数量 List&lt;Character&gt; list = new ArrayList(); StringBuilder bf = new StringBuilder(); int left = 0; // 记录输出的 ( 数量 int right = 0; //记录输出的 ) 数量 for(int i=0; i&lt;S.length(); i++)&#123; char c = S.charAt(i); if(c==&#x27;(&#x27;) list.add(c); if(c==&#x27;)&#x27;)&#123; if(list.size()==1&amp;&amp;left==right) list.remove(0); if(list.size()&gt;1)&#123; while(list.size()!=1)&#123; bf.append(&quot;(&quot;); list.remove(list.size()-1); ++left; &#125; &#125; if(left!=right)&#123; bf.append(&quot;)&quot;); ++right; &#125; &#125; &#125; return bf.toString(); &#125;&#125; 更Niubility的code：123456789101112131415161718class Solution &#123; public String removeOuterParentheses(String S) &#123; StringBuilder bf = new StringBuilder(); int flag = 0; for(char c: S.toCharArray())&#123; if(c == &#x27;(&#x27;)&#123; ++flag; if(flag == 1) continue; &#125; if(c==&#x27;)&#x27;)&#123; --flag; if(flag == 0) continue; &#125; bf.append(c); &#125; return bf.toString(); &#125;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Algorithm--Minimum path sum","slug":"Algorithm-Minimum-path-sum","date":"2019-05-21","updated":"2022-11-05","comments":true,"path":"Algorithm-Minimum-path-sum/","link":"","permalink":"https://sunyunzeng.com/Algorithm-Minimum-path-sum/","excerpt":"","text":"Dynamic ProgrammingMinimum Path SumTitle Detail Given an integer array A, you partition the array into (contiguous) subarrays of length at most K. After partitioning, each subarray has their values changed to become the maximum value of that subarray. Return the largest sum of the given array after partitioning. Example 1:123Input: A = [1,15,7,9,2,5,10], K = 3Output: 84Explanation: A becomes [15,15,15,9,10,10,10]Note:121 &lt;= K &lt;= A.length &lt;= 5000 &lt;= A[i] &lt;= 10^6 思路动态规划 问题。 用原来的grid矩阵存储路径和 注意三种特殊情况，即矩阵初始位置、顶栏及左侧栏和求解。 初始：grid[0][0] = grid[0][0] 顶栏：grid[i][j] = grid[i][j-1] 左侧栏：grid[i][j] = grid[i-1][j] 其余位置：grid[i][j] = min(grid[i][j-1], grid[i-1][j]) Algorithm12345678910111213141516171819202122class Solution &#123; public int minPathSum(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; for(int i=0; i&lt;m;i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(i==0&amp;&amp;j==0)&#123; continue; &#125; else if(i==0&amp;&amp;j!=0)&#123; grid[i][j] += grid[i][j-1]; &#125; else if(j==0&amp;&amp;i!=0)&#123; grid[i][j] += grid[i-1][j]; &#125;else&#123; grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]); &#125; &#125; &#125; return grid[m-1][n-1]; &#125;&#125; 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Algorithm--Partition-array-for-maximum-sum","slug":"Algorithm-partition-array-for-maximum-sum","date":"2019-05-21","updated":"2022-11-05","comments":true,"path":"Algorithm-partition-array-for-maximum-sum/","link":"","permalink":"https://sunyunzeng.com/Algorithm-partition-array-for-maximum-sum/","excerpt":"","text":"Dynamic ProgrammingPartition Array for Maximum SumTitle Detail Given an integer array A, you partition the array into (contiguous) subarrays of length at most K. After partitioning, each subarray has their values changed to become the maximum value of that subarray. Return the largest sum of the given array after partitioning. Example 1:123Input: A = [1,15,7,9,2,5,10], K = 3Output: 84Explanation: A becomes [15,15,15,9,10,10,10] Note:121 &lt;= K &lt;= A.length &lt;= 5000 &lt;= A[i] &lt;= 10^6 思路动态规划 问题。 用一个长度为A.length的数组dp维护最终的加和结果。 计算思想如下： dp[i] := max sum of A[0] ~ A[i] dp[i] = max{dp[i – k] + max(A[i+1-k:i]) * k}, 1 &lt;= k &lt;= min(i, K) 最终返回结果 dp[A.length-1] Algorithm1234567891011121314class Solution &#123; public int maxSumAfterPartitioning(int[] A, int K) &#123; int len = A.length; int[] dp = new int[len]; for(int i=0; i&lt;A.length; ++i)&#123; int max_num = A[i]; for(int k=1; k&lt;=K &amp;&amp; i+1-k&gt;=0; ++k)&#123; max_num = Math.max(max_num, A[i+1-k]); dp[i] = Math.max(dp[i], (i-k&gt;=0?dp[i-k]:0) + k*max_num); &#125; &#125; return dp[len-1]; &#125;&#125; 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Java-for循环那些事","slug":"Java-for循环那些事","date":"2019-05-21","updated":"2022-11-05","comments":true,"path":"Java-for循环那些事/","link":"","permalink":"https://sunyunzeng.com/Java-for%E5%BE%AA%E7%8E%AF%E9%82%A3%E4%BA%9B%E4%BA%8B/","excerpt":"","text":"Java for循环里面的 i++ 与 ++i在for循环里两者的作用是一样的 i++12345for(int i=0; i&lt;5; i++)&#123; System.out.print(i + &quot;,&quot;);&#125;&gt;&gt; 0, 1, 2, 3, 4 ++i12345for(int i=0; i&lt;5; ++i)&#123; System.out.print(i + &quot;,&quot;);&#125;&gt;&gt; 0, 1, 2, 3, 4 工作原理 i++1234&#123; System.out.print(i + &quot;,&quot;); i++;&#125; ++i1234&#123; System.out.print(i + &quot;,&quot;); ++i;&#125; 区别 在Java里面，i++ 需要开辟新的存储空间用于存储结果，++i 直接在原存储空间中存储结果。故 ++i 在 for 循环里面执行效率要高。 可以作为代码优化的一部分。 foreach 与 for循环的效率 首先测试数组 123456789101112131415161718192021// 测试for循环int[] A = new int[100000000];long startTime = System.nanoTime();int len = A.length;int res = 0;for(int i=0; i&lt;len; i++)&#123; res += A[i];&#125;long endTime = System.nanoTime();System.out.println(&quot;for循环: &quot;+(endTime- startTime));// 测试foreachint[] A = new int[100000000];long startTime = System.nanoTime();int len = A.length;int res = 0;for(Integer i: A)&#123; res += i;&#125;long endTime = System.nanoTime();System.out.println(&quot;foreach循环: &quot;+(endTime- startTime)); 结果 12for循环: 37143324forecah循环: 75450311 可见对于大数组采用for循环效率更高 再测试ArrayList 12345678910111213141516171819202122ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(30000000); for(int i=0; i&lt;30000000; i++)&#123; list.add(i); &#125;// 测试for循环long startTime = System.nanoTime();int size = list.size();int res = 0;for(int i=0; i&lt;size; i++)&#123; res += list.get(i);&#125;long endTime = System.nanoTime();System.out.println(&quot;for循环: &quot;+(endTime- startTime));// 测试foreachlong startTime = System.nanoTime();int res = 0;for(Integer i: list)&#123; res += i; &#125;long endTime = System.nanoTime();System.out.println(&quot;foreach循环: &quot;+(endTime- startTime)); 结果 12for循环: 39368248forecah循环: 42177137 可见对于ArrayList仍然是采用for循环效率更高！ for循环小技巧关于数组 循环嵌套采用小套大。原理跟复制几个大文件跟复制一堆小文件耗时一样。 测试 12345678910long startTime = System.nanoTime();int res = 0;// 大套小for(int i=0; i&lt;10000000; i++)&#123; for(int j=0; j&lt;100; j++)&#123; res += i; &#125;&#125;long endTime = System.nanoTime();System.out.println(&quot;大套小: &quot;+(endTime- startTime)); 12345678// 小套大for(int i=0; i&lt;100; i++)&#123; for(int j=0; j&lt;10000000; j++)&#123; res += i; &#125;&#125;long endTime = System.nanoTime();System.out.println(&quot;小套大: &quot;+(endTime- startTime)); 结果 12大套小: 57934223小套大: 4918044 数组复制时采用System.arraycopy()方法比for循环复制效率高。 System.arraycopy() public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 代码解释: Object src : 原数组 int srcPos : 从元数据的起始位置开始 Object dest : 目标数组 int destPos : 目标数组的开始起始位置 int length : 要copy的数组的长度 关于ArrayList在循环时，首先把ArrayList长度size记录下来。 测试 1234567891011121314151617181920ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(30000000);for(int i=0; i&lt;30000000; i++)&#123; list.add(i);&#125;long startTime = System.nanoTime();//先把长度保存下来int len = list.size();int res = 0;for(int i=0; i&lt;len; i++)&#123; res += list.get(i);&#125;long endTime = System.nanoTime();System.out.println(&quot;保存size(): &quot;+(endTime- startTime));//没有保存size()for(int i=0; i&lt;list.size(); i++)&#123; res += list.get(i);&#125;long endTime = System.nanoTime();System.out.println(&quot;没有保存size(): &quot;+(endTime- startTime)); 结果12保存size(): 38973440没有保存size(): 39486862","categories":[{"name":"Java","slug":"Java","permalink":"https://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://sunyunzeng.com/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"Java：Map API","slug":"Java-Map-API","date":"2019-05-19","updated":"2022-11-05","comments":true,"path":"Java-Map-API/","link":"","permalink":"https://sunyunzeng.com/Java-Map-API/","excerpt":"","text":"Java Map常用类型 类型 特征 HashMap 根据 HashCode 存储数据，访问速度快。至多允许一条记录键为 null;允许多条记录的值为 null；线程非同步 TreeMap 保存的记录按照键(key)排序，也可自定义排序规则。用生成的 Iterator 遍历 TreeMap 得到记录是排序后的。不允许记录的键为 null；线程非同步 Hashtable 用 HashMap 类似,不同的是键值都不允许为 null。 支持线程同步，但写入较慢 LinkedHashMap 保留记录的插入顺序，生成Iterator遍历顺序与插入顺序一致。遍历比HashMap慢，键值都允许为 null；线程非同步 —&gt; HashMap剖析 常用 API 方法 描述 Object put(Object k, Object v) 存入键值对 Object get(Object k) 返回键所映射的值；如果不存在该映射则返回 null boolean containsKey(Object k) 是否包含键 k boolean containsValue(Object v) 是否包含值 v boolean isEmpty() Map 是否为空 int size() 返回 Map 的键值对数 boolean remove(Object k) 如果存在一个键映射关系，则删除此关系(映射关系不存在不会报错) void clear() 移除Map中所有映射关系 boolean equals(Object obj) 比较指定对象于此 Map 是否相等 void putAll(Map m) 将指定 Map 的映射关系复制到此 Map 中 Collection values() 以 Collection 形式返回 Map 包含的值 Set keySet() 以 Set 形式返回 Map 包含的键 Set entrySet() 以 Set 形式返回 Map 的映射关系 Map 应用示例 123456789Map&lt;Integer, Character&gt; map = new HashMap&lt;&gt;();map.put(1, &#x27;c&#x27;);map.get(1);for(int i: map.keySet())&#123; System.out.println(map.get(i)); &#125;if(map.containsKey(1))&#123; map.remove(1);&#125; 常用遍历方法1. 只获取键或值 12345678910// 获取键for(Integer key: map.keyset())&#123; System.out.println(key);&#125;// 获取值for(Integer value: map.value())&#123; System.out.println(value);&#125; 2. 同时获取键和值 1234567891011// 2.1 先取key再取value。不推荐for(Integer key:map.keySet())&#123; System.out.println(map.get(key));&#125;// 2.2 通过map entrySet遍历。性能优于上一种。for(Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet())&#123; System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue());&#125; 3. Iterator 上面的foreach都可以用Interator代替。 foreach是对Set遍历,大小不能改变。如果改变map的大小，会报错。如果想要删除元素，还是要用Interator的方式删除。 123456Interator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.enteySet().iterator();while(it.hasNext())&#123; Map.Entry&lt;Integer, Integer&gt; entry = it.next(); System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue()); // it.remove() 删除元素&#125; 4. Lambda 代码简洁，但是性能低于entrySet。 123map.forEach((key, value)-&gt;&#123; System.out.println(key + &quot;:&quot; + value);&#125;) 5. 性能测试 用10万条数据，做了一个简单性能测试，数据类型为Integer，map实现选取HashMap12345static&#123; for (int i = 0; i &lt; 100000; i++) &#123; map.put(i, 1); &#125;&#125; 测试结果如下： KeySet： 392 Values： 320 keySet get(key)： 552 entrySet： 465 entrySet Iterator：508 Lambda： 536 Map的遍历方法参考(侵删)","categories":[{"name":"Java","slug":"Java","permalink":"https://sunyunzeng.com/categories/Java/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://sunyunzeng.com/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"Algorithm--Coin Change","slug":"Algorithm-Coin-Change","date":"2019-05-19","updated":"2022-11-05","comments":true,"path":"Algorithm-Coin-Change/","link":"","permalink":"https://sunyunzeng.com/Algorithm-Coin-Change/","excerpt":"","text":"Dynamic ProgrammingCoin ChangeTitle Detail You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1:123Input: coins = [1, 2, 5], amount = 11Output: 3 Explanation: 11 = 5 + 5 + 1Example 1:12Input: coins = [2], amount = 3Output: -1Note: You may assume that you have an infinite number of each kind of coin. 思路动态规划 问题。 用一个 amount+1长度的数组 bp 维护不同面值金额需要最小的硬币数。 bp[0]=0 bp[1~amount]=amount+1 位置0表示面值为零，最小需要0个硬币，初始为0. 位置0~amount假设需要amount个硬币，因硬币类型为int，即代表无解。 对于硬币类型coins[i]，寻找j=coins[i] ~j=amount对应面值金额的最小硬币数，即为min(dp[j], dp[j-coins[i]]+1)。dp[j-coins[i]]+1代表放入一个该类型硬币。 前提： dp[j-coins[i]]面值的金额不是无解，因为如果无解，那么dp[j-coins[i]]+1对于当前面值金额也是无解。 返回dp数组第amount位置数字，即为所求。 Algorithm12345678910111213141516171819class Solution &#123; public int coinChange(int[] coins, int amount) &#123; if(coins.length==0) return -1; // 创建维护结果的数组 int[] dp=new int[amount+1]; Arrays.fill(dp,1,dp.length,amount+1); for(int i=0; i&lt;coins.length;i++)&#123; // 前提 for(int j=coins[i]; j&lt;=amount;j++)&#123; // 硬币数量统计 if(dp[j-coins[i]]!=amount+1)&#123; dp[j]=Math.min(dp[j], dp[j-coins[i]]+1); &#125; &#125; &#125; if(dp[amount]!=amount+1) return dp[amount]; return -1; &#125;&#125; 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Algorithm--Sqrt(x)","slug":"Algorithm-Sqrt-x","date":"2019-05-19","updated":"2022-11-05","comments":true,"path":"Algorithm-Sqrt-x/","link":"","permalink":"https://sunyunzeng.com/Algorithm-Sqrt-x/","excerpt":"","text":"Some Algorithm using Math AlgorithmAlgorithm-1 Sqrt(x)Title detail Implement int sqrt(int x)Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1:12Input: 4Output: 2Example 2:1234Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 思路 牛顿迭代法 公式： $x_{k+1} = \\lfloor {x_k + n / {x_k}} \\rfloor / 2$ 当$k \\rightarrow \\infty$ 时，${x_{k+1}}^2 \\rightarrow n$ Algorithm123456789101112class Solution &#123; public int mySqrt(int x) &#123; if(x&lt;=1) return x; long r=x; long t = x/r; while(r&gt;t)&#123; t = x/r; r = (r + t)/2; &#125; return (int)r; &#125;&#125; 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Algortthm--Jewels and Stones","slug":"Algortthm-Jewels-and-Stones","date":"2019-05-19","updated":"2022-11-05","comments":true,"path":"Algortthm-Jewels-and-Stones/","link":"","permalink":"https://sunyunzeng.com/Algortthm-Jewels-and-Stones/","excerpt":"","text":"Map的应用Jewels and StonesTitle Detail You’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”. Example 1:12Input: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;Output: 3Example 2:12Input: J = &quot;z&quot;, S = &quot;ZZ&quot;Output: 0Note: S and J will consist of letters and have length at most 50.The characters in J are distinct. 思路使用Java里面的 Map。key键保存宝石类型，value键保存数量统计。 Algorithm1234567891011121314151617181920class Solution &#123; public int numJewelsInStones(String J, String S) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for(int i=0; i&lt;J.length(); i++)&#123; map.put(J.charAt(i), 0); &#125; for(int i=0; i&lt;S.length();i++)&#123; Character c = S.charAt(i); if(map.get(c)!=null)&#123; Integer freq =map.get(c); map.put(c, freq+1); &#125; &#125; int result = 0; for(Integer value: map.values())&#123; result += value; &#125; return result; &#125;&#125; 法2 正则表达式123String a = &quot;[^&quot;+J+&quot;]&quot;; S = S.replaceAll(a, &quot;&quot;); return S.length(); Python方法1return sum(S.count(i) for i in J) 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Algorithm--Fast and Slow Pointer","slug":"Algorithm-Fase-and-Low-Pointer","date":"2019-05-17","updated":"2022-11-05","comments":true,"path":"Algorithm-Fase-and-Low-Pointer/","link":"","permalink":"https://sunyunzeng.com/Algorithm-Fase-and-Low-Pointer/","excerpt":"","text":"快慢指针的应用判断链表是否存在环Title Detail Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Example 1: 123Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1Output: trueExplanation: There is a cycle in the linked list, where tail connects to the second node. 思路利用快慢指针，快指针每次走两步，慢指针每次走一步。如果快指针能够追上慢指针，则链表存在环。 Algorithm1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head==null || head.next==null || head.next.next==null) return false; ListNode fast = head; ListNode slow = head; while(fast.next!=null &amp;&amp; fast.next.next!=null)&#123; fast = fast.next.next; slow = slow.next; if(fast == slow)&#123; return true; &#125; &#125; return false; &#125;&#125; 题目链接 有序数组移除重复数字Title Detail Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1:12345Given nums &#x3D; [1,1,2],Your function should return length &#x3D; 2, with the first two elements of nums being 1 and 2 respectively.It doesn&#39;t matter what you leave beyond the returned length. Example 1:12345Given nums &#x3D; [0,0,1,1,1,2,2,3,3,4],Your function should return length &#x3D; 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&#39;t matter what values are set beyond the returned length. Clarification:Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this:12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 思路前提是有序数组，可见排序是很基础且重要的算法！ 过程： 初始，快慢指针指向第一个数字。 当快慢指针指向的数字都相同，快指针往前移动一位。 当快慢指针指向的数字不相同，慢指针往前移动一位，把快指针指向的数字赋予慢指针，快指针往前移动一位。 慢指针移动的 位数+1 即为不同数字的数量。且数组从初始位置到慢指针指向的位置，数字都是排好序的。 Algorithm1234567891011121314class Solution &#123; public int removeDuplicates(int[] nums) &#123; int fast=0; int slow=0; while(fast&lt;nums.length)&#123; if(nums[fast]==nums[slow])&#123; fast++; &#125;else&#123; nums[++slow]=nums[fast++]; &#125; &#125; return slow+1; &#125;&#125; 图片地址 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"Algorithm--Find Common Characters","slug":"Algorithm-Find-Common-Characters","date":"2019-05-17","updated":"2022-11-05","comments":true,"path":"Algorithm-Find-Common-Characters/","link":"","permalink":"https://sunyunzeng.com/Algorithm-Find-Common-Characters/","excerpt":"","text":"Find Common CharactersTitle detail Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates). For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer. You may return the answer in any order. Example 112Input: [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]Output: [&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]Example 212Input: [&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]Output: [&quot;c&quot;,&quot;o&quot;]Note:1231 &lt;= A.length &lt;= 1001 &lt;= A[i].length &lt;= 100A[i][j] is a lowercase letter 思路统计每个字符串中26个字母的出现次数。每个字符串都出现的字母且统计次数最少的即为结果输出的字符。 用int数组0-25位置表示0-26个字母，存储的整数代表出现总次数。 Algorithm1234567891011121314151617181920212223242526class Solution &#123; public List&lt;String&gt; commonChars(String[] A) &#123; List&lt;String&gt; list = new ArrayList(); int[] res = new int[26]; for(int i=0; i&lt;A[0].length();i++)&#123; res[A[0].charAt(i) - &#x27;a&#x27;] += 1; &#125; for(int i=0; i&lt;A.length;i++)&#123; int[] temp = new int[26]; for(int j=0; j&lt;A[i].length(); j++)&#123; temp[A[i].charAt(j) - &#x27;a&#x27;] +=1; &#125; for(int m=0; m&lt;26; m++)&#123; res[m] = Math.min(res[m], temp[m]); &#125; &#125; for(int i=0; i&lt;26; i++)&#123; if(res[i] &gt; 0)&#123; for(int j=0; j&lt;res[i]; j++)&#123; list.add((char)(&#x27;a&#x27;+i)+&quot;&quot;); &#125; &#125; &#125; return list; &#125;&#125; 题目链接","categories":[{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"}]},{"title":"在Linux系统中同步更新我们的Github博客","slug":"在Linux系统中同步更新我们的Github博客","date":"2019-04-28","updated":"2022-11-05","comments":true,"path":"在Linux系统中同步更新我们的Github博客/","link":"","permalink":"https://sunyunzeng.com/%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E6%88%91%E4%BB%AC%E7%9A%84Github%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"原理介绍类似于版本管理，我们把hexo博客文件系统在Github上建立一个分支，通过管理分支提交最新的博客文件系统，保证我们博客框架的更新。然后我们基于最新的博客框架，撰写文章，进行Github Pages网页的更新，即我们博客内容的更新。 创建两个分支，一个用于存放博客静态资源，一个用于备份博客的部署文件。 参考资料 前期准备 一台Linux系统的电脑（我的linux系统是Ubuntu 18.04.2 LTS） 安装node.js 及 npm 安装 ssh 安装 git 按照我们前面教程搭建好的博客 创建Github 博客仓库分支首先在我们搭建Hexo博客的电脑上，创建我们博客仓库在Github上的分支。 打开我们的博客仓库，选择setting： 选择Branches,创建博客仓库的Hexo分支，并将其设置为默认分支。 将该仓库克融到本地，并把本地博客的(所有Hexo目录下文件)全部拷贝进username.github.io文件目录中去。 然后把更新后的博客部署文件提交到Github的hexo分支中。 依次执行123git add .git commit -m &#39;some info&#39;git push 注意事项： 将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。 然后我们的博客备份分支就创建好了。 Linux 部署项目 安装Node.js 与 npm 安装git linux与Github建立联系 把我们创建好的博客备份仓库clone到本机（linux） 4.1 在要保存的位置执行语句 git clone git@github.com:your.github.io/your.github.io.git 4.2 进入username.github.io目录，执行npm install (由于仓库有一个.gitignore文件，里面默认是忽略掉 node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录，所以要安装依赖) 安装hexo插件 sudo npm install hexo-cli -g 撰写我们的博客文章，然后依次执行下面指令，更新我们的博客备份。 12345hexo cleanhexo ggit add .git commit -m &#39;some info&#39;git push 更新博客界面 hexo d 注意事项 1. 每当撰写博客前，先 git pull，获取最新的博客备份。 2. 写完博客后，先依次执行hexo clean 、 hexo g 、 git add . 、 git commit -m &#39;some info 、 git push&#39;进行博客备份部署文件更新。 3. 最后执行 hexo d部署博客界面，实现博客更新。","categories":[{"name":"教程","slug":"教程","permalink":"https://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://sunyunzeng.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Markdown简单教程","slug":"markdown简单教程","date":"2019-04-26","updated":"2022-11-05","comments":true,"path":"markdown简单教程/","link":"","permalink":"https://sunyunzeng.com/markdown%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/","excerpt":"","text":"Markdown语言简介Markdown是一种轻量级的「标记语言」，语法简单易于上手，2004年由John Gruber创建。Markdown通过纯文本编写的方式实现文章的撰写与排版，然后被转化为html或者pdf，可以轻松地将文章分享。相较于文本编辑器word的文章排版的方式，Markdown通过固定的文本格式实现了绝大多数的排版场景，让创作者可以专心于文章的构思于撰写，而从繁琐的排版工作中解脱出来。 Markdown书写工具Markdown也得到了广泛的支持，例如简书、github、知乎、博客园等等都支持直接上传Markdown文档，同时一些桌面程序也支持利用Markdown语法记录文章。推荐的Markdown文档工具如下： Mac系统：Mou Windows系统：MarkPad Linux系统：retext 网页版：简书，可支持在线预览Markdown文档的功能 一些在线的Markdown工具： MaHua在线编辑器，无须测试 Cmd Markdown客户端编译器 Markdown语法很多博客的文章也是用Markdown写成的，因此花几分钟学习Markdown的语法还是很有必要的。下面介绍最常用的几种Markdown语法。 标题12345# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题 字体123**加粗***斜线*~~删除线~~ 加粗斜线删除线由于markdown支持插入html标签，因此更复杂的字体设置可以通过html标签跟css控制：123456&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot; color=#0099ff&gt;我是华文彩云&lt;/font&gt;&lt;font color=#00ffff size=2&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=3&gt;color=gray&lt;/font&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt;背景色是：orange&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 我是黑体字 我是微软雅黑 我是华文彩云 color=#00ffff color=gray 背景色是：orange 分割线1*** 或者 --- 下面是分割线： 引用123&gt; 有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。&gt; 此后如竟没有炬火，我便是唯一的光。倘若有了炬火，出了太阳，我们自然心悦诚服的消失。&gt; 不但毫无不平，而且还要随喜赞美这炬火或太阳；因为他照了人类，连我都在内。 有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。此后如竟没有炬火，我便是唯一的光。倘若有了炬火，出了太阳，我们自然心悦诚服的消失。不但毫无不平，而且还要随喜赞美这炬火或太阳；因为他照了人类，连我都在内。 列表12341. 有序列表.12. 有序列表.2- 无序列表.1- 无序列表.2 有序列表.1 有序列表.2 无序列表.1 无序列表.2 代码1234行内代码： `行内代码`块内代码：```javascriptlet name = &#x27;syz&#x27;``` 行内代码： 行内代码块内代码：1let name = &#x27;syz&#x27; 表格12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 :——————-: 表示居中，——-:表示靠右居中 外链及图片12插入链接：[链接名称](链接地址) 链接名称 12插入图片：![](图片地址) 公式行内公式：使用两个“ $ ”符号引用公式: 公式 行间公式：使用两对“ $ ”公式$$$$ 本博客采用的数学公式库为 katex，它是一个支持HTML的轻量级的数学公式引擎，使用起来也非常简单。 可以通过在线可视化公式编辑器，实现公式代码的生成 1行内公式：$E&#x3D;mc^2$ 行内公式：$E=mc^2$ 12行间公式：$$\\begin&#123;bmatrix&#125;1&amp;2\\\\1&amp;4\\end&#123;bmatrix&#125;&#x3D;\\int_0^1\\lim_&#123;x\\rightarrow\\infty&#125;\\operatorname dx$$ \\begin{bmatrix}1&2\\\\1&4\\end{bmatrix}=\\int_0^1\\lim_{x\\rightarrow\\infty}\\operatorname dxMarkdown进阶Tabs使用方法：123456789101112131415161718192021&#123;% tabs Unique name, [index] %&#125;&lt;!-- tab [Tab caption] [@icon] --&gt;Any content (support inline tags too).&lt;!-- endtab --&gt;&#123;% endtabs %&#125;Unique name : Unique name of tabs block tag without comma. Will be used in #id&#x27;s as prefix for each tab with their index numbers. If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes. Only for current url of post/page must be unique![index] : Index number of active tab. If not specified, first tab (1) will be selected. If index is -1, no tab will be selected. It&#x27;s will be something like spoiler. Optional parameter.[Tab caption] : Caption of current tab. If not caption specified, unique name with tab index suffix will be used as caption of tab. If not caption specified, but specified icon, caption will empty. Optional parameter.[@icon] : FontAwesome icon name (full-name, look like &#x27;fas fa-font&#x27;) Can be specified with or without space; e.g. &#x27;Tab caption @icon&#x27; similar to &#x27;Tab caption@icon&#x27;. Optional parameter. Demo 1 - 预设选择第一个【默认】 1234567891011121314&#123;% tabs test1 %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; test1 1test1 2test1 3This is Tab 1.This is Tab 2.This is Tab 3. Demo 2 - 预设选择tabs 12345678910111213&#123;% tabs test2, 3 %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; test2 1test2 2test2 3This is Tab 1.This is Tab 2.This is Tab 3. Demo 3 - 没有预设值 12345678910111213&#123;% tabs test3, -1 %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; test3 1test3 2test3 3This is Tab 1.This is Tab 2.This is Tab 3. Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名 12345678910111213&#123;% tabs test4 %&#125;&lt;!-- tab 第一个Tab --&gt;**tab名字为第一个Tab**&lt;!-- endtab --&gt;&lt;!-- tab @fab fa-apple-pay --&gt;**只有图标 没有Tab名字**&lt;!-- endtab --&gt;&lt;!-- tab 炸弹@fas fa-bomb --&gt;**名字+icon**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 第一个Tab炸弹tab名字为第一个Tab只有图标 没有Tab名字名字+icon Note便签通用设置用法1用法2（自定义icon）移植于next主题，并进行修改。 修改 主题配置文件123456789101112note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: simple icons: false border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0icons和light_bg_offset只对方法一生效 Note 标签外挂有两种用法123&#123;% note [class] [no-icon] [style] %&#125;Any content (support inline tags too.io).&#123;% endnote %&#125; 名称 用法 class 【可选】标签，不同的标签有不同的配色（ default / primary / success / info / warning / danger ） no-icon 【可选】不显示 icon style 【可选】可以覆盖配置中的 style （simple/modern/flat/disabled） simple123456789101112131415161718192021222324252627&#123;% note simple %&#125;默认 提示块标籤&#123;% endnote %&#125;&#123;% note default simple %&#125;default 提示块标籤&#123;% endnote %&#125;&#123;% note primary simple %&#125;primary 提示块标籤&#123;% endnote %&#125;&#123;% note success simple %&#125;success 提示块标籤&#123;% endnote %&#125;&#123;% note info simple %&#125;info 提示块标籤&#123;% endnote %&#125;&#123;% note warning simple %&#125;warning 提示块标籤&#123;% endnote %&#125;&#123;% note danger simple %&#125;danger 提示块标籤&#123;% endnote %&#125; 默认 提示块标籤 default 提示块标籤 primary 提示块标籤 success 提示块标籤 info 提示块标籤 warning 提示块标籤 danger 提示块标籤 modern123456789101112131415161718192021222324252627&#123;% note modern %&#125;默认 提示块标籤&#123;% endnote %&#125;&#123;% note default modern %&#125;default 提示块标籤&#123;% endnote %&#125;&#123;% note primary modern %&#125;primary 提示块标籤&#123;% endnote %&#125;&#123;% note success modern %&#125;success 提示块标籤&#123;% endnote %&#125;&#123;% note info modern %&#125;info 提示块标籤&#123;% endnote %&#125;&#123;% note warning modern %&#125;warning 提示块标籤&#123;% endnote %&#125;&#123;% note danger modern %&#125;danger 提示块标籤&#123;% endnote %&#125; 默认 提示块标籤 default 提示块标籤 primary 提示块标籤 success 提示块标籤 info 提示块标籤 warning 提示块标籤 danger 提示块标籤 flat123456789101112131415161718192021222324252627&#123;% note flat %&#125;默认 提示块标籤&#123;% endnote %&#125;&#123;% note default flat %&#125;default 提示块标籤&#123;% endnote %&#125;&#123;% note primary flat %&#125;primary 提示块标籤&#123;% endnote %&#125;&#123;% note success flat %&#125;success 提示块标籤&#123;% endnote %&#125;&#123;% note info flat %&#125;info 提示块标籤&#123;% endnote %&#125;&#123;% note warning flat %&#125;warning 提示块标籤&#123;% endnote %&#125;&#123;% note danger flat %&#125;danger 提示块标籤&#123;% endnote %&#125; 默认 提示块标籤 default 提示块标籤 primary 提示块标籤 success 提示块标籤 info 提示块标籤 warning 提示块标籤 danger 提示块标籤 disabled123456789101112131415161718192021222324252627&#123;% note disabled %&#125;默认 提示块标籤&#123;% endnote %&#125;&#123;% note default disabled %&#125;default 提示块标籤&#123;% endnote %&#125;&#123;% note primary disabled %&#125;primary 提示块标籤&#123;% endnote %&#125;&#123;% note success disabled %&#125;success 提示块标籤&#123;% endnote %&#125;&#123;% note info disabled %&#125;info 提示块标籤&#123;% endnote %&#125;&#123;% note warning disabled %&#125;warning 提示块标籤&#123;% endnote %&#125;&#123;% note danger disabled %&#125;danger 提示块标籤&#123;% endnote %&#125; 默认 提示块标籤 default 提示块标籤 primary 提示块标籤 success 提示块标籤 info 提示块标籤 warning 提示块标籤 danger 提示块标籤 123&#123;% note [color] [icon] [style] %&#125;Any content (support inline tags too.io).&#123;% endnote %&#125; 名称 用法 color 【可选】顔色 (default / blue / pink / red / purple / orange / green) icon 【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon ) style 【可选】可以覆盖配置中的 style （simple/modern/flat/disabled） simple123456789101112131415161718192021&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125; 你是刷 Visa 还是 UnionPay 2021年快到了…. 小心开车 安全至上 这是三片呢？还是四片？ 你是刷 Visa 还是 UnionPay 剪刀石头布 前端最讨厌的浏览器 modern123456789101112131415161718192021&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125; 你是刷 Visa 还是 UnionPay 2021年快到了…. 小心开车 安全至上 这是三片呢？还是四片？ 你是刷 Visa 还是 UnionPay 剪刀石头布 前端最讨厌的浏览器 flat123456789101112131415161718192021&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125; 你是刷 Visa 还是 UnionPay 2021年快到了…. 小心开车 安全至上 这是三片呢？还是四片？ 你是刷 Visa 还是 UnionPay 剪刀石头布 前端最讨厌的浏览器 disabled123456789101112131415161718192021&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125; 你是刷 Visa 还是 UnionPay 2021年快到了…. 小心开车 安全至上 这是三片呢？还是四片？ 你是刷 Visa 还是 UnionPay 剪刀石头布 前端最讨厌的浏览器 no-icon123456789101112131415161718192021&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125; 你是刷 Visa 还是 UnionPay 2021年快到了…. 小心开车 安全至上 这是三片呢？还是四片？ 你是刷 Visa 还是 UnionPay 剪刀石头布 前端最讨厌的浏览器 tag-hide请注意，tag-hide内的标签外挂content内都不建议有h1 - h6 等标题。因为Toc会把隐藏内容标题也显示出来，而且当滚动屏幕时，如果隐藏内容没有显示出来，会导致Toc的滚动出现异常。 InlineBlockToggleinline 在文本里面添加按钮隐藏内容，只限文字( content不能包含英文逗号，可用&amp;sbquo;)1&#123;% hideInline content,display,bg,color %&#125; content: 文本内容 display: 按钮显示的文字(可选) bg: 按钮的背景颜色(可选) color: 按钮文字的颜色(可选) Demo123哪个英文字母最酷？ &#123;% hideInline 因为西装裤(C装酷),查看答案,#FF7242,#fff %&#125;门里站着一个人? &#123;% hideInline 闪 %&#125;哪个英文字母最酷？ 查看答案 因为西装裤(C装酷)&lt;/span&gt; 门里站着一个人? Click 闪&lt;/span&gt;block独立的block隐藏内容，可以隐藏很多内容，包括图片，代码块等等 ( display 不能包含英文逗号，可用&amp;sbquo;) 123&#123;% hideBlock display,bg,color %&#125;content&#123;% endhideBlock %&#125; content: 文本内容 display: 按钮显示的文字(可选) bg: 按钮的背景颜色(可选) color: 按钮文字的颜色(可选) Demo 1234查看答案&#123;% hideBlock 查看答案 %&#125;傻子，怎么可能有答案&#123;% endhideBlock %&#125; 查看答案 查看答案 傻子，怎么可能有答案 如果你需要展示的内容太多，可以把它隐藏在收缩框里，需要时再把它展开。 ( display 不能包含英文逗号，可用&amp;sbquo;)123&#123;% hideToggle display,bg,color %&#125;content&#123;% endhideToggle %&#125; Demo12345678910&#123;% hideToggle Butterfly安装方法 %&#125;在你的博客根目录里git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly如果想要安装比较新的dev分支，可以git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly&#123;% endhideToggle %&#125; Butterfly安装方法在你的博客根目录里 git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly 如果想要安装比较新的dev分支，可以 git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly mermaid 绘图mermaid标签不允许嵌套于一些隐藏属性的标签外挂，例如: tag-hide内的标签外挂和tabs标签外挂，这会导致mermaid图示无法正常显示，使用时请留意。 请不要压缩html代码，不然会导致mermaid显示异常 使用mermaid标签可以绘製Flowchart（流程图）、Sequence diagram（时序图 ）、Class Diagram（类别图）、State Diagram（状态图）、Gantt（甘特图）和Pie Chart（圆形图），具体可以查看mermaid文档 修改 主题配置文件 1234mermaid: enable: true # built-in themes: default/forest/dark/neutral theme: default 写法： 123&#123;% mermaid %&#125;内容&#123;% endmermaid %&#125; 例如： 12345678&#123;% mermaid %&#125;pie title Key elements in Product X &quot;Calcium&quot; : 42.96 &quot;Potassium&quot; : 50.05 &quot;Magnesium&quot; : 10.01 &quot;Iron&quot; : 5&#123;% endmermaid %&#125; Button使用方法： 1234567891011121314151617&#123;% btn [url],[text],[icon],[color] [style] [layout] [position] [size] %&#125;[url] : 链接[text] : 按钮文字[icon] : [可选] 图标[color] : [可选] 按钮背景顔色(默认style时） 按钮字体和边框顔色(outline时) default/blue/pink/red/purple/orange/green[style] : [可选] 按钮样式 默认实心 outline/留空[layout] : [可选] 按钮佈局 默认为line block/留空[position] : [可选] 按钮位置 前提是设置了layout为block 默认为左边 center/right/留空[size] : [可选] 按钮大小 larger/留空 Demo 12345This is my website, click the button &#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly %&#125;This is my website, click the button &#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right %&#125;This is my website, click the button &#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,,outline %&#125;This is my website, click the button &#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline %&#125;This is my website, click the button &#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,larger %&#125; This is my website, click the button ButterflyThis is my website, click the button ButterflyThis is my website, click the button ButterflyThis is my website, click the button ButterflyThis is my website, click the button Butterfly 123&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,block %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,block center larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,block right outline larger %&#125; Butterfly Butterfly Butterfly more than one button in center 1234567&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,blue larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,pink larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,red larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,purple larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,orange larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,green larger %&#125; Butterfly Butterfly Butterfly Butterfly Butterfly Butterfly Butterfly 123456789&lt;div class=&quot;btn-center&quot;&gt;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline blue larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline pink larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline red larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline purple larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline orange larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline green larger %&#125;&lt;/div&gt; Butterfly Butterfly Butterfly Butterfly Butterfly Butterfly Butterfly inlineimg主题中的图片都是默认以块级元素显示，如果你想以内联元素显示，可以使用这个标签外挂。 1234&#123;% inlineImg [src] [height] %&#125;[src] : 图片链接[height] ： 图片高度限制【可选】 Demo 12345你看我长得漂亮不![](https://i.loli.net/2021/03/19/2P6ivUGsdaEXSFI.png)我觉得很漂亮 &#123;% inlineImg https://i.loli.net/2021/03/19/5M4jUB3ynq7ePgw.png 150px %&#125;","categories":[{"name":"教程","slug":"教程","permalink":"https://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://sunyunzeng.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Windows环境下Hexo+Github搭建个人博客教程","slug":"博客搭建教程","date":"2019-04-23","updated":"2022-11-05","comments":true,"path":"博客搭建教程/","link":"","permalink":"https://sunyunzeng.com/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/","excerpt":"","text":"前言你是否也想拥有属于自己的博客？是否也想拥有跟我一样的博客空间？如果心动了，就赶紧往下看吧！ 教程炒鸡简单，炒鸡详细，而且博客搭建完全是Free of Charge! 原理Github PagesGithub不仅可以让我们把代码托管在平台上，而且允许我们利用Github的服务器部署自定义网页对我们的项目作简介。这个网页就被称为Github Pages。这是我们可以利用Github搭建免费博客的基础啦~ HexoHexo是一款轻量但高逼格的搭建博客快速工具，它是基于Node.js开发的。而Node.js…好了，扯远了…有兴趣的童鞋可以出门左转自己百度… 准备知道了大致的原理，我们首先需要准备搭建博客的材料。如下： 1. 一台windows系统的电脑2. 一个Github账号3. 安装Node.js4. 安装Git5. 安装Hexo 开始申请Github账号，建立一个仓库，并为此创建一个说明网页(Github Pages)假设我们都有了Github账号，这是首先在右上角点击“+”号，选择New repository 注意 仓库名一定是”你的Github用户名”+github.io !!! 之后为我们的项目添加一个说明Pages！ 建好的项目顶部最右边有个Setting按钮，点击进入配置界面，下滑界面，直到看到Github Pages，这时你发现竟然自动生成了一个说明网页！ 因为Github说明网页的默认地址就是“你的Github用户名”+github.io，其它说明网页都是基于该地址的。 Ok! 到此为止，Gihub Pages的部分就结束了。 搭建Hexo，把Github Pages修改为自己的博客界面！安装Git以及Node.js！因为我们需要通过Git把我们的Hexo生成的网页提交到Github pages上，而Node.js是我们Hexo插件运行的基础！ 下载安装Windows版Git 下载安装Node.js 验证：“Win”+R打开运行界面，输入”cmd”打开命令行窗口。是否安装Git:输入git version出现版本信息： 1git version 2.19.1.windows.1 是否安装Node.js:输入node -v出现版本信息：1v8.12.0 安装及部署Hexo首先创建一个文件夹，用来放置我们的Hexo。 然后进入我们的文件夹，例如我们文件夹路径为D:\\blog 则在终端依次输入并执行D: 、 cd blog 进入文件夹 打开命令终端，利用Node.js的包管理器npm安装Hexo:npm install hexo-cli -g输入hexo -v验证是否安装成功输入hexo init初始化该文件夹输入npm install安装需要的组件输入npm g生成静态文件输入npm s启动服务器，现在在浏览器输入http://localhost:4000/打开我们的博客界面！ 是不是有点鸡冻！别急，我们还需要把页面推送到Github Pages上，步骤如下： 1. 设置Git的user name和email 在我们创建博客文件夹里右击，选择 Git Base Here，然后在窗口中依次输入git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 2. SSH 授权打开git bash，输入ssh-keygen -t rsa, 接着回车三下。 最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\\Users\\Administrator.ssh） 登录Github，点击头像下的settings，添加ssh。新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 3. 上传项目 首先用IDE(我用的是WebStorm)打开我们的Hexo文件夹，发现它的文档目录是这样的：12345678|-- _config.yml|-- package.json|-- scaffolds|-- source |-- _posts|-- public|-- themes|-- .gitignore _config.yml：网站的全局配置文件，设置包括网站标题、副标题、作者、关键字和描述信息等。 package.json：框架的基本参数信息和它所依赖的插件，在 npm 安装时使用 —save 保存进去。 scaffolds：本意是 “脚手架” 的意思，这里引申为模板文件夹。当你 hexo new &lt;’title’&gt; 的时候，Hexo 会根据该文件夹下的对应文件进行初始化构建。 source：正如其名，source 文件夹存储一些直接来自用户的文件，它很重要，如果不出意外你的文章就是保存在这个文件夹下(_posts)。_posts 目录下的md文件，会被编译成 html 文件，放到 public 文件夹下。 public：参考 source 文件夹，在初始化后是没有 public 文件夹的，除非 hexo g 编译生成静态文件后，public 文件夹会自动生成。使用hexo clean 清除 db.json 和 public 文件夹下的所有文件。 themes：主题文件夹，存储主题。相关的主题可以在 Github 上免费采购。 .gitignore：.gitignore 文件作用是声明不被 git 记录的文件，hexo init 也会产生一个 .gitignore 文件，可以先删除或者直接编辑，对hexo不会有影响。 打开配置文档_config.yml，修改deploy值（在末尾）:1234deploy: type: git repo: git@github.com:SUNYunZeng&#x2F;SUNYunZeng.github.io.git branch: master 安装在git上部署文章的扩展npm install hexo-deployer-git --save 打开终端并进入到Hexo文件系统中，创建一篇新博客hexo new post &quot;博客名&quot; 这时文件夹source/_posts文件夹里会出现博客名.md的博客文章源文件 文件是markdown格式，书写方法有一套规范，下篇博客会讲到。PS:非常简单啦~ 编辑好博客内容后，一顿滚键盘，依次执行以下命令：hexo g 生成静态文件hexo d 部署到Github Pages 就这样，你的第一篇博客就上传啦！ 更换Hexo主题由于默认的博客主题可能不能满足大家的需求，所以再提一下更换主题的方法。 首先到Hexo官网中选择一款喜欢的主题 这里我以我博客采用的主题为例，我采用的pure主题 首先在Hexo系统文件夹中打开终端，然后输入git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 之后在系统目录theme文件夹下你会发现多出了pure命名的一个文件夹，这就是我们主题保存的位置,其中pure文件夹下的config.yml文件就是我们博客的配置文件，在里面可以自己对博客界面进行个性化配置，详情请参看网址 在我们的Hexo系统配置文件config.yml中，修改theme为我们的pure主题 1theme: pure 然后进入文件夹 cd themes/pure 把主题提交git pull 重新生成博客静态文件，然后部署到Github Pageshexo ghexo d 当当~我们的个性化博客就搭建完毕啦！","categories":[{"name":"教程","slug":"教程","permalink":"https://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://sunyunzeng.com/tags/%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"杂记","slug":"杂记","permalink":"https://sunyunzeng.com/categories/%E6%9D%82%E8%AE%B0/"},{"name":"算法","slug":"算法","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"科技","slug":"科技","permalink":"https://sunyunzeng.com/categories/%E7%A7%91%E6%8A%80/"},{"name":"Web前端","slug":"Web前端","permalink":"https://sunyunzeng.com/categories/Web%E5%89%8D%E7%AB%AF/"},{"name":"教程","slug":"教程","permalink":"https://sunyunzeng.com/categories/%E6%95%99%E7%A8%8B/"},{"name":"Web可视化","slug":"Web可视化","permalink":"https://sunyunzeng.com/categories/Web%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"算法题","slug":"算法题","permalink":"https://sunyunzeng.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"MySQL","slug":"MySQL","permalink":"https://sunyunzeng.com/categories/MySQL/"},{"name":"Java","slug":"Java","permalink":"https://sunyunzeng.com/categories/Java/"},{"name":"Git","slug":"Git","permalink":"https://sunyunzeng.com/categories/Git/"},{"name":"Linux","slug":"Linux","permalink":"https://sunyunzeng.com/categories/Linux/"}],"tags":[{"name":"思考","slug":"思考","permalink":"https://sunyunzeng.com/tags/%E6%80%9D%E8%80%83/"},{"name":"机器学习","slug":"机器学习","permalink":"https://sunyunzeng.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"数学","slug":"数学","permalink":"https://sunyunzeng.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"区块链","slug":"区块链","permalink":"https://sunyunzeng.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"语法","slug":"语法","permalink":"https://sunyunzeng.com/tags/%E8%AF%AD%E6%B3%95/"},{"name":"npm","slug":"npm","permalink":"https://sunyunzeng.com/tags/npm/"},{"name":"博客","slug":"博客","permalink":"https://sunyunzeng.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"深度学习","slug":"深度学习","permalink":"https://sunyunzeng.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"控制论","slug":"控制论","permalink":"https://sunyunzeng.com/tags/%E6%8E%A7%E5%88%B6%E8%AE%BA/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sunyunzeng.com/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://sunyunzeng.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"React","slug":"React","permalink":"https://sunyunzeng.com/tags/React/"},{"name":"D3","slug":"D3","permalink":"https://sunyunzeng.com/tags/D3/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://sunyunzeng.com/tags/LeetCode/"},{"name":"CSS","slug":"CSS","permalink":"https://sunyunzeng.com/tags/CSS/"},{"name":"Vue","slug":"Vue","permalink":"https://sunyunzeng.com/tags/Vue/"},{"name":"动态规划","slug":"动态规划","permalink":"https://sunyunzeng.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心法","slug":"贪心法","permalink":"https://sunyunzeng.com/tags/%E8%B4%AA%E5%BF%83%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://sunyunzeng.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"排序算法","slug":"排序算法","permalink":"https://sunyunzeng.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://sunyunzeng.com/tags/%E5%89%91%E6%8C%87Offer/"},{"name":"回溯法","slug":"回溯法","permalink":"https://sunyunzeng.com/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"},{"name":"JVM","slug":"JVM","permalink":"https://sunyunzeng.com/tags/JVM/"},{"name":"Servlet","slug":"Servlet","permalink":"https://sunyunzeng.com/tags/Servlet/"},{"name":"Git","slug":"Git","permalink":"https://sunyunzeng.com/tags/Git/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://sunyunzeng.com/tags/TCP-IP/"},{"name":"http","slug":"http","permalink":"https://sunyunzeng.com/tags/http/"}]}