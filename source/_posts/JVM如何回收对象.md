---
title: JVM如何回收对象
comments: true
toc: true
date: 2019-08-14 21:33:32
categories: JVM
tags: JVM
---

# 如何判断对象是否要回收？

## 对象回收的依据——是否被有效引用？

引用的可分为**强引用**(Strong Reference)——指向**new** 对象的引用、**软引用**(Soft Reference)——有用但没必要的引用、**弱引用**(Weak Reference)——没有必要的引用、**虚引用**(Phantom Reference)——为了在对象被回收时获得系统通知。

> 强引用只要存在就不回收；
> 软引用只有在内存即将不足的情况下才回收；
> 弱引用及虚引用随便回收。

## 怎么判断对象是否被有效引用？

1. **引用计数法**。如果对象的引用计数器为0，则表示该对象可以回收。但是存在互相引用无法清理的情况。

2. **可达性分析法**。通过创建一个成为“GC Root”的对象作为搜索根节点，向下搜索。如果对象到该对象之间没有引用链关联，则该对象可回收。

## 对象死亡的判决书

再对象确定没有引用的情况下，还需要判断其**finalize**方法没有被覆盖或者已经被执行一次（该方法只能执行一次），满足这两个条件，GC才会回收该对象。

如果**finalize**方法被覆盖，则将该对象加入一个 **"F-Queue"**队列中，由虚拟机创建的、优先级低的**Finalizer的线程**去处理。

如果对象在finalize方法中**建立了与"GC Root"对象的连接链**，则对象成功逃离了死亡的命运。否则，对象就被判决了死刑。

# 垃圾回收算法

## 标记-清理算法。

根据对象是否被有效引用进行标记，然后清理无用对象。
    **优点**：简洁有效。
    **缺点**：存在空间碎片，不利于下次对象内存的分配及内存空间的合理利用。

## 复制算法。

将内存划分为两大块，一块用于存储对象，另一块用于复制准备。第一步也是标记，第二步是把不需清理的对象复制到另一块内存区域，保持这些对象在内存空间上是连续排列。
    **优点**：无碎片空间，且新对象内存空间分配便捷。
    **缺点**：二分法对空间利用率不高，且复制过程中效率不高。由于新生代中无用对象多，需要复制移动的对象少，所以该法很适合。
    **改进版**：内存划分为**一块**较大的**Eden内存空间**及**两块**较小的**Survivor空间**（默认8:1:1），一块Eden及Survivor用于分配对象，另一块用于复制准备。如果要复制的对象的内存超出了准备的Survivor，则需要其他内存（老生代）进行分配担保。

## 标记-整理。

第一步标记。第二步将存活的对象都往前移动，在内存空间中紧密排列，然后对于边界外的内存空间进行清理。

## 分代收集算法。

将内存空间分为**新生代**与**老生代**。新生代中每次垃圾回收时都会有大量对象死亡，需要复制的对象很少，因此采用复制算法。老生代对象的利用率高，存活时间长，因此采用标记-清理或者标记整理算法。


参考: [深入理解java虚拟机](https://book.douban.com/subject/6522893/)


