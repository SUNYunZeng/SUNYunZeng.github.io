<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Algorithm--Coin Change</title>
    <url>/Algorithm-Coin-Change/</url>
    <content><![CDATA[<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a><strong>Dynamic Programming</strong></h1><h2 id="Coin-Change"><a href="#Coin-Change" class="headerlink" title="Coin Change"></a><strong>Coin Change</strong></h2><p><strong>Title Detail</strong></p>
<blockquote>
<p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>
<p><strong>Example 1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">Output: <span class="number">3</span> </span><br><span class="line">Explanation: <span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure><br><strong>Example 1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: coins = [<span class="number">2</span>], amount = <span class="number">3</span></span><br><span class="line">Output: -<span class="number">1</span></span><br></pre></td></tr></table></figure><br><strong>Note:</strong></p>
<p>You may assume that you have an infinite number of each kind of coin.</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><a href="https://zh.wikipedia.org/zh-hans/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a> 问题。</p>
<ol>
<li><p>用一个 <code>amount+1</code>长度的数组 <code>bp</code> 维护不同面值金额需要最小的硬币数。</p>
<blockquote>
<p><code>bp[0]=0</code></p>
<p><code>bp[1~amount]=amount+1</code></p>
</blockquote>
<p> 位置<code>0</code>表示面值为零，最小需要0个硬币，初始为0.</p>
<p> 位置<code>0~amount</code>假设需要amount个硬币，因硬币类型为<code>int</code>，即代表<strong>无解</strong>。</p>
</li>
<li><p>对于硬币类型<code>coins[i]</code>，寻找<code>j=coins[i] ~j=amount</code>对应面值金额的最小硬币数，即为<code>min(dp[j], dp[j-coins[i]]+1)</code>。<code>dp[j-coins[i]]+1</code>代表放入一个该类型硬币。</p>
<p> <strong>前提：</strong> <code>dp[j-coins[i]]</code>面值的金额不是无解，因为如果无解，那么<code>dp[j-coins[i]]+1</code>对于当前面值金额也是无解。</p>
</li>
<li><p>返回<code>dp</code>数组第<code>amount</code>位置数字，即为所求。</p>
</li>
</ol>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(coins.length==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 创建维护结果的数组</span></span><br><span class="line">       <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">       Arrays.fill(dp,<span class="number">1</span>,dp.length,amount+<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;coins.length;i++)&#123;</span><br><span class="line">           <span class="comment">// 前提</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=coins[i]; j&lt;=amount;j++)&#123;</span><br><span class="line">               <span class="comment">// 硬币数量统计</span></span><br><span class="line">               <span class="keyword">if</span>(dp[j-coins[i]]!=amount+<span class="number">1</span>)&#123;</span><br><span class="line">                  dp[j]=Math.min(dp[j], dp[j-coins[i]]+<span class="number">1</span>); </span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(dp[amount]!=amount+<span class="number">1</span>) <span class="keyword">return</span> dp[amount];</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/coin-change/">题目链接</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm--Fast and Slow Pointer</title>
    <url>/Algorithm-Fase-and-Low-Pointer/</url>
    <content><![CDATA[<h1 id="快慢指针的应用"><a href="#快慢指针的应用" class="headerlink" title="快慢指针的应用"></a><strong>快慢指针的应用</strong></h1><h2 id="判断链表是否存在环"><a href="#判断链表是否存在环" class="headerlink" title="判断链表是否存在环"></a><strong>判断链表是否存在环</strong></h2><p><strong>Title Detail</strong></p>
<p>Given a linked list, determine if it has a cycle in it.</p>
<p>To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.</p>
<blockquote>
<p>Example 1:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure>
<img src="/Algorithm-Fase-and-Low-Pointer/circularlinkedlist.png" class>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>利用快慢指针，快指针每次走两步，慢指针每次走一步。如果快指针能够追上慢指针，则链表存在环。</p>
<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a><strong>Algorithm</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span> || head.next.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span> &amp;&amp; fast.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">题目链接</a></p>
<h2 id="有序数组移除重复数字"><a href="#有序数组移除重复数字" class="headerlink" title="有序数组移除重复数字"></a><strong>有序数组移除重复数字</strong></h2><p><strong>Title Detail</strong></p>
<p>Given a sorted array nums, remove the duplicates <strong>in-place</strong> such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure></p>
<p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure></p>
<p><strong>Clarification:</strong><br>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums is passed in by reference. (i.e., without making a copy)</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// any modification to nums in your function would be known by the caller.</span></span><br><span class="line"><span class="comment">// using the length returned by your function, it prints the first len elements.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>前提是有序数组，可见排序是很基础且重要的算法！</p>
<blockquote>
<p>过程：</p>
<ol>
<li>初始，快慢指针指向第一个数字。</li>
<li>当快慢指针指向的数字都相同，快指针往前移动一位。</li>
<li>当快慢指针指向的数字不相同，慢指针往前移动一位，把快指针指向的数字赋予慢指针，快指针往前移动一位。</li>
<li>慢指针移动的 <strong>位数+1</strong> 即为不同数字的数量。且数组从初始位置到慢指针指向的位置，数字都是排好序的。</li>
</ol>
</blockquote>
<img src="/Algorithm-Fase-and-Low-Pointer/remove-duplicates-from-sorted-array.gif" class>
<h3 id="Algorithm-1"><a href="#Algorithm-1" class="headerlink" title="Algorithm"></a><strong>Algorithm</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fast=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]==nums[slow])&#123;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[++slow]=nums[fast++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><a href="https://github.com/MisterBooo/LeetCodeAnimation">图片地址</a>   </p>
</li>
<li><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/">题目链接</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm--Find Common Characters</title>
    <url>/Algorithm-Find-Common-Characters/</url>
    <content><![CDATA[<h1 id="Find-Common-Characters"><a href="#Find-Common-Characters" class="headerlink" title="Find Common Characters"></a>Find Common Characters</h1><h2 id="Title-detail"><a href="#Title-detail" class="headerlink" title="Title detail"></a><strong>Title detail</strong></h2><blockquote>
<p>Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list <strong>(including duplicates)</strong>.  For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.</p>
<p>You may return the answer in any order.</p>
<p><strong>Example 1</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="string">&quot;bella&quot;</span>,<span class="string">&quot;label&quot;</span>,<span class="string">&quot;roller&quot;</span>]</span><br><span class="line">Output: [<span class="string">&quot;e&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;l&quot;</span>]</span><br></pre></td></tr></table></figure><br><strong>Example 2</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="string">&quot;cool&quot;</span>,<span class="string">&quot;lock&quot;</span>,<span class="string">&quot;cook&quot;</span>]</span><br><span class="line">Output: [<span class="string">&quot;c&quot;</span>,<span class="string">&quot;o&quot;</span>]</span><br></pre></td></tr></table></figure><br><strong>Note:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= A.length &lt;= <span class="number">100</span></span><br><span class="line"><span class="number">1</span> &lt;= A[i].length &lt;= <span class="number">100</span></span><br><span class="line">A[i][j] is a lowercase letter</span><br></pre></td></tr></table></figure></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>统计每个字符串中26个字母的出现次数。每个字符串都出现的字母且统计次数最少的即为结果输出的字符。</p>
</blockquote>
<p>用<code>int</code>数组0-25位置表示0-26个字母，存储的整数代表出现总次数。</p>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">commonChars</span><span class="params">(String[] A)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A[<span class="number">0</span>].length();i++)&#123;</span><br><span class="line">            res[A[<span class="number">0</span>].charAt(i) - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;A[i].length(); j++)&#123;</span><br><span class="line">                temp[A[i].charAt(j) - <span class="string">&#x27;a&#x27;</span>] +=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>; m&lt;<span class="number">26</span>; m++)&#123;</span><br><span class="line">                res[m] = Math.min(res[m], temp[m]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;res[i]; j++)&#123;</span><br><span class="line">                    list.add((<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span>+i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/find-common-characters/">题目链接</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm--Minimum path sum</title>
    <url>/Algorithm-Minimum-path-sum/</url>
    <content><![CDATA[<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a><strong>Dynamic Programming</strong></h1><h2 id="Minimum-Path-Sum"><a href="#Minimum-Path-Sum" class="headerlink" title="Minimum Path Sum"></a><strong>Minimum Path Sum</strong></h2><p><strong>Title Detail</strong></p>
<blockquote>
<p>Given an integer array A, you partition the array into (contiguous) subarrays of length at most K.  After partitioning, each subarray has their values changed to become the maximum value of that subarray.</p>
<p>Return the largest sum of the given array after partitioning.</p>
<p><strong>Example 1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: A = [<span class="number">1</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>], K = <span class="number">3</span></span><br><span class="line">Output: <span class="number">84</span></span><br><span class="line">Explanation: A becomes [<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure><br><strong>Note:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= K &lt;= A.length &lt;= <span class="number">500</span></span><br><span class="line"><span class="number">0</span> &lt;= A[i] &lt;= <span class="number">10</span>^<span class="number">6</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><a href="https://zh.wikipedia.org/zh-hans/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a> 问题。</p>
<ol>
<li>用原来的<code>grid</code>矩阵存储路径和</li>
<li><p>注意三种特殊情况，即矩阵<strong>初始位置、顶栏及左侧栏</strong>和求解。</p>
<p> 初始：<code>grid[0][0] = grid[0][0]</code></p>
<p> 顶栏：<code>grid[i][j] = grid[i][j-1]</code></p>
<p> 左侧栏：<code>grid[i][j] = grid[i-1][j]</code></p>
</li>
<li>其余位置：<code>grid[i][j] = min(grid[i][j-1], grid[i-1][j])</code></li>
</ol>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j!=<span class="number">0</span>)&#123;</span><br><span class="line">                    grid[i][j] += grid[i][j-<span class="number">1</span>]; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>&amp;&amp;i!=<span class="number">0</span>)&#123;</span><br><span class="line">                    grid[i][j] += grid[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    grid[i][j] += Math.min(grid[i-<span class="number">1</span>][j], grid[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/minimum-path-sum/submissions/">题目链接</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm--Sqrt(x)</title>
    <url>/Algorithm-Sqrt-x/</url>
    <content><![CDATA[<h1 id="Some-Algorithm-using-Math-Algorithm"><a href="#Some-Algorithm-using-Math-Algorithm" class="headerlink" title="Some Algorithm using Math Algorithm"></a>Some Algorithm using Math Algorithm</h1><h2 id="Algorithm-1-Sqrt-x"><a href="#Algorithm-1-Sqrt-x" class="headerlink" title="Algorithm-1 Sqrt(x)"></a><strong>Algorithm-1 Sqrt(x)</strong></h2><p><strong>Title detail</strong></p>
<blockquote>
<p>Implement int sqrt(int x)<br>Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</p>
<p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p>
<p><strong>Example 1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">4</span></span><br><span class="line">Output: <span class="number">2</span></span><br></pre></td></tr></table></figure><br><strong>Example 2:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">8</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: The square root of <span class="number">8</span> is <span class="number">2.82842</span>..., and since </span><br><span class="line">             the decimal part is truncated, <span class="number">2</span> is returned.</span><br></pre></td></tr></table></figure></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3></blockquote>
<p><a href="https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division">牛顿迭代法</a></p>
<blockquote>
<p>公式： $x_{k+1} = \lfloor {x_k +  n / {x_k}} \rfloor / 2$</p>
<p>当$k \rightarrow \infty$ 时，${x_{k+1}}^2 \rightarrow  n$</p>
</blockquote>
<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a><strong>Algorithm</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">long</span> r=x;</span><br><span class="line">        <span class="keyword">long</span> t = x/r;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;t)&#123;</span><br><span class="line">            t = x/r;</span><br><span class="line">            r = (r + t)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/sqrtx/">题目链接</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm--Third Maximum Number</title>
    <url>/Algorithm-Third-Maximum-Number/</url>
    <content><![CDATA[<h1 id="1-Third-Maximum-Number"><a href="#1-Third-Maximum-Number" class="headerlink" title="1. Third Maximum Number"></a>1. Third Maximum Number</h1><h2 id="Title-Detail"><a href="#Title-Detail" class="headerlink" title="Title Detail"></a>Title Detail</h2><blockquote>
<p>Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. <strong>The time complexity must be in O(n).</strong></p>
<p><strong>Example 1:</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: The third maximum is <span class="number">1.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Example 2:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: The third maximum does not exist, <span class="function">so the <span class="title">maximum</span> <span class="params">(<span class="number">2</span>)</span> is returned instead.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Example 3:</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">Output: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Explanation:</strong><br>Note that the third maximum here means the third maximum distinct number.<br>Both numbers with value 2 are both considered as second maximum.</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h2><p>因为要求算法的时间复杂度为O(n)，所以不能用排序的方法。因为只求第三大的数，跟求第一大的数原理类似，只不过注意边界条件。</p>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a><strong>Algorithm</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> max1 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> max2 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> max3 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> f = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;max1)&#123;</span><br><span class="line">                max3=max2;</span><br><span class="line">                max2=max1;</span><br><span class="line">                max1=nums[i];</span><br><span class="line">                ++flag;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max1&gt;nums[i] &amp;&amp; nums[i]&gt;max2)&#123;</span><br><span class="line">                max3=max2;</span><br><span class="line">                max2=nums[i];</span><br><span class="line">                ++flag;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max2&gt;nums[i] &amp;&amp; nums[i]&gt;max3)&#123;</span><br><span class="line">                max3=nums[i];</span><br><span class="line">                ++flag;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 边界条件，如果有多个最小值，则只算一次</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]==Integer.MIN_VALUE&amp;&amp;f)&#123;</span><br><span class="line">                flag++;</span><br><span class="line">                f = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (flag&lt;<span class="number">3</span>?max1:max3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/third-maximum-number/">题目链接</a></p>
<h1 id="2-Smallest-Range-I"><a href="#2-Smallest-Range-I" class="headerlink" title="2. Smallest Range I"></a>2. Smallest Range I</h1><h2 id="Title-Detail-1"><a href="#Title-Detail-1" class="headerlink" title="Title Detail"></a>Title Detail</h2><blockquote>
<p>Given an array A of integers, for each integer A[i] we may choose any x with -K &lt;= x &lt;= K, and add x to A[i].<br>After this process, we have some array B.<br>Return the smallest possible difference between the maximum value of B and the minimum value of B.</p>
</blockquote>
<p><strong>Example 1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: A = [<span class="number">1</span>], K = <span class="number">0</span></span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line">Explanation: B = [<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>Example 2:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: A = [<span class="number">0</span>,<span class="number">10</span>], K = <span class="number">2</span></span><br><span class="line">Output: <span class="number">6</span></span><br><span class="line">Explanation: B = [<span class="number">2</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>Example 3:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: A = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>], K = <span class="number">3</span></span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line">Explanation: B = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>] or B = [<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= A.length &lt;= <span class="number">10000</span></span><br><span class="line"><span class="number">0</span> &lt;= A[i] &lt;= <span class="number">10000</span></span><br><span class="line"><span class="number">0</span> &lt;= K &lt;= <span class="number">10000</span></span><br></pre></td></tr></table></figure></p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>求出数组最大值与最小值的差值，比较差值与K/2的关系。</p>
<h2 id="Algorithm-1"><a href="#Algorithm-1" class="headerlink" title="Algorithm"></a>Algorithm</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestRangeI</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.length==<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;min) min = A[i];</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;=max) max = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = max-min;</span><br><span class="line">        <span class="keyword">if</span>(len&gt;<span class="number">2</span>*K) </span><br><span class="line">            <span class="keyword">return</span> len-<span class="number">2</span>*K;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/smallest-range-i/">题目链接</a></p>
<h1 id="3-数组形式的整数加法"><a href="#3-数组形式的整数加法" class="headerlink" title="3. 数组形式的整数加法"></a>3. 数组形式的整数加法</h1><h2 id="题目细节"><a href="#题目细节" class="headerlink" title="题目细节"></a>题目细节</h2><blockquote>
<p>对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。</p>
<p>给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。</p>
</blockquote>
<p><strong>示例1：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>], K = <span class="number">34</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释：<span class="number">1200</span> + <span class="number">34</span> = <span class="number">1234</span></span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：A = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>], K = <span class="number">181</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">解释：<span class="number">274</span> + <span class="number">181</span> = <span class="number">455</span></span><br></pre></td></tr></table></figure></p>
<p><strong>示例3：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：A = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>], K = <span class="number">806</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：<span class="number">215</span> + <span class="number">806</span> = <span class="number">1021</span></span><br></pre></td></tr></table></figure></p>
<p><strong>示例4：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：A = [<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>], K = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">解释：<span class="number">9999999999</span> + <span class="number">1</span> = <span class="number">10000000000</span></span><br></pre></td></tr></table></figure></p>
<p><strong>提示：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= A.length &lt;= <span class="number">10000</span></span><br><span class="line"><span class="number">0</span> &lt;= A[i] &lt;= <span class="number">9</span></span><br><span class="line"><span class="number">0</span> &lt;= K &lt;= <span class="number">10000</span></span><br><span class="line">如果 A.length &gt; <span class="number">1</span>，那么 A[<span class="number">0</span>] != <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>最初思路是字符串转数字，相加后转字符串。</p>
<p>但是最终没过，因为数据量太大，不允许。</p>
<p>后又通过进位方式实现，老太太的裹脚布。</p>
<h2 id="Algorithm-2"><a href="#Algorithm-2" class="headerlink" title="Algorithm"></a>Algorithm</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">addToArrayForm</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = A[i] + K;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                A[i] = temp % <span class="number">10</span>;</span><br><span class="line">                K = temp / <span class="number">10</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                A[i] = temp;</span><br><span class="line">                K = temp /<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (K!=<span class="number">0</span>)&#123;</span><br><span class="line">            String s = String.valueOf(K);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c: s.toCharArray())</span><br><span class="line">            result.add(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">            result.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>官方答案</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">addToArrayForm</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        <span class="keyword">int</span> cur = K;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = N;</span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span> || cur &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">                cur += A[i];</span><br><span class="line">            ans.add(cur % <span class="number">10</span>);</span><br><span class="line">            cur /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.reverse(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/">题目链接</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm--Partition-array-for-maximum-sum</title>
    <url>/Algorithm-partition-array-for-maximum-sum/</url>
    <content><![CDATA[<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a><strong>Dynamic Programming</strong></h1><h2 id="Partition-Array-for-Maximum-Sum"><a href="#Partition-Array-for-Maximum-Sum" class="headerlink" title="Partition Array for Maximum Sum"></a><strong>Partition Array for Maximum Sum</strong></h2><p><strong>Title Detail</strong></p>
<blockquote>
<p>Given an integer array A, you partition the array into (contiguous) subarrays of length at most K.  After partitioning, each subarray has their values changed to become the maximum value of that subarray.</p>
<p>Return the largest sum of the given array after partitioning.</p>
<p><strong>Example 1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: A = [<span class="number">1</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>], K = <span class="number">3</span></span><br><span class="line">Output: <span class="number">84</span></span><br><span class="line">Explanation: A becomes [<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= K &lt;= A.length &lt;= <span class="number">500</span></span><br><span class="line"><span class="number">0</span> &lt;= A[i] &lt;= <span class="number">10</span>^<span class="number">6</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><a href="https://zh.wikipedia.org/zh-hans/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a> 问题。</p>
<ol>
<li><p>用一个长度为<code>A.length</code>的数组<code>dp</code>维护最终的加和结果。</p>
</li>
<li><p>计算思想如下：</p>
<p> dp[i] := max sum of A[0] ~ A[i]</p>
<p> dp[i] = max{dp[i – k] + max(A[i+1-k:i]) * k}, 1 &lt;= k &lt;= min(i, K)</p>
</li>
<li><p>最终返回结果</p>
<p> dp[A.length-1]</p>
</li>
</ol>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> max_num = A[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=K &amp;&amp; i+<span class="number">1</span>-k&gt;=<span class="number">0</span>; ++k)&#123;</span><br><span class="line">                max_num = Math.max(max_num, A[i+<span class="number">1</span>-k]);</span><br><span class="line">                dp[i] = Math.max(dp[i], (i-k&gt;=<span class="number">0</span>?dp[i-k]:<span class="number">0</span>) + k*max_num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/partition-array-for-maximum-sum/">题目链接</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm：删除最外层的括号</title>
    <url>/Algorithm-%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="删除最外层括号"><a href="#删除最外层括号" class="headerlink" title="删除最外层括号"></a>删除最外层括号</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote>
<p>有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。</p>
<p>如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为<strong>原语（primitive）</strong>，其中 A 和 B 都是非空有效括号字符串。</p>
<p>给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。</p>
<p>对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。</p>
</blockquote>
<p><strong>示例1</strong></p>
<blockquote>
<p>输入：”(()())(())”<br>输出：”()()()”<br>解释：<br>输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，<br>删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。</p>
</blockquote>
<p><strong>示例2</strong></p>
<blockquote>
<p>输入：”(()())(())(()(()))”<br>输出：”()()()()(())”<br>解释：<br>输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，<br>删除每隔部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。</p>
</blockquote>
<p><strong>示例3</strong></p>
<blockquote>
<p>输入：”()()”<br>输出：””<br>解释：<br>输入字符串为 “()()”，原语化分解得到 “()” + “()”，<br>删除每个部分中的最外层括号后得到 “” + “” = “”。</p>
</blockquote>
<p><strong>提示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">S.length &lt;= <span class="number">10000</span></span><br><span class="line">S[i] 为 <span class="string">&quot;(&quot;</span> 或 <span class="string">&quot;)&quot;</span></span><br><span class="line">S 是一个有效括号字符串</span><br></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用一个数组模拟栈，发现 “(“ 使其进栈，发现 “)” 时使 “(“ 出栈。</p>
<p><strong>注意:</strong> 栈底的 “(“ 出栈不输出，当输出字符串中 “(“ 和 “)” 数量不相等时，才输出 “)” 。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeOuterParentheses</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// list作为栈，记录(数量</span></span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        StringBuilder bf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>; <span class="comment">// 记录输出的 ( 数量</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>; <span class="comment">//记录输出的 ) 数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;S.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = S.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>) list.add(c);</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(list.size()==<span class="number">1</span>&amp;&amp;left==right) list.remove(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(list.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(list.size()!=<span class="number">1</span>)&#123;</span><br><span class="line">                        bf.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">                        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">                        ++left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(left!=right)&#123;</span><br><span class="line">                    bf.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">                    ++right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bf.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更Niubility的code："><a href="#更Niubility的code：" class="headerlink" title="更Niubility的code："></a>更<strong>Niubility</strong>的code：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeOuterParentheses</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        StringBuilder bf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: S.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                ++flag;</span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                --flag;</span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bf.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bf.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序 | 选择排序 | 冒泡排序</title>
    <url>/Algorithm-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>每次选择最小的元素放在第一个位置，再选第二小元素放到第二个位置… 以此类推，排序完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] A = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        System.arraycopy(nums, <span class="number">0</span>, A, <span class="number">0</span>, len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[min]&gt;A[j])&#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(A, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>每次将最大的(或最小的)沉入数组最底层。<br><img src="/Algorithm-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bubble.gif" class></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] A = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        System.arraycopy(arr,<span class="number">0</span>, A, <span class="number">0</span>, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[j]&gt;A[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">// 无需中介的数值互换方法</span></span><br><span class="line">                    A[j] += A[j+<span class="number">1</span>];</span><br><span class="line">                    A[j+<span class="number">1</span>] = A[j] - A[j+<span class="number">1</span>];</span><br><span class="line">                    A[j] -= A[j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转自<a href="https://zhuanlan.zhihu.com/p/52884590">知乎</a>(插入、冒泡图片来源，侵删)</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>每次找出一个基准，作为划分标准。方法<strong>类似于二分法，每次都把小于基准的数放于基准数组的左边，把大于基准的数放于数组的右边</strong>。</p>
<p>算法不稳定，<strong>时间复杂度</strong>最好$O(nlog(n))$，最差$O(n^2)$</p>
<img src="/Algorithm-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/qucikSort.gif" class>
<p>当数组本来是排序好的，例如是顺序排列，此时要计算逆序排列，如果利用快排方法，则时间复杂度为$O(n^2)$，当然，此时的基准选取是头部或者尾部。</p>
<p>所以<strong>基准的选取</strong>很重要，常见得有随机选取、取首或末端的数及三数中值法（取首末及中间位置三个数的中值）。</p>
<p>理论上，选取的基准是<strong>所有数的中位数</strong>，则划分最均匀，用时最短。</p>
<h2 id="选取末尾值作为基准"><a href="#选取末尾值作为基准" class="headerlink" title="选取末尾值作为基准"></a>选取末尾值作为基准</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[]arr)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="comment">// 在新数组上进行排序而不影响原始数组</span></span><br><span class="line">        <span class="keyword">int</span>[]A = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, A, <span class="number">0</span>, len);</span><br><span class="line">        quickSort(A, <span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[]A, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 获取基准值</span></span><br><span class="line">        <span class="keyword">int</span> pivot = partition(A, left, right);</span><br><span class="line">        quickSort(A, left, pivot-<span class="number">1</span>);</span><br><span class="line">        quickSort(A, pivot+<span class="number">1</span>, right);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[]A, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 以末端的数字为基准</span></span><br><span class="line">        <span class="keyword">int</span> criterion = A[right];</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="comment">// 必须左边的哨兵先走，否则交换数值会出错</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; A[i]&lt;=criterion)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; A[j]&gt;=criterion)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = A[i];</span><br><span class="line">                A[i] = A[j];</span><br><span class="line">                A[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        A[right] = A[i];</span><br><span class="line">        A[i] = criterion;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化的快速排序"><a href="#优化的快速排序" class="headerlink" title="优化的快速排序"></a>优化的快速排序</h2><p>采用<strong>三值法作为划分基准，并在数据量不大时采用插入排序，提高效率。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold = <span class="number">4</span>;</span><br><span class="line">    QuickSort()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    QuickSort(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.threshold = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[]arr)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="comment">// 在新数组上进行排序而不影响原始数组</span></span><br><span class="line">        <span class="keyword">int</span>[]A = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, A, <span class="number">0</span>, len);</span><br><span class="line">        quickSort(A, <span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[]A, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 小数据情况下递归方法需要调用栈，效率较低，此时采用插入排序方法</span></span><br><span class="line">        <span class="keyword">if</span>(right-left&gt;<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="comment">// 获取基准值</span></span><br><span class="line">            <span class="keyword">int</span> pivot = partition(A, left, right);</span><br><span class="line">            quickSort(A, left, pivot-<span class="number">1</span>);</span><br><span class="line">            quickSort(A, pivot+<span class="number">1</span>, right);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            insertionSort(A);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[]A, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 以末端的数字为基准</span></span><br><span class="line">        <span class="keyword">int</span> criterion = getMedianPivot(A, left, right);</span><br><span class="line">        <span class="comment">// 从第二个及倒数第二个开始，因为getMedianPivot已经对首末数值进行了排序</span></span><br><span class="line">        <span class="keyword">int</span> i = left+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = right-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="comment">// 必须左边的哨兵先走，否则交换数值会出错</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; A[i]&lt;=criterion)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; A[j]&gt;=criterion)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = A[i];</span><br><span class="line">                A[i] = A[j];</span><br><span class="line">                A[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        A[right-<span class="number">1</span>] = A[i];</span><br><span class="line">        A[i] = criterion;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMedianPivot</span><span class="params">(<span class="keyword">int</span>[]A, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> center = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 对于首末及中间的数进行排序</span></span><br><span class="line">        <span class="keyword">if</span> (A[left] &gt; A[center]) &#123;</span><br><span class="line">            swap(A, left, center);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A[center] &gt; A[right]) &#123;</span><br><span class="line">            swap(A, center, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A[left] &lt; A[right]) &#123;</span><br><span class="line">            swap(A, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换中间与倒数第二个数，因为经过排序，最后一个已经是最大</span></span><br><span class="line">        swap(A, center, right-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> A[right-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = A[i];</span><br><span class="line">        A[i] = A[j];</span><br><span class="line">        A[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = A[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; A[j] &lt; A[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">                A[j] = A[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            A[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>学习资料:</strong></p>
<ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/52884590">LeetCode 知乎回答排序算法</a>      </p>
</li>
<li><p><a href="https://blog.csdn.net/shujuelin/article/details/82423852">快速排序—CSDN讲解</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/IAZnN00i65Ad3BicZy5kzQ">十大排序算法讲解推荐—微信公众号</a>(快排图片来源，侵删)</p>
</li>
<li><p><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F">排序算法—CyC2018大神博客</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序 | 插入排序 | 希尔排序</title>
    <url>/Algorithm%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>每次遍历都将对应位置的数字插入到合适的位置，当前位置之前的数据保持排序。<br></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] A = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, A, <span class="number">0</span>, len);</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = A[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; A[j - <span class="number">1</span>] &gt; temp; j--) &#123;</span><br><span class="line">                A[j] = A[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            A[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>是插入排序的变种，通过根据步长对原数组切分，加大了视野范围。</p>
<p>步长一直到1，此时交换的数量少，运行时间少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] A = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        System.arraycopy(nums,<span class="number">0</span>,A,<span class="number">0</span>,len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> step = len/<span class="number">2</span>; step &gt; <span class="number">0</span>; step/=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=step; i&lt;len; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = A[i];</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">for</span>(j=i; j&gt;=step &amp;&amp; A[j-step] &gt; tmp; j-=step)</span><br><span class="line">                    A[j] = A[j-step];</span><br><span class="line">                A[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>分而治之的思想。</p>
<center><img src="/Algorithm%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/mergeSort.jpg" class></center>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] A = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        System.arraycopy(nums, <span class="number">0</span>, A, <span class="number">0</span>, len);</span><br><span class="line">        mergeSort(A, <span class="number">0</span>, A.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=j)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = i + (j-i)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(nums,i, m);</span><br><span class="line">        mergeSort(nums, m+<span class="number">1</span>, j);</span><br><span class="line">        <span class="comment">// m位置属于左数组</span></span><br><span class="line">        merge(nums, i, m, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] leftArr = <span class="keyword">new</span> <span class="keyword">int</span>[m-i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] rightArr = <span class="keyword">new</span> <span class="keyword">int</span>[j-m];</span><br><span class="line">        <span class="comment">// 辅助数组填充</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=i; l&lt;=m; l++)&#123;</span><br><span class="line">            leftArr[l-i] = nums[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=m+<span class="number">1</span>; r&lt;=j; r++)&#123;</span><br><span class="line">            rightArr[r-m-<span class="number">1</span>] = nums[r];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, k=i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l&lt;leftArr.length &amp;&amp; r&lt;rightArr.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftArr[l]&lt;rightArr[r])&#123;</span><br><span class="line">                nums[k++]=leftArr[l++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[k++] = rightArr[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l&lt;leftArr.length)</span><br><span class="line">            nums[k++] = leftArr[l++];</span><br><span class="line">        <span class="keyword">while</span> (r&lt;rightArr.length)</span><br><span class="line">            nums[k++] = rightArr[r++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 知识要点</title>
    <url>/CSS-%E7%9F%A5%E8%AF%86%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<h1 id="选择元素"><a href="#选择元素" class="headerlink" title="选择元素"></a>选择元素</h1><ol>
<li>基本元素选择</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 把段落文本设置成红色，12像素大，粗体 */</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:red; <span class="attribute">font-size</span>:<span class="number">12px</span>; <span class="attribute">font-weight</span>:bold;&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>上下文选择</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选择祖先元素为 article 标签的所有段落 p 后代 */</span></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:red; <span class="attribute">font-size</span>:<span class="number">12px</span>; <span class="attribute">font-weight</span>:bold;&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>特殊上下文选择</li>
</ol>
<p><strong>子选择符</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将 section 的 h2 子元素的字体设置为 italic */</span></span><br><span class="line"><span class="selector-tag">section</span> &gt; <span class="selector-tag">h2</span> &#123;<span class="attribute">font-style</span>:italic;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>紧邻同胞选择</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将紧邻着 h2 的元素同胞 p 选择设置 */</span></span><br><span class="line"><span class="selector-tag">h2</span> + <span class="selector-tag">p</span> &#123;<span class="attribute">font-style</span>:italic;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>一般同胞选择</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将 h2 与 p 之间的同胞全部选择 */</span></span><br><span class="line"><span class="selector-tag">h2</span> ~ <span class="selector-tag">p</span> &#123;<span class="attribute">font-style</span>:italic;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>通用选择</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 全文所有字体颜色（包括文本框）设置为黑色 */</span></span><br><span class="line">* &#123;<span class="attribute">color</span>: black&#125;</span><br><span class="line"><span class="comment">/* 只把 p 元素中所有元素文本设置为红色 */</span></span><br><span class="line"><span class="selector-tag">p</span> *&#123;<span class="attribute">color</span>: red&#125;</span><br></pre></td></tr></table></figure>
<p><strong>类选择</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 把属于 specialtext 类的元素设置字体类型 */</span></span><br><span class="line"><span class="selector-class">.specialtext</span> &#123;<span class="attribute">font-style</span>:italic;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>标签带类选择</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 把 p元素中属于 specialtext 类的元素设置字体类型 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.specialtext</span> &#123;<span class="attribute">font-style</span>:italic;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ID选择</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*把 ID 为 mainmenu 元素中的 a 元素的字体颜色修改*/</span></span><br><span class="line"><span class="selector-id">#mainmenu</span> <span class="selector-tag">a</span> &#123;<span class="attribute">color</span>:orange;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>属性名选择</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*将带有 title 属性的 HTML img 元素显示 2 像素宽的蓝色边框*/</span></span><br><span class="line"><span class="selector-tag">img</span><span class="selector-attr">[title]</span> &#123;&#123;<span class="attribute">border</span>:<span class="number">2px</span> solid blue;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>伪类选择</strong></p>
<p>伪类就是当 HTML 元素在某种状态时触发显示相应的 CSS 样式，伪类的用法是 元素名:状态 {属性名: 值}</p>
<p>例如：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>:black;&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要的伪类状态有以下几种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">状态名</th>
<th style="text-align:center">描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">link</td>
<td style="text-align:center">链接初始状态</td>
</tr>
<tr>
<td style="text-align:center">visited</td>
<td style="text-align:center">链接被点击过状态</td>
</tr>
<tr>
<td style="text-align:center">hover</td>
<td style="text-align:center">鼠标悬浮上去状态</td>
</tr>
<tr>
<td style="text-align:center">active</td>
<td style="text-align:center">鼠标正在被点击的状态</td>
</tr>
<tr>
<td style="text-align:center">focus</td>
<td style="text-align:center">表单获取焦点时状态</td>
</tr>
<tr>
<td style="text-align:center">target</td>
<td style="text-align:center">对于设置为目标的元素被选择时的状态</td>
</tr>
<tr>
<td style="text-align:center">first-child</td>
<td style="text-align:center">一组同胞元素的第一个元素</td>
</tr>
<tr>
<td style="text-align:center">last-child</td>
<td style="text-align:center">一组同胞元素中最后一个元素</td>
</tr>
<tr>
<td style="text-align:center">nth-child</td>
<td style="text-align:center">一组同胞元素中第 n 个元素</td>
</tr>
</tbody>
</table>
</div>
<p><strong>伪元素选择</strong></p>
<p>两个冒号后面加伪元素状态，常用的有 ::first-letter (首字母状态)、::first-line (首行状态)、::before与::after (特定元素前后添加特殊内容)。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;age&quot;</span>&gt;</span>25<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.age</span><span class="selector-pseudo">::before</span> &#123;<span class="attribute">content</span>:<span class="string">&quot;Age: &quot;</span>;&#125; </span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.age</span><span class="selector-pseudo">::after</span> &#123;<span class="attribute">content</span>:<span class="string">&quot; years.&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 显示如下：Age: 25 years.*/</span></span><br></pre></td></tr></table></figure>
<h1 id="CSS样式叠加顺序"><a href="#CSS样式叠加顺序" class="headerlink" title="CSS样式叠加顺序"></a>CSS样式叠加顺序</h1><p>CSS 样式叠加遵循以下四个规则：</p>
<p><strong>1. 首先找到各元素所有的 CSS 声明。</strong></p>
<p><strong>2. 按照以下顺序层叠显示，越靠后的 CSS 定义方式显示级别越高。</strong></p>
<ul>
<li>浏览器默认样式</li>
<li>用户自定义样式</li>
<li>链接样式 （<code>&lt;link href=&quot;style.css&quot; rel=stylesheet type=&quot;text/css&quot; /&gt;</code>）</li>
<li>嵌入样式 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其他 head 元素（如 meta、title）放在这里 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span> </span><br><span class="line"><span class="css">        <span class="selector-tag">h1</span> &#123;<span class="attribute">font-size</span>:<span class="number">16px</span>;&#125; </span></span><br><span class="line"><span class="css">        <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue;&#125;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>行内样式</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 12px; font-weight:bold; font-style:italic; color:red;&quot;</span>&gt;</span></span><br><span class="line">By adding inline CSS styling to this paragraph, you override the default styles.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果 css 里面的权重定义是 <strong>!important</strong>，则不考虑 CSS样式的优先级规则，优先使用。</p>
<p><strong>3. 按照特指度确定显示优先级</strong></p>
<p>特指度指的是说明元素信息的详细程度，例如 元素 p 的特指度就要低于某一 css 类的特指度。</p>
<p>计算规则：I-C-E</p>
<p>I-C-E 表示 ID、Class、Element三个维度的得分三位数，初始为 0-0-0。</p>
<p>如果样式里指明一个 ID，I 代表的数字 +1。</p>
<p>如果样式里指明一个 类 class，C 代表的数字 +1。</p>
<p>如果样式里指明一个 元素 Element，E代表的数字 +1。</p>
<p>例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">p                              0-0-1 特指度=1 </span><br><span class="line">p.largetext                    0-1-1 特指度=11 </span><br><span class="line">p#largetext                    1-0-1 特指度=101</span><br><span class="line">body p#largetext               1-0-2 特指度=102</span><br><span class="line">body p#largetext ul.mylist     1-1-3 特指度=113        </span><br><span class="line">body p#largetext ul.mylist li  1-1-4 特指度=114</span><br></pre></td></tr></table></figure>
<p><strong>4. 特指度相同的情况下按照叠加顺序</strong></p>
<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p>令人困惑的盒子属性。</p>
<p>每个元素就是一个盒子，其有对应的形状，对应的属性有三组：<strong>边框（border）、内边距（padding）及外边距 （margin）。</strong></p>
<center></center>

<p><strong>1. 垂直方向的外边距取最大值。</strong></p>
<p>如果有两个段落 p，其CSS样式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">height</span>:<span class="number">50px</span>; <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#000</span>; backgroundcolor:<span class="number">#fff</span>; <span class="attribute">margin-top</span>:<span class="number">50px</span>; <span class="attribute">margin-bottom</span>:<span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>那么它们之间的距离为 <strong>50px，</strong>而不是 50px + 30px= 80px。</p>
<p><strong>2. 水平方向外边距叠加。</strong></p>
<p><strong>3. 盒子的大小视 width 属性而定。</strong></p>
<ul>
<li>在 width 没有指定情况下，元素的宽度与父元素一致。</li>
</ul>
<p>此时设置盒子的 <strong>border</strong> 及 <strong>padding</strong> 会向内拓展，不改变盒子大小。</p>
<p>设置 <strong>margin</strong> 会使元素宽度相对父元素的宽度减去两倍的外边距。</p>
<ul>
<li>在指定了 width 宽度大小情况下，元素宽度会拓展。</li>
</ul>
<p>此时设置盒子的 <strong>border</strong> 及 <strong>padding</strong> 会向外拓展，使盒子变大。</p>
<ul>
<li>添加 <strong>box-sizing:border-box</strong> 属性，使盒子在指定宽度 width 同时，也能像未指定一样工作。</li>
</ul>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Algortthm--Jewels and Stones</title>
    <url>/Algortthm-Jewels-and-Stones/</url>
    <content><![CDATA[<h1 id="Map的应用"><a href="#Map的应用" class="headerlink" title="Map的应用"></a><strong>Map的应用</strong></h1><h2 id="Jewels-and-Stones"><a href="#Jewels-and-Stones" class="headerlink" title="Jewels and Stones"></a><strong>Jewels and Stones</strong></h2><p><strong>Title Detail</strong></p>
<blockquote>
<p>You’re given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.</p>
<p>The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.</p>
<p><strong>Example 1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: J = <span class="string">&quot;aA&quot;</span>, S = <span class="string">&quot;aAAbbbb&quot;</span></span><br><span class="line">Output: <span class="number">3</span></span><br></pre></td></tr></table></figure><br><strong>Example 2:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: J = <span class="string">&quot;z&quot;</span>, S = <span class="string">&quot;ZZ&quot;</span></span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure><br><strong>Note:</strong></p>
<p>S and J will consist of letters and have length at most 50.<br>The characters in J are distinct.</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用Java里面的 <strong><code>Map</code></strong>。key键保存宝石类型，value键保存数量统计。</p>
<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;J.length(); i++)&#123;</span><br><span class="line">            map.put(J.charAt(i), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;S.length();i++)&#123;</span><br><span class="line">            Character c = S.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map.get(c)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                Integer freq =map.get(c);</span><br><span class="line">                map.put(c, freq+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer value: map.values())&#123;</span><br><span class="line">            result += value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="法2-正则表达式"><a href="#法2-正则表达式" class="headerlink" title="法2 正则表达式"></a><strong>法2 正则表达式</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String  a = <span class="string">&quot;[^&quot;</span>+J+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">        S = S.replaceAll(a, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> S.length();</span><br></pre></td></tr></table></figure>
<h3 id="Python方法"><a href="#Python方法" class="headerlink" title="Python方法"></a><strong>Python方法</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>(S.count(i) <span class="keyword">for</span> i <span class="keyword">in</span> J)</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/jewels-and-stones/">题目链接</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 布局知识</title>
    <url>/CSS-%E5%B8%83%E5%B1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="CSS实现垂直水平居中"><a href="#CSS实现垂直水平居中" class="headerlink" title="CSS实现垂直水平居中"></a>CSS实现垂直水平居中</h1><p>对于父元素 parent 与 子元素 child，如何实现子元素在父元素内部的水平垂直居中？</p>
<p>元素的 html 代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        .parent&#123;</span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: aquamarine;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .child&#123;</span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: coral;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    .parent&#123;</span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: aquamarine;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">        <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">        <span class="attribute">justify-content</span>: center;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .child&#123;</span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: coral;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="行内元素居中"><a href="#行内元素居中" class="headerlink" title="行内元素居中"></a>行内元素居中</h2><p><strong>text-algin</strong> 与 <strong>vertical-algin</strong> 只对行内元素起作用，可以实现行内元素的的垂直于水平居中，此时可以利用 <strong>display: inline-block</strong> 使子元素具有行内元素的属性，实现子元素垂直水平居中 (需设置 line-height 使垂直居中有对齐的基准)。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-class">.parent</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: aquamarine;</span><br><span class="line">        vertical-algin: middle;</span><br><span class="line">        text-algin: center;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">300px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.child</span>&#123;</span><br><span class="line">        <span class="attribute">display</span>: inline-block;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: coral;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h2 id="绝对定位-元素自身移动"><a href="#绝对定位-元素自身移动" class="headerlink" title="绝对定位 + 元素自身移动"></a>绝对定位 + 元素自身移动</h2><p>通过 left: 50% 以及 top: 50% 只使得子元素的左上角位于父元素的中心，此时需要通过 <strong>transform: translate(-50%, -50%)</strong> 移动子元素。translate(x,y) 括号的百分比数据，会以本身的长宽做参考，比如，本身的长为100px，高为100px. 那填(50%,50%)就是向右，向下移动50px，添加负号就是向着相反的方向移动50%</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-class">.parent</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: aquamarine;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.child</span>&#123;</span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: coral;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-class">.parent</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: aquamarine;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.child</span>&#123;</span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: coral;</span><br><span class="line">        <span class="attribute">margin</span>: -<span class="number">100px</span> -<span class="number">100px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h2 id="利用-margin"><a href="#利用-margin" class="headerlink" title="利用 margin"></a>利用 margin</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-class">.parent</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: aquamarine;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.child</span>&#123;</span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: coral;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">margin</span>: auto;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h1 id="CSS实现三栏布局"><a href="#CSS实现三栏布局" class="headerlink" title="CSS实现三栏布局"></a>CSS实现三栏布局</h1><p>所谓的三栏布局，既是指左右两栏固定宽度，中间一栏宽度自适应的布局方式。下面列出五种实现三栏布局的方式，分别是绝对定位、float方式、flex布局、圣杯布局、双飞翼布局。</p>
<center> <img src="/CSS-%E5%B8%83%E5%B1%80%E7%9F%A5%E8%AF%86/three.jpg" class> </center>

<h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><p>利用绝对定位将左右两栏确定位置，中间一栏通过 margin 属性调整位置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        *&#123;</span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-tag">body</span>, <span class="selector-tag">html</span>, <span class="selector-class">.parent</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line"><span class="css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: coral;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .middle&#123;</span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: blueviolet;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line"><span class="css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: crimson;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="float布局"><a href="#float布局" class="headerlink" title="float布局"></a>float布局</h2><p>float定位实现三栏布局的思想是：利用float将左右两栏固定位置，并利用margin控制中间一栏的边距，从而使其宽度自适应。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        *&#123;</span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-tag">body</span>, <span class="selector-tag">html</span>, <span class="selector-class">.parent</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: coral;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: crimson;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .middle&#123;</span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: blueviolet;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>flex布局实现三栏布局的思想是：利用flex:0 0 200px固定左右两栏的位置，同时确保其不随浏览器的高度和宽度而放大缩小。 flex参数参照:<a href="https://www.w3cschool.cn/cssref/css3-pr-flex.html">https://www.w3cschool.cn/cssref/css3-pr-flex.html</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        *&#123;</span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-tag">body</span>, <span class="selector-tag">html</span>, <span class="selector-class">.parent</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .parent&#123;</span><br><span class="line"><span class="css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: coral;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: crimson;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .middle&#123;</span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: blueviolet;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p>圣杯布局的原理是通过左、中、右列同向浮动，中间列宽度设置为100%实现宽度自适应，左右两列宽度宽度固定并通过位置控制实现分列左右两端。该布局可以实现中间布局的优先渲染，因为DOM结构上 middle 元素位于 left 和 right 元素的上层。</p>
<p><strong>1. 首先父级元素设置内边距</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 各自设置浮动方式及页面宽度</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 左栏控制位置</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. 右栏控制位置</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. 设置左右两栏的最小宽度</strong></p>
<p>最小宽度并不是 200px + 200px = 400px，因为 left 元素采用了相对定位，其在 middle 元素上方还占有 200px 位置，所以页面的 min-width 参数为 400px + 200px = 600px。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>全部代码：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        *&#123;</span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-tag">body</span>, <span class="selector-tag">html</span>, <span class="selector-class">.parent</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">min-width</span>: <span class="number">600px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .parent&#123;</span><br><span class="line"><span class="css">            <span class="attribute">padding-left</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding-right</span>: <span class="number">200px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">            <span class="attribute">left</span>: -<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: coral;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-right</span>: -<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: crimson;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .middle&#123;</span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: blueviolet;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><p>双飞翼布局与圣杯布局的区别是：双飞翼布局的 parent 元素只包裹 middle 元素，left 元素与 right 元素通过控制与 parent的相对位置关系实现三栏布局。</p>
<p><strong>1. 首先用 parent 仅包裹 middle 元素</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 所有元素设置宽度与浮动</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span>&#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 设置左栏位置</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br></pre></td></tr></table></figure>
<p><strong>4. 设置右栏位置</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin-right</span>: -<span class="number">200px</span>;</span><br></pre></td></tr></table></figure>
<p><strong>5. 完整代码</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        *&#123;</span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-tag">body</span>, <span class="selector-tag">html</span>, <span class="selector-class">.parent</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">min-width</span>: <span class="number">600px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .parent&#123;</span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: blueviolet;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: coral;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: crimson;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .middle&#123;</span><br><span class="line"><span class="css">            <span class="attribute">padding-left</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding-right</span>: <span class="number">200px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Class文件长什么样</title>
    <url>/Class%E6%96%87%E4%BB%B6%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><font color="#f07c82">Class</font>文件是Java语言实现跨平台的原材料，<font color="#f07c82">JVM(Java Vritual Machine)</font>是实现跨平台的机器。

机器 + 原材料 = 跨平台。

不同的平台有自己的JVM，但是Class文件是一样的。

Class文件由java文件编译产生。

<font color="#f07c82">Class文件是由8位字节构成的二进制流，用类似于C语言结构体的伪结构来存储数据。</font>

<p>Class文件由<font color="#f07c82">无符号数和表</font>组成。</p>
<p><strong>无符号数</strong>用<font color="#f07c82">u1 u2 u4 u8</font>来表示1 2 4 8个字节的无符号数。它用来表示数量值、数值、索引引用、按照UTF-8编码的字符串。</p>
<p><strong>表</strong>是一种特殊的数据结构，它由表及无符号数组成，习惯表以<font color="#f07c82">_info</font>结尾。</p>
<p><strong>Class文件就是一张表，用来描述唯一确定的类或接口。</strong></p>
<p>下面是从《深入了解JVM》中摘的Class文件的表结构。</p>
<img src="/Class%E6%96%87%E4%BB%B6%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7/Class_info.PNG" class>
<p><strong><center>图1 Class表结构</center></strong></p>
<h1 id="进入Class这张表"><a href="#进入Class这张表" class="headerlink" title="进入Class这张表"></a>进入Class这张表</h1><p>首先我们写一个简单的类，叫做<font color="#f07c82">HelloClass</font>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后编译生成 <font color="#f07c82">HelloClass.class</font>文件，我们用文本编辑器打开它，如下：</p>
<center><img src="/Class%E6%96%87%E4%BB%B6%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7/class2.png" class></center>

<p><strong><center>图2 编译后的class文件</center></strong></p>
<h2 id="最复杂的结构，常量池"><a href="#最复杂的结构，常量池" class="headerlink" title="最复杂的结构，常量池"></a>最复杂的结构，常量池</h2><p>由于Class本身就是一张表，而<font color="#f07c82">常量池</font>是嵌套在Class中的表，其结构最复杂。</p>
<p>常量池用来存储<strong>类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。</strong></p>
<p>如<strong>图2</strong>所示，前四个字节的无符号数 <font color="#f07c82">u4</font>表示 Magic Number，是用来区分文件格式的，这样比文件名后缀更安全。</p>
<p><strong><font color="#f07c82">CAFE BABE</font></strong>是Java的Class文件的魔数，很魔性。</p>
<p>接着的<font color="#f07c82">u4</font>是版本号，即<strong>图1</strong>中的 <strong>00 00 00 34</strong>。</p>
<p>然后就是常量池了，先看常量池的项目类型：</p>
<center><img src="/Class%E6%96%87%E4%BB%B6%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7/fig1.PNG" class></center>
<center><img src="/Class%E6%96%87%E4%BB%B6%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7/fig.2.PNG" class></center>

<p><strong><center>图3 常量池的项目类型</center></strong></p>
<p>每个项目类型的第一位都是项目标志，唯一标识该类型。</p>
<p>常量池开始是容量说明，<font color="#f07c82">u2</font>类型，及 <strong>00 16</strong>，表示容量为 16+6=22-1=21，因为常量池容量计算是从1开始，0表示为空。</p>
<p>之后一个<font color="#f07c82">u1</font>类型是常量类型标志符，为 <strong>0A</strong>，为 10。查找<strong>图2</strong>表示该常量为 <strong>CONSTANT_Methodref_info</strong>，由两个<font color="#f07c82">u2</font>无符号类型组成，第一个指向 <strong>00 04</strong> 即第4个常量，为 <strong>CONSTANT_Class_info</strong> 类型；第二个指向 <strong>00 12</strong> 即第 16+2=18 个常量， 为 <strong>CONSTANT_NameAndType</strong> 类型。</p>
<p>依次类推，直到翻译完常量池。</p>
<p>我们可以通过<strong>javap</strong>工具的 <strong>-verbose</strong> 输出字节码内容，如下：</p>
<center><img src="/Class%E6%96%87%E4%BB%B6%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7/javap.png" class></center>

<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p><strong>访问标志(access_flags)</strong>用于识别类和接口的访问信息，诸如是否是public及抽象类等。</p>
<p>常量池后面是访问标志。</p>
<center><img src="/Class%E6%96%87%E4%BB%B6%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7/access_flags.png" class></center>

<p>不同访问标志求 <font color="#f07c82">|</font> 运算得到。</p>
<h2 id="类索引、父类索引、接口索引"><a href="#类索引、父类索引、接口索引" class="headerlink" title="类索引、父类索引、接口索引"></a>类索引、父类索引、接口索引</h2><p>分别是一个 <strong>u2、u2</strong>和一组<strong>u2</strong>，因为java单继承，可实现多个接口。</p>
<p>各自指向一个 <strong>CONSTANT_Class_info</strong> 的类描述常量。</p>
<h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p><strong><font color="#f07c82">字段表(field_info)</font>用来描述接口或类中声明的变量，字段包括类级别变量以及实例级别变量。</strong>但不包括方法内部声明的局部变量。</p>
<p>字段需要用<strong>访问标志描述</strong>，<font color="#f07c82">包括作用域(public、protected、default、private)、实例变量还是类变量(static)、是否为final、并发可见性(volatile)、是否可序列化(transient)、类型(基本类型、对象及数组)以及字段名称。</font></p>
<center><img src="/Class%E6%96%87%E4%BB%B6%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7/ziduan.PNG" class></center>

<p>字段表的结果除了访问标志描述，还有字段的简单名称 <strong>name_index</strong> 及方法的描述符 <strong>discriptor_index</strong>、属性表统计 <strong>attributes_count</strong> 及属性表 <strong>attributes</strong>。</p>
<center><img src="/Class%E6%96%87%E4%BB%B6%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7/attributes.png" class></center>

<p>字段的简单名称及方法描述符都是对常量池引用。</p>
<p><strong>描述符是用来描述字段与方法的类型与返回参数的。</strong></p>
<p><strong><font color="#f07c82">由于这类信息不能跟访问标志描述一样，可以用固定长度来表示，所以需要在常量池中表示后然后引用。</font></strong></p>
<p>基本数据类型用相应大写字母表示，对象类型用大写字母 <strong>L</strong>加对象全限定名表示。</p>
<center><img src="/Class%E6%96%87%E4%BB%B6%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7/L.PNG" class></center>

<p>其中数组类型用前面 <strong>[</strong>加类型表示，如 String[][],就表示为 <strong>[[Ljava/lang/String;</strong>。</p>
<p><strong>描述方法时，先参数列表，后返回类型。</strong>如 int i(), 表示为 <strong>（）I</strong></p>
<h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>与字段表类似,只不过并发可见性(volatile)、是否可序列化(transient)不能修饰方法。</p>
<center><img src="/Class%E6%96%87%E4%BB%B6%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7/fangfa.PNG" class></center>

<p>方法中的代码描述，由编译器编译成字节指令后，存放在属性表<strong>attributes</strong> 的 <strong><font color="#f07c82">Code</font></strong>属性里。</p>
<h2 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h2><p><font color="#f07c82">属性表(attributes_info)</font>在Class文件、属性表与方法表内都有出现，用于描述场景特殊信息。</p>
<p>属性表其它数据项目严格要求的顺序、长度和内容，它<strong>不再要求各个属性有严格的顺序，且只要不与已有属性名重复，任何实现的编译器都可向属性表中写入自己定义的属性信息；</strong>Java虚拟机在运行时会忽略掉不认识的属性。</p>
<p>《Java虚拟机规范(Java SE 7)》中，预定义的属性为：</p>
<center><img src="/Class%E6%96%87%E4%BB%B6%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7/predefine1.PNG" class></center>
<center><img src="/Class%E6%96%87%E4%BB%B6%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7/predefine2.PNG" class></center>

<p>其中每个属性表首先根据 <font color="#f07c82">attributes_name_index</font> 去常量池引用 <font color="#f07c82">CONSTANT_Class_info</font> 类型的名称，然后用一个 <font color="#f07c82">u4</font> 长度的属性说明属性表占用的长度 <font color="#f07c82">attribute_length</font> 即可。属性表中描述的信息单位是 <font color="#f07c82">u1</font>，共<font color="#f07c82">attribute_length</font>个。</p>
<p>属性表的结构如下：</p>
<center><img src="/Class%E6%96%87%E4%BB%B6%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7/attributes_info.PNG" class></center>

<h3 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h3><p><strong>java程序方法体内的代码通过编译成字节码后，存在Code属性中。</strong></p>
<p>Code属性存储在<strong>方法表的属性表集合</strong>中。</p>
<p>Code属性是Class文件中<strong>最重要的</strong>属性，是对代码的描述。其它信息可以看做是对元数据（类型、字段、方法及其他信息）的描述。</p>
<p>Code的属性表如下：</p>
<center><img src="/Class%E6%96%87%E4%BB%B6%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7/code_info.PNG" class></center>

<p>各部分的含义如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">attributes_name_index</td>
<td style="text-align:center">指向 CONSTANT_Class_info 常量索引，表示该属性表名称</td>
</tr>
<tr>
<td style="text-align:center">u1</td>
<td style="text-align:center">attribute_length</td>
<td style="text-align:center">属性表长度。由于属性名称索引 u2 加长属性名长度 u4，所以属性表长度为整个属性表长度减去 <strong>6</strong> 字节。</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">max_stack</td>
<td style="text-align:center">栈的最大深度。<strong>Java虚拟机为该方法体分配栈针的操作栈深度</strong>。</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">max_locals</td>
<td style="text-align:center">局部变量的最大存储空间。<strong>方法参数、显示异常处理的参数及方法体中定义的局部变量都需用局部变量表表示。</strong>局部变量中统计单位是 <strong>Slot</strong>。小于32位(boolean、short、char、int、float、returnAddress)的变量用一个 Slot 表示，double与long两个64位的用两个Slot表示。</td>
</tr>
<tr>
<td style="text-align:center">u4</td>
<td style="text-align:center">code_length</td>
<td style="text-align:center">字节码长度。实际是 u2 长度，即16个字节， 65535条字节码，超过改长度虚拟机将拒绝编译。</td>
</tr>
<tr>
<td style="text-align:center">u1</td>
<td style="text-align:center">code</td>
<td style="text-align:center">一些类的字节码指令，用于描述编译后的方法体内方法。</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">exception_table_lenght</td>
<td style="text-align:center">显示异常处理表长度。</td>
</tr>
<tr>
<td style="text-align:center">excessption_info</td>
<td style="text-align:center">exception_table</td>
<td style="text-align:center">显示异常处理表</td>
</tr>
<tr>
<td style="text-align:center">u2</td>
<td style="text-align:center">attributes_count</td>
<td style="text-align:center">属性表数量</td>
</tr>
<tr>
<td style="text-align:center">attributes_info</td>
<td style="text-align:center">attributes</td>
<td style="text-align:center">属性表</td>
</tr>
</tbody>
</table>
</div>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://book.douban.com/subject/6522893/">深入理解java虚拟机</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>D3实现多对多关联关系弧线图</title>
    <url>/D3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E5%BC%A7%E7%BA%BF%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="多对多关联关系"><a href="#多对多关联关系" class="headerlink" title="多对多关联关系"></a>多对多关联关系</h1><p>基于D3实现的多对多关联关系：<a href="https://github.com/SUNYunZeng/ChordDependencyChart">github地址</a></p>
<p>各人员之间的互动关系、各公司上下游企业的关联关系、各地之间的交互关系等等，都是多对多关联关系的表达，他们之间可以通过矩阵图的形式来表达, 如下图所示 (用python的<a href="http://seaborn.pydata.org/generated/seaborn.heatmap.html0库实现的">heatmap</a>：</p>
<img src="/D3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E5%BC%A7%E7%BA%BF%E5%9B%BE/seaborn-heatmap.png" class>
<p>而利用 <a href="https://observablehq.com/@d3/gallery">D3</a>库函数可以实现更为酷炫的弧线,如下图所示：</p>

<ul>
<li><ol>
<li>要画多方关系图，首先需要确定绘制的数据，是一个 N * N 的矩阵。</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">    <span class="keyword">const</span> matrix = [</span><br><span class="line">        [<span class="number">1</span>, <span class="number">41</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">        [<span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li><ol>
<li>然后对 i 行 j 列对应的数据设计一个对象字典检索其对应的名字：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nameByIndex = &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">332</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="number">229</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="number">333</span>,</span><br><span class="line">        <span class="number">3</span>: <span class="number">343</span>,</span><br><span class="line">        <span class="number">4</span>: <span class="number">313</span>,</span><br><span class="line">        <span class="number">5</span>: <span class="number">357</span>,</span><br><span class="line">        <span class="number">6</span>: <span class="number">344</span>,</span><br><span class="line">        <span class="number">7</span>: <span class="number">318</span>,</span><br><span class="line">        <span class="number">8</span>: <span class="number">312</span>,</span><br><span class="line">        <span class="number">9</span>: <span class="number">329</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> indexByName = &#123;</span><br><span class="line">        <span class="number">332</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="number">229</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="number">333</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="number">343</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="number">313</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="number">357</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="number">344</span>: <span class="number">6</span>,</span><br><span class="line">        <span class="number">318</span>: <span class="number">7</span>,</span><br><span class="line">        <span class="number">312</span>: <span class="number">8</span>,</span><br><span class="line">        <span class="number">329</span>: <span class="number">9</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><ol>
<li>定义好 svg 图片的长和宽。</li>
</ol>
</li>
<li><ol>
<li>利用D3绘制svg，核心代码如下：</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.d3 || !<span class="built_in">this</span>.config || !<span class="built_in">this</span>.matrix || !<span class="built_in">this</span>.nameByIndex || !<span class="built_in">this</span>.indexByName) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">&#x27;initial error!&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> color = <span class="built_in">this</span>.d3.scaleOrdinal(<span class="built_in">this</span>.d3.schemeCategory10);</span><br><span class="line">        <span class="keyword">let</span> outerRadius = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.width, <span class="built_in">this</span>.height) * <span class="number">0.5</span>;</span><br><span class="line">        <span class="keyword">let</span> innerRadius = outerRadius - <span class="number">124</span>;</span><br><span class="line">        <span class="keyword">let</span> ribbon = <span class="built_in">this</span>.d3.ribbon().radius(innerRadius);</span><br><span class="line">        <span class="keyword">let</span> arc = <span class="built_in">this</span>.d3.arc().innerRadius(innerRadius).outerRadius(innerRadius + <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">let</span> chord = <span class="built_in">this</span>.d3.chord().padAngle(<span class="number">.04</span>).sortSubgroups(<span class="built_in">this</span>.d3.descending).sortChords(<span class="built_in">this</span>.d3</span><br><span class="line">            .descending);</span><br><span class="line">        <span class="keyword">let</span> svg = <span class="built_in">this</span>.d3.select(<span class="string">&quot;svg&quot;</span>).attr(<span class="string">&quot;viewBox&quot;</span>, [-<span class="built_in">this</span>.width / <span class="number">2</span>, -<span class="built_in">this</span>.height / <span class="number">2</span>, <span class="built_in">this</span>.width, <span class="built_in">this</span></span><br><span class="line">                .height</span><br><span class="line">            ])</span><br><span class="line">            .attr(<span class="string">&quot;font-size&quot;</span>, <span class="built_in">this</span>.font_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> chords = chord(<span class="built_in">this</span>.matrix);</span><br><span class="line">        <span class="keyword">const</span> group = svg.append(<span class="string">&quot;g&quot;</span>).selectAll(<span class="string">&quot;g&quot;</span>).data(chords.groups).join(<span class="string">&quot;g&quot;</span>);</span><br><span class="line"></span><br><span class="line">        group.append(<span class="string">&quot;path&quot;</span>).attr(<span class="string">&quot;fill&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> color(d.index)).attr(<span class="string">&quot;stroke&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> color(d.index)).attr(<span class="string">&quot;d&quot;</span>,</span><br><span class="line">            arc);</span><br><span class="line"></span><br><span class="line">        group.append(<span class="string">&quot;text&quot;</span>).each(<span class="function"><span class="params">d</span> =&gt;</span> &#123;</span><br><span class="line">                d.angle = (d.startAngle + d.endAngle) / <span class="number">2</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">            .attr(<span class="string">&quot;dy&quot;</span>, <span class="string">&quot;.35em&quot;</span>)</span><br><span class="line">            .attr(<span class="string">&quot;transform&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">            rotate(<span class="subst">$&#123;(d.angle * <span class="number">180</span> / <span class="built_in">Math</span>.PI - <span class="number">90</span>)&#125;</span>)</span></span><br><span class="line"><span class="string">            translate(<span class="subst">$&#123;innerRadius + <span class="number">26</span>&#125;</span>)</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;d.angle &gt; <span class="built_in">Math</span>.PI ? <span class="string">&quot;rotate(180)&quot;</span> : <span class="string">&quot;&quot;</span>&#125;</span>`</span>)</span><br><span class="line">            .attr(<span class="string">&quot;text-anchor&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> d.angle &gt; <span class="built_in">Math</span>.PI ? <span class="string">&quot;end&quot;</span> : <span class="literal">null</span>)</span><br><span class="line">            .text(<span class="function"><span class="params">d</span> =&gt;</span> <span class="built_in">this</span>.nameByIndex[d.index]);</span><br><span class="line"></span><br><span class="line">        svg.append(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">            .attr(<span class="string">&quot;fill-opacity&quot;</span>, <span class="number">0.67</span>)</span><br><span class="line">            .selectAll(<span class="string">&quot;path&quot;</span>)</span><br><span class="line">            .data(chords)</span><br><span class="line">            .join(<span class="string">&quot;path&quot;</span>)</span><br><span class="line">            .attr(<span class="string">&quot;stroke&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> <span class="built_in">this</span>.d3.rgb(color(d.source.index)).darker())</span><br><span class="line">            .attr(<span class="string">&quot;fill&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> color(d.source.index))</span><br><span class="line">            .attr(<span class="string">&quot;d&quot;</span>, ribbon);</span><br><span class="line">        <span class="built_in">this</span>.svg = svg;</span><br><span class="line">        <span class="keyword">return</span> svg;</span><br></pre></td></tr></table></figure>
<p>html代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://d3js.org/d3.v5.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;ChordDependencyChart.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">style</span>=<span class="string">&quot;width: 1000px; height:1000px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> matrix = [</span></span><br><span class="line">        [1, 41, 0, 0, 8, 4, 2, 0, 5, 5],</span><br><span class="line">        [6, 0, 1, 1, 1, 0, 4, 1, 0, 1],</span><br><span class="line">        [1, 12, 0, 0, 3, 0, 1, 0, 1, 3],</span><br><span class="line">        [0, 11, 3, 0, 4, 1, 1, 0, 0, 2],</span><br><span class="line">        [1, 1, 0, 0, 1, 0, 0, 2, 2, 0],</span><br><span class="line">        [4, 0, 4, 0, 0, 0, 0, 1, 0, 1],</span><br><span class="line">        [0, 6, 0, 0, 1, 1, 0, 0, 1, 0],</span><br><span class="line">        [1, 4, 2, 0, 0, 1, 0, 0, 0, 0],</span><br><span class="line">        [1, 0, 1, 0, 0, 2, 0, 0, 0, 0],</span><br><span class="line">        [0, 0, 0, 0, 0, 3, 0, 0, 1, 0],</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> nameByIndex = &#123;</span></span><br><span class="line">        0: 332,</span><br><span class="line">        1: 229,</span><br><span class="line">        2: 333,</span><br><span class="line">        3: 343,</span><br><span class="line">        4: 313,</span><br><span class="line">        5: 357,</span><br><span class="line">        6: 344,</span><br><span class="line">        7: 318,</span><br><span class="line">        8: 312,</span><br><span class="line">        9: 329</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> indexByName = &#123;</span></span><br><span class="line">        332: 0,</span><br><span class="line">        229: 1,</span><br><span class="line">        333: 2,</span><br><span class="line">        343: 3,</span><br><span class="line">        313: 4,</span><br><span class="line">        357: 5,</span><br><span class="line">        344: 6,</span><br><span class="line">        318: 7,</span><br><span class="line">        312: 8,</span><br><span class="line">        329: 9</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> config = &#123;</span></span><br><span class="line">        matrix: matrix,</span><br><span class="line">        nameByIndex: nameByIndex,</span><br><span class="line">        indexByName: indexByName,</span><br><span class="line">        width: 1000,</span><br><span class="line">        height: 1000</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> chart = <span class="keyword">new</span> Chart(d3, config);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> svg = chart.draw();</span></span><br><span class="line"><span class="javascript">    chart.saveAsPng(svg, name = <span class="string">&quot;local&quot;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>其中 d3 是 D3 库函数依赖，可以使用离线包或者在线引用的方式。</p>
</li>
<li><p><strong>ChordDependencyChart</strong>是我自定义的一个库函数，可以实现多对多关联关系弧线图绘制，并可以保存为 png 图片，效果如下：</p>
</li>
</ul>
<img src="/D3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E5%BC%A7%E7%BA%BF%E5%9B%BE/local10.png" class>
<p><a href="https://github.com/SUNYunZeng/ChordDependencyChart">github地址</a></p>
]]></content>
      <categories>
        <category>Web可视化</category>
      </categories>
      <tags>
        <tag>D3</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 常用命令</title>
    <url>/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h1><p>Git是世界上<font color="#f07c82">最先进的</font><strong>分布式</strong>版本控制系统。</p>
<p>当时是为了帮助管理 <strong>linux</strong> 内核开发而开发的一个开源码版本控制系统。</p>
<img src="/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/git_priciple.jpg" class>
<ul>
<li><p>Workspace：工作区</p>
</li>
<li><p>Index / Stage：暂存区</p>
</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
<p>Git 是分布式版本控制系统，每个人的电脑上都有完整的版本库。</p>
<h1 id="常用命令列表"><a href="#常用命令列表" class="headerlink" title="常用命令列表"></a>常用命令列表</h1><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:yeszao&#x2F;dofiler.git         # 配置远程git版本库</span><br><span class="line">$ git pull origin master                                          # 下载代码及快速合并 </span><br><span class="line">$ git add .                       # 跟踪所有改动过的文件</span><br><span class="line">$ git add &lt;file&gt;                  # 跟踪指定的文件</span><br><span class="line">$ git commit -m “commit message”  # 提交所有更新过的文件</span><br><span class="line">$ git push origin master                                          # 上传代码及快速合并</span><br><span class="line">$ git fetch origin                                                # 从远程库获取代码</span><br><span class="line"></span><br><span class="line">$ git branch                                                      # 显示所有分支</span><br><span class="line">$ git checkout master                                             # 切换到master分支</span><br><span class="line">$ git checkout -b dev                                             # 创建并切换到dev分支</span><br><span class="line">$ git commit -m &quot;first version&quot;                                   # 提交</span><br><span class="line"></span><br><span class="line">$ git status                                                      # 查看状态</span><br><span class="line">$ git log                                                         # 查看提交历史</span><br><span class="line"></span><br><span class="line">$ git config --global core.editor vim                             # 设置默认编辑器为vim（git默认用nano）</span><br><span class="line">$ git config core.ignorecase false                                # 设置大小写敏感</span><br><span class="line">$ git config --global user.name &quot;YOUR NAME&quot;                       # 设置用户名</span><br><span class="line">$ git config --global user.email &quot;YOUR EMAIL ADDRESS&quot;             # 设置邮箱</span><br></pre></td></tr></table></figure>
<h2 id="别名Alias"><a href="#别名Alias" class="headerlink" title="别名Alias"></a>别名Alias</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.br&#x3D;&quot;branch&quot;                 # 创建&#x2F;查看本地分支</span><br><span class="line">$ git config --global alias.co&#x3D;&quot;checkout&quot;               # 切换分支</span><br><span class="line">$ git config --global alias.cb&#x3D;&quot;checkout -b&quot;            # 创建并切换到新分支</span><br><span class="line">$ git config --global alias.cm&#x3D;&quot;commit -m&quot;              # 提交</span><br><span class="line">$ git config --global alias.st&#x3D;&quot;status&quot;                 # 查看状态</span><br><span class="line">$ git config --global alias.pullm&#x3D;&quot;pull origin master&quot;  # 拉取分支</span><br><span class="line">$ git config --global alias.pushm&#x3D;&quot;push origin master&quot;  # 提交分支</span><br><span class="line">$ git config --global alias.log&#x3D;&quot;git log --oneline --graph --decorate --color&#x3D;always&quot; # 单行、分颜色显示记录</span><br><span class="line">$ git config --global alias.logg&#x3D;&quot;git log --graph --all --format&#x3D;format:&#39;%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold white)— %an%C(reset)%C(bold yellow)%d%C(reset)&#39; --abbrev-commit --date&#x3D;relative&quot; # 复杂显示</span><br></pre></td></tr></table></figure>
<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone &lt;url&gt;                 # 克隆远程版本库</span><br><span class="line">$ git init                        # 初始化本地版本库</span><br></pre></td></tr></table></figure>
<h2 id="修改和提交"><a href="#修改和提交" class="headerlink" title="修改和提交"></a>修改和提交</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status                      # 查看状态</span><br><span class="line">$ git diff                        # 查看变更内容</span><br><span class="line">$ git add .                       # 跟踪所有改动过的文件</span><br><span class="line">$ git add &lt;file&gt;                  # 跟踪指定的文件</span><br><span class="line">$ git mv &lt;old&gt; &lt;new&gt;              # 文件改名</span><br><span class="line">$ git rm &lt;file&gt;                   # 删除文件</span><br><span class="line">$ git rm --cached &lt;file&gt;          # 停止跟踪文件但不删除</span><br><span class="line">$ git commit -m “commit message”  # 提交所有更新过的文件</span><br><span class="line">$ git commit --amend              # 修改最后一次提交</span><br></pre></td></tr></table></figure>
<h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log                         # 查看提交历史</span><br><span class="line">$ git log -p &lt;file&gt;               # 查看指定文件的提交历史</span><br><span class="line">$ git blame &lt;file&gt;                # 以列表方式查看指定文件的提交历史</span><br></pre></td></tr></table></figure>
<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD           # 撤消工作目录中所有未提交文件的修改内容</span><br><span class="line">$ git reset --hard &lt;version&gt;      # 撤销到某个特定版本</span><br><span class="line">$ git checkout HEAD &lt;file&gt;        # 撤消指定的未提交文件的修改内容</span><br><span class="line">$ git checkout -- &lt;file&gt;          # 同上一个命令</span><br><span class="line">$ git revert &lt;commit&gt;             # 撤消指定的提交</span><br></pre></td></tr></table></figure>
<h2 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch                      # 显示所有本地分支</span><br><span class="line">$ git checkout &lt;branch&#x2F;tag&gt;       # 切换到指定分支或标签</span><br><span class="line">$ git branch &lt;new-branch&gt;         # 创建新分支</span><br><span class="line">$ git branch -d &lt;branch&gt;          # 删除本地分支</span><br><span class="line">$ git tag                         # 列出所有本地标签</span><br><span class="line">$ git tag &lt;tagname&gt;               # 基于最新提交创建标签</span><br><span class="line">$ git tag -a &quot;v1.0&quot; -m &quot;一些说明&quot;  # -a指定标签名称，-m指定标签说明</span><br><span class="line">$ git tag -d &lt;tagname&gt;            # 删除标签</span><br><span class="line"></span><br><span class="line">$ git checkout dev                # 合并特定的commit到dev分支上</span><br><span class="line">$ git cherry-pick 62ecb3</span><br></pre></td></tr></table></figure>
<h2 id="合并与衍合"><a href="#合并与衍合" class="headerlink" title="合并与衍合"></a>合并与衍合</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git merge &lt;branch&gt;              # 合并指定分支到当前分支</span><br><span class="line">$ git merge --abort               # 取消当前合并，重建合并前状态</span><br><span class="line">$ git merge dev -Xtheirs          # 以合并dev分支到当前分支，有冲突则以dev分支为准</span><br><span class="line">$ git rebase &lt;branch&gt;             # 衍合指定分支到当前分支</span><br></pre></td></tr></table></figure>
<h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码</span><br><span class="line">$ git remote -v                   # 查看远程版本库信息</span><br><span class="line">$ git remote show &lt;remote&gt;        # 查看指定远程版本库信息</span><br><span class="line">$ git remote add &lt;remote&gt; &lt;url&gt;   # 添加远程版本库</span><br><span class="line">$ git remote remove &lt;remote&gt;      # 删除指定的远程版本库</span><br><span class="line">$ git fetch &lt;remote&gt;              # 从远程库获取代码</span><br><span class="line">$ git pull &lt;remote&gt; &lt;branch&gt;      # 下载代码及快速合并</span><br><span class="line">$ git push &lt;remote&gt; &lt;branch&gt;      # 上传代码及快速合并</span><br><span class="line">$ git push &lt;remote&gt; :&lt;branch&#x2F;tag-name&gt; # 删除远程分支或标签</span><br><span class="line">$ git push --tags                 # 上传所有标签</span><br></pre></td></tr></table></figure>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git archive --format&#x3D;zip --output ..&#x2F;file.zip master    # 将master分支打包成file.zip文件，保存在上一级目录</span><br><span class="line">$ git archive --format&#x3D;zip --output ..&#x2F;v1.2.zip v1.2      # 打包v1.2标签的文件，保存在上一级目录v1.2.zip文件中</span><br><span class="line">$ git archive --format&#x3D;zip v1.2 &gt; ..&#x2F;v1.2.zip             # 作用同上一条命令</span><br></pre></td></tr></table></figure>
<h2 id="远程与本地合并"><a href="#远程与本地合并" class="headerlink" title="远程与本地合并"></a>远程与本地合并</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init                              # 初始化本地代码仓</span><br><span class="line">$ git add .                             # 添加本地代码</span><br><span class="line">$ git commit -m &quot;add local source&quot;      # 提交本地代码</span><br><span class="line">$ git pull origin master                # 下载远程代码</span><br><span class="line">$ git merge master                      # 合并master分支</span><br><span class="line">$ git push -u origin master             # 上传代码</span><br></pre></td></tr></table></figure>
<p>参考资料：<u><a href="https://www.cnblogs.com/ldj3/p/9172804.html">https://www.cnblogs.com/ldj3/p/9172804.html</a></u><br>        <u><a href="https://www.zhihu.com/question/41667536/answer/486640083">https://www.zhihu.com/question/41667536/answer/486640083</a></u></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>JS实现图片的懒加载</title>
    <url>/JS%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="场景需求"><a href="#场景需求" class="headerlink" title="场景需求"></a>场景需求</h1><p>在长博客、商品网站上经常见到大量的图片，而同时加载如此多的图片会导致服务器响应慢、页面卡顿，用户体验不佳。</p>
<p>而<strong>图片懒加载</strong>就是应对这个痛点。图片懒加载技术就是根据图片在可视区域的位置对图片进行逐步加载，利用 DOM对象元素属性、分流等技术实现。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="步骤一-隐藏懒加载图片的-src-属性"><a href="#步骤一-隐藏懒加载图片的-src-属性" class="headerlink" title="步骤一   隐藏懒加载图片的 src 属性"></a>步骤一   隐藏懒加载图片的 src 属性</h2><p>我们首先需要确定懒加载的图片资源，对于 <font color="#f07c82">img</font> 标签，首先把<font color="#f07c82">src</font> 属性用自定义的属性如 <font color="#f07c82">data-src</font> 代替，等到图片需要加载时我们将  <font color="#f07c82">data-src</font> 的网址赋予 <font color="#f07c82">src</font> 属性即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&#x27;./dzq.jpg&#x27;</span> <span class="attr">alt</span>=<span class="string">&quot;dzq&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="步骤二-判断待加载图片是否位于视窗范围内"><a href="#步骤二-判断待加载图片是否位于视窗范围内" class="headerlink" title="步骤二   判断待加载图片是否位于视窗范围内"></a>步骤二   判断待加载图片是否位于视窗范围内</h2><p>DOM 元素拥有一个方法 <font color="#f07c82">element.getBoundingClientRect()</font>，可以获取该元素的大小及其相对于视口的位置，方法返回的是一个 DOMRect 对象，其 left, top, right, bottom 属性解释了相对于视口位置，如下所示。</p>
<center><img src="/JS%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD/rect.png" class></center>

<p>然后利用 <strong><font color="#f07c82">img.getBoundingClientRect().top &lt; document.documentElement.clientHeight</font></strong> 对图片位置进行判断。</p>
<h2 id="步骤三-对加载到视口内的元素进行显示"><a href="#步骤三-对加载到视口内的元素进行显示" class="headerlink" title="步骤三   对加载到视口内的元素进行显示"></a>步骤三   对加载到视口内的元素进行显示</h2><p>通过对 <font color="#f07c82">windows.scroll</font> 进行监听，然后 img 元素新建 <font color="#f07c82">src</font> 属性，并将 <font color="#f07c82">data-src</font> 的地址赋予该属性。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>而我们在监听<font color="#f07c82">windows.scroll</font> 事件过程中，对于 <font color="#f07c82">img</font> 元素的操作一致在进行，这就浪费了很多计算资源。为了绕开这个问题，我们使用<font color="#f07c82">节流</font>技术手段。</p>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>对于高频事件，我们希望<strong>处理函数仅在固定的频率响应</strong>。例如，对于窗口滑动事件，可能每 20ms 就触发一次，而我们希望每 200ms 处理函数只响应一次，这样就节约了很多不必要的计算资源。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节流函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">            timer = setTimeOut(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                fn.apply(that, args);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;,wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流函数使用</span></span><br><span class="line">widow.addEventListener(<span class="string">&quot;scroll&quot;</span>, throttle(showImg, <span class="number">200</span>));</span><br></pre></td></tr></table></figure>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>另一个类似的技术手段就是防抖，是在<strong>高频事件触发后一定时间内使处理函数响应</strong>。它与节流函数的区别是，如果高频事件一直触发，那么处理函数一直得不到响应。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">            clearTimeOut(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeOut(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fn.apply(that, args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">html</span>, <span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;upContext&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 100%; width: 100%; position: relative; background-color: aquamarine;&quot;</span>&gt;</span>?<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;display:flex; position: relative; align-items: center; justify-content: center;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">d-src</span>=<span class="string">&quot;./dzq.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片&quot;</span> <span class="attr">id</span>=<span class="string">&quot;img1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> img = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;img1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> showImg = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(img.getBoundingClientRect().top &lt; <span class="built_in">document</span>.documentElement.clientHeight)&#123;</span></span><br><span class="line"><span class="javascript">            img.setAttribute(<span class="string">&#x27;src&#x27;</span>, img.getAttribute(<span class="string">&#x27;d-src&#x27;</span>));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> timer;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> that = <span class="built_in">this</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span></span><br><span class="line">            if(!timer)&#123;</span><br><span class="line"><span class="javascript">                timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">                    fn.apply(that, args);</span><br><span class="line"><span class="javascript">                    timer = <span class="literal">null</span>;</span></span><br><span class="line">                &#125;, wait);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>, throttle(showImg, <span class="number">200</span>));</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的优化技巧</title>
    <url>/JS%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="使用-Promise-all-同时触发多个不互相依赖的异步请求"><a href="#使用-Promise-all-同时触发多个不互相依赖的异步请求" class="headerlink" title="使用 Promise.all 同时触发多个不互相依赖的异步请求"></a>使用 Promise.all 同时触发多个不互相依赖的异步请求</h1><p>对于互不依赖的多个Promise任务，可以使用 Promise.all 方法使这些方法并行执行，而不是串行执行，这样可以大量的节省任务执行时间。</p>
<p><strong>举例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>resolve(<span class="number">1</span>), <span class="number">10000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>resolve(<span class="number">2</span>), <span class="number">20000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">oneByOneAsyncFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> start_time = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">await</span> getData1();</span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">await</span> getData2();</span><br><span class="line">  <span class="built_in">console</span>.log(&#123;</span><br><span class="line">    a,</span><br><span class="line">    b,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> end_time = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="built_in">console</span>.log(end_time.getSeconds()-start_time.getSeconds());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">twoAsyncFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> start_time = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">let</span> [a, b] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getData1(), getData2()]);</span><br><span class="line">  <span class="built_in">console</span>.log(&#123;</span><br><span class="line">    a,</span><br><span class="line">    b,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> end_time = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="built_in">console</span>.log(end_time.getSeconds()-start_time.getSeconds())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">twoAsyncFunc() <span class="comment">// 执行时间为 20 秒</span></span><br><span class="line"></span><br><span class="line">oneByOneAsyncFunc() <span class="comment">// 执行时间为 30 秒</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="http://sunyunzeng.com/JS%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E5%B0%8F%E7%BB%93/">Promise 的一些知识</a></p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的设计模式（上）</title>
    <url>/JS%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>js 程序中很多情况下只需要创建一个对象，例如全局缓存、widows 对象、线程池、以及界面中具备唯一性的窗口，此时需要利用单例模式来保证对象的唯一性。</p>
<p>使用代理实现 <strong>单一职原则</strong> ，将创建单例的 DIV 与管理代理的代码分开。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 DIV 逻辑</span></span><br><span class="line">CreateDiv = <span class="function"><span class="keyword">function</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.html = html;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    div.innerHtml = <span class="built_in">this</span>.html;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingletonProxy = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance || instance = <span class="keyword">new</span> CreateDiv(html)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>很多公司的年终奖是根据员工的工资基数和年底绩效情况来发放的。例如，绩效为 S的人年终奖有 4倍工资，绩效为A的人年终奖有 3倍工资，而绩效为 B的人年终奖是 2倍工资。假设财 务部要求我们提供一段代码，来方便他们计算员工的年终奖。</p>
<p>我们可以采用策略模式，对于每个等级的奖金都创建一个策略，然后再一个计算环境中调用对应策略，得到相应结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strategies = &#123; </span><br><span class="line">    <span class="string">&quot;S&quot;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123; <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;A&quot;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123; <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;B&quot;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123; <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> calculateBonus = <span class="function"><span class="keyword">function</span>(<span class="params"> level, salary </span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> strategies[ level ]( salary );</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( calculateBonus( <span class="string">&#x27;S&#x27;</span>, <span class="number">20000</span> ) ); <span class="comment">// 输出：80000 </span></span><br><span class="line"><span class="built_in">console</span>.log( calculateBonus( <span class="string">&#x27;A&#x27;</span>, <span class="number">10000</span> ) ); <span class="comment">// 输出：30000</span></span><br></pre></td></tr></table></figure>
<p><strong>例子2</strong></p>
<p>在验证表单的过程中，可以对于不同的输入项设置不同的检查策略，例如手机号格式的检校等等，下面就采用粗略模式实现变化的抽离与不变的抽离。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;registerForm&#x27;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>请输入用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>请输入密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>请输入手机号码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;phoneNumber&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> strategies = &#123;</span></span><br><span class="line"><span class="javascript">        nonEmpty: <span class="function"><span class="keyword">function</span> (<span class="params">value, errMsg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (value == <span class="string">&#x27;&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> errMsg;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        minLength: <span class="function"><span class="keyword">function</span> (<span class="params">value, length, errMsg</span>) </span>&#123;</span></span><br><span class="line">            if (value.length &lt; length) &#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> errMsg;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        isPhoneNumber: <span class="function"><span class="keyword">function</span> (<span class="params">value, errMsg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (!<span class="regexp">/(^1[3|5|8][0-9]&#123;9&#125;$)/</span>.test(value)) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> errMsg;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> Validator = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.cache = [];</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    Validator.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params">dom, rules</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> self = <span class="built_in">this</span>;</span></span><br><span class="line">        for (rule of rules) &#123;</span><br><span class="line"><span class="javascript">            (<span class="function"><span class="keyword">function</span> (<span class="params">rule</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 闭包保存中间变量 rule，防止多个函数应用同一个出问题</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> errMsg = rule.errMsg;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> strategy = rule.strategy.split(<span class="string">&#x27;:&#x27;</span>);</span></span><br><span class="line">                self.cache.push(</span><br><span class="line"><span class="javascript">                    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">let</span> strategyKey = strategy.shift();</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">let</span> value = dom.value;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">let</span> args = [value, ...strategy, errMsg];</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> strategies[strategyKey].apply(dom, args);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;)(rule)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    Validator.prototype.start = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (evalFuc <span class="keyword">of</span> <span class="built_in">this</span>.cache) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> errMsg = evalFuc()</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(errMsg)</span></span><br><span class="line">            if (errMsg) &#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> errMsg</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> registerForm = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;registerForm&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ValidatorFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> validator = <span class="keyword">new</span> Validator();</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 添加多个策略</span></span></span><br><span class="line">        validator.add(registerForm.userName, [&#123;</span><br><span class="line"><span class="javascript">                <span class="string">&#x27;strategy&#x27;</span>: <span class="string">&#x27;nonEmpty&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="string">&#x27;errMsg&#x27;</span>: <span class="string">&#x27;输入用户名不能为空&#x27;</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line"><span class="javascript">                <span class="string">&#x27;strategy&#x27;</span>: <span class="string">&#x27;minLength:2&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="string">&#x27;errMsg&#x27;</span>: <span class="string">&#x27;用户名的最短长度不能小于2&#x27;</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        ]);</span><br><span class="line"></span><br><span class="line">        validator.add(registerForm.password, [&#123;</span><br><span class="line"><span class="javascript">                <span class="string">&#x27;strategy&#x27;</span>: <span class="string">&#x27;nonEmpty&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="string">&#x27;errMsg&#x27;</span>: <span class="string">&#x27;输入密码不能为空&#x27;</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line"><span class="javascript">                <span class="string">&#x27;strategy&#x27;</span>: <span class="string">&#x27;minLength:6&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="string">&#x27;errMsg&#x27;</span>: <span class="string">&#x27;用户名的最短长度不能小于6&#x27;</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        ]);</span><br><span class="line"></span><br><span class="line">        validator.add(registerForm.phoneNumber, [&#123;</span><br><span class="line"><span class="javascript">                <span class="string">&#x27;strategy&#x27;</span>: <span class="string">&#x27;isPhoneNumber&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="string">&#x27;errMsg&#x27;</span>: <span class="string">&#x27;输入手机号码的格式不对&#x27;</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        ]);</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> validator.start()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">    registerForm.onsubmit = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> errMsg = ValidatorFunc();</span></span><br><span class="line">        if (errMsg) &#123;</span><br><span class="line">            alert(errMsg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式是由代理者作为中间请求的中转方，来代替客户完成对代理对象的控制。</p>
<p>这样可以实现代理对象与客户之间的解耦，方便代码的复用。</p>
<p><strong>图片加载代理</strong></p>
<p>场景：异步加载图片非常可能非常耗时，此时图片的位置是一片空白，非常影响美观，此时在加载过程中可以利用图片代理来控制图片加载中完与加载后的逻辑控制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载图片的操作</span></span><br><span class="line"><span class="keyword">let</span> myImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(imgNode);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        setSrc: <span class="function"><span class="keyword">function</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">            imgNode.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片加载代理</span></span><br><span class="line"><span class="keyword">let</span> proxyImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> img = <span class="keyword">new</span> Image;</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        myImage.setSrc(img.src);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        setSrc: <span class="function"><span class="keyword">function</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">            imgNode.setSrc(<span class="string">&#x27;http://myGif.gif&#x27;</span>);</span><br><span class="line">            img.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">proxyImage.setSrc(<span class="string">&#x27;http://realImg.png&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>缓存代理</strong></p>
<p>利用缓存代理调用逻辑代码并执行，由缓存代理缓存计算结果。由于很多复杂耗时的计算结果可以由缓存代理缓存，下次计算可以直接调用缓存结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存代理</span></span><br><span class="line"><span class="keyword">let</span> createProxyFactory = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cache = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> storeKey = <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(storeKey <span class="keyword">in</span> cache)&#123;</span><br><span class="line">            <span class="keyword">return</span> cache[storeKey]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache[storeKey] = fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算逻辑</span></span><br><span class="line"><span class="keyword">let</span> mul = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...arguments].reduce(<span class="function">(<span class="params">prev, cur</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prev*cur;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mulProxy = createProxyFactory(mul);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mulProxy(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)); <span class="comment">// 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接返回缓存结果</span></span><br><span class="line"><span class="built_in">console</span>.log(mulProxy(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure>
<h1 id="发布者-订阅者模式"><a href="#发布者-订阅者模式" class="headerlink" title="发布者-订阅者模式"></a>发布者-订阅者模式</h1><p>发布者-订阅者模式是一种很常见的设计模式，在我们为事件绑定监听事件时，其实就运用了该模式。</p>
<p>例如为页面的 body 可绑定多个点击事件监听，等于注册了多个订阅者。事件真实发生时，再通知各个监听函数，执行回调函数。</p>
<p>在 Vue 的双向绑定实现中，就利用了发布者-订阅者模式，实现了数据更新的消息通知到各个页面更新渲染的回调函数中，实现数据变化驱动视图更新。</p>
<p>在两个隔离的对象之间，也可以运用发布者-订阅者模式实现消息的互通，Angular的子组件之间的通信就是利用了发布者-订阅者模式来实现。</p>
<p>下面构建了一个订阅者工厂函数，可以构建多个订阅者。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> client=&#123;&#125;, _listen, _trigger, _remove;</span><br><span class="line">    _listen = <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(key <span class="keyword">in</span> client))&#123;</span><br><span class="line">            client[key] = []</span><br><span class="line">        &#125;</span><br><span class="line">        client[key].push(fn)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">let</span> fns = client[key]</span><br><span class="line">        <span class="keyword">if</span>(!fns) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span>(fn <span class="keyword">of</span> fns)&#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _remove = <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!key <span class="keyword">in</span> client) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">let</span> fns = client[key]</span><br><span class="line">        <span class="keyword">if</span>(!fn)&#123;</span><br><span class="line">            fns &amp;&amp; (fns.length=<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        listen: _listen,</span><br><span class="line">        trigger: _trigger,</span><br><span class="line">        remove: _remove</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Event = getEvent();</span><br><span class="line"></span><br><span class="line">Event.listen(<span class="string">&#x27;手机降价&#x27;</span>, <span class="function">(<span class="params">value</span>)=&gt;</span><span class="built_in">console</span>.log(<span class="string">`降价了 <span class="subst">$&#123;value&#125;</span> 元`</span>))</span><br><span class="line"></span><br><span class="line">Event.trigger(<span class="string">&#x27;手机降价&#x27;</span>, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的设计模式（下）</title>
    <url>/JS%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>命令模式中的命令（command）指的是一个执行某些特定事情的指令。</p>
<p>命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。</p>
<p>例如前端开发分为界面开发以及代码逻辑开发两部分，界面开发的同学设计了一个刷新按钮，点击可以执行刷新操作。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;refreshBtn&quot;</span>&gt;</span>刷新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> refreshBth = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;refreshBtn&#x27;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是这时候负责开发实际代码逻辑的同学由于业务比较复杂，因此还没来得及开发完成，此时界面开发的同学不知道如何调用实际的刷新操作。</p>
<p>此时可以利用命令模式，统一规定了命令的执行需要调用 execute 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> setCommand = <span class="function"><span class="keyword">function</span>(<span class="params">button, command</span>)</span>&#123;</span><br><span class="line">    button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时负责代码逻辑的同学直接实现带 execute 功能的对象或函数即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ButtonRefresh = &#123;</span><br><span class="line">    refresh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;按钮刷新&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> RefreshCommand = <span class="function"><span class="keyword">function</span>(<span class="params">receiver</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        receiver.refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> refreshCommand = <span class="keyword">new</span> RefreshCommand(ButtonRefresh);</span><br><span class="line"></span><br><span class="line">setCommand(refreshBth, refreshCommand);</span><br></pre></td></tr></table></figure>
<p><strong>宏命令</strong></p>
<p>宏命令即执行一系列的名利，例如点外面时候的 下单 -&gt; 做餐 -&gt; 包装 -&gt; 配送 -&gt;取餐 一系列的命令。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> OrderCommand = &#123;</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;下单啦&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> CookCommand = &#123;</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;做餐啦&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> PackCommand = &#123;</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;包装啦&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> DeliveryCommand = &#123;</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;配送啦&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> PickCommand = &#123;</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;取餐啦&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> MacroCommand = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        commandList: [],</span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params">command</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.commandList.push(command)</span><br><span class="line">        &#125;,</span><br><span class="line">        execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(command <span class="keyword">of</span> <span class="built_in">this</span>.commandList)&#123;</span><br><span class="line">                command.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> macroCommand = MacroCommand()</span><br><span class="line">macroCommand.add(OrderCommand)</span><br><span class="line">macroCommand.add(CookCommand)</span><br><span class="line">macroCommand.add(PackCommand)</span><br><span class="line">macroCommand.add(DeliveryCommand)</span><br><span class="line">macroCommand.add(PickCommand)</span><br><span class="line"></span><br><span class="line">macroCommand.execute()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下单啦</span></span><br><span class="line"><span class="comment">// 做餐啦</span></span><br><span class="line"><span class="comment">// 包装啦</span></span><br><span class="line"><span class="comment">// 配送啦</span></span><br><span class="line"><span class="comment">// 取餐啦</span></span><br></pre></td></tr></table></figure>
<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>上述一系列的命令可以组合成一些复杂的命令，例如命令直接存在树状结构，此时可以采用组合模式进行命令的组合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> MacroCommand = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        commandList: [],</span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params">command</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.commandList.push(command)</span><br><span class="line">        &#125;,</span><br><span class="line">        execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(command <span class="keyword">of</span> <span class="built_in">this</span>.commandList)&#123;</span><br><span class="line">                command.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>  macroCommand1 = MacroCommand()</span><br><span class="line"><span class="keyword">let</span>  macroCommand2 = MacroCommand()</span><br><span class="line"><span class="keyword">let</span>  macroCommand3 = MacroCommand()</span><br><span class="line"><span class="keyword">let</span>  macroCommand4 = MacroCommand()</span><br><span class="line"></span><br><span class="line">macroCommand1.add(macroCommand2)</span><br><span class="line">macroCommand2.add(macroCommand3)</span><br><span class="line">macroCommand2.add(macroCommand4)</span><br><span class="line"></span><br><span class="line">macroCommand1.execute()</span><br></pre></td></tr></table></figure>
<p><strong>文件扫描系统</strong></p>
<p>文件系统时典型的树状结构，可以通过文件夹与文件的组合，模拟树状结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.files = []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.files.push(...arguments)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">scan</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> file <span class="keyword">of</span> <span class="built_in">this</span>.files)&#123;</span><br><span class="line">            file.scan()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;文件不能添加文件&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">scan</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> folder1 = <span class="keyword">new</span> Folder()</span><br><span class="line"><span class="keyword">let</span> folder2 = <span class="keyword">new</span> Folder()</span><br><span class="line"><span class="keyword">let</span> folder3 = <span class="keyword">new</span> Folder()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> file1 = <span class="keyword">new</span> File(<span class="string">&#x27;文件1&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> file2 = <span class="keyword">new</span> File(<span class="string">&#x27;文件2&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> file3 = <span class="keyword">new</span> File(<span class="string">&#x27;文件3&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> file4 = <span class="keyword">new</span> File(<span class="string">&#x27;文件4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">folder1.add(folder2)</span><br><span class="line">folder2.add(folder3)</span><br><span class="line">folder2.add(file1, file2)</span><br><span class="line">folder3.add(file3, file4)</span><br><span class="line"></span><br><span class="line">folder1.scan()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件3</span></span><br><span class="line"><span class="comment">// 文件4</span></span><br><span class="line"><span class="comment">// 文件1</span></span><br><span class="line"><span class="comment">// 文件2</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JS异步函数小结</title>
    <url>/JS%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1 id="JS的异步"><a href="#JS的异步" class="headerlink" title="JS的异步"></a>JS的异步</h1><p>JavaScript的执行环境是<strong>单线程的</strong>，对于http事件触发线程、浏览器事件触发线程、浏览器定时器等浏览器会单独开辟出一个异步线程处理，处理完毕后，加入任务队列，等待JS主线程调用执行。</p>
<p>例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;触发了&#x27;</span>),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我先触发&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我先触发</span></span><br><span class="line"><span class="comment">触发了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>虽然setTimeout()被设置为马上触发，但是setTimeout触发的异步任务需先放在任务队列中，等主线程中console()函数执行完毕后，再能被触发。</p>
<blockquote>
<p>JavaScript执行环境(浏览器)是从头到尾一行一行往下执行，但是遇到异步任务，先放入任务队列，等待主线程可以执行该任务，才被执行。</p>
</blockquote>
<p>详细的JS代码执行顺序可查看 <a href="https://juejin.im/post/59e85eebf265da430d571f89">https://juejin.im/post/59e85eebf265da430d571f89</a></p>
<p>异步程序在JS代码中很常见，因为Web应用总归要与远方的服务器交互，请求数据，这个过程需要异步进行。否则，浏览器会一直卡住，直到结果请求完毕。</p>
<p>我们先看一下最简单的回调函数：setTimeout() 与 setsetInterval()，它们都是Windows对象的自带方法。</p>
<h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h2><p>setTimeout()表示指定一个异步程序，在规定的时间后执行，但不保证百分百执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2000ms后执行 console.log()</span></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;执行啦！&quot;</span>), <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">let</span> innerFun = <span class="function"><span class="keyword">function</span>(<span class="params">test</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(innerFun, <span class="number">2000</span>, <span class="string">&#x27;执行啦！&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>如果前面有耗时的密集计算，哪怕setTimeout()设定了在很短的时间后执行，也要等主线程执行完毕，所以说 setTimeout()的延迟时间为理想时间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预期1s后执行console.log()</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="keyword">let</span> innerFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log((<span class="built_in">Date</span>.now()-s)/<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(innerFun, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">let</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j =<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">        m += j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际5.547后执行</span></span><br></pre></td></tr></table></figure>
<p>clearTimeout() 方法可取消由 setTimeout() 方法设置的定时操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;执行!&quot;</span>), <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">clearTimeout</span>(timeout);</span><br></pre></td></tr></table></figure>
<h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h2><p>setInterval()跟setTimeout用法类似，只不过不是执行一次，而是如果不停止就永远重复执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每1000ms执行一次setInterval</span></span><br><span class="line"><span class="keyword">let</span> i =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> interval = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(i++), <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>clearInterval()可以清除interval操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">clearInterval</span>(interval);</span><br></pre></td></tr></table></figure>
<p>setInterval()指定的时间也是理想的时间，该时间包括程序本身的运行时间。如果程序本身运行时间大于指定时间，则setInterval()无法满足间隔时间定时运行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Date</span>.now();</span><br><span class="line">innerFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j =<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">            m += j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log((<span class="built_in">Date</span>.now() - s)/<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(innerFun, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 每次的运行时间都远远大于1s</span></span><br></pre></td></tr></table></figure>
<p>如果你想无论程序执行多长时间，每间隔固定时间都触发程序，你可以利用setTimeout()递归实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> run = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">recur</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i++);</span><br><span class="line">    <span class="built_in">setTimeout</span>(recur, <span class="number">1000</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>上面的程序可以保证每隔1000ms就执行console.log()方法，而不用管程序的执行时间。</p>
<blockquote>
<p>setTimeout() 与 setInterval()都是系统自带的基础的异步程序添加方法，可以时间指定延迟时间触发程序。</p>
</blockquote>
<p>旧版本JS的异步是依靠回调函数实现的，例如传统的AJAX：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.get(<span class="string">&#x27;ajax/text.html&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// doSomeThing</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> success(request.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是回调函数之间往往存在依赖关系，即下一次回调函数的执行依赖于上一次回调函数的执行结果，然后，当这种依赖变得越来越多，代码的可读性就变得很差，此时称为“回调地狱”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// callback hall</span></span><br><span class="line">chooseToppings(<span class="function"><span class="keyword">function</span>(<span class="params">toppings</span>) </span>&#123;</span><br><span class="line">  placeOrder(toppings, <span class="function"><span class="keyword">function</span>(<span class="params">order</span>) </span>&#123;</span><br><span class="line">    collectOrder(order, <span class="function"><span class="keyword">function</span>(<span class="params">pizza</span>) </span>&#123;</span><br><span class="line">      eatPizza(pizza);</span><br><span class="line">    &#125;, failureCallback);</span><br><span class="line">  &#125;, failureCallback);</span><br><span class="line">&#125;, failureCallback)</span><br></pre></td></tr></table></figure>
<p>此时还有一个问题，就是对于每个回调函数，都要重复写一个对应的 catch 失败的函数，显然是非常冗余的，因此，ES6提出了<font color="#f07c82"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a></font>方法！</p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise，英语单词，承诺，就像它的名称一样，Promise对象一定会实现它的诺言，也就是执行的结果无论成功与失败，都会给你一个答复。</p>
<p>Promise是一个构造器，可以生成Promise对象，是ES6异步编程的解决方案。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/*异步执行成功*/</span>)&#123;</span><br><span class="line">        resolve(res);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise在异步过程中一共有三个状态，<strong>pending</strong>等待结果状态,<strong>fullfilled</strong>的执行成功状态以及<strong>rejected</strong>拒绝状态。</p>
<p>三个状态之间转换关系为：</p>
<blockquote>
<p>pending状态 -&gt; fullfilled 状态<br>pending状态 -&gt; rejected 状态</p>
</blockquote>
<p>pending无论转向哪两个状态都是resloved(已完成)状态。</p>
<p>一般resolved状态表示fullfilled状态，这是习惯的写法。</p>
<h2 id="Promise-then"><a href="#Promise-then" class="headerlink" title="Promise.then()"></a>Promise.then()</h2><p>then()方法是Promise原型对象的方法，Promise.prototype.then()。该方法接受两个参数， promise.then(onFulfilled, onRejected)，一个是异步函数执行成功的处理函数，一个是执行失败的处理函数。但是错误处理函数最好在处理语句的最后用Promise.catch()方法捕获（后面会讲到），因为可提高代码的可读性。</p>
<p><strong>then()方法的onFulfilled传参要求如下：</strong></p>
<ol>
<li><strong>必须是函数，不是函数被忽略。</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>resolve(<span class="string">&#x27;你好&#x27;</span>));</span><br><span class="line"></span><br><span class="line">promise.then(<span class="string">&#x27;JS&#x27;</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span><span class="built_in">console</span>.log(result));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 你好，最开始的JS被忽略</span></span><br></pre></td></tr></table></figure>
<ol>
<li>其参数必须是上个then()或Promise函数所返回。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Promise返回的&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> ordinal = <span class="function">()=&gt;</span><span class="string">&#x27;仅仅函数返回的&#x27;</span>;</span><br><span class="line">promise.then(<span class="function">(<span class="params">result</span>) =&gt;</span><span class="built_in">console</span>.log(result)).then(ordinal).then(<span class="function">(<span class="params">result</span>) =&gt;</span><span class="built_in">console</span>.log(result));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise返回的</span></span><br><span class="line"><span class="comment">// 仅仅函数返回的</span></span><br></pre></td></tr></table></figure>
<ol>
<li>如果函数没有返回值，则返回 undefined</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ordinal = <span class="function">()=&gt;</span><span class="string">&#x27;仅仅函数返回的&#x27;</span>;</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ordinal();</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span><span class="built_in">console</span>.log(result));</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<ol>
<li>then()方法只执行一次。</li>
</ol>
<p>由上规则的值，then()存在链式法则，一系列异步操作可以通过一系列的then()方法连接。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chooseToppings()</span><br><span class="line">.then(<span class="function"><span class="params">toppings</span> =&gt;</span> placeOrder(toppings))</span><br><span class="line">.then(<span class="function"><span class="params">order</span> =&gt;</span> collectOrder(order))</span><br><span class="line">.then(<span class="function"><span class="params">pizza</span> =&gt;</span> eatPizza(pizza))</span><br><span class="line">.catch(failureCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">chooseToppings().then(placeOrder).then(collectOrder).then(eatPizza).catch(failureCallback);</span><br></pre></td></tr></table></figure>
<h2 id="Promise-catch"><a href="#Promise-catch" class="headerlink" title="Promise.catch"></a>Promise.catch</h2><p>catch()方法是Promise原型对象的方法，Promise.prototype.catch()，用来捕获错误。</p>
<blockquote>
<p>最佳实战：永远在then()调用链的最后使用，可以捕获异步操作的任意步骤出现的错误。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chooseToppings().then(placeOrder).then(collectOrder).then(eatPizza).catch(failureCallback);</span><br></pre></td></tr></table></figure>
<h2 id="Promise-finally"><a href="#Promise-finally" class="headerlink" title="Promise.finally"></a>Promise.finally</h2><p>finally()方法是Promise原型对象的方法，Promise.prototype.finally()，用来最异步操作执行后（无论成功还是失败）都执行的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chooseToppings().then(placeOrder).then(collectOrder).then(eatPizza).catch(failureCallback).finally(server.stop);</span><br></pre></td></tr></table></figure>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>可以令多个Pormise并行执行，等所有的Promise都执行完毕，然后按照Promise的顺序返回一个由结果构成的Array。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;成功了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = Promse.reject(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)               <span class="comment">//[&#x27;成功了&#x27;, &#x27;success&#x27;]</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1,p3,p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)      <span class="comment">// 失败了，打出 &#x27;失败&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h2><p>Promise.resolve()将现有对象转为Promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">&#x27;foo&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>Promise的参数分为四种情况:</p>
<ol>
<li><p>参数是Promise实例，则依旧返回Promise实例。</p>
</li>
<li><p>参数是一个 thenable 对象，则将该对象转为 Promise 对象，并立即执行。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol>
<li>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
<ol>
<li>不带有任何参数</li>
</ol>
<p>Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;three&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong></p>
<p>立即resolve的 Promise 对象是在事件循环中当前宏任务的后面添加微任务，因此需要等当前宏任务结束后再执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>)).then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>); <span class="comment">// 1, 2, 3</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM如何回收对象</title>
    <url>/JVM%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="如何判断对象是否要回收？"><a href="#如何判断对象是否要回收？" class="headerlink" title="如何判断对象是否要回收？"></a>如何判断对象是否要回收？</h1><h2 id="对象回收的依据——是否被有效引用？"><a href="#对象回收的依据——是否被有效引用？" class="headerlink" title="对象回收的依据——是否被有效引用？"></a>对象回收的依据——是否被有效引用？</h2><p>引用的可分为<strong>强引用</strong>(Strong Reference)——指向<strong>new</strong> 对象的引用、<strong>软引用</strong>(Soft Reference)——有用但没必要的引用、<strong>弱引用</strong>(Weak Reference)——没有必要的引用、<strong>虚引用</strong>(Phantom Reference)——为了在对象被回收时获得系统通知。</p>
<blockquote>
<p>强引用只要存在就不回收；<br>软引用只有在内存即将不足的情况下才回收；<br>弱引用及虚引用随便回收。</p>
</blockquote>
<h2 id="怎么判断对象是否被有效引用？"><a href="#怎么判断对象是否被有效引用？" class="headerlink" title="怎么判断对象是否被有效引用？"></a>怎么判断对象是否被有效引用？</h2><ol>
<li><p><strong>引用计数法</strong>。如果对象的引用计数器为0，则表示该对象可以回收。但是存在互相引用无法清理的情况。</p>
</li>
<li><p><strong>可达性分析法</strong>。通过创建一个成为“GC Root”的对象作为搜索根节点，向下搜索。如果对象到该对象之间没有引用链关联，则该对象可回收。</p>
</li>
</ol>
<h2 id="对象死亡的判决书"><a href="#对象死亡的判决书" class="headerlink" title="对象死亡的判决书"></a>对象死亡的判决书</h2><p>再对象确定没有引用的情况下，还需要判断其<strong>finalize</strong>方法没有被覆盖或者已经被执行一次（该方法只能执行一次），满足这两个条件，GC才会回收该对象。</p>
<p>如果<strong>finalize</strong>方法被覆盖，则将该对象加入一个 <strong>“F-Queue”</strong>队列中，由虚拟机创建的、优先级低的<strong>Finalizer的线程</strong>去处理。</p>
<p>如果对象在finalize方法中<strong>建立了与”GC Root”对象的连接链</strong>，则对象成功逃离了死亡的命运。否则，对象就被判决了死刑。</p>
<h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记-清理算法。"><a href="#标记-清理算法。" class="headerlink" title="标记-清理算法。"></a>标记-清理算法。</h2><p>根据对象是否被有效引用进行标记，然后清理无用对象。<br>    <strong>优点</strong>：简洁有效。<br>    <strong>缺点</strong>：存在空间碎片，不利于下次对象内存的分配及内存空间的合理利用。</p>
<h2 id="复制算法。"><a href="#复制算法。" class="headerlink" title="复制算法。"></a>复制算法。</h2><p>将内存划分为两大块，一块用于存储对象，另一块用于复制准备。第一步也是标记，第二步是把不需清理的对象复制到另一块内存区域，保持这些对象在内存空间上是连续排列。<br>    <strong>优点</strong>：无碎片空间，且新对象内存空间分配便捷。<br>    <strong>缺点</strong>：二分法对空间利用率不高，且复制过程中效率不高。由于新生代中无用对象多，需要复制移动的对象少，所以该法很适合。<br>    <strong>改进版</strong>：内存划分为<strong>一块</strong>较大的<strong>Eden内存空间</strong>及<strong>两块</strong>较小的<strong>Survivor空间</strong>（默认8:1:1），一块Eden及Survivor用于分配对象，另一块用于复制准备。如果要复制的对象的内存超出了准备的Survivor，则需要其他内存（老生代）进行分配担保。</p>
<h2 id="标记-整理。"><a href="#标记-整理。" class="headerlink" title="标记-整理。"></a>标记-整理。</h2><p>第一步标记。第二步将存活的对象都往前移动，在内存空间中紧密排列，然后对于边界外的内存空间进行清理。</p>
<h2 id="分代收集算法。"><a href="#分代收集算法。" class="headerlink" title="分代收集算法。"></a>分代收集算法。</h2><p>将内存空间分为<strong>新生代</strong>与<strong>老生代</strong>。新生代中每次垃圾回收时都会有大量对象死亡，需要复制的对象很少，因此采用复制算法。老生代对象的利用率高，存活时间长，因此采用标记-清理或者标记整理算法。</p>
<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="新生代垃圾收集器"><a href="#新生代垃圾收集器" class="headerlink" title="新生代垃圾收集器"></a>新生代垃圾收集器</h2><p><strong><font color="#f07c82">1. Serial收集器</font></strong> </p>
<p><strong>特点：</strong> Serial 收集器只能使用一条线程进行垃圾收集工作，并且在进行垃圾收集的时候，所有的工作线程都需要停止工作，等待垃圾收集线程完成以后，其他线程才可以继续工作。</p>
<p><strong>使用算法：复制算法</strong></p>
<p><strong><font color="#f07c82">2. ParNew收集器</font></strong> </p>
<p><strong>特点：</strong> ParNew 垃圾收集器是Serial收集器的多线程版本。为了利用 CPU 多核多线程的优势，ParNew 收集器可以运行多个收集线程来进行垃圾收集工作。这样可以提高垃圾收集过程的效率。</p>
<p><strong>使用算法：复制算法</strong></p>
<p><strong><font color="#f07c82">3. Parallel Scavenge收集器</font></strong> </p>
<p><strong>特点：</strong> Parallel Scavenge 收集器是一款多线程的垃圾收集器，但是它又和 ParNew 有很大的不同点。<br>Parallel Scavenge 收集器和其他收集器的关注点不同。其他收集器，比如 ParNew 和 CMS 这些收集器，它们主要关注的是如何缩短垃圾收集的时间。而 Parallel Scavenge 收集器关注的是如何控制系统运行的吞吐量。这里说的吞吐量，指的是 CPU 用于运行应用程序的时间和 CPU 总时间的占比，吞吐量 = 代码运行时间 / （代码运行时间 + 垃圾收集时间）。如果虚拟机运行的总的 CPU 时间是 100 分钟，而用于执行垃圾收集的时间为 1 分钟，那么吞吐量就是 99%。</p>
<p><strong>使用算法：复制算法</strong></p>
<h2 id="老年代垃圾收集器"><a href="#老年代垃圾收集器" class="headerlink" title="老年代垃圾收集器"></a>老年代垃圾收集器</h2><p><strong><font color="#f07c82">1. Serial Old收集器</font></strong> </p>
<p><strong>特点：</strong> Serial Old 收集器是 Serial 收集器的老年代版本。这款收集器主要用于客户端应用程序中作为老年代的垃圾收集器，也可以作为服务端应用程序的垃圾收集器。</p>
<p><strong>使用算法：标记-整理</strong></p>
<p><strong><font color="#f07c82">2. Parallel Old收集器</font></strong></p>
<p><strong>特点：</strong> Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本这个收集器是在 JDK1.6 版本中出现的，所以在 JDK1.6 之前，新生代的 Parallel Scavenge 只能和 Serial Old 这款单线程的老年代收集器配合使用。Parallel Old 垃圾收集器和 Parallel Scavenge 收集器一样，也是一款关注吞吐量的垃圾收集器，和 Parallel Scavenge 收集器一起配合，可以实现对 Java 堆内存的吞吐量优先的垃圾收集策略。</p>
<p><strong>使用算法：标记-整理</strong></p>
<p><strong><font color="#f07c82">3. CMS收集器</font></strong></p>
<p><strong>特点：</strong> CMS 收集器是目前老年代收集器中比较优秀的垃圾收集器。CMS 是 Concurrent Mark Sweep，从名字可以看出，这是一款使用”标记-清除”算法的并发收集器。CMS 收集器的工作过程可以分为 4 个阶段：初始标记（CMS initial mark）阶段、并发标记（CMS concurrent mark）阶段、重新标记（CMS remark）阶段、并发清除(（CMS concurrent sweep）阶段。</p>
<p><strong>使用算法：</strong>复制+标记清除</p>
<p><strong><font color="#f07c82">3. G1 垃圾收集器</font></strong></p>
<p><strong>特点：</strong> 主要步骤：初始标记，并发标记，重新标记，复制清除。<br><strong>使用算法：</strong>复制 + 标记整理</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h1><p><a href="https://book.douban.com/subject/6522893/">深入理解java虚拟机</a>  </p>
<p><a href="https://zhuanlan.zhihu.com/p/79794189">JVM面试突破</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：List API</title>
    <url>/Java-ArrayList-API/</url>
    <content><![CDATA[<h1 id="Java-List"><a href="#Java-List" class="headerlink" title="Java List"></a><strong>Java List</strong></h1><h2 id="常用类型"><a href="#常用类型" class="headerlink" title="常用类型"></a><strong>常用类型</strong></h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">特征 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>ArrayList</strong></td>
<td style="text-align:center">随机访问元素快；中间插入与删除元素较慢；操作不是线程安全的 </td>
</tr>
<tr>
<td style="text-align:center"><strong>LinkedList</strong></td>
<td style="text-align:center">中间插入与删除操作代价较低，提供优化的顺序访问；随机访问元素慢 </td>
</tr>
</tbody>
</table>
</div>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a><strong>ArrayList</strong></h2><p><strong>ArrayList的UML类图如下所示：</strong></p>
<p><img src="http://www.plantuml.com/plantuml/png/TKynQiGm4Epr2k7UVa4AcrI1L4a-i9Ot85XB8AsBXFmahqWTo6_2VUDiOT_D2QuHgvcTsPa-AoLTPZ5lNeLjCwH47yy-w-ddz__xhp4-AATtScoVre56OO0UemWxzJ40kAaDZLaJERLEA6Sxx5yGtDdOr63sGc6Ay-0Svuo79GQkmhnoyYJ-iy2xwT76c2EzVVXgMmn-7LUgwwgezKfH5qVSG_AcoFQWxGvZgq93qakrca27SWeux8uwp81Ops5QPZa3" alt="avatar"></p>
<p>ArrayList 继承了<font color="#f07c82"> AbstractList</font>, 直接实现了<font color="#f07c82"> Cloneable, Serializable，RandomAccess </font>类型标志接口。</p>
<ul>
<li><p>AbstractList 作为列表的抽象实现，将元素的增删改查都交给了具体的子类去实现，在元素的迭代遍历的操作上提供了默认实现。</p>
</li>
<li><p>RandomAccess 接口实现，表示 ArrayList 里的元素可以被高效效率的随机访问，以下标数字的方式获取元素。实现 RandomAccess 接口的列表上在遍历时可直接使用普通的<font color="#f07c82"> for </font>循环方式，并且执行效率上给迭代器方式更高。</p>
</li>
<li><p>Cloneable 接口的实现，表示了 ArrayList 支持调用 Object 的 <font color="#f07c82"> clone </font>方法，实现 ArrayList 的拷贝。</p>
</li>
<li><p>Serializable 接口实现，说明了 ArrayList 还支持序列化和反序列操作，具有固定的 <font color="#f07c82"> serialVersionUID </font> 属性值。</p>
</li>
</ul>
<h3 id="ArrayList-常用-API"><a href="#ArrayList-常用-API" class="headerlink" title="ArrayList 常用 API"></a><strong>ArrayList 常用 API</strong></h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>boolean add(E object)</strong></td>
<td style="text-align:center">再 ArrayList 尾存入对象 </td>
</tr>
<tr>
<td style="text-align:center"><strong>void add(int location, E object)</strong></td>
<td style="text-align:center">在 location 添加对象 </td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean addAll(Collection&lt;? extends E&gt; collection)</strong></td>
<td style="text-align:center">将一个 Collection 对象中存储全部的对象复制并存入 </td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean addAll(int location, Collection&lt;? extends E&gt; collection)</strong></td>
<td style="text-align:center">将一个 Collection 对象中存储全部的对象复制并存入location </td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean contains(Object object)</strong></td>
<td style="text-align:center">是否包对象 object </td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean containsAll(Collection&lt;?&gt; collection)</strong></td>
<td style="text-align:center">是否包含一个 Collection 对象 </td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean isEmpty()</strong></td>
<td style="text-align:center">ArrayList 是否为空 </td>
</tr>
<tr>
<td style="text-align:center"><strong>E get(int location)</strong></td>
<td style="text-align:center">获取 location 的对象 </td>
</tr>
<tr>
<td style="text-align:center"><strong>E set(int location, E object)</strong></td>
<td style="text-align:center">将某个位置的元素替换成 object</td>
</tr>
<tr>
<td style="text-align:center"><strong>int indexOf(Object object)</strong></td>
<td style="text-align:center">获取某个对象的位置（顺序遍历第一个） </td>
</tr>
<tr>
<td style="text-align:center"><strong>int lastIndexOf(Object object)</strong></td>
<td style="text-align:center">获取某个对象的位置（逆序遍历第一个） </td>
</tr>
<tr>
<td style="text-align:center"><strong>int size()</strong></td>
<td style="text-align:center">返回 ArrayList 存储的对象数量 </td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean remove(Object object)</strong></td>
<td style="text-align:center">删除存储的某个对象 </td>
</tr>
<tr>
<td style="text-align:center"><strong>E remove(int lcoation)</strong></td>
<td style="text-align:center">删除位于 location 的对象 </td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean removeAll(Collection&lt;?&gt; collection)</strong></td>
<td style="text-align:center">删除存储的某个 Collection 对象 </td>
</tr>
<tr>
<td style="text-align:center"><strong>Object [] toArray()</strong></td>
<td style="text-align:center">ArrayList 转数组 </td>
</tr>
<tr>
<td style="text-align:center"><strong>List&lt;’E’&gt; subList(int start, int end)</strong></td>
<td style="text-align:center">获取位于 start 与 end 之间的 List </td>
</tr>
<tr>
<td style="text-align:center"><strong>void clone()</strong></td>
<td style="text-align:center">克隆ArrayList </td>
</tr>
<tr>
<td style="text-align:center"><strong>void clear()</strong></td>
<td style="text-align:center">移除ArrayList中所有对象 </td>
</tr>
<tr>
<td style="text-align:center"><strong>Iterator&lt;’E’&gt; iterator()</strong></td>
<td style="text-align:center">获取该 ArrayList 对应的迭代器对象 </td>
</tr>
</tbody>
</table>
</div>
<h3 id="ArrayList-应用示例"><a href="#ArrayList-应用示例" class="headerlink" title="ArrayList 应用示例"></a>ArrayList 应用示例</h3><p><strong>1. ArrayList与数组之间的转换</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转数组</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">String[] strings = <span class="keyword">new</span> String[list.size()];</span><br><span class="line">list.toArray(strings);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">String[] strings = (String[])list.toArray(<span class="keyword">new</span> String[list.size()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组转List</span></span><br><span class="line"><span class="comment">// 法1 快速，但是以视图形式返回，无法对数据进行删除及添加操作；</span></span><br><span class="line"><span class="comment">// 可用 set() 方法修改元素，但是原始List数据会随之改变</span></span><br><span class="line"></span><br><span class="line">String[] s = &#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = java.util.Arrays.asList(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//法 2 慢，但是新生成一个ArrayList，可对List进行操作不会对原对象产生影响</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; assertList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Collections.addAll(assertList, strings);</span><br></pre></td></tr></table></figure><br><strong>2. ArrayList遍历方式</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种，通过迭代器遍历。即通过Iterator去遍历。</span></span><br><span class="line">Integer value = <span class="keyword">null</span>;</span><br><span class="line">Iterator iter = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">value = (Integer)iter.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种，随机访问，通过索引值去遍历。</span></span><br><span class="line">Integer value = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> size = list.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">value = (Integer)list.get(i);        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种，for循环遍历。</span></span><br><span class="line">Integer value = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer integer: list) &#123;</span><br><span class="line">value = integer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四种，利用Stream API的 stream.forEach()方法依次获取。</span></span><br><span class="line">list.forEach(num -&gt; System.out.println(num));</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 初始化</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种方式 Arrays.asList()方法</span></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> Arraylist&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法 常规方式</span></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">List innerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">list.addAll(innerList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种方法 使用生成匿名内部类</span></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;()&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        add(<span class="number">1</span>);</span><br><span class="line">        add(<span class="number">2</span>);</span><br><span class="line">        add(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四种方式 使用Collection.nCopies</span></span><br><span class="line"><span class="keyword">int</span> element = <span class="number">1</span>;</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.nCopies(<span class="number">2</span>, element)); <span class="comment">//复制伍分到list中。</span></span><br></pre></td></tr></table></figure><br><strong>4. 打印信息</strong></p>
<p>由于ArrayList内部实现了toString()方法，所以可以直接打印<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure></p>
<p>对于数组信息的打印<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] A = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">for</span>(Integer i: A)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">System.out.println(Arrays.toString(A));</span><br></pre></td></tr></table></figure></p>
<p><strong>5. 大量头部的增删操作</strong></p>
<blockquote>
<p>ArrayList是数组实现的，使用的是连续的内存空间，当有在数组头部将元素添加或者删除的时候，需要对头部以后的数据进行复制并重新排序，效率很低。针对有大量类似操作的场景，出于性能考虑，我们应该使用 <font color="f07c82">LinkedList</font> 代替。<br>由于LinkedList 是基于链表实现，当需要操作的元素位置位于List 前半段时，就从头开始遍历，马上找到后将把元素在相应的位置进行插入或者删除操作。</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<ol>
<li><font color="#2b1216"> ArrayList源码剖析:</font> <u><a href="http://www.spring4all.com/article/16262">http://www.spring4all.com/article/16262</a></u></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：Map API</title>
    <url>/Java-Map-API/</url>
    <content><![CDATA[<h1 id="Java-Map"><a href="#Java-Map" class="headerlink" title="Java Map"></a><strong>Java Map</strong></h1><h2 id="常用类型"><a href="#常用类型" class="headerlink" title="常用类型"></a><strong>常用类型</strong></h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">特征 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>HashMap</strong></td>
<td style="text-align:center">根据 HashCode 存储数据，访问速度快。至多允许一条记录键为 null;允许多条记录的值为 null；线程非同步  </td>
</tr>
<tr>
<td style="text-align:center"><strong>TreeMap</strong></td>
<td style="text-align:center">保存的记录按照键(key)排序，也可自定义排序规则。用生成的 Iterator 遍历 TreeMap 得到记录是排序后的。不允许记录的键为 null；线程非同步 </td>
</tr>
<tr>
<td style="text-align:center"><strong>Hashtable</strong></td>
<td style="text-align:center">用 HashMap 类似,不同的是键值都不允许为 null。 支持线程同步，但写入较慢 </td>
</tr>
<tr>
<td style="text-align:center"><strong>LinkedHashMap</strong></td>
<td style="text-align:center">保留记录的插入顺序，生成Iterator遍历顺序与插入顺序一致。遍历比HashMap慢，键值都允许为 null；线程非同步 </td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>—&gt; <a href="https://zhuanlan.zhihu.com/p/21673805"><strong>HashMap剖析</strong></a></p>
</blockquote>
<h2 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a><strong>常用 API</strong></h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>Object put(Object k, Object v)</strong></td>
<td style="text-align:center">存入键值对 </td>
</tr>
<tr>
<td style="text-align:center"><strong>Object get(Object k)</strong></td>
<td style="text-align:center">返回键所映射的值；如果不存在该映射则返回 null </td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean containsKey(Object k)</strong></td>
<td style="text-align:center">是否包含键 k </td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean containsValue(Object v)</strong></td>
<td style="text-align:center">是否包含值 v </td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean isEmpty()</strong></td>
<td style="text-align:center">Map 是否为空 </td>
</tr>
<tr>
<td style="text-align:center"><strong>int size()</strong></td>
<td style="text-align:center">返回 Map 的键值对数 </td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean remove(Object k)</strong></td>
<td style="text-align:center">如果存在一个键映射关系，则删除此关系(映射关系不存在不会报错) </td>
</tr>
<tr>
<td style="text-align:center"><strong>void clear()</strong></td>
<td style="text-align:center">移除Map中所有映射关系 </td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean equals(Object obj)</strong></td>
<td style="text-align:center">比较指定对象于此 Map 是否相等 </td>
</tr>
<tr>
<td style="text-align:center"><strong>void putAll(Map m)</strong></td>
<td style="text-align:center">将指定 Map 的映射关系复制到此 Map 中 </td>
</tr>
<tr>
<td style="text-align:center"><strong>Collection values()</strong></td>
<td style="text-align:center">以 Collection 形式返回 Map 包含的值 </td>
</tr>
<tr>
<td style="text-align:center"><strong>Set keySet()</strong></td>
<td style="text-align:center">以 Set 形式返回 Map 包含的键 </td>
</tr>
<tr>
<td style="text-align:center"><strong>Set entrySet()</strong></td>
<td style="text-align:center">以 Set 形式返回 Map 的映射关系</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Map 应用示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">map.get(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i: map.keySet())&#123;</span><br><span class="line">        System.out.println(map.get(i));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(<span class="number">1</span>))&#123;</span><br><span class="line">    map.remove(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用遍历方法"><a href="#常用遍历方法" class="headerlink" title="常用遍历方法"></a><strong>常用遍历方法</strong></h2><p><strong>1. 只获取键或值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取键</span></span><br><span class="line"><span class="keyword">for</span>(Integer key: map.keyset())&#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取值</span></span><br><span class="line"><span class="keyword">for</span>(Integer value: map.value())&#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2. 同时获取键和值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.1 先取key再取value。不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Integer key:map.keySet())&#123;</span><br><span class="line">    System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2 通过map entrySet遍历。性能优于上一种。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. Iterator</strong></p>
<p>上面的foreach都可以用Interator代替。</p>
<p>foreach是对Set遍历,大小不能改变。如果改变map的大小，会报错。如果想要删除元素，还是要用Interator的方式删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Interator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.enteySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;Integer, Integer&gt; entry = it.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">    <span class="comment">// it.remove()  删除元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. Lambda</strong></p>
<p>代码简洁，但是性能低于entrySet。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.forEach((key, value)-&gt;&#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;:&quot;</span> + value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>5. 性能测试</strong></p>
<p>用10万条数据，做了一个简单性能测试，数据类型为Integer，map实现选取HashMap<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">      map.put(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>测试结果如下：</strong><br>    KeySet：           392<br>    Values：           320<br>    keySet get(key)：  552<br>    entrySet：         465<br>    entrySet Iterator：508<br>    Lambda：           536</p>
</blockquote>
<p><a href="https://www.cnblogs.com/zhaoguhong/p/7074597.html?utm_source=itdadao&amp;utm_medium=referral">Map的遍历方法参考</a>(侵删)</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-for循环那些事</title>
    <url>/Java-for%E5%BE%AA%E7%8E%AF%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="Java-for循环里面的-i-与-i"><a href="#Java-for循环里面的-i-与-i" class="headerlink" title="Java for循环里面的 i++ 与 ++i"></a>Java <strong>for</strong>循环里面的 <strong>i++</strong> 与 <strong>++i</strong></h1><p><strong>在for循环里两者的作用是一样的</strong></p>
<p><strong>i++</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">    System.out.print(i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p><strong>++i</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)&#123;</span><br><span class="line">    System.out.print(i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p><strong>工作原理</strong></p>
<p>i++<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.print(i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>++i<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.print(i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>区别</strong></p>
<blockquote>
<p>在Java里面，i++ 需要开辟新的存储空间用于存储结果，++i 直接在原存储空间中存储结果。<strong>故 </strong>++i<strong> 在 for 循环里面执行效率要高。</strong> 可以作为代码优化的一部分。</p>
</blockquote>
<h1 id="foreach-与-for循环的效率"><a href="#foreach-与-for循环的效率" class="headerlink" title="foreach 与 for循环的效率"></a>foreach 与 for循环的效率</h1><ol>
<li><p><strong>首先测试数组</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试for循环</span></span><br><span class="line"><span class="keyword">int</span>[] A = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line"><span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">int</span> len = A.length;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">    res += A[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;for循环: &quot;</span>+(endTime- startTime));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试foreach</span></span><br><span class="line"><span class="keyword">int</span>[] A = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line"><span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">int</span> len = A.length;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(Integer i: A)&#123;</span><br><span class="line">    res += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;foreach循环: &quot;</span>+(endTime- startTime));</span><br></pre></td></tr></table></figure>
<p> <strong>结果</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>循环: <span class="number">37143324</span></span><br><span class="line">forecah循环: <span class="number">75450311</span></span><br></pre></td></tr></table></figure>
<p> 可见对于大数组采用<strong>for循环效率</strong>更高</p>
</li>
<li><p><strong>再测试ArrayList</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">30000000</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30000000</span>; i++)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 测试for循环</span></span><br><span class="line"><span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">int</span> size = list.size();</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">    res += list.get(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;for循环: &quot;</span>+(endTime- startTime));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试foreach</span></span><br><span class="line"><span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(Integer i: list)&#123;</span><br><span class="line">        res += i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;foreach循环: &quot;</span>+(endTime- startTime));</span><br></pre></td></tr></table></figure>
<p> <strong>结果</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>循环: <span class="number">39368248</span></span><br><span class="line">forecah循环: <span class="number">42177137</span></span><br></pre></td></tr></table></figure>
<p> 可见对于ArrayList仍然是采用<strong>for循环效率</strong>更高！</p>
</li>
</ol>
<h1 id="for循环小技巧"><a href="#for循环小技巧" class="headerlink" title="for循环小技巧"></a>for循环小技巧</h1><h2 id="关于数组"><a href="#关于数组" class="headerlink" title="关于数组"></a>关于数组</h2><ol>
<li><p>循环嵌套采用<strong>小套大</strong>。原理跟复制几个大文件跟复制一堆小文件耗时一样。</p>
<p> <strong>测试</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 大套小</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000000</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">100</span>; j++)&#123;</span><br><span class="line">        res += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;大套小: &quot;</span>+(endTime- startTime));</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小套大</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10000000</span>; j++)&#123;</span><br><span class="line">        res += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;小套大: &quot;</span>+(endTime- startTime));</span><br></pre></td></tr></table></figure>
<p> <strong>结果</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">大套小: <span class="number">57934223</span></span><br><span class="line">小套大: <span class="number">4918044</span></span><br></pre></td></tr></table></figure></li>
<li>数组复制时采用<strong>System.arraycopy()</strong>方法比<strong>for循环复制</strong>效率高。</li>
</ol>
<p><strong>System.arraycopy()</strong></p>
<pre><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
代码解释:
    Object src : 原数组
    int srcPos : 从元数据的起始位置开始
    Object dest : 目标数组
    int destPos : 目标数组的开始起始位置
    int length  : 要copy的数组的长度
</code></pre><h2 id="关于ArrayList"><a href="#关于ArrayList" class="headerlink" title="关于ArrayList"></a>关于ArrayList</h2><p>在循环时，首<strong>先把ArrayList长度size记录下来</strong>。</p>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">30000000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30000000</span>; i++)&#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"><span class="comment">//先把长度保存下来</span></span><br><span class="line"><span class="keyword">int</span> len = list.size();</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">    res += list.get(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;保存size(): &quot;</span>+(endTime- startTime));</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有保存size()</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">    res += list.get(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;没有保存size(): &quot;</span>+(endTime- startTime));</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">保存size(): <span class="number">38973440</span></span><br><span class="line">没有保存size(): <span class="number">39486862</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java: Set API</title>
    <url>/Java-Set-API/</url>
    <content><![CDATA[<h1 id="Java-Set"><a href="#Java-Set" class="headerlink" title="Java Set"></a><strong>Java Set</strong></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p><strong>Set 继承自集合（Collection），该集合不能包含相同的元素。</strong></p>
<p><strong>Set</strong> 里面进行元素是否相同的判定是通过 <strong>Object</strong> 类自带的<strong>equals()</strong>实现。</p>
<p><strong>Set</strong> 最多可存储一个 <strong>null</strong> 元素。</p>
<p><strong>Set</strong> 只是一个抽象的<strong>接口</strong>，具体的使用还要用具体的实现，如<strong>HashSet</strong>、<strong>TreeSet</strong>等。</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h2><p>因为 Set 继承自集合 Collection，所以具有集合的方法。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>int size()</strong></td>
<td style="text-align:center">返回Set里面存储的元素个数。</td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean isEmpty()</strong></td>
<td style="text-align:center">如果没有元素，返回true。</td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean add(E e)</strong></td>
<td style="text-align:center">如果Set里面没有包含元素e，就将其加入。</td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean addAll(Collection&lt;? extends E&gt;c)</strong></td>
<td style="text-align:center">如果指定集合中的元素不存在Set中，就将其加入Set。如果该Collection也是一个Set，相当于对这两个Set取并集。</td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean contains(Object o)</strong></td>
<td style="text-align:center">是否包含特定的元素 o。即对Set里面的任意元素e执行判定(o==null?e==null:o.equals(e))。</td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean containsAll(Collecton&lt; ? &gt;c)</strong></td>
<td style="text-align:center">该Set是否包含指定Collection的所有元素。</td>
</tr>
<tr>
<td style="text-align:center"><strong>void clear()</strong></td>
<td style="text-align:center">清除所有元素。</td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean remove(Object o)</strong></td>
<td style="text-align:center">删除指定元素。</td>
</tr>
<tr>
<td style="text-align:center"><strong>boolean removeAll(Collection&lt; ? &gt;c)</strong></td>
<td style="text-align:center">删除Set中存在于该Collection里的元素。</td>
</tr>
<tr>
<td style="text-align:center"><strong>Object[ ] toArray()</strong></td>
<td style="text-align:center">将Set转化为数组。</td>
</tr>
<tr>
<td style="text-align:center"><strong>&lt; T &gt; T[ ] toArray(T[ ] a)</strong></td>
<td style="text-align:center">返回所有的Set元素并存储在Array中。如果a的长度大于Set长度，则多余空间以null补全。</td>
</tr>
<tr>
<td style="text-align:center"><strong>Iterator&lt; E &gt; iterator()</strong></td>
<td style="text-align:center">返回一个该Set的迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>default Spliterator&lt; E &gt; spliterator()</strong></td>
<td style="text-align:center">在该集合中创建拆分器。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="常用Set实现"><a href="#常用Set实现" class="headerlink" title="常用Set实现"></a><strong>常用Set实现</strong></h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><strong>HashSet</strong></h3><p>HashSet的方法基本与Set一致，只不过多了一个<strong>Object clone()</strong>方法（浅复制，只复制地址）。</p>
<p><strong>主要方法包括：</strong></p>
<ul>
<li>add()</li>
<li>clear()</li>
<li>clone()</li>
<li>contains()</li>
<li>isEmpty()</li>
<li>iterator()</li>
<li>remove()</li>
<li>size()</li>
<li>spliterator()</li>
</ul>
<p><strong>HashSet</strong>底层是基于<strong>HashMap</strong>实现的。即通过HashMap的键唯一性实现。</p>
<p><strong>构造方法示例</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 该构造方法为LinkedHashSet实现准备</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a><strong>LinkedHashSet</strong></h3><p><strong>LinkedHashSet</strong>保存了元素的顺序，即插入时的顺序，再使用iterator遍历时会按顺序遍历。</p>
<p><strong>LinkedHashSet</strong>底层也是根据<strong>LinkHashMap</strong>实现的。通过父类<strong>HashSet</strong>的构造方法，调用<strong>LinkHashMap</strong>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>继承自 <strong>HashSet</strong>，实现了接口 <strong>Serializable</strong> 及 <strong>Cloneable</strong>。</p>
<p><strong>Serializable</strong>是一个空接口，是一个序列化的标记，用来告诉JVM该类可以序列化。</p>
<p><u><strong>序列化就是把对象的状态转化为可存储和传输的格式（如二进制流）；反序列化就是序列化的逆过程，根据序列化后的数据重新恢复对象及其状态。</strong></u></p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a><strong>TreeSet</strong></h3><p>可实现排序的Set，排序规则可以是自带的或者通过Comparator实现。</p>
<p>基础操作（add,contains and remove）的耗时是log(n)。</p>
<p>实现了<strong>NavigableSet</strong>接口，该接口是基于<strong>TreeMap</strong>的。</p>
<p><strong>TreeSet</strong>底层是基于TreeMap实现，所以对于系统内部类例如Integer、String等，由于实现了Comparable接口，可直接进行存储；对于自定义的类，必须实现Comparable接口并重写comparaTo（）方法，这样TreeSet才能根据排序规则进行排序。</p>
<p><strong>TreeSet</strong>不能有重复元素。</p>
<p><strong>TreeSet</strong>的存取不如<strong>HashSet</strong>快。</p>
<p><strong>comparaTo()</strong>方法在被调用过程中，如果返回真值（或大于零的数），就认为新插入元素大于根元素，存入右节点，此时为顺序排列；反之存入左节点，为逆序排列。</p>
<p><strong>构造函数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">构造函数的说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">TreeSet()，此构造函数构造空树集，将在根据其元素的自然顺序按升序排序。</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">TreeSet (集合 c)，此构造函数生成树的集合，它包含的元素的集合 c。</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">TreeSet (比较器 comp)，此构造函数构造一个空树集，将根据给定的比较器进行排序。</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">TreeSet (SortedSet ss)，此构造函数生成包含给定 SortedSet 的元素 TreeSet</td>
</tr>
</tbody>
</table>
</div>
<p> <strong>常用方法</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">修饰符和类型</th>
<th style="text-align:center">方法和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">add(E e)，将指定的元素添加到这套，如果它已不存在。</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">addAll(Collection&lt;? extends E&gt; c)，在加入这一组指定的集合中添加的所有元素。</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">ceiling(E e)，返回最小的元素在这一组大于或等于给定的元素，则null如果没有这样的元素。</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">clear()，从这一组中移除所有元素。</td>
</tr>
<tr>
<td style="text-align:center">Object</td>
<td style="text-align:center">clone()，返回此TreeSet实例浅表副本。</td>
</tr>
<tr>
<td style="text-align:center">Comparator&lt;? super E&gt;</td>
<td style="text-align:center">comparator()，返回用于排序在这集，或空元素，如果这套使用自然排序其元素的比较。</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">contains(Object o)，如果此集合包含指定的元素，则返回true 。</td>
</tr>
<tr>
<td style="text-align:center">Iterator<E></E></td>
<td style="text-align:center">descendingIterator()，返回迭代器中这套降序排序的元素。</td>
</tr>
<tr>
<td style="text-align:center">NavigableSet<E></E></td>
<td style="text-align:center">descendingSet()，返回逆序视图中包含的元素这一套。</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">first()，返回第一个 （最低） 元素当前在这一套。</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">floor(E e)，返回的最大元素在这一组小于或等于null如果没有这样的元素。</td>
</tr>
<tr>
<td style="text-align:center">SortedSet<E></E></td>
<td style="text-align:center">headSet(E toElement)，返回其元素是严格小于toElement这套的部分视图.</td>
</tr>
<tr>
<td style="text-align:center">NavigableSet<E></E></td>
<td style="text-align:center">headSet(E toElement, boolean inclusive)，返回一个视图的这部分设置的元素都小于 （或等于，如果inclusive是真的） toElement.</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">higher(E e)，返回最小的元素在这套严格大于给定的元素，则null如果没有这样的元素。</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">isEmpty()，如果此集不包含任何元素，则返回true 。</td>
</tr>
<tr>
<td style="text-align:center">Iterator<E></E></td>
<td style="text-align:center">iterator()，返回迭代器中这套以升序排序的元素。</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">last()，在这套目前返回的最后一个 （最高） 的元素。</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">lower(E e)，在这一套严格的小于给定的元素，则null返回的最大元素，如果没有这样的元素。</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">pollFirst()，检索和删除第一个 （最低） 元素，或如果此集合为空，则返回null 。</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">pollLast()，检索和删除的最后一个 （最高） 的元素，或如果此集合为空，则返回null 。</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">remove(Object o)，从这一组中移除指定的元素，如果它存在。</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">size()，在这套 （其基数） 中返回的元素的数目。</td>
</tr>
<tr>
<td style="text-align:center">NavigableSet<E></E></td>
<td style="text-align:center">subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)，返回此集的部分视图的元素范围从fromElement到toElement.</td>
</tr>
<tr>
<td style="text-align:center">SortedSet<E></E></td>
<td style="text-align:center">subSet(E fromElement, E toElement)，返回视图的部分的这一套的元素范围从fromElement，具有包容性，到toElement，独家。</td>
</tr>
<tr>
<td style="text-align:center">SortedSet<E></E></td>
<td style="text-align:center">tailSet(E fromElement)，返回其元素是大于或等于fromElement这套的部分视图.</td>
</tr>
<tr>
<td style="text-align:center">NavigableSet<E></E></td>
<td style="text-align:center">tailSet(E fromElement, boolean inclusive)，返回其元素是大于 （或等于，如果inclusive是真的） 这套的部分视图fromElement.</td>
</tr>
</tbody>
</table>
</div>
<p><strong>实现原理</strong></p>
<p><strong>TreeSet</strong>底层依赖于TreeMap，通过TreeMap来作为存储TreeSet的容易，键值保证了元素的唯一性。</p>
<p>采用“<strong>红黑树</strong>”的排序二叉树保存Map中的每个Entry，每个Entry被当做“红黑树”的一个节点。</p>
<p>“<strong>红黑树</strong>”是一种平衡二叉查找树，树中节点都大于等于左子树所有节点，且小于等于右子树左右节点。</p>
<p><strong>TreeSet部分源码</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用NavigableMap对象的key来保存Set集合的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用PRESENT作为Map集合中的value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不带参数的构造函数。创建一个空的TreeMap</span></span><br><span class="line">    <span class="comment">//以自然排序方法创建一个新的TreeMap，再根据该TreeMap创建一个TreeSet</span></span><br><span class="line">    <span class="comment">//使用该TreeMap的key来保存Set集合的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将TreeMap赋值给 &quot;NavigableMap对象m&quot;</span></span><br><span class="line">    TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以定制排序的方式创建一个新的TreeMap。根据该TreeMap创建一个TreeSet</span></span><br><span class="line">    <span class="comment">//使用该TreeMap的key来保存set集合的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;(comparator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TreeSet，并将集合c中的全部元素都添加到TreeSet中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="comment">// 将集合c中的元素全部添加到TreeSet中</span></span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TreeSet，并将s中的全部元素都添加到TreeSet中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(s.comparator());</span><br><span class="line">        addAll(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回TreeSet的顺序排列的迭代器。</span></span><br><span class="line">    <span class="comment">// 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.navigableKeySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回TreeSet的逆序排列的迭代器。</span></span><br><span class="line">    <span class="comment">// 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.descendingKeySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回TreeSet的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回TreeSet是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回TreeSet是否包含对象(o)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加e到TreeSet中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除TreeSet中的对象o</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空TreeSet</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将集合c中的全部元素添加到TreeSet中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use linear-time version if applicable</span></span><br><span class="line">        <span class="keyword">if</span> (m.size()==<span class="number">0</span> &amp;&amp; c.size() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            c <span class="keyword">instanceof</span> SortedSet &amp;&amp;</span><br><span class="line">            m <span class="keyword">instanceof</span> TreeMap) &#123;</span><br><span class="line">            <span class="comment">//把C集合强制转换为SortedSet集合</span></span><br><span class="line">            SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c; </span><br><span class="line">             <span class="comment">//把m集合强制转换为TreeMap集合</span></span><br><span class="line">            TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m;</span><br><span class="line">            Comparator&lt;? <span class="keyword">super</span> E&gt; cc = (Comparator&lt;? <span class="keyword">super</span> E&gt;) set.comparator();</span><br><span class="line">            Comparator&lt;? <span class="keyword">super</span> E&gt; mc = map.comparator();</span><br><span class="line">            <span class="comment">//如果cc和mc两个Comparator相等</span></span><br><span class="line">            <span class="keyword">if</span> (cc==mc || (cc != <span class="keyword">null</span> &amp;&amp; cc.equals(mc))) &#123;</span><br><span class="line">            <span class="comment">//把Collection中所有元素添加成TreeMap集合的key</span></span><br><span class="line">                map.addAllForTreeSet(set, PRESENT);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回子Set，实际上是通过TreeMap的subMap()实现的。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> fromInclusive,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  E toElement,   <span class="keyword">boolean</span> toInclusive)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;E&gt;(m.subMap(fromElement, fromInclusive,</span><br><span class="line">                                       toElement,   toInclusive));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回Set的头部，范围是：从头部到toElement。</span></span><br><span class="line">    <span class="comment">// inclusive是是否包含toElement的标志</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;E&gt;(m.headMap(toElement, inclusive));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回Set的尾部，范围是：从fromElement到结尾。</span></span><br><span class="line">    <span class="comment">// inclusive是是否包含fromElement的标志</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;E&gt;(m.tailMap(fromElement, inclusive));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回子Set。范围是：从fromElement(包括)到toElement(不包括)。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subSet(fromElement, <span class="keyword">true</span>, toElement, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回Set的头部，范围是：从头部到toElement(不包括)。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> headSet(toElement, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回Set的尾部，范围是：从fromElement到结尾(不包括)。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tailSet(fromElement, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回Set的比较器</span></span><br><span class="line">    <span class="keyword">public</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator() &#123;</span><br><span class="line">        <span class="keyword">return</span> m.comparator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回Set的第一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.firstKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回Set的最后一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.lastKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回Set中小于e的最大元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">lower</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.lowerKey(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回Set中小于/等于e的最大元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">floor</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.floorKey(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回Set中大于/等于e的最小元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">ceiling</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.ceilingKey(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回Set中大于e的最小元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">higher</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.higherKey(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一个元素，并将该元素从TreeMap中删除。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span>)? <span class="keyword">null</span> : e.getKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最后一个元素，并将该元素从TreeMap中删除。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map.Entry&lt;E,?&gt; e = m.pollLastEntry();</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span>)? <span class="keyword">null</span> : e.getKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆一个TreeSet，并返回Object对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;E&gt; clone = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clone = (TreeSet&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        clone.m = <span class="keyword">new</span> TreeMap&lt;E,Object&gt;(m);</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java.io.Serializable的写入函数</span></span><br><span class="line">    <span class="comment">// 将TreeSet的“比较器、容量，所有的元素值”都写入到输出流中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入比较器</span></span><br><span class="line">        s.writeObject(m.comparator());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入容量</span></span><br><span class="line">        s.writeInt(m.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入“TreeSet中的每一个元素”</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator i=m.keySet().iterator(); i.hasNext(); )</span><br><span class="line">            s.writeObject(i.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java.io.Serializable的读取函数：根据写入方式读出</span></span><br><span class="line">    <span class="comment">// 先将TreeSet的“比较器、容量、所有的元素值”依次读出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Read in any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从输入流中读取TreeSet的“比较器”</span></span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; c = (Comparator&lt;? <span class="keyword">super</span> E&gt;) s.readObject();</span><br><span class="line"></span><br><span class="line">        TreeMap&lt;E,Object&gt; tm;</span><br><span class="line">        <span class="keyword">if</span> (c==<span class="keyword">null</span>)</span><br><span class="line">            tm = <span class="keyword">new</span> TreeMap&lt;E,Object&gt;();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tm = <span class="keyword">new</span> TreeMap&lt;E,Object&gt;(c);</span><br><span class="line">        m = tm;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从输入流中读取TreeSet的“容量”</span></span><br><span class="line">        <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从输入流中读取TreeSet的“全部元素”</span></span><br><span class="line">        tm.readTreeSet(size, s, PRESENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TreeSet的序列版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2479143000061671589L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现，<strong>TreeSet</strong>底层是依靠<strong>TreeMap</strong>对<strong>key</strong>进行存储排序实现的，现在看一下<strong>TreeMap</strong>的部分源码。</p>
<p><strong>TreeMap的put()方法</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//定义一个t来保存根元素</span></span><br><span class="line">        Entry&lt;K,V&gt; t = root;</span><br><span class="line">        <span class="comment">//如果t==null，表明是一个空链表</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果根节点为null，将传入的键值对构造成根节点（根节点没有父节点，所以传入的父节点为null）</span></span><br><span class="line">            root = <span class="keyword">new</span> Entry&lt;K,V&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//设置该集合的size为1</span></span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//修改此时+1</span></span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录比较结果</span></span><br><span class="line">        <span class="keyword">int</span> cmp;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        <span class="comment">// 分割比较器和可比较接口的处理</span></span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">        <span class="comment">// 有比较器的处理，即采用定制排序</span></span><br><span class="line">        <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// do while实现在root为根节点移动寻找传入键值对需要插入的位置</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//使用parent上次循环后的t所引用的Entry</span></span><br><span class="line">                <span class="comment">// 记录将要被掺入新的键值对将要节点(即新节点的父节点)</span></span><br><span class="line">                parent = t;</span><br><span class="line">                <span class="comment">// 使用比较器比较父节点和插入键值对的key值的大小</span></span><br><span class="line">                cmp = cpr.compare(key, t.key);</span><br><span class="line">                <span class="comment">// 插入的key较大</span></span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="comment">// 插入的key较小</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="comment">// key值相等，替换并返回t节点的value(put方法结束)</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有比较器的处理</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// key为null抛出NullPointerException异常</span></span><br><span class="line">            <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">            <span class="comment">// 与if中的do while类似，只是比较的方式不同</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = k.compareTo(t.key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有找到key相同的节点才会有下面的操作</span></span><br><span class="line">        <span class="comment">// 根据传入的键值对和找到的“父节点”创建新节点</span></span><br><span class="line">        Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;K,V&gt;(key, value, parent);</span><br><span class="line">        <span class="comment">// 根据最后一次的判断结果确认新节点是“父节点”的左孩子还是又孩子</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            parent.left = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent.right = e;</span><br><span class="line">        <span class="comment">// 对加入新节点的树进行调整</span></span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">        <span class="comment">// 记录size和modCount</span></span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// 因为是插入新节点，所以返回的是null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>发现在插入过程中，会进行二叉树排序的判定：</p>
<ol>
<li>如果新增节点大于当前节点且当前节点的右子节点存在，则以右子节点作为当前节点。并继续循环</li>
<li>如果新增节点小于当前节点且当前节点的左子节点存在，则以左子节点作为当前节点。并继续循环</li>
<li>如果新增节点等于当前节点，则新增节点覆盖当前节点，并结束循环。</li>
</ol>
<p><strong>TreeMap的get()方法</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//根据key取出Entry</span></span><br><span class="line">     Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">     <span class="comment">//取出Entry所包含的value</span></span><br><span class="line">     <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>关键在于 <strong>getEntry()</strong>是怎么根据Comparable取出对应Entry的。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果有比较器，返回getEntryUsingComparator(Object key)的结果</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="comment">// 查找的key为null，抛出NullPointerException</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 如果没有比较器，而是实现了可比较接口</span></span><br><span class="line">    <span class="comment">//将key强制转换为Comparable接口</span></span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    <span class="comment">// 获取根节点</span></span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="comment">// 从根节点开始对树进行遍历查找节点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把key和当前节点的key进行比较</span></span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="comment">// key小于当前节点的key</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// p “移动”到左节点上</span></span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="comment">// key大于当前节点的key</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// p “移动”到右节点上</span></span><br><span class="line">　　　　p = p.right;</span><br><span class="line">        <span class="comment">// key值相等则当前节点就是要找的节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 返回找到的节点</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 没找到则返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实就是一个二叉查找，根据Comparable进行key大小的判断。如果采用定制比较器，则采用<strong>getEntryUsingComparator()</strong>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    K k = (K) key;</span><br><span class="line">    <span class="comment">// 获取比较器</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="comment">// 其实在调用此方法的get(Object key)中已经对比较器为null的情况进行判断，这里是防御性的判断</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取根节点</span></span><br><span class="line">            Entry&lt;K,V&gt; p = root;</span><br><span class="line">            <span class="comment">// 遍历树</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取key和当前节点的key的比较结果</span></span><br><span class="line">                <span class="keyword">int</span> cmp = cpr.compare(k, p.key);</span><br><span class="line">                <span class="comment">// 查找的key值较小</span></span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// p“移动”到左孩子</span></span><br><span class="line">                    p = p.left;</span><br><span class="line">                <span class="comment">// 查找的key值较大</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// p“移动”到右节点</span></span><br><span class="line">                    p = p.right;</span><br><span class="line">                <span class="comment">// key值相等</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 返回找到的节点</span></span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到key值对应的节点，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u><a href="https://blog.csdn.net/qq_36057761/article/details/80923053">参考资料1</a></u>      <u><a href="https://www.jianshu.com/p/12f4dbdbc652">参考资料2</a></u></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 运行时数据区域</title>
    <url>/Java-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>Java虚拟机把所管理的内存划分为不同的区域，总称为运行时数据区域。</p>
<p>数据区域用途各不相同，有的随虚拟机启动而存在，有的随线程的生命周期存在。</p>
<p>根据《Java虚拟机规范（Java SE7版)》规定，Java虚拟机将数据区域划分为：<strong>程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区（运行时常量池）</strong>。</p>
<img src="/Java-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/jvm0.png" class>
<h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p>• <strong>线程私有</strong>，每个线程都有一个用来记录字节码执行位置。</p>
<p>• <strong>一块内存区域</strong>，java虚拟机规范中唯一没有规定OutOfMemoryError的区域。</p>
<p>• java字节码解释器通过改变计数器的值实现分支、跳转、循环、异常处理、线程恢复等操作。</p>
<p>• 如果执行的是<strong>Java方法</strong>，则<strong>存储的是虚拟机字节码指令地址</strong>；如果是Native方法，则存储为空。</p>
<h1 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h1><p>• 所谓的<strong>栈内存</strong>指的就是Java虚拟机栈。</p>
<p>• <strong>Java方法的运行</strong>，都会生成一个栈帧，用来存储执行Java方法的局部变量、操作数栈、动态链接、方法出口等信息。</p>
<p>• <strong>一个Java方法的执行到结束，对应为一个栈帧的出栈与入栈</strong>。</p>
<p>• 虚拟机栈可以为固定内存，也可动态扩展。如果线程请求栈深度大于虚拟机深度，则会报<strong>StackOverflowError</strong>;如果动态扩展时无法申请到足够内存，则会报<strong>OutOfMemoryError</strong>。</p>
<h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>• 与Java虚拟机栈类似，但是是为Native方法的执行提供服务。</p>
<p>• 也会抛出StackOverflowError与OutOfMemoryError。</p>
<h1 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h1><p>• <strong>各线程共享区域</strong>。</p>
<p>• 是java虚拟机管理的最大的一块内存区域。</p>
<p>• <strong>是Java对象实例存储的空间</strong>。</p>
<p>• 是垃圾收集器主要工作区域。</p>
<p>• 存储空间逻辑上连续，物理上可以不连续。</p>
<p>• 可设置为固定大小或动态扩展，如果动态扩展时无法申请到足够内存，则会报<strong>OutOfMemoryError</strong>。</p>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>• <strong>各线程共享区域</strong>。</p>
<p>• 用于<strong>存储已被Java虚拟机加载的类信息，常量，静态变量、即时编译器编译后的代码等</strong>。</p>
<p>• 方法区无法内存分配需求时，会抛出<strong>OutOfMemoryError</strong>。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>• 是方法区的一部分。</p>
<p>• <strong>Class类文件中有一项是常量池，用来存放编译期生成的字面量和符号引用</strong>。</p>
<p>• 类加载后<strong>常量池</strong>存储在<strong>方法区内的运行时常量池</strong>。</p>
<p>• 具有动态性，非编译期间的新的常量也可放入运行时常量池中。</p>
<h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p>• 不是Java虚拟机规范定义的内存区域。</p>
<p>• JDK1.4后新加入的NI/O（New Input/Output）类，引入了仅与通道（Channel）与缓存。(Buffer)的I/O方式，可以直接通过Native函数库分配堆外内存。</p>
<p>• 内存收到本机总内存及处理器寻址空间的限制。直接内存无法内存分配需求时，会抛出<strong>OutOfMemoryError</strong>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h1><p><a href="https://book.douban.com/subject/6522893/">深入理解java虚拟机</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的函数表达式</title>
    <url>/JavaScript%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h1><p><strong>函数表达式是定义函数的一种方式</strong>，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">v1, v2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">v1, v2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数表达式可以创建一个匿名函数，它与JS的很多特性与模式有关，包括闭包、私有变量创建等等。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><strong>闭包指一个函数，该函数有权访问其他函数作用域中的变量。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 闭包</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">        <span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(value1 &lt; value2)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value1 &gt; value2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> compare = createComparisonFunction(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(compare(&#123;<span class="attr">name</span>: <span class="string">&quot;syz&quot;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&quot;xj&quot;</span>&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line">compare = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>放回的匿名函数引用了外包函数createComparisonFunction()的变量propertyName。</p>
<p>需要注意的是，在createComparisonFunction()执行完毕产生比较函数compare()时，其<strong>作用域链</strong>被销毁，但是其<strong>活动对象</strong>(此处指<strong>propertyName</strong>)仍被compare()函数引用，并没有销毁。</p>
<p>闭包实现的具体原理是：</p>
<blockquote>
<p>首先，每一个执行环境都有一个<strong>变量对象</strong>表示。全局执行环境的变量对象始终存在，而函数内部的变量对象在执行过程中创建，执行完毕销毁。<strong>createComparisonFunction()</strong>函数执行过程，首先创建一个包含全局变量对象的作用域链，并被内部属性[[Scope]]引用，其中的<strong>参数、变量与方法</strong>都作为<strong>活动对象</strong>(该函数的变量对象)被推入作用域链的顶端，构成<strong>该函数的作用域链</strong>。作用域链提供一个变量对象的引用链，通过它可以访问链上的变量。</p>
<p>然后，内部函数的创建，首先创建一个包含全局变量对象的作用域链。如果内部函数引用了外部函数的变量，即<strong>闭包</strong>，那么内部函数的作用域链会添加<strong>外部函数的活动对象</strong>，最后再将本函数的活动对象推入作用域链顶端。</p>
<p>最后，外部函数createComparisonFunction()执行完毕，本来所有作用域链与活动对象全部销毁，但由于内部函数的引用，导致只销毁作用域链，而<strong>活动对象继续被内部函数引用，直到内部函数被销毁。</strong></p>
</blockquote>
<img src="/JavaScript%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/bibao.png" class="%">
<h1 id="匿名函数中的this对象"><a href="#匿名函数中的this对象" class="headerlink" title="匿名函数中的this对象"></a>匿名函数中的this对象</h1><p><strong>要熟知函数的this对象指向其对应的执行环境。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子1</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">&quot;this indicator&quot;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">因为调用函数getName()返回一个内部函数，而此内部函数的执行环境为全局执行环境,</span></span><br><span class="line"><span class="comment">尽管其作用域链存在外部函数的this对象，但是作用域链的顶端this对象指向全局执行环境,</span></span><br><span class="line"><span class="comment">所以返回 windows</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(object.getName()()); <span class="comment">// windows</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子2</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">&quot;this indicator&quot;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定匿名函数的this对象就是指向外部函数的this对象，因此返回 this indicator</span></span><br><span class="line"><span class="built_in">console</span>.log(object.getName()()); <span class="comment">// this indicator</span></span><br></pre></td></tr></table></figure>
<h1 id="模拟块级作用域"><a href="#模拟块级作用域" class="headerlink" title="模拟块级作用域"></a>模拟块级作用域</h1><p>由于JS不存在块级作用域，因此<strong>if、for</strong>语句中声明的变量存在于全局变量中，会导致内存的溢出及命名的冲突。</p>
<p>可以通过<strong>匿名函数的方式模拟模拟块级作用域</strong>，将生命的变量<strong>随匿名函数的生命周期绑定。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(); <span class="comment">// 表示立即执行该函数，如果匿名函数没有被()包裹，则报错。</span></span><br></pre></td></tr></table></figure>
<h1 id="自定义类型的私有变量"><a href="#自定义类型的私有变量" class="headerlink" title="自定义类型的私有变量"></a>自定义类型的私有变量</h1><p>JS的所有属性没有私有概念。但是函数内的变量是局部的，外部不可访问的。<br>可<strong>在构造函数或私有作用域中声明私有变量与方法，在匿名函数中引用外部函数的私有变量，并提供可访问这些方法的特权函数，实现自定义类型的私有变量。</strong></p>
<h2 id="构造函数中创建私有变量"><a href="#构造函数中创建私有变量" class="headerlink" title="构造函数中创建私有变量"></a>构造函数中创建私有变量</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 私有变量与方法</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;syz&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getGender</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;man&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 特权方法获取私有变量</span></span><br><span class="line">    <span class="built_in">this</span>.getInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        name = <span class="string">&quot;xj&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> getGender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以通过匿名函数实现私有变量的<strong>不可修改与直接读取的设定</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保护私有变量，此时Person构造函数的变量name通过闭包访问，形成了每个成员的保护变量</span></span><br><span class="line">    <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h2><p>采用构造函数声明私有变量对每个实例都是唯一的，会造成代码的重复。</p>
<p>对属于类的公共的属性与方法，可以通过静态私有变量的方式私有化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过私有作用域实现私有变量的保存</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 私有变量</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 全局构造函数</span></span><br><span class="line">    Person = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过原型实现静态私有变量</span></span><br><span class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;syz&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// syz</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;xj&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// xj</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.getName()); <span class="comment">// xj</span></span><br></pre></td></tr></table></figure>
<h1 id="单例的私有变量"><a href="#单例的私有变量" class="headerlink" title="单例的私有变量"></a>单例的私有变量</h1><p>JS中的单例很简单。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = &#123;</span><br><span class="line">    description: <span class="string">&quot;I am a singleton&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h2><p>单例可以通过<strong>模块模式</strong>的方式实现变量的私有化。基本思想是<strong>通过将私有变量与方法保存在外部匿名函数的活动对象中，然后返回一个具有特权访问函数的匿名对象。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> application = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 私有变量</span></span><br><span class="line">    <span class="keyword">var</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    components.push(<span class="keyword">new</span> BaseComponent());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放回单例，单例内通过特权方法访问私有变量</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getComponentCount : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">            <span class="keyword">return</span> components.length;</span><br><span class="line">        &#125;,</span><br><span class="line">        registerComponent : <span class="function"><span class="keyword">function</span>(<span class="params">component</span>)</span>&#123; </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">&quot;object&quot;</span>)&#123; </span><br><span class="line">                components.push(component);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(); <span class="comment">// 立即执行函数</span></span><br></pre></td></tr></table></figure>
<h2 id="增强模块模式"><a href="#增强模块模式" class="headerlink" title="增强模块模式"></a>增强模块模式</h2><p>如果想创建指定类型的单例，并为其添加私有变量及增加属性与方法，可采用<strong>增强模块模式</strong>。基本思想与模块模式差不多，只不多不返回匿名对象，而是先创建指定类型的单例对象，然后为该对象添加特权访问函数、增强属性与方法，然后返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> application = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="comment">//私有变量和函数</span></span><br><span class="line">    <span class="keyword">var</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>(); </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    components.push(<span class="keyword">new</span> BaseComponent());</span><br><span class="line">    <span class="comment">//创建 application 的一个局部副本 </span></span><br><span class="line">    <span class="keyword">var</span> app = <span class="keyword">new</span> BaseComponent(); </span><br><span class="line">    <span class="comment">//公共接口</span></span><br><span class="line">    app.getComponentCount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> components.length;</span><br><span class="line">    &#125;;</span><br><span class="line">    app.registerComponent = <span class="function"><span class="keyword">function</span>(<span class="params">component</span>)</span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">&quot;object&quot;</span>)&#123; </span><br><span class="line">            components.push(component);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; <span class="comment">//返回这个副本</span></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的继承</title>
    <url>/JavaScript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="浅述JS继承"><a href="#浅述JS继承" class="headerlink" title="浅述JS继承"></a>浅述JS继承</h1><p>JS作为一门不是很严谨的OO语言，由于其函数没有签名，因此不能实现签名继承的接口形式，却可实现属性与方法的完全继承。</p>
<p>JS的继承方式有六种：<strong>原型链继承、构造函数继承、组合继承、原型式继承、寄生式继承及寄生组合继承。</strong></p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>在JS对象一章讲到了构造函数的<strong>原型对象</strong>，如果一个构造函数的原型对象是另一个构造函数的实例，那么通过该构造函数创建的实例就继承了原型对象对应构造函数的全部属性与方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name= name;</span><br><span class="line">    <span class="built_in">this</span>.color = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链继承</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> SubType(<span class="string">&quot;sg&quot;</span>, <span class="number">26</span>);</span><br><span class="line">sub.sayHello(); <span class="comment">// Hello sg</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubType(<span class="string">&quot;syz&quot;</span>, <span class="number">24</span>);</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> SubType(<span class="string">&quot;xj&quot;</span>, <span class="number">22</span>);</span><br><span class="line">sub1.color.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub2.color); <span class="comment">// [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;black&#x27; ]</span></span><br></pre></td></tr></table></figure>
<p>不足：1. 对于父类的引用类型，在子类中是共享的，因为子类原型对象指向同一父类实例，无法实现与子类的单独绑定。 2. 没有办法在不影响子类的情况下为父类构造函数赋予初始值。</p>
<h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>在子类构造函数中，调用父类构造函数方法，可以实现父类属性（尤其是引用类型）与子类的单独绑定。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name= name;</span><br><span class="line">    <span class="built_in">this</span>.color = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 在SubType执行环境作用域执行父类构造函数的初始化函数</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> SubType(<span class="string">&quot;sg&quot;</span>, <span class="number">26</span>);</span><br><span class="line"><span class="comment">// 原型对象是通过内部指针访问，通过执行函数的方式无法访问</span></span><br><span class="line">sub.sayHello() <span class="comment">//TypeError: subType.sayHello is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubType(<span class="string">&quot;syz&quot;</span>, <span class="number">24</span>);</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> SubType(<span class="string">&quot;xj&quot;</span>, <span class="number">22</span>);</span><br><span class="line">sub1.color.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">sub2.color.push(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.color); <span class="comment">//[ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;black&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.color); <span class="comment">//[ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;yellow&#x27; ]</span></span><br></pre></td></tr></table></figure>
<p>不足：无法复用父类原型对象中公共的属性与方法。</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承就是综合原型链与构造函数的继承方式，结合二者各自的优点，可以继承父类构造函数与原型对象中的属性与方法，且可以实现父类引用类型数据与子类的单独绑定。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name= name;</span><br><span class="line">    <span class="built_in">this</span>.color = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 在SubType执行环境作用域执行父类构造函数的初始化函数</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>, name); <span class="comment">// 第二次调用</span></span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">//第一次调用</span></span><br><span class="line"><span class="comment">// 防止指向父类的构造器</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> SubType(<span class="string">&quot;sg&quot;</span>, <span class="number">26</span>);</span><br><span class="line"><span class="comment">// 原型对象是通过内部指针访问，通过执行函数的方式无法访问</span></span><br><span class="line">sub.sayHello() <span class="comment">// Hello sg</span></span><br></pre></td></tr></table></figure>
<p>不足： 重复调用了两次的父类的构造函数，导致子类原型对象中存储了重复的无用的数据。</p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>如果只想使得某些类表现得像某个类，可以采用原型式继承。即使这些类的原型对象指向同一个对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    name: <span class="string">&quot;syz&quot;</span>, </span><br><span class="line">    friends: [<span class="string">&quot;mzp&quot;</span>, <span class="string">&quot;wjh&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型继承函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = object(Person);</span><br><span class="line">person1.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">person1.friend.push(<span class="string">&quot;lili&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = object(Person);</span><br><span class="line">person1.name = <span class="string">&quot;gad&quot;</span>;</span><br><span class="line">person1.friend.push(<span class="string">&quot;uzi&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// John</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// gad</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends); <span class="comment">// [ &#x27;mzp&#x27;, &#x27;wjh&#x27;, &#x27;lili&#x27;, &#x27;uzi&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// [ &#x27;mzp&#x27;, &#x27;wjh&#x27;, &#x27;lili&#x27;, &#x27;uzi&#x27; ]</span></span><br></pre></td></tr></table></figure></p>
<p>ECMAScript5规范了原型式继承的方式，即采用<font color="#f07c82">Object.create()</font>方法，参数数即要继承的包含共用的属性与方法的对象，第二个参数为可选参数Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。</p>
<p>Object.create()作用与object()方法相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    name: <span class="string">&quot;syz&quot;</span>, </span><br><span class="line">    friends: [<span class="string">&quot;mzp&quot;</span>, <span class="string">&quot;wjh&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="built_in">Object</span>.create(Person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">&quot;xj&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// xj</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends); <span class="comment">// [ &#x27;mzp&#x27;, &#x27;wjh&#x27; ]</span></span><br></pre></td></tr></table></figure>
<h2 id="寄生继承"><a href="#寄生继承" class="headerlink" title="寄生继承"></a>寄生继承</h2><p>寄生继承组合了原型式继承与工厂方法，或者是装饰器模式，可以对原型示例添加装饰方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    name: <span class="string">&quot;syz&quot;</span>, </span><br><span class="line">    friends: [<span class="string">&quot;mzp&quot;</span>, <span class="string">&quot;wjh&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">_name_</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> person = <span class="built_in">Object</span>.create(Person, &#123;</span><br><span class="line">        name: &#123;</span><br><span class="line">            value: _name_</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    person.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = createPerson(<span class="string">&quot;xj&quot;</span>);</span><br><span class="line">person.sayHi(); <span class="comment">// Hi</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// xj</span></span><br></pre></td></tr></table></figure>
<h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><p>是JS继承的<strong>最优解</strong>，通过寄生继承减少了组合继承中多余的父类构造函数调用产生的子类原型对象属性重复的问题。</p>
<p>对于子类的原型对象，采用寄生继承方式继承自父类的原型对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name= name;</span><br><span class="line">    <span class="built_in">this</span>.color = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">    subType.prototype = <span class="built_in">Object</span>.create(superType.prototype);</span><br><span class="line">    subType.prototype.constructor = subType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    SuperType.call(<span class="built_in">this</span>,name);</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType,SubType);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> SubType(<span class="string">&quot;syz&quot;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub.name); <span class="comment">// syz</span></span><br><span class="line"><span class="built_in">console</span>.log(sub.age); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(sub.color); <span class="comment">// [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27; ]</span></span><br><span class="line">sub.sayHello(); <span class="comment">// Hello syz</span></span><br></pre></td></tr></table></figure></p>
<p><strong>完美！</strong></p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的对象</title>
    <url>/JavaScript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="对象的概念"><a href="#对象的概念" class="headerlink" title="对象的概念"></a>对象的概念</h1><p><strong>JS 中的对象其实是无序属性的集合，属性包括基本数据、函数与对象</strong>，每个属性有属性名，属性名与属性值以键值对的形式保存在对象内部。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JS中的一个对象</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&quot;syz&quot;</span>,</span><br><span class="line">    job: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">    sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h1><p>为了JavaScript引擎可以操作对象中的属性，每个属性定义了对应的两种属性类型：</p>
<p><strong>1. 数据属性。</strong>  <strong>2. 访问器属性。</strong></p>
<h2 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h2><p>是对一个对象属性值的操作说明，共有四类说明：<strong>configurable、enumerable、writable及value</strong>。</p>
<p>可通过<font color="#f07c82">Object.defineProperty</font>实现不同属性的值操作限定，接收三个参数，第一个是操作对象、第二个是操作对象的属性第三个是对该属性的操作限定。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&quot;syz&quot;</span>,</span><br><span class="line">    job: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">    age: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    默认true。</span></span><br><span class="line"><span class="comment">    设置为false，则该属性不能被删除，configurable、enumerable、writable(true还可设定为false)不能再设定；</span></span><br><span class="line"><span class="comment">    该属性不能在通过Object.defineProperty()方法修改为访问器属性。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     默认true。</span></span><br><span class="line"><span class="comment">    设置为false，则不能通过for-each方式遍历该属性。</span></span><br><span class="line"><span class="comment">    for(var item in person)&#123;</span></span><br><span class="line"><span class="comment">        console.log(item) // 不会输出person的age属性</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    enumerable: <span class="literal">true</span>, </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*默认true。</span></span><br><span class="line"><span class="comment">    设置为false，则属性值为可读的，严格模式强行修改会报错，一般模式修改无效。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 设置该属性的值</span></span><br><span class="line">    value: <span class="number">25</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><p>访问器属性是对访问对象属性值的操作的说明，共四类：<strong>configurable、enumerable、get及set</strong>。</p>
<p>可通过<font color="#f07c82">Object.defineProperty</font>实现不同属性的值操作限定，接收三个参数，第一个是操作对象、第二个是操作对象的属性第三个是对该属性的操作限定。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&quot;syz&quot;</span>,</span><br><span class="line">    job: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">    _age: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    默认为true。</span></span><br><span class="line"><span class="comment">    设置为false，则该属性不能被删除，该属性不能在通过Object.defineProperty()方法修改为数据属性。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     默认为true。</span></span><br><span class="line"><span class="comment">    设置为false，则不能通过for-each方式遍历该属性。</span></span><br><span class="line"><span class="comment">    for(var item in person)&#123;</span></span><br><span class="line"><span class="comment">        console.log(item) // 不会输出person的age属性</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    enumerable: <span class="literal">true</span>, </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*设置读取该属性时的返回值。</span></span><br><span class="line"><span class="comment">    注意_age前面有 _ 下划线，表示该属性值只能通过对象的方法访问到，也就是get()方法，如果没有定义相应的方法，</span></span><br><span class="line"><span class="comment">    采用person._age访问会返回undefined。</span></span><br><span class="line"><span class="comment">    如果_age前面不加下划线，而又通过get()函数访问this.age的话，会导致函数调用栈溢出.</span></span><br><span class="line"><span class="comment">    因为person.age -&gt; get.call(person) -&gt;this.age -&gt; person.age -&gt; ...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._age;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 改属性赋值时的操作</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>._age = value;</span><br><span class="line">        <span class="keyword">if</span>(value &gt; <span class="number">50</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.job = <span class="string">&quot;rubbish&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="数据属性其它知识"><a href="#数据属性其它知识" class="headerlink" title="数据属性其它知识"></a>数据属性其它知识</h2><ul>
<li>通过<font color="#f07c82">Object.defineProperties()</font>方法一次性为对象的多个属性设置属性类型。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperies(book, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">&quot;machine learning&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    _year: &#123;</span><br><span class="line">        value: <span class="number">2019</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition&#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    year: &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(value&gt;<span class="number">2019</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>._year = value;</span><br><span class="line">                <span class="built_in">this</span>.edition += value - <span class="built_in">this</span>._year;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>通过<font color="#f07c82">Object.getOwnPropertyDescriptor()</font>方法<strong>获得指定对象指定属性的属性类型说明对象。</strong>第一个参数接收查询对象，第二个参数接收对应对象的查询属性的<strong>字符串表示</strong>。该方法只能获取实例对象的属性类型描述对象，对于原型对象，需要调用Person.prototype。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">&quot;year&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.enumrable); <span class="comment">//如果是访问器属性，则返回undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.writable); <span class="comment">//如果是访问器属性，则返回undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.configurable);</span><br></pre></td></tr></table></figure>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>JavaScript中自定义的对象又是怎么创建来的呢？从前面知识，我们了解到，可以通过<strong>构造函数或者对象字面量</strong>的形式创建，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的Object构造函数</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">    name : <span class="string">&quot;syz&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象字面量形式</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name : <span class="string">&quot;syz&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，通过对象字面量形式创建的对象只能是Obejct类型实例，无法满足特定实例的要求。</p>
<p>然后，再看通过构造函数创建的方式。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数其实就是函数的一种，<strong>任何函数都可以是构造函数</strong>，只要在函数前面使用 <font color="#f07c82">new</font> 关键字，就使该函数成为了构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数通常大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;syz&quot;</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<p>前面提到，函数其实也是一种<strong>Funcation类型</strong>的实例对象，加入了new关键字后，函数执行四个步骤:</p>
<ol>
<li>创建一个新对象。</li>
<li>将构造函数的作用域赋给对象，即this的主体换为新对象。</li>
<li>执行构造函数的语句，对新对象执行初始化操作。</li>
<li>返回该对象。</li>
</ol>
<p>构造函数也可以当做普通函数使用，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此时函数的作用域是全局执行环境，因此也就是给windows对象赋予了name及age属性</span></span><br><span class="line">Person(<span class="string">&quot;syz&quot;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="comment">//通过调用call()方法在指定作用域执行,相当于为person对象赋予了姓名与年龄属性</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">Person.call(person, <span class="string">&quot;syz&quot;</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure></p>
<p>通过构造函数创建的对象实例可以通过关键字 <font color="#f07c82">instanceof</font>来判断其是否为某自定义引用类型的对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person <span class="keyword">instanceof</span> Person; <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p>然而，仅通过构造函数创建对象存在弊端。即一些属于类公共部分的属性（尤其是引用类型值）仍需要在每个实例创建过程中重新创建一份副本。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;syz&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;xj&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayHello===person2.sayHello); <span class="comment">// =&gt;false</span></span><br></pre></td></tr></table></figure></p>
<p>因为 sayHello() 方法是 <strong>Function</strong> 类型的实例，尽管其作用在每个对象实例中是相同的，但是在每个对象创建过程中，每个sayHello() 都重新创建一份副本，导致内存资源的浪费。</p>
<p>JS通过构造函数的<strong>原型对象</strong>来解决。</p>
<p><strong>原型对象其实是构造函数的属性之一</strong>，可以通过 <font color="#f07c82">Person.prototype</font> 访问 Person 构造函数原型对象，其中<strong>保存了 Person 类共享的属性与方法</strong>。</p>
<p>原型对象在<strong>每个函数</strong>的创建过程中自动生成，即每个函数自动生成一个 <font color="#f07c82">prototype</font> 属性，指向一个原型对象，该原型对象自动生成一个 <font color="#f07c82">constructor</font>属性，指向构造函数，其<strong>属性类型是不可枚举的</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 为原型兑现赋值</span></span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 还可以用简便的方法为原型对象赋值</span></span><br><span class="line"><span class="comment">Person.prototype = &#123;</span></span><br><span class="line"><span class="comment">    name: &quot;Nicholas&quot;,</span></span><br><span class="line"><span class="comment">    age: 29,</span></span><br><span class="line"><span class="comment">    job: &quot;Software Engineer&quot;,</span></span><br><span class="line"><span class="comment">    sayName: function()&#123;</span></span><br><span class="line"><span class="comment">        alert(this.name);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    /*由于此时完全重写了系统自动生成的的原型对象，所以constroctor属性不再指向Person，而是Object</span></span><br><span class="line"><span class="comment">     此时再用person.constroctor == Person 就返回false,需要重新定义constroctor的指向</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// constructor: Person, 但是此时的constructor属性时可枚举的，可用下列语句修改属性类型</span></span><br><span class="line">    Obeject.defineProperty(Person.prototype, <span class="string">&quot;constroctor&quot;</span>&#123;</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        value: Person</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(); </span><br><span class="line"></span><br><span class="line">person1.sayName(); <span class="comment">//&quot;Nicholas&quot;</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(); </span><br><span class="line">person2.sayName(); <span class="comment">//&quot;Nicholas&quot; </span></span><br><span class="line"></span><br><span class="line">alert(person1.sayName == person2.sayName); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<center><img src="/JavaScript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/prototype.png" class></center>
<center>各对象之间的关系</center>

<p>在一个实例中访问某个属性，首先在实例本身搜索，如果没找到，再通过内部属性[[Property]]找到指向的原型对象，再在其内部寻找。</p>
<p>如果实例内部定义了与原型对象中重名的属性，则读取到该属性即停止搜索。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.height = <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>相关函数<ul>
<li><strong>isPrototypeOf():</strong> 判断某个原型对象是否是某个实例对应的原型对象<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype.isPrototypeOf(person); <span class="comment">// =&gt; ture</span></span><br></pre></td></tr></table></figure></li>
<li><strong>Object.getPrototypeOf():</strong> 获得某个实例的原型对象<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = <span class="built_in">Object</span>.getPrototypeOf(person);</span><br></pre></td></tr></table></figure></li>
<li><strong>hasOwnProperty():</strong> 判断某个属性是来自实例还是原型对象，来自实例返回true<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(persom.hasOwnProperty(<span class="string">&quot;height&quot;</span>)); <span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure></li>
<li><strong>in</strong>: 判断某个实例是否包含某个属性，无论是位于实例本身还是原型对象<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;job&quot;</span> <span class="keyword">in</span> person); <span class="comment">//=&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;height&quot;</span> <span class="keyword">in</span> person); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure></li>
<li><strong>for in:</strong> 遍历所有可枚举属性，无论是位于实例本身还是原型对象<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> person)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item); <span class="comment">// name,height,age,job,sayName</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>Object.keys():</strong> 以字符串数组形式返回实例本身可枚举的属性<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(Person.prototype)); <span class="comment">//[ &#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;, &#x27;sayName&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person)); <span class="comment">//[ &#x27;name&#x27;, &#x27;height&#x27; ]</span></span><br></pre></td></tr></table></figure></li>
<li><strong>getOwnPropertyNames():</strong> 以字符串数组形式返回实例本身所有的属性（包括不可枚举）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype)); <span class="comment">//[ &#x27;constructor&#x27;, &#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;, &#x27;sayName&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(person)); <span class="comment">//[ &#x27;name&#x27;, &#x27;height&#x27; ]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="混合模式创建对象"><a href="#混合模式创建对象" class="headerlink" title="混合模式创建对象"></a>混合模式创建对象</h2><p>通过原型模式可以设置共享的对象类型，通过构造器模式可以为对象的创建赋予初始值，结合二者的混合模式是最常见的创建对象的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constroctor: Person,</span><br><span class="line">    sex: <span class="string">&quot;man&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> Person.sayName != <span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Hello, my name is &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person1 = <span class="keyword">new</span> Person(<span class="string">&quot;syz&quot;</span>, <span class="number">24</span>);</span><br><span class="line">person2 = <span class="keyword">new</span> Person(<span class="string">&quot;xj&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// &quot;syz&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// &quot;xj&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sex); <span class="comment">// &quot;man&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.sex); <span class="comment">// &quot;man&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 101.对称二叉树</title>
    <url>/Leecode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> \   \</span><br><span class="line"> <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>二叉树的一个典型套路就是递归求解。左右树分别对待。</p>
<p>注意递归截止条件以及是否对称的判断条件。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> tryTree(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryTree</span><span class="params">(TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归截止条件</span></span><br><span class="line">        <span class="keyword">if</span>(right==<span class="keyword">null</span>&amp;&amp;left==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>||right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 对称判断条件</span></span><br><span class="line">        <span class="keyword">if</span>(left.val==right.val)</span><br><span class="line">            <span class="keyword">return</span> tryTree(left.left, right.right)&amp;&amp;tryTree(left.right, right.left);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础知识点</title>
    <url>/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="为啥“又”学JavaScript？"><a href="#为啥“又”学JavaScript？" class="headerlink" title="为啥“又”学JavaScript？"></a>为啥“又”学JavaScript？</h1><p>那年头发还多，正是大四上学期。提前联系了导师，由于项目原因，第一次接触到JS。</p>
<p>然后，看了两周左右的入门书籍，入了前端的坑。</p>
<p>结果，自己觉得前端没啥技术含量，跑回去学后端开发，也就是Java开发的一套东西。</p>
<p>看到数据库、并行化编程部分，心态崩了。</p>
<p>自己还是喜欢前端开发。</p>
<p>又滚回来重新学习。</p>
<p>看到网页在自己面前展示，<strong>真TM有意思</strong>。</p>
<h1 id="JavaScript这门语言"><a href="#JavaScript这门语言" class="headerlink" title="JavaScript这门语言"></a>JavaScript这门语言</h1><p><strong>JavaScript</strong>很有趣，比<strong>Java</strong>有趣多了。</p>
<p><strong>Java</strong>好比是一个严谨的大叔，什么都严格要求，准确但无趣。</p>
<p><strong>JavaScript</strong>好比是一个热血青年，喜欢打篮球，生动有趣。</p>
<p>不过JavaScript也不老了，1995年诞生。当时叫这个名字还是蹭Java的热度。。。</p>
<p>JavaScript由三剑客组成：<strong>ECMAScript、DOM、BOM</strong>。</p>
<h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><p>ECMAScript是ECMA-262标准定义的一种语言规范，规定了一门语言的5类部分：<strong>类型、语句、关键字、保留字、操作符及对象。</strong></p>
<p>ECMAScript没有定义任何语言运行的环境要求，只是说明，你按照我这个规范，可以实现一种编程语言。不像Java，规定了虚拟机作为它的运行环境。</p>
<p>浏览器可以作为ECMAScript语言的运行环境，当然Node、Abode Flash也都是。</p>
<p><font color="#f07c82">JavaScript</font>就是一种实现了该标准的语言，同样的Adobe ActionScript也实现了ECMAScript。</p>
<p>因此，JavaScript就是按照 ECMAScript 规定的脚手架搭建起来的房子，所以掌握JavaScript必须要掌握ECMAScript规范。</p>
<blockquote>
<p>最新的ECMAScript标准是2015年6月颁布的《ECMAScript2015标准》简称ES2015，由于比前面版本有了重大改进，因此又被称为ES6.0。每年6月份ES标准委员会会颁布最新的ES标准，而2016年颁布的《ECMAScript2016标准》相比较2015标准改进不大，因此又被称为ES6.1.</p>
</blockquote>
<p>具体ES6标准的讲解后面博客中再讲。</p>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p><font color="#f07c82">DOM, Document Object Model</font>, 文档对象模型，这里指针对HTML的可编程接口。将网页通过层次性节点来表示，如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其实DOM可针对任何XML类语言进行实现，包括 SVG（Scalable Vector Graphic，可伸缩矢量图）1.0等。</p>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p><font color="#f07c82">BOM, Browser Object Model</font>, 浏览器对象模型，使开发人员可以控制浏览器网页页面之外的部分。</p>
<p>比如：弹出新浏览器、移动缩放与关闭浏览器窗口、提供用户显示器分辨率详细信息的screen对象、对cookies支持等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p><font color="#f07c82">ECMAScript</font> 标准为JavaScript提供核心语言功能；</p>
</li>
<li><p><font color="#f07c82">DOM</font> 提供访问与操作网页内容的方法和接口；</p>
</li>
<li><p><font color="#f07c82">BOM</font> 提供操作浏览器的方法和接口。</p>
</li>
</ul>
<h1 id="JS知识点"><a href="#JS知识点" class="headerlink" title="JS知识点"></a>JS知识点</h1><h2 id="在H5中使用JS"><a href="#在H5中使用JS" class="headerlink" title="在H5中使用JS"></a>在H5中使用JS</h2><ul>
<li><p><strong>引入位置：</strong>JS的\<script\>标签放在\<body\>标签内最下方，使浏览器先加载页面再加载JS代码，保证界面流畅。</body\></script\></p>
</li>
<li><p><strong>嵌入外部文件：</strong>尽量不要再 HTML 文件中嵌入JS代码，而是引入JS外部文件的方式。提高可维护性与缓存效率。</p>
</li>
<li><p><strong>严格模式：</strong>在整个脚本顶部或者函数内部上方加上语句<font color="#f07c82">“use strict”</font>。</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    <span class="comment">//函数体，在函数内部执行严格模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2></li>
<li><p><strong>数据类型：</strong>JS一共6中数据类型，5中基本数据类型：<font color="#f07c82">String、Number、Boolean、Null、Undefined</font> 及一种复杂类型 <font color="#f07c82">Object</font>。基本数据类型占据固定的内存大小，存储在栈内存中。引用类型的变量名保存在栈空间中。</p>
<ul>
<li><p>JS的变量只是转递数据的载体，其本身是松散类型，一个变量即可存储字符串又可存储数组。此时需要用<font color="#f07c82">typeof</font>操作符检查数据类型。</p>
</li>
<li><p>简单数据类型<strong>变量与值</strong>都存储在<strong>栈内存(stack)中</strong>。</p>
<ul>
<li>浏览器从电脑内存中开辟一块栈内存，再分配一个主线程自上而下执行程序。</li>
<li>栈内存分为变量存储空间与值存储空间。</li>
<li>赋值语句将两个空间对应的变量与值关联起来。  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let a = 12的赋值过程：</span></span><br><span class="line"><span class="comment">// 1. 首先新建变量a(如没有)，将其存入变量存储空间</span></span><br><span class="line"><span class="comment">// 2. 再新建数值12(如没有)，将其存入值存储空间。</span></span><br><span class="line"><span class="comment">// 3. 再执行赋值操作 = ，将变量a与值12关联。 </span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">let</span> b = a;</span><br><span class="line">    b = <span class="number">13</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>引用数据类型的变量名存储在栈内存中，<strong>值存储在堆内存(heap)</strong>中。<ul>
<li>浏览器从电脑内存中开辟一块栈内存，再分配一个主线程自上而下执行程序。</li>
<li>由于引用数据类型的值非常复杂，因此开辟一块堆内存，每块内存对应一个唯一的内存地址。</li>
<li>赋值操作 = 将变量与堆内存的内存地址关联起来。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c = &#123;</span><br><span class="line">            name: <span class="string">&quot;syz&quot;</span>,</span><br><span class="line">            age: <span class="number">24</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">let</span> d = c;</span><br><span class="line">d.age = <span class="number">256</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a><strong>基本数据类型</strong></h3><ul>
<li><p><strong>String类型</strong></p>
<ul>
<li>不同于Java,它是简单数据类型，但相同点是<strong>它是不可变的</strong>。</li>
<li>任何数据都可转为String类型。通过调用对象的toString方法或者对于Null及Undefined直接返回”null”与”undefined”。</li>
<li>通过 a.toString()转换。</li>
<li>通过String(a, n)转换。n为可选项，当a为数值类型时，n可以指定转换的进制数。</li>
</ul>
</li>
<li><p><strong>Number类型</strong></p>
<ul>
<li>分为浮点值和整型值。浮点值小数点后面必须有数字，否则认为值整型。</li>
<li>浮点值最高精度是17位，因此不要测试某个具体的浮点值，例如<font color="#f07c82">0.3==0.1+0.2<font>。</font></font></li>
<li>Number最大值为<strong>Number.MAX_VALUE</strong>，最小值是<strong>Number.MIN_VALUE</strong>，超出范围则根据正负情况得到<strong>正负Infinity</strong>。</li>
<li>用isFinite()函数判断一个数是不是无穷。</li>
<li>0 / 0 的结果是<strong>NaN</strong>。它不与任何数相等，包括自身。 可用isNaN()判断一个数据是不是数。</li>
<li>parseInt(a, n) 与 parseFloat()可以解析数值。如果字符串前面有数值的话也能被解析出来。</li>
</ul>
</li>
<li><p><strong>Boolean类型</strong></p>
<ul>
<li>可用Boolean()来对任意数值进行转换。</li>
<li>非零及非NaN的数值(包括无限大)为真。</li>
<li>非空的字符串为真。</li>
<li>任何非null的对象为真。</li>
<li>undefined 始终为假。</li>
</ul>
</li>
<li><p><strong>Null与Undefined</strong></p>
<ul>
<li>null表示空指针，即声明了对象指针，但没实例化。</li>
<li>undefined表示没有初始化。</li>
<li>undefined 派生自 null，所以null==undefined,返回true。</li>
</ul>
</li>
<li><p>所有的类型复制都是<strong>值传递</strong>。</p>
<ul>
<li>对于基本类型的复制结果的修改不影响原数据，因为再拷贝了一份。</li>
<li>复杂类型的复制结果是对<strong>其指针的复制</strong>，复制结果的修改会影响原数据。</li>
<li>方法内部传递的复杂类型也是<strong>复制后的指针</strong>。</li>
</ul>
</li>
<li><p>所有<strong>基本数据类型都是不可变的，</strong>即使对相同名字的变量赋值，也是先销毁原先变量再生成新变量。</p>
</li>
<li><p><strong>==与===</strong></p>
<ul>
<li><strong>== 是相等，即判断两者不同时，先进行类型转换。</strong></li>
<li>true转为数值 1， false转为0。</li>
<li>字符串与数值比较，先转为数值。</li>
<li>对象与其它类型数据比较，先调用valueOf()方法将对象转为字符串，再按照上面规则判定。</li>
<li><strong>NaN与任何数据比较都是false。</strong></li>
<li><strong>对象的比较是他们是否指向同一个对象。</strong></li>
<li><p><strong>null==undefined</strong>返回ture。</p>
</li>
<li><p><strong>=== 是全等。如果比较的两者类型不同，则直接返回false。</strong></p>
</li>
</ul>
</li>
<li><p><strong>方法的形参：</strong>命名只是为了操作方便，内部实现不管形参定义，而是利用数组依次存储数据。</p>
<ul>
<li>可调用内部数组arguments读取传入的参数。</li>
<li>JS的方法不存在重载。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> argument[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">arguments</span>[<span class="number">0</span>] + argument[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>) <span class="comment">//输出1</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">//输出3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>执行环境与作用域链</strong></p>
<ul>
<li><p><strong>执行环境：ECMAScript代码运行的环境</strong></p>
<ul>
<li>执行环境用一个与之关联的<strong>变量对象</strong>表示，<strong>环境中所有的变量与函数都保存在该对象内部</strong>。环境对象的生命周期也就是内部变量与函数的声明周期。</li>
<li>全局执行环境是最外围的执行环境，根据宿主环境不同，变量对象也不同。例如Web浏览器中的全局执行环境的变量对象为<font color="#f07c82">windows</font>，浏览器关闭就相当于 windows 变量对象死亡，内部代码也消亡。</li>
<li>每个<strong>函数</strong>也有自己的<strong>执行环境</strong>，进入函数内，函数环境推入<strong>环境栈</strong>，运行完毕弹出环境栈，类似于Java的虚拟机栈，会存在栈溢出错误。</li>
</ul>
</li>
<li><p><strong>作用域链：定义了可访问变量的顺序。</strong></p>
<ul>
<li>全局执行环境变量在最外围。</li>
<li>函数内部变量在最前端，例如arguments。</li>
<li>由前端向根部查找，<strong>找到便不再往后查找，哪怕存在重名变量</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>没有块级作用域</strong></p>
<ul>
<li>与Java等C类语言不同， if或for等块级作用域声明的变量会被加入到全局执行环境中作为全局变量。  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    doSomeThing(i);</span><br><span class="line">&#125;</span><br><span class="line">alert(i); <span class="comment">//输出10</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a><strong>引用数据类型</strong></h3><p><strong>对象其实是某个特定引用类型的实例</strong>，由一组键值对组成 <font color="#f07c82"><code>&#123;[key]:[value]&#125;</code></font>，属性名：属性值。</p>
<ul>
<li><p><strong>Onject类型</strong></p>
<ul>
<li>所有JS的对象类型都基于Object类，因此含有它一切的方法。</li>
<li>hasOwnProperty(“propertyName”): 检查<strong>对象实例中</strong>属性是存在实例自身还是存在于原型对象中。</li>
<li>isPrototypeOf(Object): 检查传入对象是否是传入对象的原型。</li>
<li>toLocalString(): 返回本地环境的对象字符串表示。</li>
<li>toString(): 返回对象的字符串表示。</li>
<li><p>valueOf(): 返回对象的数值、字符串即布尔表示，一般与toString()返回相同。</p>
</li>
<li><p><strong>创建方法</strong>有两种。</p>
<ul>
<li>通过构造函数创建。  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用Object构造函数创建对象</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">// 定义属性</span></span><br><span class="line">obj.name = <span class="string">&quot;syz&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li>通过对象字面量表示法  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过花括号将要赋值内容用的键值对表示</span></span><br><span class="line"><span class="comment">// 空花括号与new Object()作用相当； var obj = &#123;&#125;;</span></span><br><span class="line"><span class="comment">// 属性名可以是字符串、数字</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">&quot;syz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>对象属性访问方式</strong>也有两种<ul>
<li><strong>通过对象加 <code>.</code>方式引用</strong>，但不能引用数字及会导致引用语法错误的字符。  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&quot;syz&quot;</span>,</span><br><span class="line">    age: <span class="number">12</span>,</span><br><span class="line">    <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 访问name及agr属性</span></span><br><span class="line">alert(person.name);</span><br><span class="line">alert(person.age);</span><br><span class="line"><span class="comment">// 但不能访问属性 12， person.12是语法错误</span></span><br></pre></td></tr></table></figure></li>
<li><strong>通过中括号+属性字符串方式引用</strong>，可通过变量访问属性。  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&quot;syz&quot;</span>,</span><br><span class="line">    age: <span class="number">12</span>,</span><br><span class="line">    <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 访问name属性</span></span><br><span class="line">alert(person[<span class="string">&quot;name&quot;</span>]);</span><br><span class="line"><span class="comment">// 访问age属性</span></span><br><span class="line"><span class="keyword">var</span> propertyName = <span class="string">&quot;age&quot;</span>;</span><br><span class="line">alert(person[propertyName]);</span><br><span class="line"><span class="comment">//访问12属性</span></span><br><span class="line">alert(person[<span class="string">&quot;12&quot;</span>]);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Array类型</strong><br>JS的数组比Java的强大太多，不仅可以支持类似于Python的切片功能，而且还可以模拟队列、栈等数据结构，还能够很方便的实现数组的迭代、拼接、插入、删除等功能。</p>
<ul>
<li><strong>新建Array</strong>有两种方式。<ul>
<li>通过Array构造函数创建，可<strong>省略new关键字</strong>。  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr0 = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 构建数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="built_in">Array</span>(<span class="number">5</span>); <span class="comment">// 预定义长度为5的数组，每一项为 undefined</span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="built_in">Array</span>(<span class="string">&quot;1&quot;</span>,<span class="number">2</span>,<span class="string">&quot;test&quot;</span>); <span class="comment">// 可以存储任何类型的数据，且长度是动态扩展的</span></span><br></pre></td></tr></table></figure></li>
<li>通过数组字面量表示法  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="string">&quot;test&quot;</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>数组的<strong>length属性</strong><br>  数组的length属性不是可读的，可以控制它实现数据的删除与扩展操作。  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.length = <span class="number">2</span>;</span><br><span class="line">alert(arr[<span class="number">2</span>]); <span class="comment">// 返回unfefined</span></span><br><span class="line">arr.length = <span class="number">99</span>; <span class="comment">// 2-98位置都为undefined</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>检查数组</strong></p>
<ul>
<li>由于全局执行环境可能有多种（框架多种），不同环境的Array定义不同，所以采用 <font color="#f07c82">instanceOf Array</font>可能有错误。</li>
<li>采用<font color="#f07c82">Array.isArray()</font>方法来判断。</li>
</ul>
</li>
<li><p><strong>打印数组</strong></p>
<ul>
<li>调用toString()打印（默认采用）;</li>
<li>采用join(“||”)打印，里面接收分隔符。  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">alert(a.join(<span class="string">&quot;||&quot;</span>)); <span class="comment">//打印 1||2||3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>数组的<strong>类栈</strong>操作</p>
<ul>
<li>push()方法入栈，返回数组长度</li>
<li>pop()方法出栈，移除并返回数组最后一个元素</li>
</ul>
</li>
<li><p>数组的<strong>类队列</strong>操作</p>
<ul>
<li>push()方法入队列</li>
<li>shift()方法出队列，即移除并返回数组第一个元素</li>
<li>unshift()方法反向入队列，即在数据第一个位置插入，并返回数组长度</li>
<li>pop()方法反向出队列，移除并返回数组最后一个元素</li>
</ul>
</li>
<li><p>数组<strong>拼接、切片、插入与删除</strong></p>
<ul>
<li><strong>concat()函数</strong>实现拼接新元素，并返回新数组<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.concat(<span class="string">&quot;3&quot;</span>,[<span class="string">&quot;string&quot;</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//打印 1,2,3,3,string,4,5</span></span><br></pre></td></tr></table></figure>
-<strong>slice(startIndex, endIndex)函数</strong>实现数组切片,返回新数组<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.slice(<span class="number">1</span>,<span class="number">3</span>); </span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// 输出[2,3]</span></span><br><span class="line"></span><br><span class="line">arr2 = arr.slice(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// 输出[4,5],默认从位置3开始切片到末尾</span></span><br><span class="line"></span><br><span class="line">arr2 = arr.slice(-<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// 输出[5],从最后的位置开始切片</span></span><br><span class="line"></span><br><span class="line">arr2 = arr.slice(-<span class="number">3</span>,-<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// 输出[3, 4],从倒数第3位置开始切分，不包括倒数第一位置的数</span></span><br></pre></td></tr></table></figure></li>
<li><strong>splice(startIndex, removeNum, insertElement)方法</strong>插入与删除元素，返回删除的数据<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr.splice(<span class="number">0</span>, <span class="number">0</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//输出[ [ 1, 2, 3 ], 1, 2, 3, 4, 5 ]， 即在首位插入[1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> deleteEle = arr.splice(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// 输出 [1]，即从第二个位置删除4项</span></span><br><span class="line"><span class="built_in">console</span>.log(deleteEle);  <span class="comment">// 输出[2,3,4,5]，即删除的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;insertEle&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// 输出[ 1,&#x27;insertEle&#x27;, 4, 5 ]，即从第位置1删除两项并在位置1开始插入&quot;insertEle&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>数组的排序</strong><ul>
<li><strong>reverse()函数</strong>，颠倒数组<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a.reverse()); <span class="comment">//输出[3,2,1]</span></span><br></pre></td></tr></table></figure></li>
<li><strong>sort()函数</strong>，排序数组，默认是先把元素转为字符串，然后排序<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认字符串排序</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a.sort()); <span class="comment">//输出[ 1, 10, 15, 20, 5 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传入比较函数，实现自定义排序</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等 则返回 0，如果第</span></span><br><span class="line"><span class="comment">一个参数应该位于第二个之后则返回一个正数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">v1, v2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 逆序</span></span><br><span class="line">    <span class="keyword">return</span> v2-v1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.sort(compare)); <span class="comment">//输出[[ 20, 15, 10, 5, 1 ]]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>数组元素位置查询</strong><ul>
<li>indexOf(searchLocation)，从指定位置顺序查询</li>
<li>lastIndexOf(searchLocation)，从指定位置逆序查询</li>
</ul>
</li>
<li><strong>数组迭代</strong><br>每个迭代方法都接收两个参数：<strong>要在每一项上运行的函数和（可选的）运行该函数的作用域对象</strong>——影响 this 的值。传入这些方法中的函数会接收三个参数：<strong>数组项的值、该项在数组中的位置和数组对象本身</strong>。<ul>
<li><strong>every()</strong>：对数组中的每一项运行给定函数，如果该函数对<strong>每一项</strong>都返回 true，则返回 true。 </li>
<li><strong>filter()</strong>：对数组中的每一项运行给定函数，<strong>返回该函数会返回 true 的项组成的数组</strong>。 </li>
<li><strong>forEach()</strong>：对数组中的每一项运行给定函数。这个方法没有返回值。 </li>
<li><strong>map()</strong>：对数组中的每一项运行给定函数，返回<strong>每次函数调用的结果组成的数组</strong>。 </li>
<li><strong>some()</strong>：对数组中的每一项运行给定函数，如果该函数对<strong>任一项</strong>返回 true，则返回 true。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// every</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> everyResult = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;); </span><br><span class="line">alert(everyResult); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// some</span></span><br><span class="line"><span class="keyword">var</span> someResult = numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;); </span><br><span class="line">alert(someResult); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> filterResult = numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;); </span><br><span class="line">alert(filterResult); <span class="comment">//[3,4,5,4,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> mapResult = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;); </span><br><span class="line">alert(mapResult); <span class="comment">//[2,4,6,8,10,8,6,4,2]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>数组归并</strong><br>两个归并数组的方法：<strong>reduce()和 reduceRight()</strong>。归并元素生成一个值。<br>两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。<br>传给 reduce()和 reduceRight()的函数接收4个参数：<strong>前一个值、当前值、项的索引和数组对象。</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;); </span><br><span class="line">alert(sum); <span class="comment">//15</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>Function类型</strong><br>所有的函数都是Function类型的实例，因此函数名也就是实例的指针，函数可以拥有方法和属性，函数也可以作为参数传入另一个函数或对象中，就跟一个对象没区别。<ul>
<li><strong>创建函数</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用函数声明定义函数,此时存在函数声明提升的过程。即在代码还没运行前，</span></span><br><span class="line"><span class="comment">将函数声明的函数解析并放到代码树的顶端，以供后面的代码使用。*/</span></span><br><span class="line">alert(sum1(<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">//可以执行，因为sum1已经被提升到最前端</span></span><br><span class="line"><span class="comment">// 函数声明方式创建</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum1</span>(<span class="params">d1, d2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d1 + d2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式创建</span></span><br><span class="line"><span class="comment">// alert(sum(1, 2)) 报错，因为函数表达式不会有函数提升过程</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">d1, d2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d1 + d2;</span><br><span class="line">&#125;; <span class="comment">//有分号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数可以作为 对象/参数 传入函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apply</span>(<span class="params">fc, num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fc(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">d1, d2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d1 + d2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(apply(sum,<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">// 输出3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><strong>apply()与call()方法</strong><br><strong>两个都是Function除Object对象自带函数外内置的另外两个函数，作用是在指定的环境中运行某函数</strong>，两个方法接收两个参数，第一个表示当前环境的指针，另一个表示传入的参数。区别是，apply第二个可以是参数属性arguments或者是数组，而call()必须是参数依次列出。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// apply应用场景</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> sum.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> sum.apply(<span class="built_in">this</span>, [num1, num2]);</span><br><span class="line">&#125;</span><br><span class="line">alert(callSum1(<span class="number">10</span>,<span class="number">10</span>)); </span><br><span class="line">alert(callSum2(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// call应用场景</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> sum.call(<span class="built_in">this</span>, num1, num2);</span><br><span class="line">&#125; </span><br><span class="line">alert(callSum(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply在指定环境运行函数</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span>:<span class="string">&quot;blue&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.color;</span><br><span class="line">&#125;</span><br><span class="line">alert(sayColor()); <span class="comment">//red</span></span><br><span class="line">alert(sayColor.call(<span class="built_in">this</span>)); <span class="comment">// red 全局执行环境，即windows</span></span><br><span class="line">alert(sayColor.call(whidows)); <span class="comment">// red 全局执行环境</span></span><br><span class="line">alert(sayColor.call(o)); <span class="comment">// blue 执行环境为对象o</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>arguments对象与this对象</strong></p>
<ul>
<li>arguments表示传入的参数数组，该对象具有属性length及callee。<ul>
<li>lenght属性查看传入参数的数量。</li>
<li><strong>callee，获得包含arguments的函数指针</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阶乘函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">1</span>) <span class="keyword">return</span> num;</span><br><span class="line">    <span class="comment">// 与函数名解耦</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>.callee(num-<span class="number">1</span>)*num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fc2 = factorial;</span><br><span class="line">alert(fc2(<span class="number">10</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>this对象指向表示函数的执行环境的对象。</strong></li>
</ul>
</li>
<li><p><strong>length与prototype属性</strong></p>
<ul>
<li>length表示函数<strong>希望</strong>接收的参数个数。</li>
<li>prototype保存函数的所有实例方法。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>基本包装类型</strong></li>
</ul>
<p><strong>JS在生成一个基本类型数据时，同时产生一个基本包装类型，为读取基本数据的一些操作提供执行方法的入口。</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Hello JS&quot;</span>；</span><br><span class="line">str.substring(<span class="number">0</span>,<span class="number">5</span>)；</span><br><span class="line">str.name = <span class="string">&quot;str&quot;</span>;</span><br><span class="line">alert(str.name); <span class="comment">//输出undefined，因为执行完毕后立即销毁该包装类型对象</span></span><br></pre></td></tr></table></figure><br>上面的例子生成一个string类型的基本数据，但是调用substring()方法时，是调用的同时生成的基本包装类型String对象内的方法。在执行完毕后该对象立马销毁。</p>
<p>基本包装类型有Boolean、Number和String，都有Object内置的toString()、toLocalString()以及valueOf()等方法。</p>
<ul>
<li><strong>String包装类型内置方法</strong><ul>
<li>三种切片方法substring、slice及substr，返回新的字符串<ul>
<li><strong>substring(startIndex, endIndex):</strong>在索引都是正数时，与slice()一样，但是遇到负数取零。</li>
<li><strong>slice(startIndex, endIndex):</strong>与数组切片方法一致。</li>
<li><strong>substr(startIndex, cut_length):</strong> 第一个切片起点，第二个切片长度，长度为负数时返回空字符串””。</li>
</ul>
</li>
<li><strong>charAt()与charCodeAt():</strong> 分别返回所在位置的字符及字符编码。</li>
<li><strong>length:</strong> 放回字符数量。</li>
<li><strong>concat():</strong> 拼接字符串，返回新字符串。</li>
<li><strong>split():</strong> 用指定字符切割字符串，第一个参数是切割字符，第二个可选参数为返回数组的长度。</li>
<li><strong>match()与search():</strong> 子字符串的查找。</li>
</ul>
</li>
<li><strong>Number包装类型</strong><ul>
<li>toFixed(n): 精确到小数点后n位。</li>
<li>toExponential(n): 用指数表示法表示，n为精确的小数点位数。</li>
<li>toPrecision(n): n为显示数值的位数，根据情况调用toFixed()或toExponential()方法。</li>
</ul>
</li>
<li><del>Boolean包装类型</del><br>不推荐使用。</li>
</ul>
<ul>
<li><strong>Global对象与Math对象</strong></li>
</ul>
<p>全局对象Global是JS最终的“兜底”对象，所有对象包含在其内部，不属于其它方法(如isNaN()、isFinite())与属性(如NaN、undifined)都属于它的方法与属性。例如windows对象就是一个全局对象。</p>
<center><img src="/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/fun_global.png" class></center>

<center>**Global对象的属性**</center>

<p>Math对象是为数学运算设计的，包括常用的max()、min()、ceil()、floor()、round()及random()方法等。其中，max()与min()与java不同的是，可以比较获得所有数据的最大值与最小值。</p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>JavaScript是按照ECMAScript语言标准设计，可操作DOM、BOM接口与方法的一门前端语言。</p>
</li>
<li><p>JavaScript数据类型分为五种基本数据类型与引用数据类型。</p>
</li>
<li><p>基本数据类型存储在栈内存中，且是final的，即不可修改。</p>
</li>
<li><p>引用数据类型的变量名存储在栈内存中存储实例的指针，内容存储在堆内存中，以键值对方式保存。</p>
</li>
<li><p>JavaScript语言的类型都是松散型的，且为顺序执行。</p>
</li>
</ol>
<p><strong><font color="#f07c82">让我们拥抱JS，一起迎接大前端时代吧！</font></strong></p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式：Java创建对象</title>
    <url>/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="使用静态工厂方法代替构造方法"><a href="#使用静态工厂方法代替构造方法" class="headerlink" title="使用静态工厂方法代替构造方法"></a>使用静态工厂方法代替构造方法</h1><p>静态工厂方法是一个静态方法，用来生成实例。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="comment">// 私有方法防止在外调用创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> class <span class="title">Inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.dog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为构造方法每次调用都需要<font color="#f07c82">新建一个对象</font>，有些情况下不能满我们的要求。</p>
<p>而静态工厂方法生成对象有以下几个好处：</p>
<p><strong>1. 名字更有意义。</strong></p>
<ul>
<li><font color="#f07c82">from</font> —— 类型转换方法，它接受单个参数并返回此类型的相应实例，例如：Date d = Date.from(instant);</li>
<li><font color="#f07c82">of</font> —— 聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起，例如：Set faceCards = EnumSet.of(JACK, QUEEN, KING);</li>
<li><font color="#f07c82">valueOf</font> —— from 和 to 更为详细的替代 方式，例如：BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</li>
<li><font color="#f07c82">instance 或 getinstance</font> —— 返回一个由其参数 (如果有的话) 描述的实例，但不能说它具有相同的值，例如：StackWalker luke = StackWalker.getInstance(options);</li>
<li><font color="#f07c82">create 或 newInstance</font> —— 与 instance 或 getInstance 类似，除此之外该方法保证每次调用返回一个新的实例，例如：Object newArray = Array.newInstance(classObject, arrayLen);</li>
<li><font color="#f07c82">getType</font> —— 与 getInstance 类似，但是在工厂方法处于不同的类中的时候使用。getType 中的 Type 是工厂方法返回的对象类型，例如：FileStore fs = Files.getFileStore(path);</li>
<li><font color="#f07c82">newType</font> —— 与 newInstance 类似，但是在工厂方法处于不同的类中的时候使用。newType中的 Type 是工厂方法返回的对象类型，例如：BufferedReader br = Files.newBufferedReader(path);</li>
<li><font color="#f07c82">type —— getType 和 newType</font> 简洁的替代方式，例如：List litany = Collections.list(legacyLitany);</li>
</ul>
<p><strong>2. 可以实现实例数量的控制。</strong></p>
<p>例如单例、不可实例化类的实现。</p>
<p><strong>3. 返回的对象可以根据参数不同而不同。</strong></p>
<p><strong>4. 返回的实例可以没有对应的对象类型。</strong></p>
<p>例如服务者提供框架，就是用到静态工厂方法。</p>
<p>服务接口，表示实现；提供者注册API，选择实现；服务访问API，客户端调用。服务提供者接口，描述生成服务接口实例的工厂对象。</p>
<font color="#f07c82">依赖注入框架</font>可以被看作强大的服务提供者。

# 当构造函数多时使用**builder**模式

构造函数名字都与类名一样，区分不同构造函数依靠参数的顺序与数量。

当构造参数很多时，实例的生成非常麻烦，往往不知道调用哪个构造函数。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span>  <span class="keyword">int</span> calories;</span><br><span class="line">        <span class="keyword">private</span>  <span class="keyword">int</span> fat;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> calories)</span></span>&#123;</span><br><span class="line">            calories = calories;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> fat)</span></span>&#123;</span><br><span class="line">            fat = fat;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servingSize = builder.servingSize;</span><br><span class="line">        <span class="keyword">this</span>.calories = builder.calories;</span><br><span class="line">        <span class="keyword">this</span>.fat = builder.fat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NutritionFacts coca = NutritionFacts.Builder(<span class="number">10</span>).calories(<span class="number">40</span>).fat(<span class="number">0</span>).build();</span><br></pre></td></tr></table></figure>

**使用场景：**

当设计类的构造方法或静态工厂的参数超过几个时，Builder 模式是一个不错的选择，特别是如果许多参数是可选的或相同类型的。

# 单例模式

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 懒汉模式，线程不安全，不是严格意义上单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Dog dog;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dog==<span class="keyword">null</span>)</span><br><span class="line">            dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉模式，线程安全，但易产生垃圾</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类方式，线程安全，但是序列化要保证单例，需要重写 readResolve()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> class <span class="title">Inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化也保证一个单类</span></span><br><span class="line">    <span class="function">Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举模式，最简单，但不常用。线程安全，且保证序列化唯一性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Dog.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

# 使用私有构造方法非实例化

构造方法声明为私有方法，可以创建非实例化类。

该类存在的意义就是提供工具静态方法，例如 <font color="#f07c82">java.util.Arrays</font> 工具类等。

# 简单依赖注入

通过构造方法把**类依赖**的**客户端资源**注入到类中，是依赖注入的一种方式。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Chinese dictionary;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">(Chinese dictionary)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dictionary = Object.requireNonNull(dictionary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

可以通过依赖注入把同一子类的资源工厂当做参数。

<font color="#f07c82">工厂就是可以被重复调用生产实例的对象。</font>

<p>Java 8的函数式接口<font color="#f07c82">Supplier<T></T></font>非常适合工厂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 用来提供对象</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Mosaic <span class="title">create</span><span class="params">(Supplier&lt;T? extends Tile&gt; tileFactroy)</span></span>&#123;..&#125;</span><br></pre></td></tr></table></figure>
<h1 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h1><p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子1</span></span><br><span class="line">Integer it = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++)&#123;</span><br><span class="line">    <span class="comment">// 创建了1000000对象</span></span><br><span class="line">    it += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子2</span></span><br><span class="line"><span class="comment">// 多创建了一个String</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;moreClass&quot;</span>);</span><br></pre></td></tr></table></figure>
<font color="#f07c82">原则：</font>

<p><strong>尽量使用基本类型而不使用装箱的基本类型，即使自动装箱也要考虑。</strong></p>
<h1 id="消除过期的对象引用。"><a href="#消除过期的对象引用。" class="headerlink" title="消除过期的对象引用。"></a>消除过期的对象引用。</h1><p>如果对象引用是隐式存在，如果不需要，则置为<strong>null</strong>。</p>
<p>例如编写stack类pop()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; pop()&#123;</span><br><span class="line">    &lt;T&gt; result = bucket[--size];</span><br><span class="line">    bucket[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="避免使用Finalizer和Cleaner机制！"><a href="#避免使用Finalizer和Cleaner机制！" class="headerlink" title="避免使用Finalizer和Cleaner机制！"></a><strong>避免使用<font color="#f07c82">Finalizer</font>和<font color="#f07c82">Cleaner</font>机制！</strong></h1><p><strong>参考：</strong> <u><a href="https://sjsdfg.github.io/effective-java-3rd-chinese/#/">https://sjsdfg.github.io/effective-java-3rd-chinese/#/</a></u></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 155.最小栈</title>
    <url>/Leecode-155-%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) — 将元素 x 推入栈中。<br>pop() — 删除栈顶的元素。<br>top() — 获取栈顶元素。<br>getMin() — 检索栈中的最小元素。</p>
<p><strong>示例:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(-<span class="number">2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(-<span class="number">3</span>);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -<span class="number">3.</span></span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 <span class="number">0.</span></span><br><span class="line">minStack.getMin();   --&gt; 返回 -<span class="number">2.</span></span><br></pre></td></tr></table></figure></p>
<h1 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h1><p>可以用两个栈，一个栈用来维护当前栈内最小的元素，一个栈用来维度当前栈内的元素。</p>
<p>属于投机取巧的方法。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(minStack.isEmpty() || x &lt;= minStack.peek())&#123;</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意，peek()方法返回的是Integer对象，而java在比较Integer时数据范围在-128~127用 == 比较是相等的，但是</span></span><br><span class="line">        <span class="comment">// 超过这个范围就是不相等的。这是因为常量池范围内地Integer对象都是同一个，而 == 是比较对象是否为同一个对象</span></span><br><span class="line">        <span class="comment">// 如果比较数值是否相等，应该采用Integer重写的equals()方法!!!</span></span><br><span class="line">        <span class="keyword">if</span>(stack.peek().equals(minStack.peek()))&#123;</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h1><p>自己用数组实现元素栈与存储最小元素的栈。</p>
<p>要点，数组的自动扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] minValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minValue = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        index = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        <span class="keyword">if</span>(++index&gt;data.length-<span class="number">1</span>)</span><br><span class="line">            resize();</span><br><span class="line">        data[index] = x;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span> || x &lt;minValue[index-<span class="number">1</span>])&#123;</span><br><span class="line">            minValue[index]=x;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minValue[index] = minValue[index-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minValue[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] newdata = <span class="keyword">new</span> <span class="keyword">int</span>[data.length*<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span>[] newMinValue = <span class="keyword">new</span> <span class="keyword">int</span>[data.length*<span class="number">2</span>];</span><br><span class="line">        System.arraycopy(data,<span class="number">0</span>,newdata,<span class="number">0</span>,data.length);</span><br><span class="line">        System.arraycopy(minValue,<span class="number">0</span>,newMinValue,<span class="number">0</span>,minValue.length);</span><br><span class="line">        data = newdata;</span><br><span class="line">        minValue = newMinValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minValue = Integer.MAX_VALUE;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        index = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        <span class="keyword">if</span>(++index&gt;data.length-<span class="number">1</span>)</span><br><span class="line">            data = Arrays.copyOf(data, data.length*<span class="number">2</span>);</span><br><span class="line">        data[index] = x;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; minValue)&#123;</span><br><span class="line">            minValue = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        index--;</span><br><span class="line">        <span class="keyword">if</span>(data[index+<span class="number">1</span>]==minValue)&#123;</span><br><span class="line">            minValue = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=index; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(data[i]&lt;minValue)&#123;</span><br><span class="line">                     minValue = data[i];</span><br><span class="line">                &#125;     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minValue;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/min-stack">https://leetcode-cn.com/problems/min-stack</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 198.打家劫舍</title>
    <url>/Leecode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p><strong>示例1：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">1</span>) ，然后偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">3</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">12</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">2</span>), 偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">9</span>)，接着偷窃 <span class="number">5</span> 号房屋 (金额 = <span class="number">1</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>动态规划</p>
<p>用一个数组维护截止到当前偷窃的最大值。更新条件：dp[i]=max(nums[i]+dp[i-1], dp[i-1])。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span> ) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;len; i++)&#123;</span><br><span class="line">            dp[i] = Math.max(nums[i]+dp[i-<span class="number">2</span>], dp[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/house-robber">https://leetcode-cn.com/problems/house-robber</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 53.最大子序和</title>
    <url>/Leecode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>],</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 连续子数组 [<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span>。</span><br></pre></td></tr></table></figure>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>动态规划。</p>
<p>用一个数组维护一个包含当前数字的最大子序列，取该数组的最大值即为结果。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>]+nums[i], nums[i]);</span><br><span class="line">            result = Math.max(dp[i], result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/maximum-subarray/">题目链接</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 234.回文链表</title>
    <url>/Leecode-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请判断一个链表是否为回文链表。</p>
<p><strong>示例1：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure><br><strong>进阶：</strong></p>
<blockquote>
<p>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>用 <strong>栈+快慢指针</strong> 或者 <strong>快慢指针+反转链表</strong></p>
<p>快慢指针是用来寻找中间节点。栈是用来反转链表。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ol>
<li>栈 + 快慢指针</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 栈用来反转链表</span></span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode low = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;      </span><br><span class="line">            stack.push(low);</span><br><span class="line">            low = low.next;</span><br><span class="line">            <span class="comment">// 奇数链表中间位置需要往后移动一位</span></span><br><span class="line">            <span class="keyword">if</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next==<span class="keyword">null</span>)</span><br><span class="line">                low = low.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环遍历前后链表是否相等</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.pop().val!=low.val) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            low = low.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>快慢指针 + 反转链表</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode low = head;</span><br><span class="line">        <span class="comment">// 快慢指针找到中间点</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;      </span><br><span class="line">            low = low.next;</span><br><span class="line">            <span class="keyword">if</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next==<span class="keyword">null</span>)</span><br><span class="line">                low = low.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode compNode = reverseLinkedList(low);</span><br><span class="line">        <span class="comment">// 链表前后判断</span></span><br><span class="line">        <span class="keyword">while</span>(compNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(compNode.val!=head.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            compNode = compNode.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseLinkedList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode preNode = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curNode = head;</span><br><span class="line">        <span class="keyword">while</span>(curNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp = curNode.next;</span><br><span class="line">            curNode.next = preNode;</span><br><span class="line">            preNode = curNode;</span><br><span class="line">            curNode = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">题目链接</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 48.旋转图像</title>
    <url>/Leecode-48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个 n × n 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p>说明：</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<p><strong>示例1：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>,<span class="number">11</span>],</span><br><span class="line">  [ <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>,<span class="number">10</span>],</span><br><span class="line">  [<span class="number">13</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">16</span>]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">13</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">14</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">12</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">  [<span class="number">16</span>, <span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>如果可以拷贝矩阵，则可以每一行与每一列同时旋转。</p>
<p>但是要求在原矩阵中操作，所以需要每一个元素进行位置旋转变换。</p>
<p>一个4*4的矩阵如下图所示：</p>
<img src="/Leecode-48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/rotate.png" class>
<p>顺时针旋转即相同颜色的元素进行依次替换。</p>
<p><strong>对于四阶矩阵，先从最外圈i=0开始，到里圈i=1结束。n+1阶矩阵从最外圈i=0开始，i=n/2里圈结束。</strong></p>
<p><strong>每j圈依次从j行第i个元素开始，n-i个元素结束。</strong></p>
<p><strong>四个元素互换条件：</strong></p>
<pre><code>tmp = matrix[j][n-i];
matrix[j][n-i] = matrix[i][j];
matrix[i][j] = matrix[n-j][i];
matrix[n-j][i] = matrix[n-i][n-j];
matrix[n-i][n-j] = tmp;
</code></pre><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="comment">// 循环几圈</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//  每一圈要交换几轮</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n-i;j++)&#123;</span><br><span class="line">                <span class="comment">// 四个元素依次交换</span></span><br><span class="line">                tmp = matrix[j][n-i];</span><br><span class="line">                matrix[j][n-i] = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n-j][i];</span><br><span class="line">                matrix[n-j][i] = matrix[n-i][n-j];</span><br><span class="line">                matrix[n-i][n-j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotate-image">https://leetcode-cn.com/problems/rotate-image</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 448.找到所有数组中消失的数字</title>
    <url>/Leecode-448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p>
<p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<p><strong>示例：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>将出现数字位置的数置为负数。</p>
<p>关键点：置负数时一定<strong>取绝对值后取负数</strong>，否则会出现负负得正的情况。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[-<span class="number">2</span>,-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            nums[Math.abs(nums[i])-<span class="number">1</span>] = -Math.abs(nums[Math.abs(nums[i])-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array">https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 538.二叉搜索树转换为累加树</title>
    <url>/Leecode-538-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
<p>二叉搜索树：它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>因为二叉搜索树左子树、根节点及右子树已经拍好顺序，所以只需遍历右子树计算累加值，然后对根节点与左子树分别累加。</p>
<p>可采用递归或遍历方法。首先累加右子树数值，然后依次修改根节点与左子树的数值。</p>
<h1 id="代码1-递归"><a href="#代码1-递归" class="headerlink" title="代码1 递归"></a>代码1 递归</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        convertBST(root.right);</span><br><span class="line">        root.val +=sum;</span><br><span class="line">        sum = root.val;</span><br><span class="line">        convertBST(root.left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代码2-遍历"><a href="#代码2-遍历" class="headerlink" title="代码2 遍历"></a>代码2 遍历</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; rightNodeStack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span> || !rightNodeStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                rightNodeStack.add(node);</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">            node = rightNodeStack.pop();</span><br><span class="line">            node.val += sum;</span><br><span class="line">            sum = node.val;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree">题目链接</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 70.爬楼梯</title>
    <url>/Leecode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p><strong>示例1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入： <span class="number">2</span></span><br><span class="line">输出： <span class="number">2</span></span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">2</span> 阶</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入： <span class="number">3</span></span><br><span class="line">输出： <span class="number">3</span></span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span>  <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>递归或者动态规划。</p>
<p>第n阶楼梯的走法 = 第n-1阶楼梯走法 + 第n阶楼梯走法。</p>
<p>边界条件，n&lt;=3。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            dp[i] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;n; i++)&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">2</span>]+dp[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> climbStairs(n-<span class="number">2</span>) + climbStairs(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 114.二叉树展开为链表</title>
    <url>/LeetCode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个二叉树，原地将它展开为链表。</p>
<p>例如，给定二叉树：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>将其展开为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h1 id="题解-思路"><a href="#题解-思路" class="headerlink" title="题解 + 思路"></a>题解 + 思路</h1><p>一开始想的是递归，但是递归是由底向顶递归生成，而这道题是由顶到底生成，虽然存在子问题，但是仍难以求解。</p>
<p>其实可以看做如下步骤：</p>
<ol>
<li>找到左子树的最右节点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>
<ol>
<li>将右子树移到左子树的最右节点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / </span><br><span class="line">  <span class="number">2</span>   </span><br><span class="line"> / \   </span><br><span class="line"><span class="number">3</span>   <span class="number">4</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">5</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">6</span></span><br></pre></td></tr></table></figure>
<ol>
<li>右子树换为左子树，左子树置为 null</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span>   </span><br><span class="line"> / \   </span><br><span class="line"><span class="number">3</span>   <span class="number">4</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">5</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">6</span></span><br></pre></td></tr></table></figure>
<ol>
<li>从右节点开始，继续该操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span>   </span><br><span class="line">   \   </span><br><span class="line">    <span class="number">4</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">5</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(root.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">               root=root.right;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               TreeNode pre  = root.left;</span><br><span class="line">               <span class="keyword">while</span>(pre.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                   pre = pre.right;</span><br><span class="line">               &#125;</span><br><span class="line">               pre.right = root.right;</span><br><span class="line">               root.right = root.left;</span><br><span class="line">               root.left = <span class="keyword">null</span>;</span><br><span class="line">               root = root.right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 15.三数之和</title>
    <url>/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如, 给定数组 nums = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路+代码"></a>思路+代码</h1><p>先<font color="#f07c82">排序</font>，然后三数之和等于零必定有<font color="#f07c82"> 1 到 2 </font>个小于零，<font color="#f07c82"> 1 到 2 </font>个大于零。</p>
<p>然后我们采用<font color="#f07c82">双指针</font>，先固定最小的一个数（负值）；然后双指针再后面区间寻找两个数，与前面数相加等于零。</p>
<p><font color="#f07c82">注意：</font>因为不能包含重复三元组，在遍历过程中注意去重。<font color="#f07c82">保证每次遍历的数字与前面不一样即可</font>（因为排序了）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">// 排序求解</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 循环求解</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="comment">// 此时没有满足条件的情况</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 避免重复计算</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> j=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> k=len-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]+nums[k]==-nums[i])&#123;</span><br><span class="line">                    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">                    list.add(nums[j]);</span><br><span class="line">                    list.add(nums[k]);</span><br><span class="line">                    res.add(list);</span><br><span class="line">                    <span class="comment">// 跳过重复的数字</span></span><br><span class="line">                    <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[j]==nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[k]==nums[k-<span class="number">1</span>])&#123;</span><br><span class="line">                        k--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j++;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[j]+nums[k]&lt;-nums[i])&#123;</span><br><span class="line">                    <span class="comment">// 左边负值大了</span></span><br><span class="line">                    j++;</span><br><span class="line">                    </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 右边正值大了</span></span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/3sum">https://leetcode-cn.com/problems/3sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1143.最长公共子序列</title>
    <url>/LeetCode-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>
<p>若这两个字符串没有公共子序列，则返回 0。</p>
<p>示例 1:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：text1 = <span class="string">&quot;abcde&quot;</span>, text2 = <span class="string">&quot;ace&quot;</span> </span><br><span class="line">输出：<span class="number">3</span>  </span><br></pre></td></tr></table></figure><br>解释：最长公共子序列是 “ace”，它的长度为 3。<br>示例 2:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：text1 = <span class="string">&quot;abc&quot;</span>, text2 = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><br>解释：最长公共子序列是 “abc”，它的长度为 3。<br>示例 3:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：text1 = <span class="string">&quot;abc&quot;</span>, text2 = <span class="string">&quot;def&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><br>解释：两个字符串没有公共子序列，返回 0。</p>
<p>提示:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= text1.length &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">1</span> &lt;= text2.length &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><br>输入的字符串只含有小写英文字符。</p>
<p><strong>题解</strong></p>
<p>动态规划，不过要设计一个二维数组dp，来统计<code>dp[i][j]</code>时对应 text1 在 i 位置与text2 在 j 位置时两子字符串对应的最长公共子序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self, text1, text2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type text1: str</span></span><br><span class="line"><span class="string">        :type text2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        l1, l2 = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">        <span class="keyword">if</span> l1==<span class="number">0</span> <span class="keyword">or</span> l2==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l2+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,l1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,l2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i-<span class="number">1</span>]==text2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[l1][l2]</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-common-subsequence">https://leetcode-cn.com/problems/longest-common-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="两个字符串的删除操作-最长公共子序列的变体"><a href="#两个字符串的删除操作-最长公共子序列的变体" class="headerlink" title="两个字符串的删除操作(最长公共子序列的变体)"></a>两个字符串的删除操作(最长公共子序列的变体)</h1><p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<p>示例 1:</p>
<p>输入: “sea”, “eat”<br>输出: 2<br>解释: 第一步将”sea”变为”ea”，第二步将”eat”变为”ea”<br>说明:</p>
<p>给定单词的长度不超过500。<br>给定单词中的字符只含有小写字母。</p>
<h2 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h2><p>最长公共子序列的变体，其实就是求最长公共自序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1, word2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type word1: str</span></span><br><span class="line"><span class="string">        :type word2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>]==word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> m+n-<span class="number">2</span>*dp[m][n]</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings">https://leetcode-cn.com/problems/delete-operation-for-two-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h1><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>注意:</p>
<p>每个数组中的元素不会超过 100<br>数组的大小不会超过 200</p>
<p>示例 1:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">5</span>]</span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">解释: 数组可以分割成 [<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>] 和 [<span class="number">11</span>].</span><br></pre></td></tr></table></figure></p>
<p>示例 2:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">输出: <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure></p>
<p><strong>题解</strong></p>
<p>这是一道以 0-1 背包问题为背景的算法练习题，我们把这个题目翻译一下：</p>
<p>给定一个只包含正整数的非空数组。是否可以从这个数组中挑选出一些正整数，每个数只能用一次，使得这些数的和等于整个数组元素的和的一半。</p>
<p>0-1 背包问题也是最基础的背包问题，它的特点是：待挑选的物品有且仅有一个，可以选择也可以不选择。下面我们定义状态，不妨就用问题的问法定义状态试试看。</p>
<blockquote>
<p>dp[i][j]：表示从数组的 [0, i] 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和等于 j。</p>
</blockquote>
<p>根据我们学习的 0-1 背包问题的状态转移推导过程，新来一个数，例如是 nums[i]，根据这个数可能选择也可能不被选择：</p>
<p>如果不选择 nums[i]，在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true；<br>如果选择 nums[i]，在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i] ，我既然这样写出来了，你就应该知道，这里讨论的前提条件是 nums[i] &lt;= j。</p>
<p>以上二者成立一条都行。于是得到状态转移方程是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] or dp[i - <span class="number">1</span>][j - nums[i]], (nums[i] &lt;= j)</span><br></pre></td></tr></table></figure>
<p>于是按照 0-1 背包问题的模板，我们不难写出以下代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        s = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> s &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = s // <span class="number">2</span></span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(target+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(target+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[<span class="number">0</span>]==i:</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,size):</span><br><span class="line">            n = nums[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j&gt;=n:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] <span class="keyword">or</span> dp[i][j-n]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>优化版：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        s = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> s &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = s // <span class="number">2</span></span><br><span class="line">        dp = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(target+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(target+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[<span class="number">0</span>]==i:</span><br><span class="line">                dp[i] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,size):</span><br><span class="line">            n = nums[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target, n-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j&gt;=n:</span><br><span class="line">                    dp[j] = dp[j] <span class="keyword">or</span> dp[j-n]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum">https://leetcode-cn.com/problems/partition-equal-subset-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 160.相交链表</title>
    <url>/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p><strong>1. 最容易想到的，两层遍历求解。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="keyword">null</span> || headB==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode tmp;</span><br><span class="line">        <span class="keyword">while</span>(headA!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            tmp = headB;</span><br><span class="line">            <span class="keyword">while</span>(tmp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp!=headA)</span><br><span class="line">                    <span class="keyword">return</span> tmp;</span><br><span class="line">                tmp = tmp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            headA = headA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(M*N)<br>空间复杂度O(1)</p>
<p><strong>2. 利用Map记录一个链表的每个节点，第二个链表寻找第一次出现的节点。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="keyword">null</span> || headB==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;ListNode,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;ListNode,Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(headA!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(headA,<span class="number">1</span>);</span><br><span class="line">            headA = headA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(headB!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(headB))</span><br><span class="line">                <span class="keyword">return</span> headB;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(M+N)<br>空间复杂度O(M)或O(N)</p>
<p><strong>3. 或者两个指针，分别从两个链表的头结点开始，当一个节点遍历到尾部时换到另一个链表头部。</strong></p>
<p>即利用 a+all+b = b+all+a，也就是两个指针走的路程一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="keyword">null</span> || headB==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode tmpA = headA;</span><br><span class="line">        ListNode tmpB = headB;</span><br><span class="line">        <span class="keyword">while</span>(tmpA!=tmpB)&#123;</span><br><span class="line">            tmpA = tmpA==<span class="keyword">null</span>?headB:tmpA.next;</span><br><span class="line">            tmpB = tmpB==<span class="keyword">null</span>?headA:tmpB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmpA;</span><br><span class="line">        <span class="keyword">return</span> tmpA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(M+N)<br>空间复杂度O(1)</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 208.实现Trie(前缀树)</title>
    <url>/LeetCode-208-%E5%AE%9E%E7%8E%B0Trie-%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p>
<p><strong>示例:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">trie.search(<span class="string">&quot;apple&quot;</span>);   <span class="comment">// 返回 true</span></span><br><span class="line">trie.search(<span class="string">&quot;app&quot;</span>);     <span class="comment">// 返回 false</span></span><br><span class="line">trie.startsWith(<span class="string">&quot;app&quot;</span>); <span class="comment">// 返回 true</span></span><br><span class="line">trie.insert(<span class="string">&quot;app&quot;</span>);   </span><br><span class="line">trie.search(<span class="string">&quot;app&quot;</span>);     <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>说明:</strong></p>
<blockquote>
<p>你可以假设所有的输入都是由小写字母 a-z 构成的。<br>保证所有输入均为非空字符串。</p>
</blockquote>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode/">题解</a></p>
<p>实现一个链表，每一个链表节点存储的是数组，数组包含所有可能的键（这里指26个字符）。</p>
<p>类似于HashMap的entry结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> TrieNode[] links;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line">        </span><br><span class="line">        TrieNode()&#123;</span><br><span class="line">            links = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> links[c-<span class="string">&#x27;a&#x27;</span>]!=<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> links[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">char</span> c, TrieNode node)</span></span>&#123;</span><br><span class="line">            links[c-<span class="string">&#x27;a&#x27;</span>] = node;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isEnd = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.isEnd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(!node.containsKey(c))&#123;</span><br><span class="line">                node.set(c, <span class="keyword">new</span> TrieNode());</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        node.setEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">searchPrefix</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(node.containsKey(c))</span><br><span class="line">                node = node.get(c);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node!=<span class="keyword">null</span> &amp;&amp; node.isEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode node = searchPrefix(prefix);</span><br><span class="line">        <span class="keyword">return</span> node!=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 221.最大正方形</title>
    <url>/LeetCode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>是动态规划的题目。</p>
<p>关键在于问题的转化。</p>
<p>问题转化为最长边长。</p>
<p>然后截止当前位置的最长边长是左边、上边及右上三者中的最小值 + 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> max_side = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]), dp[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">                    max_side = Math.max(max_side, dp[i][j]);</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_side*max_side;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 22.括号生成</title>
    <url>/LeetCode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n = 3，生成结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">&quot;((()))&quot;</span>,</span><br><span class="line">  <span class="string">&quot;(()())&quot;</span>,</span><br><span class="line">  <span class="string">&quot;(())()&quot;</span>,</span><br><span class="line">  <span class="string">&quot;()(())&quot;</span>,</span><br><span class="line">  <span class="string">&quot;()()()&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>回溯法，通过两个整数统计“（”与“）”的数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        backtracing(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracing</span><span class="params">(String s, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(close&gt;open || open&gt;n || close&gt;n)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">2</span>*n)&#123;</span><br><span class="line">            res.add(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String str = <span class="keyword">new</span> String(s);</span><br><span class="line">        backtracing(str+<span class="string">&quot;(&quot;</span>, open+<span class="number">1</span>, close, n);</span><br><span class="line">        backtracing(str+<span class="string">&quot;)&quot;</span>, open, close+<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 238.除自身以外数组的乘积</title>
    <url>/LeetCode-238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p>
<p><strong>示例：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出: [<span class="number">24</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>说明：</strong>请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>不能常规的循环暴力解决，因为时间限制在O(n)内。</p>
<p>考虑上三角/下三角的乘法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Arrays.fill(res, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="comment">// 只经过左指针操作，res[0] = 1, res[1] = 1, res[2] = 1*2, res[3] = 1*2*3</span></span><br><span class="line">            res[i] *= left;</span><br><span class="line">            left *= nums[i];</span><br><span class="line">            <span class="comment">// 只经过右指针操作，res[0] = 2*3*4, res[1] = 3*4, res[2] = 4 res[3] = 1</span></span><br><span class="line">            res[len-<span class="number">1</span>-i] *= right;</span><br><span class="line">            right *= nums[len-<span class="number">1</span>-i];</span><br><span class="line">            <span class="comment">// 上下相乘得到结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/product-of-array-except-self">https://leetcode-cn.com/problems/product-of-array-except-self</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 437.路径总和 III</title>
    <url>/LeetCode-437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p>
<p>找出路径和等于给定数值的路径总数。</p>
<p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
<p><strong>示例1：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">root = [<span class="number">10</span>,<span class="number">5</span>,-<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="keyword">null</span>,<span class="number">11</span>,<span class="number">3</span>,-<span class="number">2</span>,<span class="keyword">null</span>,<span class="number">1</span>], sum = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">      <span class="number">10</span></span><br><span class="line">     /  \</span><br><span class="line">    <span class="number">5</span>   -<span class="number">3</span></span><br><span class="line">   / \    \</span><br><span class="line">  <span class="number">3</span>   <span class="number">2</span>   <span class="number">11</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>  -<span class="number">2</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">返回 <span class="number">3</span>。和等于 <span class="number">8</span> 的路径有:</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>  <span class="number">5</span> -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">2.</span>  <span class="number">5</span> -&gt; <span class="number">2</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">3.</span>  -<span class="number">3</span> -&gt; <span class="number">11</span></span><br></pre></td></tr></table></figure></p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>双重递归。</p>
<p>首先建立一个递归寻找以每个节点为根节点的路径查找。</p>
<p>再建立一个递归遍历每一个节点，并以该节点为根节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        helper(root, sum);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        search(root, sum, root.val);</span><br><span class="line">        helper(root.left, sum);</span><br><span class="line">        helper(root.right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> tmp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum==tmp)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">            search(root.left, sum, tmp+root.left.val);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">            search(root.right, sum, tmp+root.right.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/path-sum-iii">https://leetcode-cn.com/problems/path-sum-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 23.合并K个排序链表</title>
    <url>/LeetCode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p><strong>示例：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p><a href="http://sunyunzeng.com/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/">合并两个有序链表</a>的翻版。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists==<span class="keyword">null</span> || lists.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(lists.length==<span class="number">1</span>) <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        ListNode res = lists[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;lists.length; i++)&#123;</span><br><span class="line">            res = mergeTwoLists(res, lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并两个有序链表的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode prehead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode node = prehead;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span> &amp;&amp; l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">                node.next = l1;</span><br><span class="line">                l1=l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node.next = l2;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next=l1==<span class="keyword">null</span>?l2:l1;</span><br><span class="line">        <span class="keyword">return</span> prehead.next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 300.最长上升子序列</title>
    <url>/LeetCode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h1><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">18</span>]</span><br><span class="line">输出: <span class="number">4</span> </span><br><span class="line">解释: 最长的上升子序列是 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>]，它的长度是 <span class="number">4</span>。</span><br></pre></td></tr></table></figure></p>
<p><strong>说明:</strong></p>
<p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。</p>
<p><strong>进阶:</strong> 你能将算法的时间复杂度降低到 O(n log n) 吗?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        l = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> l==<span class="number">0</span> <span class="keyword">or</span> l==<span class="number">1</span>: <span class="keyword">return</span> l</span><br><span class="line">        dp = [<span class="number">1</span>]*l</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">                <span class="keyword">if</span> nums[i]&gt;nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">https://leetcode-cn.com/problems/longest-increasing-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="最长数对链"><a href="#最长数对链" class="headerlink" title="最长数对链"></a>最长数对链</h1><p>给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。</p>
<p>现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。</p>
<p>给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p>
<p>示例 :<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 最长的数对链是 [<span class="number">1</span>,<span class="number">2</span>] -&gt; [<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong></p>
<p>给出数对的个数在 [1, 1000] 范围内。</p>
<p>更上面一题类似，只不要是任意顺序的选择，可以先对列表进行排序，按照数对的第二个数值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestChain</span>(<span class="params">self, pairs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type pairs: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        l = <span class="built_in">len</span>(pairs)</span><br><span class="line">        <span class="keyword">if</span> l==<span class="number">0</span> <span class="keyword">or</span> l==<span class="number">1</span>: <span class="keyword">return</span> l</span><br><span class="line">        pairs = <span class="built_in">sorted</span>(pairs, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">        dp = [<span class="number">1</span>]*l</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,l):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">                <span class="keyword">if</span> pairs[i][<span class="number">0</span>]&gt;pairs[j][<span class="number">1</span>]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain">https://leetcode-cn.com/problems/maximum-length-of-pair-chain</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h1><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
<p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<p>示例 1:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">6</span> </span><br><span class="line">解释: 整个序列均为摆动序列。</span><br></pre></td></tr></table></figure></p>
<p>示例 2:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">17</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">16</span>,<span class="number">8</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 这个序列包含几个长度为 <span class="number">7</span> 摆动序列，其中一个可为[<span class="number">1</span>,<span class="number">17</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">10</span>,<span class="number">16</span>,<span class="number">8</span>]。</span><br></pre></td></tr></table></figure></p>
<p>示例 3:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p><strong>算法</strong></p>
<p>首先计算得到差值序列，例如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>, <span class="number">1</span>] -&gt; [<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">2</span>]</span><br></pre></td></tr></table></figure><br>然后去重：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>, <span class="number">1</span>] -&gt; [<span class="number">1</span>, -<span class="number">2</span>]</span><br><span class="line"><span class="comment">// 注意：全零序列的结果为1</span></span><br><span class="line">[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] -&gt; [<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br>动态规划计算，dp[i]保存的是截止位置i的最长摆动序列。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 判断i位置的元素可以添加到j元素的尾部，构成摆动序列</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSuccess</span>(<span class="params">self, nums, i, j</span>):</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &gt; nums[j] <span class="keyword">or</span> nums[i] &lt; <span class="number">0</span> &lt; nums[j]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wiggleMaxLength</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        l = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> l == <span class="number">0</span> <span class="keyword">or</span> l == <span class="number">1</span>: <span class="keyword">return</span> l</span><br><span class="line">        <span class="keyword">if</span> l == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp, _nums = [<span class="number">1</span>] * (l - <span class="number">1</span>), [<span class="number">1</span>] * (l - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l):</span><br><span class="line">            _nums[i - <span class="number">1</span>] = nums[i] - nums[i - <span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 差序列去重</span></span><br><span class="line">        nums = <span class="built_in">list</span>(<span class="built_in">set</span>(_nums))</span><br><span class="line">        nums.sort(key=_nums.index)</span><br><span class="line">        <span class="comment"># 防止全零序列的干扰</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>] == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># 动态规划求解</span></span><br><span class="line">        dp = [<span class="number">1</span>] * <span class="built_in">len</span>(_nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(_nums)):</span><br><span class="line">            <span class="keyword">if</span> _nums[i] == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">                <span class="keyword">if</span> self.isSuccess(_nums, i, j):</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp) + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/wiggle-subsequence">https://leetcode-cn.com/problems/wiggle-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 474.一和零</title>
    <url>/LeetCode-474-%E4%B8%80%E5%92%8C%E9%9B%B6/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在计算机界中，我们总是追求用有限的资源获取最大的收益。</p>
<p>现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。</p>
<p>你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。</p>
<p>注意:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定 <span class="number">0</span> 和 <span class="number">1</span> 的数量都不会超过 <span class="number">100</span>。</span><br><span class="line">给定字符串数组的长度不会超过 <span class="number">600</span>。</span><br></pre></td></tr></table></figure></p>
<p>示例 1:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: Array = &#123;<span class="string">&quot;10&quot;</span>, <span class="string">&quot;0001&quot;</span>, <span class="string">&quot;111001&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>&#125;, m = <span class="number">5</span>, n = <span class="number">3</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释: 总共 <span class="number">4</span> 个字符串可以通过 <span class="number">5</span> 个 <span class="number">0</span> 和 <span class="number">3</span> 个 <span class="number">1</span> 拼出，即 <span class="string">&quot;10&quot;</span>,<span class="string">&quot;0001&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span> 。</span><br></pre></td></tr></table></figure></p>
<p>示例 2:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: Array = &#123;<span class="string">&quot;10&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>&#125;, m = <span class="number">1</span>, n = <span class="number">1</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure><br>解释: 你可以拼出 “10”，但之后就没有剩余数字了。更好的选择是拼出 “0” 和 “1” 。</p>
<p><strong>题解</strong></p>
<p>多维背包，动态规划方程：<code>dp[i][j]=max(dp[i][j], dp[i-conut_0][j-count_1])</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span>(<span class="params">self, strs, m, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(strs)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> strs:</span><br><span class="line">            count_0, count_1 = item.count(<span class="string">&#x27;0&#x27;</span>), item.count(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m, count_0-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n, count_1-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i-count_0][j-count_1]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ones-and-zeroes">https://leetcode-cn.com/problems/ones-and-zeroes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h1><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>示例 1:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>示例 2:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: coins = [<span class="number">2</span>], amount = <span class="number">3</span></span><br><span class="line">输出: -<span class="number">1</span></span><br></pre></td></tr></table></figure><br>说明:<br>你可以认为每种硬币的数量是无限的。</p>
<p><strong>题解</strong></p>
<p>背包问题，无限背包，从小到大遍历。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins, amount</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)]*(amount+<span class="number">1</span>) </span><br><span class="line">        dp[<span class="number">0</span>] = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount+<span class="number">1</span>):</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i-coin]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>] <span class="keyword">if</span> dp[-<span class="number">1</span>] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/coin-change">https://leetcode-cn.com/problems/coin-change</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="零钱兑换-II"><a href="#零钱兑换-II" class="headerlink" title="零钱兑换 II"></a>零钱兑换 II</h1><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p>
<p>示例 1:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: amount = <span class="number">5</span>, coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 有四种方式可以凑成总金额:</span><br><span class="line"><span class="number">5</span>=<span class="number">5</span></span><br><span class="line"><span class="number">5</span>=<span class="number">2</span>+<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"><span class="number">5</span>=<span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span></span><br><span class="line"><span class="number">5</span>=<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>示例 2:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: amount = <span class="number">3</span>, coins = [<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></table></figure><br>解释: 只用面额2的硬币不能凑成总金额3。</p>
<p>示例 3:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: amount = <span class="number">10</span>, coins = [<span class="number">10</span>] </span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>注意:</p>
<p>你可以假设：<br>0 &lt;= amount (总金额) &lt;= 5000<br>1 &lt;= coin (硬币面额) &lt;= 5000<br>硬币种类不超过 500 种<br>结果符合 32 位符号整数</p>
<p><strong>题解</strong></p>
<p>无限背包，注意递归条件是 <code>dp[i] += dp[i-coin]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount, coins</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount+<span class="number">1</span>):</span><br><span class="line">                dp[i] += dp[i-coin]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/coin-change-2">https://leetcode-cn.com/problems/coin-change-2</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h1><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;leetcode&quot;</span>, wordDict = [<span class="string">&quot;leet&quot;</span>, <span class="string">&quot;code&quot;</span>]</span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 返回 <span class="keyword">true</span> 因为 <span class="string">&quot;leetcode&quot;</span> 可以被拆分成 <span class="string">&quot;leet code&quot;</span>。</span><br></pre></td></tr></table></figure></p>
<p>示例 2：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;applepenapple&quot;</span>, wordDict = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pen&quot;</span>]</span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure><br>解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。<br>     注意你可以重复使用字典中的单词。</p>
<p>示例 3：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;catsandog&quot;</span>, wordDict = [<span class="string">&quot;cats&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;sand&quot;</span>, <span class="string">&quot;and&quot;</span>, <span class="string">&quot;cat&quot;</span>]</span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure></p>
<p><strong>题解</strong></p>
<p>采用动态规划 <code>dp[i]</code>表示 截止 s 字符串的 i 位置的子字符串是否能被单词字典里的单词来表示。</p>
<p><code>dp[i]</code>为真的条件为：</p>
<ol>
<li><code>dp[j]</code>为真</li>
<li><code>dp[j:i]</code>表示的字符串存在于字典中</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span>(<span class="params">self, s, wordDict</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type wordDict: List[str]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># dp[i]表示s[i]是否可用wordDict里的元素表示</span></span><br><span class="line">        <span class="comment"># dp[i]能够被表示的前提是dp[j]可用wordDict里元素表示，而且dp[j:i]存在于wordDict中</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果字典为空，字符串为空，则返回true，否则返回false</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> wordDict: <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        size = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [<span class="literal">False</span>]*(size+<span class="number">1</span>)</span><br><span class="line">        wordDict = <span class="built_in">list</span>(<span class="built_in">set</span>(wordDict))</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> dp[j:i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    dp[i] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/word-break">https://leetcode-cn.com/problems/word-break</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h1><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<p>示例:</p>
<p>nums = [1, 2, 3]<br>target = 4</p>
<p>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)</p>
<p>请注意，顺序不同的序列被视作不同的组合。</p>
<p>因此输出为 7。<br>进阶：<br>如果给定的数组中含有负数会怎么样？<br>问题会产生什么变化？<br>我们需要在题目中添加什么限制来允许负数的出现？</p>
<p><strong>题解</strong></p>
<p>思路与零钱兑换一模一样，代码甚至都一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span>]*(target+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, target+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> i&gt;=n:</span><br><span class="line">                    dp[i] += dp[i-n]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/combination-sum-iv">https://leetcode-cn.com/problems/combination-sum-iv</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 494.目标和</title>
    <url>/LeetCode-494-%E7%9B%AE%E6%A0%87%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p><strong>示例1：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], S: <span class="number">3</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">-<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span>-<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span>+<span class="number">1</span>-<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>-<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>-<span class="number">1</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">一共有<span class="number">5</span>种方法让最终目标和为<span class="number">3</span>。</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong></p>
<ol>
<li>数组非空，且长度不会超过20。</li>
<li>初始的数组的和不会超过1000。</li>
<li>保证返回的最终结果能被32位整数存下。</li>
</ol>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p><strong>首先是回溯方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        dfs(nums, S, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[]nums, <span class="keyword">int</span> S, <span class="keyword">int</span> tmpS, <span class="keyword">int</span> location)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(location==nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S==tmpS)</span><br><span class="line">                cnt++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(nums, S, tmpS + nums[location], location+<span class="number">1</span>);</span><br><span class="line">        dfs(nums, S, tmpS - nums[location], location+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>然后是动态规划</strong></p>
<p>一个数组可分为两个子集和 X 跟 Y，然后 X-Y=S，X+Y=Sum，由此得到 X=(Sum+S)/2。</p>
<p>也就是寻找一个子集和X，满足 X=(Sum+S)/2，此和且为整数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> n: nums)&#123;</span><br><span class="line">           sum += n;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(sum &lt; S || (sum+S)%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> s = (sum+S)/<span class="number">2</span>;</span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[s+<span class="number">1</span>];</span><br><span class="line">       dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> n: nums)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=s; i&gt;=n; i--)&#123;</span><br><span class="line">               <span class="comment">// 如果考虑数n，结果数为dp[i]，否则为dp[i-n]</span></span><br><span class="line">               dp[i] += dp[i-n];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[s];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/target-sum">https://leetcode-cn.com/problems/target-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 524.通过删除字母匹配到字典里最长单词</title>
    <url>/LeetCode-524-%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</p>
<p><strong>示例 1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">&quot;abpcplea&quot;</span>, d = [<span class="string">&quot;ale&quot;</span>,<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;monkey&quot;</span>,<span class="string">&quot;plea&quot;</span>]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"><span class="string">&quot;apple&quot;</span></span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s = <span class="string">&quot;abpcplea&quot;</span>, d = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>说明:<br>所有输入的字符串只包含小写字母。<br>字典的大小不会超过 1000。<br>所有输入的字符串长度不会超过 1000。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>快慢指针判断是否在字符串里面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInWord</span>(<span class="params">self, a, b</span>) -&gt; bool:</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(b)-<span class="number">1</span></span><br><span class="line">        m, n = <span class="number">0</span>, <span class="built_in">len</span>(a)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="keyword">if</span> m &gt; n: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> a[m]==b[i]:</span><br><span class="line">                m+=<span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> m&lt;=n <span class="keyword">and</span> a[m]!=b[i]:</span><br><span class="line">                    m+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> m &gt; n <span class="keyword">and</span> i&lt;=j: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> a[n]==b[j]:</span><br><span class="line">                n-=<span class="number">1</span></span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> m&lt;=n <span class="keyword">and</span> a[n]!=b[j]:</span><br><span class="line">                    n-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> m &gt; n <span class="keyword">and</span> i&lt;=j: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestWord</span>(<span class="params">self, s: <span class="built_in">str</span>, d: List[<span class="built_in">str</span>]</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)==<span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(d)==<span class="number">0</span>: <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        res=<span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(d)):</span><br><span class="line">            <span class="keyword">if</span> self.isInWord(s, d[i]):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(d[i])&gt;<span class="built_in">len</span>(res):</span><br><span class="line">                    res = d[i]</span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">len</span>(d[i])==<span class="built_in">len</span>(res) <span class="keyword">and</span> d[i]&lt;res:</span><br><span class="line">                    res = d[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting">https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 543.二叉树的直径</title>
    <url>/LeetCode-543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p>
<p><strong>示例：</strong><br>给定二叉树<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> / \     </span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>    </span><br></pre></td></tr></table></figure></p>
<p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>路径长度一定是以某个节点为根节点，左右子树的最大深度和。</p>
<p>与题目<a href="http://sunyunzeng.com/%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3/">求二叉树的最大深度</a>类似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        getDepth(root);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = getDepth(root.right);</span><br><span class="line">        sum = Math.max(sum,  left+right );</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">题目链接</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 62.不同路径</title>
    <url>/LeetCode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>动态规划。。用回溯竟然做不出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m&lt;=<span class="number">0</span> || n&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths">https://leetcode-cn.com/problems/unique-paths</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 560.和为K的子数组</title>
    <url>/LeetCode-560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<p><strong>示例1：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">2</span> , [<span class="number">1</span>,<span class="number">1</span>] 与 [<span class="number">1</span>,<span class="number">1</span>] 为两种不同的情况。</span><br></pre></td></tr></table></figure></p>
<p><strong>说明：</strong></p>
<ol>
<li><p>数组的长度为 [1, 20,000]。</p>
</li>
<li><p>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</p>
</li>
</ol>
<h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>先固定数组的左侧位置，然后依次移动右侧指针，如何数组和为 k，结果加一。</p>
<p>数组和置为零，更新左侧位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>; left&lt;nums.length; left++)&#123;</span><br><span class="line">           <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> right = left; right&lt;nums.length; right++)&#123;</span><br><span class="line">               sum += nums[right];</span><br><span class="line">               <span class="keyword">if</span>(sum==k)</span><br><span class="line">                    res++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时空间复杂度为 1， 时间复杂度为 O(n)。</p>
<h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>只需要遍历一次，统计到各个位置的累积和。</p>
<p>如果至 j 位置的和与至 i 位置的和差为k，那么位于 i~j 的子序列和为 k。</p>
<p>用一个Map统计不同累积和出现的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;  </span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n: nums)&#123;</span><br><span class="line">            sum += n;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(sum-k))</span><br><span class="line">                res += map.get(sum-k);</span><br><span class="line">            <span class="comment">// map.getOrDefault(key, default)--如果存在键K就取出对应的V，否则值为default</span></span><br><span class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 72.编辑距离</title>
    <url>/LeetCode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符<br>示例 1:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: word1 = <span class="string">&quot;horse&quot;</span>, word2 = <span class="string">&quot;ros&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: </span><br><span class="line">horse -&gt; rorse (将 <span class="string">&#x27;h&#x27;</span> 替换为 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">rorse -&gt; rose (删除 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">rose -&gt; ros (删除 <span class="string">&#x27;e&#x27;</span>)</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: word1 = <span class="string">&quot;intention&quot;</span>, word2 = <span class="string">&quot;execution&quot;</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: </span><br><span class="line">intention -&gt; inention (删除 <span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">inention -&gt; enention (将 <span class="string">&#x27;i&#x27;</span> 替换为 <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">enention -&gt; exention (将 <span class="string">&#x27;n&#x27;</span> 替换为 <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">exention -&gt; exection (将 <span class="string">&#x27;n&#x27;</span> 替换为 <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">exection -&gt; execution (插入 <span class="string">&#x27;u&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h2><ul>
<li><p>问题1：如果 word1[0..i-1] 到 word2[0..j-1] 的变换需要消耗 k 步，那 word1[0..i] 到 word2[0..j] 的变换需要几步呢？</p>
</li>
<li><p>答：先使用 k 步，把 word1[0..i-1] 变换到 word2[0..j-1]，消耗 k 步。再把 word1[i] 改成 word2[j]，就行了。如果 word1[i] == word2[j]，什么也不用做，一共消耗 k 步，否则需要修改，一共消耗 k + 1 步。</p>
</li>
<li><p>问题2：如果 word1[0..i-1] 到 word2[0..j] 的变换需要消耗 k 步，那 word1[0..i] 到 word2[0..j] 的变换需要消耗几步呢？</p>
</li>
<li><p>答：先经过 k 步，把 word1[0..i-1] 变换到 word2[0..j]，消耗掉 k 步，再把 word1[i] 删除，这样，word1[0..i] 就完全变成了 word2[0..j] 了。一共 k + 1 步。</p>
</li>
<li><p>问题3：如果 word1[0..i] 到 word2[0..j-1] 的变换需要消耗 k 步，那 word1[0..i] 到 word2[0..j] 的变换需要消耗几步呢？</p>
</li>
<li><p>答：先经过 k 步，把 word1[0..i] 变换成 word2[0..j-1]，消耗掉 k 步，接下来，再插入一个字符 word2[j], word1[0..i] 就完全变成了 word2[0..j] 了。</p>
</li>
</ul>
<p>从上面三个问题来看，word1[0..i] 变换成 word2[0..j] 主要有三种手段，用哪个消耗少，就用哪个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1, word2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type word1: str</span></span><br><span class="line"><span class="string">        :type word2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 如果当前的字符相等，则最小操作数与dp[i-1][j-1]相同</span></span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>]==word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j-<span class="number">1</span>], <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]))+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/edit-distance">https://leetcode-cn.com/problems/edit-distance</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="只有两个键的键盘"><a href="#只有两个键的键盘" class="headerlink" title="只有两个键的键盘"></a>只有两个键的键盘</h1><p>最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：</p>
<p>Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。<br>Paste (粘贴) : 你可以粘贴你上一次复制的字符。<br>给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。输出能够打印出 n 个 ‘A’ 的最少操作次数。</p>
<p>示例 1:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">最初, 我们只有一个字符 <span class="string">&#x27;A&#x27;</span>。</span><br><span class="line">第 <span class="number">1</span> 步, 我们使用 Copy All 操作。</span><br><span class="line">第 <span class="number">2</span> 步, 我们使用 Paste 操作来获得 <span class="string">&#x27;AA&#x27;</span>。</span><br><span class="line">第 <span class="number">3</span> 步, 我们使用 Paste 操作来获得 <span class="string">&#x27;AAA&#x27;</span>。</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">n 的取值范围是 [<span class="number">1</span>, <span class="number">1000</span>] 。</span><br></pre></td></tr></table></figure></p>
<h2 id="思路-代码-1"><a href="#思路-代码-1" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h2><p>动态规划。例如 9 ，从数字 8 开始依次找其最大除数，例如是3.<br>那么<code>dp[9] = d[3] + 9/3</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSteps</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">                    dp[i] = dp[j] + i//j</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/2-keys-keyboard">https://leetcode-cn.com/problems/2-keys-keyboard</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 75.颜色分类</title>
    <url>/LeetCode-75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p>
<p>示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>先统计0,1,2分别出现的次数，然后按照各自数量依次赋予数组新数值。</p>
<p>时间复杂度: O(N^2)<br>空间复杂度: O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            counts[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(counts[<span class="number">0</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">                counts[<span class="number">0</span>]--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(counts[<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] = <span class="number">1</span>;</span><br><span class="line">                counts[<span class="number">1</span>]--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[i] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者三指针方法，左指针负责交换0， 右指针负责交换2，中间指针负责扫描。<br>时间复杂度: O(N)<br>空间复杂度: O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p0 = cur = <span class="number">0</span></span><br><span class="line">        p1 = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur &lt;= p1:</span><br><span class="line">            <span class="keyword">if</span> nums[cur] == <span class="number">0</span>:</span><br><span class="line">                nums[cur], nums[p0] = nums[p0], nums[cur]</span><br><span class="line">                <span class="comment"># 这里左边遍历当前位置加一，因为左边的确定全部扫描过，而右边交换过的未进行判断</span></span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">                p0 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[cur] == <span class="number">1</span>:</span><br><span class="line">                cur +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[cur], nums[p1] = nums[p1], nums[cur]</span><br><span class="line">                p1 -=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-colors">https://leetcode-cn.com/problems/sort-colors</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 621.任务调度器</title>
    <url>/LeetCode-621-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。</p>
<p>然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p>
<p>你需要计算完成所有任务所需要的最短时间。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: tasks = [<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>], n = <span class="number">2</span></span><br><span class="line">输出: <span class="number">8</span></span><br><span class="line">执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B.</span><br></pre></td></tr></table></figure>
<p><strong>注:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 任务的总个数为 [<span class="number">1</span>, <span class="number">10000</span>]。</span><br><span class="line"><span class="number">2.</span> n 的取值范围为 [<span class="number">0</span>, <span class="number">100</span>]。</span><br></pre></td></tr></table></figure>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>规定 n + 1 个任务为一轮，这样的好处是同一轮中一个任务最多只能被安排一次。在每一轮中，我们将当前的任务按照它们剩余的次数降序排序，并选择剩余次数最多的 n + 1 个任务依次执行。如果任务的种类 t 少于 n + 1 个，就只选择全部的 t 种任务，其余的时间空闲。这样做的正确性在于，由于冷却时间的存在，出现次数较多的那些任务如果不尽早安排，将会导致大量空闲时间的出现，因此贪心地将出现次数较多的任务安排在前面是合理的。同时我们可以保证，这一轮的第 k 个任务距离上一次执行至少有 n 个单位的冷却时间。我们可以使用逆向思维来证明：假设第 r 轮中某个任务在第 k 个执行，那么说明它在第 r 轮时为数量第 k 多的任务。在第 r 轮结束后，第 1 多到第 k 多的任务的数量都会减少 1，因此在第 r + 1 轮，这个任务最多也只能是数量第 k 多，因此它如果被执行，一定满足冷却时间的要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: tasks)</span><br><span class="line">            map[c - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        Arrays.sort(map);</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (map[<span class="number">25</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map[<span class="number">25</span>] == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">26</span> &amp;&amp; map[<span class="number">25</span> - i] &gt; <span class="number">0</span>)</span><br><span class="line">                    map[<span class="number">25</span> - i]--;</span><br><span class="line">                time++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            Arrays.sort(map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>(count[25] - 1) * (n + 1) + maxCount</p>
<p>假设数组 [“A”,”A”,”A”,”B”,”B”,”C”]，n = 2，A的频率最高，记为count = 3，所以两个A之间必须间隔2个任务，才能满足题意并且是最短时间（两个A的间隔大于2的总时间必然不是最短），因此执行顺序为： A-&gt;X-&gt;X-&gt;A-&gt;X-&gt;X-&gt;A，这里的X表示除了A以外其他字母，或者是待命，不用关心具体是什么，反正用来填充两个A的间隔的。上面执行顺序的规律是： 有count - 1个A，其中每个A需要搭配n个X，再加上最后一个A，所以总时间为 (count - 1) * (n + 1) + 1<br>要注意可能会出现多个频率相同且都是最高的任务，比如 [“A”,”A”,”A”,”B”,”B”,”B”,”C”,”C”]，所以最后会剩下一个A和一个B，因此最后要加上频率最高的不同任务的个数 maxCount<br>公式算出的值可能会比数组的长度小，如[“A”,”A”,”B”,”B”]，n = 0，此时要取数组的长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tasks==<span class="keyword">null</span> || tasks.length==<span class="number">0</span> || n&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = tasks.length;</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">// 统计数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: tasks)&#123;</span><br><span class="line">            counts[c-<span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(counts);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(counts[i]==counts[<span class="number">25</span>])</span><br><span class="line">                maxCount++;</span><br><span class="line">        <span class="keyword">int</span> res = (counts[<span class="number">25</span>]-<span class="number">1</span>)*(n+<span class="number">1</span>)+maxCount;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res&lt;len?len:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/task-scheduler">https://leetcode-cn.com/problems/task-scheduler</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 763. 划分字母区间</title>
    <url>/LeetCode-763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p>
<p><strong>示例1：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: S = <span class="string">&quot;ababcbacadefegdehijhklij&quot;</span></span><br><span class="line">输出: [<span class="number">9</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">解释:</span><br><span class="line">划分结果为 <span class="string">&quot;ababcbaca&quot;</span>, <span class="string">&quot;defegde&quot;</span>, <span class="string">&quot;hijhklij&quot;</span>。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 <span class="string">&quot;ababcbacadefegde&quot;</span>, <span class="string">&quot;hijhklij&quot;</span> 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">S的长度在[<span class="number">1</span>, <span class="number">500</span>]之间。</span><br><span class="line">S只包含小写字母<span class="string">&#x27;a&#x27;</span>到<span class="string">&#x27;z&#x27;</span>。</span><br></pre></td></tr></table></figure></p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>贪心算法。</p>
<p>统计每个字母出现的最后位置，最优分割是该区间内任意一个字母的最大位置都包括在内。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span>(<span class="params">self, S: <span class="built_in">str</span></span>) -&gt; List[int]:</span></span><br><span class="line">        dic = &#123;c:i <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(S)&#125;</span><br><span class="line">        j, anchor = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(S):</span><br><span class="line">            j = <span class="built_in">max</span>(j, dic[c])</span><br><span class="line">            <span class="keyword">if</span> i==j:</span><br><span class="line">                res.append(i-anchor+<span class="number">1</span>)</span><br><span class="line">                anchor = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>贪心法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 96.不同的二叉搜索树</title>
    <url>/LeetCode-96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p><strong>示例:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释:</span><br><span class="line">给定 n = <span class="number">3</span>, 一共有 <span class="number">5</span> 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>         <span class="number">3</span>     <span class="number">3</span>      <span class="number">2</span>      <span class="number">1</span></span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span>      <span class="number">1</span>   <span class="number">3</span>      <span class="number">2</span></span><br><span class="line">    /     /       \                 \</span><br><span class="line">   <span class="number">2</span>     <span class="number">1</span>         <span class="number">2</span>                 <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>动态规划。</p>
<p>假设 整数 n对应的二叉搜索树数量为 G(n)。</p>
<p>每个节点 i ∈ (0,n] 为根节点对应的二叉搜索树数量为 F(i)。</p>
<p>则， G(n) = F(1) + F(2) + F(3) + … + F(n)。</p>
<p>而 节点i 为根节点的二叉搜索树，可以分为 i-1 个左子树 跟 n-i个右子树，F(i) = G(i-1)*G(n-i);</p>
<p>因此 G(n) = G(0)<em>G(n-1) + G(1)</em>G(n-2) + G(2)<em>G(n-3) + … + G(n-1)</em>G(0)</p>
<p>因此</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// 边界条件</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i; j++)&#123;</span><br><span class="line">                <span class="comment">// 节点i为根节点对应的二叉搜索树数量</span></span><br><span class="line">                dp[i] += dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees">https://leetcode-cn.com/problems/unique-binary-search-trees</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1046.最后一块石头的重量</title>
    <url>/Leetcode-1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有一堆石头，每块石头的重量都是正整数。</p>
<p>每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p>
<p>如果 x == y，那么两块石头都会被完全粉碎；<br>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。</p>
<p><strong>提示</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= stones.length &lt;= <span class="number">30</span></span><br><span class="line"><span class="number">1</span> &lt;= stones[i] &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>（排序 -&gt; 选最大及第二大做差 -&gt; 更新数组 -&gt; 排序）（循环 length-1 次） -&gt;最大的为结果</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = stones.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>; i&gt;=<span class="number">1</span>; i--)&#123;</span><br><span class="line">            Arrays.sort(stones);</span><br><span class="line">            stones[len-<span class="number">1</span>] = stones[len-<span class="number">1</span>]-stones[len-<span class="number">2</span>];</span><br><span class="line">            stones[len-<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stones[len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者采用<strong>优先堆栈</strong>的方法维护数据的先后顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = stones.length;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (b - a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            queue.add(stones[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(queue.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> b = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(a-b != <span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(a-b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty()?<span class="number">0</span>:queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/last-stone-weight">https://leetcode-cn.com/problems/last-stone-weight</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>贪心法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 102.二叉树的层次遍历</title>
    <url>/Leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<p>返回其层次遍历结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>二叉树相关算法题两种解题思路：递归和迭代。</p>
<p><strong>递归方法</strong></p>
<p>用一个辅助函数，更新结果。</p>
<p>记录遍历的层数，并按照从左到右的顺序依次在相应层数List中记录数值。</p>
<p>返回结果。</p>
<p><strong>代码</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 更新记录List</span></span><br><span class="line">        <span class="keyword">if</span>(results.size()==level)</span><br><span class="line">            results.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="comment">// 从左到右记录数据</span></span><br><span class="line">        results.get(level).add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">            helper(root.left, level+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">            helper(root.right, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> results;</span><br><span class="line">        helper(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>迭代方法:</strong></p>
<p>用队列辅助，先进的节点先出。</p>
<p>层层进队列，然后层层出队列，存入结果results中。</p>
<p><strong>代码:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> results;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            results.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">            <span class="keyword">int</span> levelLength = queue.size();</span><br><span class="line">            <span class="comment">// 将level层元素依次存入List，level+1层节点依次入队列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;levelLength; ++i)&#123;</span><br><span class="line">                <span class="comment">// 改成节点出队列</span></span><br><span class="line">                root = queue.remove();</span><br><span class="line">                <span class="comment">// 按层存入</span></span><br><span class="line">                results.get(level).add(root.val);</span><br><span class="line">                <span class="comment">// 下一层节点入队列</span></span><br><span class="line">                <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(root.left);</span><br><span class="line">                <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">题目链接</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 打家劫舍 II</title>
    <url>/LeetCode-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II%E4%B8%80/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 你不能先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">2</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">2</span>）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 你可以先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">1</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">3</span>）。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure></p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>关键是环，可以通过 0~len-2, 1~len-1分别遍历规避掉环的问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subRob</span>(<span class="params">self, s, e, nums</span>)-&gt;int:</span></span><br><span class="line">        pre1, pre2, cur = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s,e):</span><br><span class="line">            cur = <span class="built_in">max</span>(pre1, pre2+nums[i])</span><br><span class="line">            pre2 = pre1</span><br><span class="line">            pre1 = cur</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        l = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> l==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> l==<span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> l==<span class="number">2</span>: <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.subRob(<span class="number">0</span>, l-<span class="number">1</span>, nums), self.subRob(<span class="number">1</span>, l, nums))     </span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/house-robber-ii">https://leetcode-cn.com/problems/house-robber-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 105.从前序与中序遍历序列构造二叉树</title>
    <url>/Leetcode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>根据一棵树的前序遍历与中序遍历构造出二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">中序遍历 inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>返回如下的二叉树：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>先序遍历：先根节点 后左子树 最后右子树</strong></p>
<p><strong>中序遍历：先左子树 再根节点 最后右子树</strong></p>
<p>所以先序遍历的第一个数值为根节点，在中序遍历中找到根节点位置，前面为左子树的中序遍历，后面为右子树的中序遍历。</p>
<p>Java代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder==<span class="keyword">null</span> || inorder==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length==<span class="number">0</span> || inorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length!=inorder.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> len = preorder.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==preorder[<span class="number">0</span>])&#123;</span><br><span class="line">                root.left = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>), Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">                root.right = buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,len),Arrays.copyOfRange(inorder,i+<span class="number">1</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Python代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder, inorder</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        x = preorder.pop(<span class="number">0</span>)</span><br><span class="line">        node = TreeNode(x)</span><br><span class="line">        idx = inorder.index(x)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        node.left = self.buildTree(preorder[:idx], inorder[:idx])</span><br><span class="line">        node.right = self.buildTree(preorder[idx:], inorder[idx+<span class="number">1</span>:])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 215.数组中第K个最大元素</title>
    <url>/Leetcode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p><strong>示例 1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>] 和 k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p><strong>示例 2::</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>] 和 k = <span class="number">4</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p><strong>简单办法，最容易想到的：用一个长度为 k 存储最大到第k大的数，然后返回数组最后一个元素，即为结果。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数组初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] results = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            results[i] = Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 特殊情况处理</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 维护结果数组的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;k; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;results[j])&#123;</span><br><span class="line">                    System.arraycopy(results,j,results,j+<span class="number">1</span>,k-<span class="number">1</span>-j);</span><br><span class="line">                    results[j] = nums[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> results[k-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行用时 :<br>74 ms, 在所有 Java 提交中击败了18.90%的用户</p>
<p>内存消耗 :<br>40.5 MB, 在所有 Java 提交中击败了35.28%的用户</p>
<p><strong>答案里的方法：桶排序，非常好理解，先遍历一遍数组找出最大最小值。创建一个桶，长度为max-min+1，桶的</strong></p>
<p><strong>引对应于与Min的差值，桶中装的元素为该值出现次数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            max=Math.max(max,num);</span><br><span class="line">            min=Math.min(min,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] bucket=<span class="keyword">new</span> <span class="keyword">int</span> [max-min+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            bucket[num-min]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=bucket.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            count+=bucket[i];</span><br><span class="line">            <span class="keyword">if</span>(count&gt;=k)    <span class="keyword">return</span> min+i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行用时 :<br>2 ms, 在所有 Java 提交中击败了99.61%的用户</p>
<p>内存消耗 :<br>37.8 MB, 在所有 Java 提交中击败了94.49%的用户</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 11.盛最多水的容器</title>
    <url>/Leetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p><strong>说明:</strong> 你不能倾斜容器，且 n 的值至少为 2。<br><img src="/Leetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/question_11.jpg" class></p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p><strong>方法1：暴力破解法</strong></p>
<p>即遍历所有情况，找到最优解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">                res = Math.max((i-j)*Math.min(height[i], height[j]),res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n^2), 空间复杂度 1</p>
<p><strong>方法2：双指针法</strong></p>
<p>两个指针，一个指向数组首，一个指向数组尾。</p>
<p>指向数字小的往中间移动，并计算一次结果。</p>
<p>取最优即为最终结果。</p>
<p>原因<a href="https://leetcode.com/problems/container-with-most-water/discuss/6099/Yet-another-way-to-see-what-happens-in-the-O(n">请戳</a>-algorithm)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(first &lt; last)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = (last-first)*Math.min(height[first], height[last]);</span><br><span class="line">            <span class="keyword">if</span>(height[first] &lt;= height[last])&#123;</span><br><span class="line">                first++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                last--;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n), 空间复杂度 1 </p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/container-with-most-water">https://leetcode-cn.com/problems/container-with-most-water</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 287.寻找重复数</title>
    <url>/Leetcode-287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p><strong>示例1：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure><br><strong>示例2：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure><br><strong>说明：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不能更改原数组（假设数组是只读的）。</span><br><span class="line">只能使用额外的 O(1) 的空间。</span><br><span class="line">时间复杂度小于 O(n2) 。</span><br><span class="line">数组中只有一个重复的数字，但它可能不止重复出现一次。</span><br></pre></td></tr></table></figure></p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p><strong>易想到方法</strong></p>
<p>不符合题目要求，因为需要额外的空间。</p>
<p>用链表或者HashMap存储数值，遇到相同的已存储的数就返回。空间复杂度最坏O(n)，时间复杂度最坏O(n)。</p>
<p>或者先排序，遇到相同的数返回。时间复杂度视排序方法而定，最好O(log(n))。</p>
<p><strong>巧妙算法1</strong></p>
<p>巧用快慢指针。</p>
<p>数组的索引与存储的数值之间形成了特殊<strong>链表</strong>。</p>
<p>如果存在重复的数，因为数组大小是 n+1，数字范围是1~n，所以该链表存在环。</p>
<p>环的入口即为结果。</p>
<p>答案的求解变成环入口的求解。<a href="https://blog.csdn.net/fynjy/article/details/47440049">思路</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        <span class="keyword">int</span> fast = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> low = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            low = nums[low];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;<span class="keyword">while</span>(fast != low);</span><br><span class="line">        <span class="keyword">int</span> step = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 寻找环链表的入口，即为结果</span></span><br><span class="line">        <span class="keyword">while</span>(step != low)&#123;</span><br><span class="line">            step = nums[step];</span><br><span class="line">            low = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>巧妙算法2</strong></p>
<p>二分法。</p>
<p>统计小于中间数 mid 的数值数量，如果大于，则在0~mid之间寻找。</p>
<p>反之，则在mid~high中寻找。</p>
<p>最终找到重复的数值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二分法</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hight = len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;hight)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = low+(hight-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&lt;=mid)</span><br><span class="line">                    count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&lt;=mid)</span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hight = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-the-duplicate-number">https://leetcode-cn.com/problems/find-the-duplicate-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 2：两数相加</title>
    <url>/Leetcode-2%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出：<span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode h = pre;</span><br><span class="line">        <span class="keyword">int</span> more = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span> || l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = l1==<span class="keyword">null</span>?<span class="number">0</span>:l1.val;</span><br><span class="line">            <span class="keyword">int</span> y = l2==<span class="keyword">null</span>?<span class="number">0</span>:l2.val;</span><br><span class="line">            <span class="keyword">int</span> n = (x + y + more)%<span class="number">10</span>;</span><br><span class="line">            more = (x + y + more) / <span class="number">10</span>;</span><br><span class="line">            h.next = <span class="keyword">new</span> ListNode(n);</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="keyword">null</span>) l1=l1.next;</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="keyword">null</span>) l2=l2.next;</span><br><span class="line">            h = h.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(more &gt;<span class="number">0</span>) h.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 347.前K个高频元素</title>
    <url>/Leetcode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p><strong>示例1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出: [<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>说明:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">你可以假设给定的 k 总是合理的，且 <span class="number">1</span> ≤ k ≤ 数组中不相同的元素的个数。</span><br><span class="line">你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</span><br></pre></td></tr></table></figure></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先用一个HashMap统计不同数字出现的次数。</p>
<p>然后用一个最小堆维护k大小的结果。</p>
<p>这里采用java的优先队列 <strong>PriorityQueue</strong> 去维护最小堆。</p>
<p>这里需要注意的一点是比较器的设计，部分源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> offer(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> i = size;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">            grow(i + <span class="number">1</span>);</span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            siftUpUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUpComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            siftUpUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUpComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="comment">// 注意：这里的比较原则是当前的与栈顶元素比较，大的就进行替换，所以维护的是最小堆栈。</span></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PriorityQueue方法参考<a href="https://www.cnblogs.com/Elliott-Su-Faith-change-our-life/p/7472265.html">博文</a></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> map.get(a) - map.get(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 统计各数字出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">                map.put(nums[i], map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用最小堆更新结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size()&lt;k)&#123;</span><br><span class="line">                pq.add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.get(i)&gt;map.get(pq.peek()))&#123;</span><br><span class="line">                    pq.remove();</span><br><span class="line">                    pq.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            result.add(pr.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;l</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 46.全排列</title>
    <url>/Leetcode-46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>
<p><strong>示例：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>回溯问题。</p>
<p>如果遇到一个问题，不用穷举所有情况找不出答案，就采用回溯。</p>
<p>回溯是DFS的一种，遍历完一条路径后，回退一步，继续寻找下一可能路径。</p>
<p>它与暴力法的区别在于，可以通过剪枝规避掉很多无意义的尝试，且不用每次都从头开始遍历到尾部。</p>
<p>讲解可以参考<u><a href="https://www.cis.upenn.edu/~matuszek/cit594-2012/Pages/backtracking.html">https://www.cis.upenn.edu/~matuszek/cit594-2012/Pages/backtracking.html</a></u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        backtracking(res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), nums, <span class="keyword">new</span> <span class="keyword">boolean</span> [nums.length]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// used访问标志防止重复使用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; arr, <span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(arr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr.size()==nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(arr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(used[i])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                arr.add(nums[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                backtracking(res, arr, nums, used);</span><br><span class="line">                arr.remove(arr.size()-<span class="number">1</span>);</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><font color="#f07c82"><a href="https://blog.csdn.net/wonner_/article/details/80373871">回溯例题参考</a></font></strong></p>
<p>来源：力扣（LeetCode）<br>链接：<u><a href="https://leetcode-cn.com/problems/permutations">https://leetcode-cn.com/problems/permutations</a></u><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 413.等差数列划分</title>
    <url>/Leetcode-413-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<h1 id="等差数列划分"><a href="#等差数列划分" class="headerlink" title="等差数列划分"></a>等差数列划分</h1><p>如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p>
<p>例如，以下数列为等差数列:</p>
<p>1, 3, 5, 7, 9<br>7, 7, 7, 7<br>3, -1, -5, -9</p>
<p>以下数列不是等差数列。</p>
<p>1, 1, 2, 5, 7</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组 A 包含 N 个数，且索引从<span class="number">0</span>开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 <span class="number">0</span>&lt;=P&lt;Q&lt;N 。</span><br></pre></td></tr></table></figure>
<p>如果满足以下条件，则称子数组(P, Q)为等差数组：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">元素 A[P], A[p + <span class="number">1</span>], ..., A[Q - <span class="number">1</span>], A[Q] 是等差的。并且 P + <span class="number">1</span> &lt; Q 。</span><br></pre></td></tr></table></figure><br>函数要返回数组 A 中所有为等差数组的子数组个数。</p>
<p>示例:</p>
<p>A = [1, 2, 3, 4]</p>
<p>返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>首先对于等差序列 B, 其元素数量为n，则其包含的连续自等差序列的总数为 1+2+…+n-2,<br>因此，该题转化为寻找序列中，<strong>最长的连续子等差序列</strong>，然后根据其数量判断。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfArithmeticSlices</span>(<span class="params">self, A: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        l = <span class="built_in">len</span>(A)</span><br><span class="line">        <span class="keyword">if</span> l &lt; <span class="number">3</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res, count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,l):</span><br><span class="line">            <span class="keyword">if</span> A[i]-A[i-<span class="number">1</span>] == A[i-<span class="number">1</span>]-A[i-<span class="number">2</span>]:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> count!=<span class="number">0</span>:</span><br><span class="line">                    res += <span class="built_in">sum</span>(<span class="built_in">range</span>(count+<span class="number">1</span>))</span><br><span class="line">                    count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> count != <span class="number">0</span>:</span><br><span class="line">            res += <span class="built_in">sum</span>(<span class="built_in">range</span>(count + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/arithmetic-slices">https://leetcode-cn.com/problems/arithmetic-slices</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<p>示例 1:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: <span class="number">2</span> = <span class="number">1</span> + <span class="number">1</span>, <span class="number">1</span> × <span class="number">1</span> = <span class="number">1</span>。</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">10</span></span><br><span class="line">输出: <span class="number">36</span></span><br><span class="line">解释: <span class="number">10</span> = <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span>, <span class="number">3</span> × <span class="number">3</span> × <span class="number">4</span> = <span class="number">36</span>。</span><br></pre></td></tr></table></figure></p>
<p>说明: 你可以假设 n 不小于 2 且不大于 58。</p>
<h1 id="思路-代码-1"><a href="#思路-代码-1" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>动态规划，整数4的最大乘积为: dp[3] = max(max(dp[2], dp[1]<em>2), 1 </em> 2)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i):</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[j] * (i - j), dp[i])</span><br><span class="line">                <span class="comment"># 很关键的一步，因为之前的dp[i]最大值可能比dp[i]小，例如2或者3</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(j*(i-j), dp[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/integer-break">https://leetcode-cn.com/problems/integer-break</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h1><p>动态规划， 与前一题类似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">            dp[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> max_n = (<span class="keyword">int</span>)Math.sqrt(i);</span><br><span class="line">            <span class="keyword">if</span>(max_n*max_n==i)&#123;</span><br><span class="line">                dp[i]=<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=max_n; j++)&#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i-j*j]+dp[j*j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        dp = [sys.maxsize] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">            dp[i] = i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>, n + <span class="number">1</span>):</span><br><span class="line">            max_n = <span class="built_in">int</span>(math.sqrt(i))</span><br><span class="line">            <span class="keyword">if</span> max_n * max_n == i:</span><br><span class="line">                dp[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, max_n + <span class="number">1</span>):</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[i - j * j] + dp[j*j])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numSquares = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n+<span class="number">1</span>).fill(<span class="built_in">Number</span>.MAX_VALUE);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++)&#123;</span><br><span class="line">        dp[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">4</span>; i&lt;n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">        max_n = <span class="built_in">Math</span>.trunc(<span class="built_in">Math</span>.sqrt(i));</span><br><span class="line">        <span class="keyword">if</span>(max_n*max_n==i) dp[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>; j&lt;=max_n; j++)&#123;</span><br><span class="line">                dp[i] = <span class="built_in">Math</span>.min(dp[i], dp[i-j*j]+dp[j*j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a>解码方法</h1><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p>
<p>示例 1:</p>
<p>输入: “12”<br>输出: 2<br>解释: 它可以解码为 “AB”（1 2）或者 “L”（12）。<br>示例 2:</p>
<p>输入: “226”<br>输出: 3<br>解释: 它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。</p>
<p><strong>思路：</strong>动态规划，需注意0的处理，1010的编码方式共有1种，而909编码方式为0种，202编码方式为1种。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        l = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> l==<span class="number">0</span> <span class="keyword">or</span> s[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(l+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, l+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i-<span class="number">1</span>]!=<span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                dp[i] += dp[i-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">9</span>&lt;<span class="built_in">int</span>(s[i-<span class="number">2</span>:i])&lt;=<span class="number">26</span>:</span><br><span class="line">                dp[i]+=dp[i-<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]      </span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/decode-ways">https://leetcode-cn.com/problems/decode-ways</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 581.最短无序连续子数组</title>
    <url>/Leetcode-581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>你找到的子数组应是最短的，请输出它的长度。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">15</span>]</span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 你只需要对 [<span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">9</span>] 进行升序排序，那么整个表都会变为升序排序。</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><p>输入的数组长度范围在 [1, 10,000]。</p>
</li>
<li><p>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</p>
</li>
</ol>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>首先用左右两个指针分别探测左右各自逆序的起点。此时序列对应的数值是局部最小值与局部最大值。</p>
<p>然后在<strong>逆序序列</strong>(左边逆序开始与右边逆序开始位置之间)中寻找全局最小值与全局最大值。</p>
<p>然后从左边开始遍历寻找小于等于全局最小值的边界；从右边寻找大于等于全局最大值的边界。</p>
<p>左右边界构成数组的长度即为所求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 异常值处理</span></span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = len-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找左右逆序的边界</span></span><br><span class="line">        <span class="keyword">while</span>(i+<span class="number">1</span>&lt;len) <span class="keyword">if</span>(nums[i+<span class="number">1</span>]&lt;nums[i++]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span>) <span class="keyword">if</span>(nums[j-<span class="number">1</span>]&gt;nums[j--]) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果i+1&gt;len，证明数组本身是升序的，返回0</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&gt;len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 寻找全局最小值与全局最大值</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;min) min = nums[i];</span><br><span class="line">        &#125;<span class="keyword">while</span>(++i&lt;len);</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&gt;max) max = nums[j];</span><br><span class="line">        &#125;<span class="keyword">while</span>(--j&gt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从左右分别开始遍历，找到逆序数组真实左右边界</span></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        j = len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len &amp;&amp; nums[] &lt;=min) i++;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; nums[j] &gt;=max) j--;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> j-i+<span class="number">1</span>&gt;<span class="number">0</span>?j-i+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray">https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 638.大礼包</title>
    <url>/Leetcode-638-%E5%A4%A7%E7%A4%BC%E5%8C%85/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在LeetCode商店中， 有许多在售的物品。</p>
<p>然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。</p>
<p>现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。</p>
<p>每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。</p>
<p>任意大礼包可无限次购买。</p>
<p><strong>示例1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">5</span>], [[<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>]], [<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">14</span></span><br><span class="line">解释: </span><br><span class="line">有A和B两种物品，价格分别为¥<span class="number">2</span>和¥<span class="number">5</span>。</span><br><span class="line">大礼包<span class="number">1</span>，你可以以¥<span class="number">5</span>的价格购买3A和0B。</span><br><span class="line">大礼包<span class="number">2</span>， 你可以以¥<span class="number">10</span>的价格购买1A和2B。</span><br><span class="line">你需要购买<span class="number">3</span>个A和<span class="number">2</span>个B， 所以你付了¥<span class="number">10</span>购买了1A和2B（大礼包<span class="number">2</span>），以及¥<span class="number">4</span>购买2A。</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>]], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">11</span></span><br><span class="line">解释: </span><br><span class="line">A，B，C的价格分别为¥<span class="number">2</span>，¥<span class="number">3</span>，¥<span class="number">4.</span></span><br><span class="line">你可以用¥<span class="number">4</span>购买1A和1B，也可以用¥<span class="number">9</span>购买2A，2B和1C。</span><br><span class="line">你需要买1A，2B和1C，所以你付了¥<span class="number">4</span>买了1A和1B（大礼包<span class="number">1</span>），以及¥<span class="number">3</span>购买1B， ¥<span class="number">4</span>购买1C。</span><br><span class="line">你不可以购买超出待购清单的物品，尽管购买大礼包<span class="number">2</span>更加便宜。</span><br></pre></td></tr></table></figure></p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>DFS + 剪枝</p>
<p>即使暴力法，然后提出一些不满足条件的情况，即购买数量超出 (大礼包数量不对)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shoppingOffers</span><span class="params">(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subShoppingOffers(price, special, needs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">subShoppingOffers</span><span class="params">(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">// index标记，顺序开始计算，防止(1,2) 与 (2,1) 的重复计算</span></span><br><span class="line">        <span class="keyword">int</span> minCost = originalCost(price, needs);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index; i&lt;special.size(); i++)&#123;</span><br><span class="line">            <span class="comment">// 统计当前还需要购买多少物品</span></span><br><span class="line">            List&lt;Integer&gt; currentNeeds = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 当前礼包信息</span></span><br><span class="line">            List&lt;Integer&gt; offer = special.get(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;needs.size(); j++)&#123;</span><br><span class="line">                <span class="comment">// 剪枝</span></span><br><span class="line">                <span class="keyword">if</span>(offer.get(j) &gt; needs.get(j))&#123;</span><br><span class="line">                    currentNeeds = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                currentNeeds.add(needs.get(j)-offer.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果礼包中物品的数量没有超,则加上该礼包金额，并且继续深度优先(DFS)遍历</span></span><br><span class="line">            <span class="keyword">if</span>(currentNeeds!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                minCost = Math.min(minCost, offer.get(offer.size()-<span class="number">1</span>)+subShoppingOffers(price, special, currentNeeds, i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">originalCost</span><span class="params">(List&lt;Integer&gt; price, List&lt;Integer&gt; needs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;needs.size(); i++)&#123;</span><br><span class="line">            sum += price.get(i) * needs.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shopping-offers">https://leetcode-cn.com/problems/shopping-offers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 647.回文子串</title>
    <url>/Leetcode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。</p>
<p><strong>示例1：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 三个回文子串: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>.</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;aaa&quot;</span></span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">说明: <span class="number">6</span>个回文子串: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aaa&quot;</span>.</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入的字符串长度不会超过<span class="number">1000</span>。</span><br></pre></td></tr></table></figure></p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>回文子串的内部一定是回文子串，因此关键在于重复利用回文子串已经统计过的数值。</p>
<p>可采用双指针由回文子串向两端同时检测的方法。</p>
<p>分为偶数回文子串与奇数回文子串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            count(s, i, i); <span class="comment">// 统计奇数的回文子串数量</span></span><br><span class="line">            count(s, i, i+<span class="number">1</span>); <span class="comment">//统计偶数的回文子串数量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&gt;=<span class="number">0</span> &amp;&amp; end&lt;s.length() &amp;&amp; s.charAt(start)==s.charAt(end))&#123;</span><br><span class="line">            sum++;</span><br><span class="line">            start--;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路-代码-1"><a href="#思路-代码-1" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>采用动态规划，用一个二维数组 <code>dp[i][j]</code> 统计字符串从 i ~ j 是否是回文子串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="comment">// 用dp数组存储回文子串结果，第一维为长度（有哨兵），第二维为起始位置</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[length+<span class="number">1</span>][length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;length+<span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;length; ++j)&#123;</span><br><span class="line">                <span class="comment">// 所有长度为1的子串都为回文子串</span></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[j][j] = <span class="keyword">true</span>;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 所有长度为2的子串情况</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j+<span class="number">1</span>&lt;length &amp;&amp; s.charAt(j)==s.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">                        dp[j][j+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">                        sum++;</span><br><span class="line">                    &#125;                                        </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 长度大于3的情况</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j+i-<span class="number">1</span>&lt;length &amp;&amp; dp[j+<span class="number">1</span>][j+i-<span class="number">2</span>] &amp;&amp; s.charAt(j)==s.charAt(j+i-<span class="number">1</span>))&#123;</span><br><span class="line">                        dp[j][j+i-<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">                        sum++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 674.最长连续子序列</title>
    <url>/Leetcode-674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个未经排序的整数数组，找到最长且连续的的递增序列。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 最长连续递增序列是 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>], 长度为<span class="number">3</span>。</span><br><span class="line">尽管 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>] 也是升序的子序列, 但它不是连续的，因为<span class="number">5</span>和<span class="number">7</span>在原数组里被<span class="number">4</span>隔开。 </span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 最长连续递增序列是 [<span class="number">2</span>], 长度为<span class="number">1</span>。</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>数组长度不会超过10000。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>我的思路，用一个栈进行递增子序列长度的检查，用<font color="#f07c82">res</font>缓存结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        s.push(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                res = Math.max(res, s.size());</span><br><span class="line">                s.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, s.size());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h1><p>动态规划，用一个长度为n的数值维度维护每个位置的最大长度，然后取其中最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">               dp[i] += dp[i-<span class="number">1</span>];</span><br><span class="line">               res = Math.max(dp[i], res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence">https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 739.每日温度</title>
    <url>/Leetcode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路+代码"></a>思路+代码</h1><p>最简单的思路，两次循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = T.length;</span><br><span class="line">        <span class="keyword">int</span>[] results = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(T[j]&gt;T[i])&#123;</span><br><span class="line">                    results[i]=tmp+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>利用栈</strong></p>
<p>栈的特性是先进后出，所以需要从后往前遍历。</p>
<p>维护一个递减数据的索引（天）序列。</p>
<p>如果当前数据（温度）大于等于栈顶索引（天）对应的数据（温度），则更新栈内数据，保持递减特性。</p>
<p>否则计算当前数据索引（天）与栈顶所索引（天）为结果值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = T.length;</span><br><span class="line">        <span class="keyword">int</span>[] results = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Stack&lt;Integer&gt; stack  = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; T[i] &gt;= T[stack.peek()])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty())</span><br><span class="line">                <span class="comment">// 更新结果值</span></span><br><span class="line">                results[i] = stack.peek() - i;</span><br><span class="line">            <span class="comment">// 维护递减序列</span></span><br><span class="line">            stack.push(i);             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/daily-temperatures">https://leetcode-cn.com/problems/daily-temperatures</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 746.使用最小花费爬楼梯</title>
    <url>/Leetcode-746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>(索引从0开始)。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p>
<p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p>
<p><strong>示例1：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: cost = [<span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>]</span><br><span class="line">输出: <span class="number">15</span></span><br><span class="line">解释: 最低花费是从cost[<span class="number">1</span>]开始，然后走两步即可到阶梯顶，一共花费<span class="number">15</span>。</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: cost = [<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 最低花费方式是从cost[<span class="number">0</span>]开始，逐个经过那些<span class="number">1</span>，跳过cost[<span class="number">3</span>]，一共花费<span class="number">6</span>。</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> cost 的长度将会在 [<span class="number">2</span>, <span class="number">1000</span>]。</span><br><span class="line"><span class="number">2.</span> 每一个 cost[i] 将会是一个Integer类型，范围为 [<span class="number">0</span>, <span class="number">999</span>]。</span><br></pre></td></tr></table></figure></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>典型的动态规划问题，上楼梯问题。</p>
<p>注意的是，最后的结果是最后一阶楼梯与倒数第二个楼梯中取最小值。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="lang-java">class Solution &#123;
    public int minCostClimbingStairs(int[] cost) &#123;
        int len = cost.length;
        if(len==2)
            return(Math.min(cost[0], cost[1]));
        int[] result = new int[len];
        result[0]=cost[0];
        result[1]=cost[1];
        for(int i=2; i&lt;len; i++)&#123;
            result[i] = Math.min(result[i-1], result[i-2])+cost[i]; 
        &#125;
        // noted
        return Math.min(result[len-2], result[len-1]);
    &#125;
&#125;


`
</code></pre>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs">https://leetcode-cn.com/problems/min-cost-climbing-stairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 94.二叉树的中序遍历</title>
    <url>/Leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，返回它的中序 遍历。</p>
<p><strong>示例:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>进阶:</strong>递归算法很简单，你可以通过迭代算法完成吗？</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>递归截止条件：root==null</p>
<p>递归执行条件：<br>    list.add(inorderTraversal(root.left))<br>    list.add(root.val)<br>    list.add(inorderTraversal(root.right))</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List &lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List &lt;Integer&gt; res = <span class="keyword">new</span> ArrayList &lt;&gt; ();</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List &lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                helper(root.left, res);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                helper(root.right, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><p>用一个栈存储遍历过得父子节点，循环遍历。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 当树没有遍历完全</span></span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 找到当前树的最左侧叶子节点（父节点）</span></span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 中序遍历</span></span><br><span class="line">            root = stack.pop();</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/comments/">题目链接</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 969.煎饼排序</title>
    <url>/Leetcode-969-%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定数组 A，我们可以对其进行煎饼翻转：我们选择一些正整数 k &lt;= A.length，然后反转 A 的前 k 个元素的顺序。我们要执行零次或多次煎饼翻转（按顺序一次接一次地进行）以完成对数组 A 的排序。</p>
<p>返回能使 A 排序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * A.length 范围内的有效答案都将被判断为正确。</p>
<p><strong>示例 1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">解释：</span><br><span class="line">我们执行 <span class="number">4</span> 次煎饼翻转，k 值分别为 <span class="number">4</span>，<span class="number">2</span>，<span class="number">4</span>，和 <span class="number">3</span>。</span><br><span class="line">初始状态 A = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">第一次翻转后 (k=<span class="number">4</span>): A = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">第二次翻转后 (k=<span class="number">2</span>): A = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">第三次翻转后 (k=<span class="number">4</span>): A = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">第四次翻转后 (k=<span class="number">3</span>): A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]，此时已完成排序。 </span><br></pre></td></tr></table></figure></p>
<p><strong>示例 2:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">输入已经排序，因此不需要翻转任何内容。</span><br><span class="line">请注意，其他可能的答案，如[<span class="number">3</span>，<span class="number">3</span>]，也将被接受。</span><br></pre></td></tr></table></figure></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>煎饼反转就是以数组中心索引位置为轴，两两数字交换。例如最后一个数字与第一个数字交换，倒数第二个与第二个交换。</p>
<p>要想实现排序效果，就是依次把最大的放入最后面，这需要以下几步：</p>
<ol>
<li><p>找到未排序的数组里面最大的数，并记录索引。</p>
</li>
<li><p>以该索引为数组边界，进行一次煎饼反转，将该数转到第一个数字。</p>
</li>
<li><p>以未排序的子数组边界索引为边界，进行一次煎饼反转，将该数转到最后面。</p>
</li>
<li><p>循环进行。</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">pancakeSort</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = A.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(findIndex(A, size) &lt; size)&#123;</span><br><span class="line">                <span class="comment">// 两次反转将未排序子数组中最大的数字移到后面</span></span><br><span class="line">                <span class="comment">// result记录反转的索引位置</span></span><br><span class="line">                result.add(findIndex(A, size)+<span class="number">1</span>);</span><br><span class="line">                reverse(A, <span class="number">0</span>, findIndex(A, size));</span><br><span class="line">                result.add(size+<span class="number">1</span>);</span><br><span class="line">                reverse(A, <span class="number">0</span>, size);</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 煎饼反转算法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;j;i++,j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = A[i];</span><br><span class="line">            A[i] = A[j];</span><br><span class="line">            A[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找当前数组的最大值所在的索引位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findIndex</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>, k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=size; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;max)&#123;</span><br><span class="line">                max = A[i];</span><br><span class="line">                k = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/pancake-sorting">https://leetcode-cn.com/problems/pancake-sorting</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 岛屿最大的面积</title>
    <url>/Leetcode-%E5%B2%9B%E5%B1%BF%E6%9C%80%E5%A4%A7%E7%9A%84%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。</p>
<p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)</p>
<p><strong>示例1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure></p>
<p>对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。</p>
<p><strong>示例2:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure></p>
<p>对于上面这个给定的矩阵, 返回 0。</p>
<p><strong>注意:</strong> 给定的矩阵grid 的长度和宽度都不超过 50。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路+代码"></a>思路+代码</h1><p>一开始想的是动态规划，但是该题没有规律的求解方法，即岛屿的形状无法用统一的方法计算。</p>
<p>此题采用 <font color="#f07c82">DFS（深度优先遍历）</font>的方法求解。</p>
<p>DFS一般解体模板（<u><a href="https://blog.csdn.net/weixin_43272781/article/details/82959089">https://blog.csdn.net/weixin_43272781/article/details/82959089</a></u>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(参数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(满足条件)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        判断边界</span><br><span class="line">        &#123;</span><br><span class="line">            相应操作</span><br><span class="line">        &#125;</span><br><span class="line">        尝试每一种可能</span><br><span class="line">        &#123;</span><br><span class="line">               满足check条件</span><br><span class="line">               标记</span><br><span class="line">               继续下一步dfs(step+<span class="number">1</span>)</span><br><span class="line">               恢复初始状态（回溯的时候要用到）</span><br><span class="line">        &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>此题的解法：</p>
<ul>
<li><p>边界条件是二维矩阵的边界。</p>
</li>
<li><p>尝试每一种可能是上、下、左、右四个方向进行遍历。</p>
</li>
<li><p>check是是否为陆地（数值是否为1）。</p>
</li>
<li><p>标记是将遍历过的陆地变成海洋（置为0）。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> col;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        row = grid.length;</span><br><span class="line">        col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span> || col==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    res = Math.max(res, dfs(grid, i, j));   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] g, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>, x=<span class="number">0</span>, y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dir = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//避免再次被选到</span></span><br><span class="line">        g[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;<span class="number">4</span>;s++)&#123;</span><br><span class="line">            x = i + dir[s][<span class="number">0</span>];</span><br><span class="line">            y = j + dir[s][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;row &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;col &amp;&amp; g[x][y]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum += dfs(g, x ,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目链接：<u><a href="https://leetcode-cn.com/explore/interview/card/bytedance/243/array-and-sorting/1034/">https://leetcode-cn.com/explore/interview/card/bytedance/243/array-and-sorting/1034/</a></u></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 983.最低票价</title>
    <url>/Leetcode-983-%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B7/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。</p>
<p>火车票有三种不同的销售方式：</p>
<p>一张为期一天的通行证售价为 costs[0] 美元；<br>一张为期七天的通行证售价为 costs[1] 美元；<br>一张为期三十天的通行证售价为 costs[2] 美元。<br>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p>
<p>返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。</p>
<p><strong>示例1：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：days = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">20</span>], costs = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">15</span>]</span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释： </span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：</span><br><span class="line">在第 <span class="number">1</span> 天，你花了 costs[<span class="number">0</span>] = $<span class="number">2</span> 买了一张为期 <span class="number">1</span> 天的通行证，它将在第 <span class="number">1</span> 天生效。</span><br><span class="line">在第 <span class="number">3</span> 天，你花了 costs[<span class="number">1</span>] = $<span class="number">7</span> 买了一张为期 <span class="number">7</span> 天的通行证，它将在第 <span class="number">3</span>, <span class="number">4</span>, ..., <span class="number">9</span> 天生效。</span><br><span class="line">在第 <span class="number">20</span> 天，你花了 costs[<span class="number">0</span>] = $<span class="number">2</span> 买了一张为期 <span class="number">1</span> 天的通行证，它将在第 <span class="number">20</span> 天生效。</span><br><span class="line">你总共花了 $<span class="number">11</span>，并完成了你计划的每一天旅行。</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：days = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">31</span>], costs = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">15</span>]</span><br><span class="line">输出：<span class="number">17</span></span><br><span class="line">解释：</span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： </span><br><span class="line">在第 <span class="number">1</span> 天，你花了 costs[<span class="number">2</span>] = $<span class="number">15</span> 买了一张为期 <span class="number">30</span> 天的通行证，它将在第 <span class="number">1</span>, <span class="number">2</span>, ..., <span class="number">30</span> 天生效。</span><br><span class="line">在第 <span class="number">31</span> 天，你花了 costs[<span class="number">0</span>] = $<span class="number">2</span> 买了一张为期 <span class="number">1</span> 天的通行证，它将在第 <span class="number">31</span> 天生效。 </span><br><span class="line">你总共花了 $<span class="number">17</span>，并完成了你计划的每一天旅行。</span><br></pre></td></tr></table></figure></p>
<p><strong>提示：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= days.length &lt;= <span class="number">365</span></span><br><span class="line"><span class="number">1</span> &lt;= days[i] &lt;= <span class="number">365</span></span><br><span class="line">days 按顺序严格递增</span><br><span class="line">costs.length == <span class="number">3</span></span><br><span class="line"><span class="number">1</span> &lt;= costs[i] &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>动态规划。</p>
<p>ans[i] = min(ans[i-1]+costs[0] + ans[i-7]+costs[1] + ans[i-30]+costs[2]);</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="keyword">int</span>[] days, <span class="keyword">int</span>[] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = days.length;</span><br><span class="line">        <span class="keyword">int</span>[] results = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)&#123;</span><br><span class="line">            results[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止一周或者一月的火车票更便宜的情况出现</span></span><br><span class="line">        <span class="keyword">int</span> minCost = Math.min(Math.min(costs[<span class="number">0</span>],costs[<span class="number">1</span>]),costs[<span class="number">2</span>]);</span><br><span class="line">        results[<span class="number">0</span>] = costs[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 动态规划寻找最优值，分三种情况，计划时间一周内，一周到一个月，一个月以上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(days[i]&lt;=<span class="number">7</span>)&#123;</span><br><span class="line">                results[i] = Math.min(minCost+results[i-<span class="number">1</span>],costs[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">7</span>&lt;days[i]&amp;&amp;days[i]&lt;=<span class="number">30</span>)&#123;</span><br><span class="line">                <span class="comment">// 遍历具今天最近的一周外的时间</span></span><br><span class="line">                <span class="keyword">int</span> j=i;</span><br><span class="line">                <span class="keyword">while</span>(days[j]&gt;days[i]-<span class="number">7</span>)&#123;</span><br><span class="line">                    j--;</span><br><span class="line">                    <span class="keyword">if</span>(j&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这种情况是如果最开始的到当前时间都在一周内，例如[5,7,8,9]</span></span><br><span class="line">                <span class="keyword">int</span> tmp0 = j&lt;<span class="number">0</span>?<span class="number">0</span>:results[j]; </span><br><span class="line">                results[i] = Math.min(Math.min(results[i-<span class="number">1</span>]+minCost,costs[<span class="number">1</span>]+tmp0),costs[<span class="number">2</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">30</span>&lt;days[i])&#123;</span><br><span class="line">                <span class="comment">// 同上</span></span><br><span class="line">                <span class="keyword">int</span> k=i;</span><br><span class="line">                <span class="keyword">while</span>(days[k]&gt;days[i]-<span class="number">30</span>)&#123;</span><br><span class="line">                    k--;</span><br><span class="line">                    <span class="keyword">if</span>(k&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> m=i;</span><br><span class="line">                <span class="keyword">while</span>(days[m]&gt;days[i]-<span class="number">7</span> &amp;&amp; m&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    m--;</span><br><span class="line">                    <span class="keyword">if</span>(m&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> tmp1 = k&lt;<span class="number">0</span>?<span class="number">0</span>:results[k];</span><br><span class="line">                <span class="keyword">int</span> tmp2 = m&lt;<span class="number">0</span>?<span class="number">0</span>:results[m];</span><br><span class="line">                results[i] = Math.min(Math.min(results[i-<span class="number">1</span>]+minCost,costs[<span class="number">2</span>]+tmp1),costs[<span class="number">1</span>]+tmp2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results[len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>大神的做法，扩充dp数组，实现算法的一致，即简化了代码，又提高了代码的运行效率。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="keyword">int</span>[] days, <span class="keyword">int</span>[] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] rec = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">365</span>+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> day:days)</span><br><span class="line">            rec[day] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> lastDay = days[days.length-<span class="number">1</span>]+<span class="number">30</span>;</span><br><span class="line">        <span class="comment">// 扩充一个月dp数组使得判定条件一致</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">366</span>+<span class="number">30</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>; i&lt;=lastDay; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rec[i-<span class="number">30</span>])</span><br><span class="line">                dp[i] = Math.min(Math.min(dp[i-<span class="number">1</span>]+costs[<span class="number">0</span>],dp[i-<span class="number">7</span>]+costs[<span class="number">1</span>]),dp[i-<span class="number">30</span>]+costs[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i]=dp[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[lastDay];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-cost-for-tickets">https://leetcode-cn.com/problems/minimum-cost-for-tickets</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 字符串的排列 (String 练习 03)</title>
    <url>/Leetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97-String-%E7%BB%83%E4%B9%A0-03/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p>
<p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p>
<p><strong>示例1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s1 = <span class="string">&quot;ab&quot;</span> s2 = <span class="string">&quot;eidbaooo&quot;</span></span><br><span class="line">输出: True</span><br><span class="line">解释: s2 包含 s1 的排列之一 (<span class="string">&quot;ba&quot;</span>).</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s1= <span class="string">&quot;ab&quot;</span> s2 = <span class="string">&quot;eidboaoo&quot;</span></span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure></p>
<p><strong>注意:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 输入的字符串只包含小写字母</span><br><span class="line"><span class="number">2.</span> 两个字符串的长度都在 [<span class="number">1</span>, <span class="number">10</span>,<span class="number">000</span>] 之间</span><br></pre></td></tr></table></figure></p>
<h1 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h1><p>暴力法，滑动窗口依次判定。</p>
<p>但是<strong>超出时间限制！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(len2&lt;len1)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+len1&lt;=len2; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(checkSubString(s1, s2.substring(i, i+len1)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkSubString</span><span class="params">(String subS1, String subS2)</span></span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(subS2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;subS1.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.indexOf(subS1.charAt(i))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                s = s.replaceFirst(String.valueOf(subS1.charAt(i)), <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.isEmpty()?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O((len2-len1) <em> len1 </em> len2 * len2)</p>
<p>空间复杂度：O(1)</p>
<h1 id="思路-2"><a href="#思路-2" class="headerlink" title="思路 2"></a>思路 2</h1><p>也是滑动窗口法，不过不用内置的函数（使用过程中存在循环遍历），而利用数组存储各个字母出现的次数，进行子串是否匹配的判定依据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(len2&lt;len1)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] temp1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len1; i++)</span><br><span class="line">            temp1[s1.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+len1&lt;=len2; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;s1.length(); j++)&#123;</span><br><span class="line">                temp2[s2.charAt(i+j)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(match(temp1, temp2))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span>[] tmp1, <span class="keyword">int</span>[] tmp2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;tmp1.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp1[i]!=tmp2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(len1 + (len2-len1) <em> len1 </em> 26)</p>
<p>空间复杂度: O(1)</p>
<h1 id="思路-3"><a href="#思路-3" class="headerlink" title="思路 3"></a>思路 3</h1><p>基于思路2，继续进行优化。其实在滑动窗口中，每次只更新哈希表（数组）的第一个值及最后一个值，中间的不需要遍历。因此时间复杂度降低 len1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(len2&lt;len1)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] temp1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] temp2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len1; i++)&#123;</span><br><span class="line">            temp1[s1.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            temp2[s2.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(match(temp1, temp2))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+len1&lt;len2; i++)&#123;</span><br><span class="line">            temp2[s2.charAt(i+len1)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            temp2[s2.charAt(i)-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span>(match(temp1, temp2))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span>[] tmp1, <span class="keyword">int</span>[] tmp2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;tmp1.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp1[i]!=tmp2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(len1 + (len2-len1) * 26)</p>
<p>空间复杂度: O(1)</p>
<p>作者：LeetCode<br>链接：<a href="https://leetcode-cn.com/problems/permutation-in-string/solution/zi-fu-chuan-de-pai-lie-by-leetcode/">https://leetcode-cn.com/problems/permutation-in-string/solution/zi-fu-chuan-de-pai-lie-by-leetcode/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 无重复字符的最长子串（String 练习 02）</title>
    <url>/Leetcode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p><strong>示例1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure></p>
<p><strong>示例3:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure></p>
<h1 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h1><p>暴力法，用Set记录检查的无重复的最长子串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(chars.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; chars.length-<span class="number">1</span>; i++)&#123;      </span><br><span class="line">            set.add(chars[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;chars.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!set.contains(chars[j]))&#123;</span><br><span class="line">                    set.add(chars[j]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result, set.size());</span><br><span class="line">            set.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路-2"><a href="#思路-2" class="headerlink" title="思路 2"></a>思路 2</h1><p>滑动窗口法。</p>
<p>暴力法虽然容易想到，但是很多情况重复考虑了。例如假定在 i ~ j 子串为不重复子串，那么该子串内的子串都会不重复。</p>
<p>滑动窗口法 1：采用标记记录左侧窗口的索引值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> leftIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 滑动窗口的右边索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;chars.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 对于当前的滑动窗口进行重复性字符检查</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> checkIndex = leftIndex; checkIndex&lt;i; checkIndex++)&#123;</span><br><span class="line">                <span class="comment">// 如果存在相同字符串，就更新窗口左边索引</span></span><br><span class="line">                <span class="keyword">if</span>(chars[checkIndex]==chars[i])&#123;</span><br><span class="line">                    <span class="comment">// 更新结果</span></span><br><span class="line">                    result = Math.max(result, i-leftIndex);</span><br><span class="line">                    leftIndex = checkIndex+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;a</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查最后一次窗口的长度与result保留长度进行对比</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(chars.length-leftIndex, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>滑动窗口 2：巧用 <strong>HashSet</strong>，利用HashSet维护范围为 <strong>[i,j)</strong> 的滑动窗口。</p>
<p>先滑动右边，j++。如果存在重复，记录此时长度，再滑动左边 i++。直到所有的 i 遍历完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>, i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len &amp;&amp; j &lt; len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j++));</span><br><span class="line">                ans = Math.max(ans, j-i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.remove(s.charAt(i++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>滑动窗口 3：上面的优化。如果 j 存在重复，那么 i 不仅移动一位，而是移动到 j+1 的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; j&lt;len; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(j)))&#123;</span><br><span class="line">                i = Math.max(i, map.get(s.charAt(j)));</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, j-i+<span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(j), j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux终端常用指令</title>
    <url>/Linux%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="常用指令集"><a href="#常用指令集" class="headerlink" title="常用指令集"></a>常用指令集</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">pwd</td>
<td style="text-align:center">打印当前工作目录</td>
</tr>
<tr>
<td style="text-align:center">hostname</td>
<td style="text-align:center">获取我的计算机的网络名称</td>
</tr>
<tr>
<td style="text-align:center">mkdir</td>
<td style="text-align:center">创建目录</td>
</tr>
<tr>
<td style="text-align:center">cd</td>
<td style="text-align:center">更改目录</td>
</tr>
<tr>
<td style="text-align:center">ls</td>
<td style="text-align:center">列出目录下的文件</td>
</tr>
<tr>
<td style="text-align:center">rmdir</td>
<td style="text-align:center">删除目录</td>
</tr>
<tr>
<td style="text-align:center">pushd</td>
<td style="text-align:center">push directory</td>
</tr>
<tr>
<td style="text-align:center">popd</td>
<td style="text-align:center">pop directory</td>
</tr>
<tr>
<td style="text-align:center">cp</td>
<td style="text-align:center">复制文件或目录</td>
</tr>
<tr>
<td style="text-align:center">mv</td>
<td style="text-align:center">移动/重命名文件或目录</td>
</tr>
<tr>
<td style="text-align:center">less</td>
<td style="text-align:center">按页查看文件</td>
</tr>
<tr>
<td style="text-align:center">cat</td>
<td style="text-align:center">输出整个文件</td>
</tr>
<tr>
<td style="text-align:center">xargs</td>
<td style="text-align:center">执行参数</td>
</tr>
<tr>
<td style="text-align:center">find</td>
<td style="text-align:center">查找文件</td>
</tr>
<tr>
<td style="text-align:center">grep</td>
<td style="text-align:center">查找文件里面的东西</td>
</tr>
<tr>
<td style="text-align:center">man</td>
<td style="text-align:center">阅读帮助手册</td>
</tr>
<tr>
<td style="text-align:center">apropos</td>
<td style="text-align:center">find what man page is appropriate</td>
</tr>
<tr>
<td style="text-align:center">env</td>
<td style="text-align:center">查看计算机环境</td>
</tr>
<tr>
<td style="text-align:center">echo</td>
<td style="text-align:center">输出一些参数</td>
</tr>
<tr>
<td style="text-align:center">export</td>
<td style="text-align:center">设置一个新的环境变量</td>
</tr>
<tr>
<td style="text-align:center">exit</td>
<td style="text-align:center">退出终端</td>
</tr>
<tr>
<td style="text-align:center">sudo</td>
<td style="text-align:center">危险! 拥有超级用户权限!</td>
</tr>
<tr>
<td style="text-align:center">sudo rm –rf /*</td>
<td style="text-align:center">赶紧跑路吧！</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown文件中添加UML图</title>
    <url>/Markdown%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0UML%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="UML图简介"><a href="#UML图简介" class="headerlink" title="UML图简介"></a>UML图简介</h1><p>UML(Unified Modeling Language)是统一建模语言的简写。</p>
<p>它可分为<font color="#f07c82">用例视图、设计视图、进程视图、实现视图和拓扑视图</font>，又可以静动分为静态视图和动态视图。静态图分为：<font color="#f07c82">用例图，类图，对象图，包图，构件图，部署图</font>。动态图分为：<font color="#f07c82">状态图，活动图，协作图，序列图</font>。</p>
<p>其中<font color="#f07c82"><strong>类图</strong></font> (Class Diagrams)是用来表示类的内部结构和类与类之间的关系的一种UML。常见的关系有：泛化 (Generalization)，实现 (Realization)，组合 (Composition)，聚合 (Aggregation)，关联 (Association)，依赖 (Dependency)。</p>
<p>各种关系的强弱顺序： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p>
<p><u><a href="https://www.cnblogs.com/jiangds/p/6596595.html">参考教程</a></u></p>
<h1 id="UML类图的绘制及插入"><a href="#UML类图的绘制及插入" class="headerlink" title="UML类图的绘制及插入"></a>UML类图的绘制及插入</h1><p>我们利用在线的开源工具<u><a href="http://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000">plantUML</a></u>实现UML图绘制。</p>
<p>具体的绘制方法可以参考官网<u><a href="http://plantuml.com/zh/">plantUML</a></u>。</p>
<p>然后将网址中生成的UML图片地址插入到<strong>Markdown</strong>文件中。</p>
<img src="/Markdown%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0UML%E5%9B%BE/uml.png" class>
<p><u><a href="https://www.heqiangfly.com/2017/07/08development-tool-markdown-plant-uml/">参考教程</a></u></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Minimum-Falling-Path-Sum</title>
    <url>/Minimum-Falling-Path-Sum/</url>
    <content><![CDATA[<h1 id="下降路径最小和"><a href="#下降路径最小和" class="headerlink" title="下降路径最小和"></a>下降路径最小和</h1><p><strong>题目细节</strong></p>
<blockquote>
<p>给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。<br>下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。</p>
</blockquote>
<p><strong>示例1</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>解释：</strong><br>可能的下降路径有：<br>    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>], [<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>], [<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>], [<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>], [<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>], [<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>], [<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>], [<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>], [<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><br>和最小的下降路径是 <strong>[1,4,7]</strong>，所以答案是 <strong>12</strong>。</p>
</blockquote>
<p><strong>提示</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= A.length == A[<span class="number">0</span>].length &lt;= <span class="number">100</span></span><br><span class="line">-<span class="number">100</span> &lt;= A[i][j] &lt;= <span class="number">100</span></span><br></pre></td></tr></table></figure></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>典型的二维动态数组题目。创建一个二维的数组<strong>A[row][column]</strong>存储结果，每一个位置存储的是第一行到该位置最小的下降路径。</p>
<p><strong>一般情况</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A[i][j] +=min(min(A[i-<span class="number">1</span>][j-<span class="number">1</span>],A[i-<span class="number">1</span>][j]),A[i-<span class="number">1</span>][j+<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></p>
<p><strong>前后两列情况</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第一列: A[i][j] += min(A[i-<span class="number">1</span>][j],A[i-<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">最后一列: A[i][j] += min(A[i-<span class="number">1</span>][j-<span class="number">1</span>],A[i-<span class="number">1</span>][j]);</span><br></pre></td></tr></table></figure></p>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = A.length;</span><br><span class="line">        <span class="keyword">int</span> col = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> A[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-<span class="number">1</span>&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    A[i][j] += min(A[i-<span class="number">1</span>][j],A[i-<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j+<span class="number">1</span>&gt;col-<span class="number">1</span>)&#123;</span><br><span class="line">                    A[i][j] += min(A[i-<span class="number">1</span>][j-<span class="number">1</span>],A[i-<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    A[i][j] +=min(min(A[i-<span class="number">1</span>][j-<span class="number">1</span>],A[i-<span class="number">1</span>][j]),A[i-<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;col;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (A[row-<span class="number">1</span>][i] &lt; result) &#123;</span><br><span class="line">                result = A[row-<span class="number">1</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a&lt;=b?a:b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/submissions/">题目链接</a></p>
<p><a href="https://sunyunzeng.github.io/SUNYunZeng.github.io/2019/05/21/Algorithm-Minimum-path-sum/">类似题目</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 最长公共前缀 (String 练习 01)</title>
    <url>/Leetcode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<p><strong>示例1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">&quot;flower&quot;</span>,<span class="string">&quot;flow&quot;</span>,<span class="string">&quot;flight&quot;</span>]</span><br><span class="line">输出: <span class="string">&quot;fl&quot;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>示例2:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;racecar&quot;</span>,<span class="string">&quot;car&quot;</span>]</span><br><span class="line">输出: <span class="string">&quot;&quot;</span></span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure></p>
<p><strong>说明:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">所有输入只包含小写字母 a-z 。</span><br></pre></td></tr></table></figure></p>
<h1 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h1><p>暴力法，时间复杂度O(n^3)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        String ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(strs.length==<span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        lable:&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;strs[<span class="number">0</span>].length(); j++)&#123;</span><br><span class="line">                <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(j);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;strs.length; i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=strs[i].length() || !isCharEqual(c, strs[i], j))&#123;</span><br><span class="line">                        <span class="keyword">break</span> lable;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCharEqual</span><span class="params">(<span class="keyword">char</span> c, String s, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c==s.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h1><p>巧用String提供的一些API，例如substring(),判定子串的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        String ans;</span><br><span class="line">        <span class="keyword">if</span>(strs.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        ans = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;strs.length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(strs[i].indexOf(ans)!=<span class="number">0</span>)&#123;</span><br><span class="line">                ans = ans.substring(<span class="number">0</span>, ans.length()-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(ans.isEmpty())</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 33.搜索旋转排序数组</title>
    <url>/Leetcode%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p><strong>示例1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p><strong>示例2:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">3</span></span><br><span class="line">输出: -<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路+代码"></a>思路+代码</h1><p>时间复杂度要求是O(log n)，也就是二分法。于是我写了一个最基础的二分法…还是用递归..</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span> || nums==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]==target?<span class="number">0</span>:-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> subSearch(nums, target, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">subSearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]==target)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span>(nums[right]==target)</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(right-left==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        tmp=subSearch(nums, target, left, mid);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(tmp!=-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        tmp=subSearch(nums, target, mid, right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了答案之后… 我想说:<em>**</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target==nums[mid])</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">// 左侧不包含旋转序列</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left]&lt;=nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;=nums[left]&amp;&amp;target&lt;nums[mid])&#123;</span><br><span class="line">                    right = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右侧不包含旋转序列</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;nums[mid]&amp;&amp;target&lt;=nums[right])&#123;</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array">https://leetcode-cn.com/problems/search-in-rotated-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL：入门</title>
    <url>/MySQL%EF%BC%9A%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="MySQL-简介"><a href="#MySQL-简介" class="headerlink" title="MySQL 简介"></a>MySQL 简介</h1><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p>
<center> <img src="/MySQL%EF%BC%9A%E5%85%A5%E9%97%A8/my-SQL.png" class> </center>

<p><strong>MySQL具有以下优点：</strong></p>
<p> 成本——MySQL是开放源代码的，一般可以免费使用（甚至可以 免费修改）。</p>
<p> 性能——MySQL执行很快（非常快）。  可信赖——某些非常重要和声望很高的公司、站点使用MySQL， 这些公司和站点都用MySQL来处理自己的重要数据。</p>
<p> 简单——MySQL很容易安装和使用。</p>
<h1 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h1><ol>
<li>启动服务</li>
</ol>
<p>Windows：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">net <span class="keyword">start</span> mysql</span><br></pre></td></tr></table></figure>
<p>ubuntu:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sudo service mysql <span class="keyword">start</span>     </span><br></pre></td></tr></table></figure>
<ol>
<li>登录</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br></pre></td></tr></table></figure>
<ol>
<li>查看已有数据库</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建数据库</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用数据库</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE DATABASE;</span><br></pre></td></tr></table></figure>
<ol>
<li>显示所有表</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure>
<ol>
<li>显示已有表的所有列</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> COLUMNS <span class="keyword">FROM</span> YOURDATABASE;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建表</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book(name <span class="type">char</span>(<span class="number">20</span>), author <span class="type">char</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure>
<ol>
<li>在表中插入数据</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book <span class="keyword">VALUES</span>(<span class="string">&#x27;C++ Primer&#x27;</span>, <span class="string">&#x27;Stanley B. Lippman&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book <span class="keyword">VALUES</span>(<span class="string">&#x27;Thinking in JAVA&#x27;</span>, <span class="string">&#x27;Bruce Eckel&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book <span class="keyword">VALUES</span>(<span class="string">&#x27;Easy Python&#x27;</span>, <span class="string">&#x27;Kukeel Borant&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>查看表中数据</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> book;</span><br></pre></td></tr></table></figure>
<h1 id="选择数据-SELECT"><a href="#选择数据-SELECT" class="headerlink" title="选择数据 SELECT"></a>选择数据 <strong>SELECT</strong></h1><ol>
<li>选择单列</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> book;</span><br></pre></td></tr></table></figure>
<ol>
<li>选择多列</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, author <span class="keyword">FROM</span> book;</span><br></pre></td></tr></table></figure>
<ol>
<li>选择所有列</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> book;</span><br></pre></td></tr></table></figure>
<ol>
<li>检索不同行</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> author <span class="keyword">FROM</span> book;</span><br></pre></td></tr></table></figure>
<ol>
<li>限制检索的行数</li>
</ol>
<p>从第一行开始，返回结果不超过3行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> author </span><br><span class="line"><span class="keyword">FROM</span> book</span><br><span class="line">LIMIT <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>从第3行（<strong>第一行为0</strong>）开始，只检索结果不超过3行<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> author </span><br><span class="line"><span class="keyword">FROM</span> book</span><br><span class="line">LIMIT <span class="number">2</span>，<span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>完全限定的表名</li>
</ol>
<p>指定从表 book 中选择 author 列<br>从数据库 library 中选择 book 表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> book.author</span><br><span class="line"><span class="keyword">FROM</span> library.book;</span><br></pre></td></tr></table></figure>
<h1 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h1><p>关系数据库设计理论认为，如果不明确规定排序顺序，则不应假设检索出得数据的顺序有意义。</p>
<p>SQL语句由字句(clause)构成，有的字句是必需的，而有的是可选的。</p>
<ol>
<li><strong>OREDR BY</strong> 关键字句排序</li>
</ol>
<p>默认升序排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> author</span><br><span class="line"><span class="keyword">FROM</span> book</span><br><span class="line">OREDER <span class="keyword">BY</span> name;</span><br></pre></td></tr></table></figure>
<p>还可以显示多列，添加多列约束，约束规则是在<strong>优先级高的数据有重复时，再按低一级的约束列排序</strong>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> author, name</span><br><span class="line"><span class="keyword">FROM</span> book</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> price, name;</span><br></pre></td></tr></table></figure>
<ol>
<li>指定排序方向</li>
</ol>
<p><strong>DESC</strong>逆序排列。</p>
<p>只对价格逆序排列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> author, name</span><br><span class="line"><span class="keyword">FROM</span> book</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>, name;</span><br></pre></td></tr></table></figure>
<ol>
<li>集合 LIMIT 与 ORDER 挑选最贵书籍</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> book</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h1 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h1><p>通过关键字 WHERE 进行数据过滤</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">等于</td>
</tr>
<tr>
<td style="text-align:center">&lt;&gt;</td>
<td style="text-align:center">不等于</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">不等于</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">小于等于</td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">大于等于</td>
</tr>
<tr>
<td style="text-align:center">BETWEEN</td>
<td style="text-align:center">在指定两个值之间</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>过滤行</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> book</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Machine Learning&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>阈值过滤</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> book</span><br><span class="line"><span class="keyword">WHERE</span> price <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>空值检查</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id</span><br><span class="line"><span class="keyword">FROM</span> book</span><br><span class="line"><span class="keyword">WHERE</span> price <span class="keyword">is</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<h2 id="LIKE-通配符搜索"><a href="#LIKE-通配符搜索" class="headerlink" title="LIKE 通配符搜索"></a>LIKE 通配符搜索</h2><p>通配符是 WHERE 字句中具有特殊含义的字符</p>
<ol>
<li>% 通配符</li>
</ol>
<p>% 通配符表示匹配任意字符出现任意次</p>
<p>匹配 Mach 开头的书名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> book</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;Mach%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>_ 通配符</li>
</ol>
<p>_ 通配符表示任意字符出现一次</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> book</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;_ach%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><ol>
<li>在首列插入新字段</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> books</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> price <span class="type">float</span>(<span class="number">5</span>,<span class="number">2</span>) <span class="comment">--总共5位，小数2位</span></span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">NULL</span> FRIST;</span><br></pre></td></tr></table></figure>
<ol>
<li>在某列后插入新字段</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> books</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> price <span class="type">float</span>(<span class="number">5</span>,<span class="number">2</span>) <span class="comment">--总共5位，小数2位</span></span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">NULL</span> AFTER author;</span><br></pre></td></tr></table></figure>
<ol>
<li>默认插入最后一列</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> books</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> price <span class="type">float</span>(<span class="number">5</span>,<span class="number">2</span>) <span class="comment">--总共5位，小数2位</span></span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<h1 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h1><p>一定记得加 <strong>WHERE</strong> 字句限定</p>
<ol>
<li>更新指定单行与单列 </li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE book</span><br><span class="line"><span class="keyword">SET</span> price <span class="operator">=</span> <span class="number">10.23</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>更新指定多列与单行</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE book</span><br><span class="line"><span class="keyword">SET</span> price <span class="operator">=</span> <span class="number">8.88</span>, <span class="comment">--多行之间逗号隔开</span></span><br><span class="line">    name <span class="operator">=</span> <span class="string">&#x27;Machine Learning&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>通过设置为NULL 删除某列的值</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE book</span><br><span class="line"><span class="keyword">SET</span> price <span class="operator">=</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h1 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h1><p>一定记得加 <strong>WHERE</strong> 字句限定</p>
<ol>
<li>删除某一行</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELECT <span class="keyword">FROM</span> book</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>删除某一列</li>
</ol>
<p>属于重构表结构，谨慎选择</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> price;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP协议</title>
    <url>/TCP-IP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><h2 id="HTTP的来历"><a href="#HTTP的来历" class="headerlink" title="HTTP的来历"></a>HTTP的来历</h2><p>CERN(欧洲核子研究组织)的蒂姆 • 伯纳斯 - 李(Tim BernersLee)博士提出了一种能让远隔两地的研究者们共享知识的设想。</p>
<p>最初的设想是通过超文本(HyperText)标记,各地互联连接成可相互参阅的<font color="#f07c82">WWW(World Wide Web, 万维网)</font>。</p>
<p>目前WWW构建的关键技术为：</p>
<ul>
<li><p>基于SGML(Standard Generalized Markup Language,标准通用标记语言)的<font color="#f07c82">HTML （HyperText Markup Language, 超文本标记语言）</font>。</p>
</li>
<li><p>指定文档所在的地址<font color="#f07c82">URL (Uniform Resource Locator, 统一资源定位符) </font>。</p>
</li>
</ul>
<p>各个Web服务器通过万维网互相连接，以 HTML 标准编辑网页（存储信息），用 URL 实现信息的查找，最后通过Web浏览器实现界面的渲染。</p>
<h2 id="如何控制信息的传输？"><a href="#如何控制信息的传输？" class="headerlink" title="如何控制信息的传输？"></a>如何控制信息的传输？</h2><p>然而，Web服务器有各种各样的类型及硬件接口，显示平台也有各种各样的类型，如何实现平台之间信息的互相交流呢？ —— <font color="#f07c82">统一协议控制</font>。答案是通过统一的<font color="#f07c82">协议 (Protocol)</font>。</p>
<h1 id="TCP-TP-协议簇"><a href="#TCP-TP-协议簇" class="headerlink" title="　TCP/TP 协议簇"></a>　TCP/TP 协议簇</h1><p>TCP/IP　有说法是专指TCP和IP协议。</p>
<p>这里指<font color="#f07c82">互联网相关的各类协议簇的总称</font>，例如：IP, PPPoE, TCP, FTP, HTTP, FDDI, IEEE 802.3, SNMP, UDP, DNS, ICMP　等等。</p>
<p>也就是说　HTTP　是　TCP/IP　协议的子集。</p>
<h2 id="分层管理"><a href="#分层管理" class="headerlink" title="分层管理"></a>分层管理</h2><p>在逻辑上，TCP/IP分为四个层次：<font color="#f07c82">应用层、传输层、网络层和数据链路层</font>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用层</td>
<td style="text-align:center">客户端实现信息的封装与解析。该层使用的协议如 HTTP、DNS (Domain Name System, 域名系统)、FTP (File Transfer Protocol, 文件传输协议)等。</td>
</tr>
<tr>
<td style="text-align:center">传输层</td>
<td style="text-align:center">提供网络连接中两台计算机之间的数据传输。使用的协议：TCP (Transmission Control Protocol) 和 UDP (User Data Protocol, 用户数据协议)。</td>
</tr>
<tr>
<td style="text-align:center">网络层</td>
<td style="text-align:center">将网络中流动的数据包（网络传输最小数据单位）通过规定的路径（传输线路）到达对方的计算机，并把数据传给对方。</td>
</tr>
<tr>
<td style="text-align:center">数据链路层</td>
<td style="text-align:center">肉眼可见的硬件层，包括网卡、光纤等。</td>
</tr>
</tbody>
</table>
</div>
<img src="/TCP-IP%E5%8D%8F%E8%AE%AE/tcp.png" class>
<h2 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h2><ol>
<li><p>用户根据HTTP协议发送一个数据请求（应用层）。</p>
</li>
<li><p>获得应用层数据后，传输层（TCP协议）为了方便，将数据（HTTP请求报文）进行分割，每个报文打上标记序号及端口号，然后转发给网络层。</p>
</li>
<li><p>网络层将通信目的地的DNS增加到数据中，然后转发给数据链路层。</p>
</li>
<li><p>数据链路层将数据发给目的地终端。</p>
</li>
</ol>
<img src="/TCP-IP%E5%8D%8F%E8%AE%AE/transform.png" class>
<p>在解析数据时，按照数据包装的逆序层层解包（<strong>去除每一层打上的首部信息</strong>），最终获得请求的HTTP报头。</p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet技术</title>
    <url>/Servlet%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="什么是Servet"><a href="#什么是Servet" class="headerlink" title="什么是Servet?"></a>什么是Servet?</h1><p>Servlet (Server Applet)，从字面上看，就是<font color="#f07c82">Java</font>服务器小程序的意思。它确实就像字面意思一样，是<font color="#f07c82">在服务中用于处理网络请求的小程序</font>。</p>
<p>在Web的世界中，客户端会提交各种请求到服务端，服务端如何处理客户端的请求呢？</p>
<p>常规的Java编程方法，好像很难完成这项任务，但是没有事情是难倒程序猿的。</p>
<p>于是，他们设计了<font color="#f07c82">Servlet规范</font>，用来处理网络的各种请求。</p>
<p>具体网络的请求呢，无非就是<font color="#f07c82">get、post等等</font>，这在<a href="http://sunyunzeng.com/categories/HTTP/">HTTP规范系列</a>里面有讲到。</p>
<p>Servlet规范也没有想象中的那么高大上，其实它就是一个<strong>Java接口</strong>，里面一共就定义了五个方法，如图：</p>
<img src="/Servlet%E6%8A%80%E6%9C%AF/servlet_interface.PNG" class>
<p>其中：</p>
<blockquote>
<ul>
<li>init() 规定了Servet如何初始化。</li>
<li>getServletConfig() 获取Sevvlet的配置。</li>
<li>service(ServletRequest, ServletResponse) 接收到请求怎么处理。</li>
<li>getServletInfo() 提供有关servlet的信息，如作者、版本、版权等。</li>
<li>destroy() 销毁Servlet。</li>
</ul>
</blockquote>
<h1 id="Servlet的运行"><a href="#Servlet的运行" class="headerlink" title="Servlet的运行"></a>Servlet的运行</h1><p>任何合理实现了Servlet接口的类都具有处理HTTP请求的能力，但是就像java类的运行需要在JVM环境中一样，Servlet的运行也要环境，这里称为<font color="#f07c82">容器</font>。</p>
<p>即Servlet的运行需要特定的容器，<strong>该容器负责实现对端口的监听，将请求内容解析，然后实例Servlet对象，给Servlet提供运行环境，然后将Servlet的处理结果发给客户端</strong>。</p>
<p><strong>Tomcat</strong>就是一个开源的Servlet的容器，它也是一个Web服务器。</p>
<font color="#f07c82">HttpServlet</font>就是已经实现好的一个Servlet类，他对一些方法进行了详细的补充，我们通过doGet()、doPost()等方法很方便地实现处理HTTP请求功能。

它的一些源码如下：

1. service()实现：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//获取http request的method参数，其实就是html的form标签  </span></span><br><span class="line">        <span class="comment">//中method属性对应的字符串 </span></span><br><span class="line">        String method = req.getMethod();</span><br><span class="line">        <span class="keyword">long</span> errMsg;</span><br><span class="line">        <span class="comment">//判断请求方式</span></span><br><span class="line">        <span class="keyword">if</span>(method.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//获取最后被修改时间 </span></span><br><span class="line">            errMsg = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span>(errMsg == -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="comment">/**如果servlet不支持http request header的if-modified-since属性 </span></span><br><span class="line"><span class="comment">             * 则继续处理 </span></span><br><span class="line"><span class="comment">             **/</span>  </span><br><span class="line">                <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//如果支持这个属性 </span></span><br><span class="line">                <span class="keyword">long</span> ifModifiedSince;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ifModifiedSince = req.getDateHeader(<span class="string">&quot;If-Modified-Since&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">                    ifModifiedSince = -<span class="number">1L</span>;</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">/** </span></span><br><span class="line"><span class="comment">                * 如果客户端的文件最后修改时间和服务器端的文件最后修改时间一致则返回304不需要修改状态 </span></span><br><span class="line"><span class="comment">                * 这样服务器就不返回html，浏览器读取本地缓存文件，否则重新获取服务器端的对应html文件 </span></span><br><span class="line"><span class="comment">                **/</span>  </span><br><span class="line">                <span class="keyword">if</span>(ifModifiedSince &lt; errMsg / <span class="number">1000L</span> * <span class="number">1000L</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.maybeSetLastModified(resp, errMsg);</span><br><span class="line">                    <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(<span class="number">304</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">            errMsg = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">this</span>.maybeSetLastModified(resp, errMsg);</span><br><span class="line">            <span class="keyword">this</span>.doHead(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(method.equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(method.equals(<span class="string">&quot;PUT&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doPut(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(method.equals(<span class="string">&quot;DELETE&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doDelete(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(method.equals(<span class="string">&quot;OPTIONS&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doOptions(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(method.equals(<span class="string">&quot;TRACE&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doTrace(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果请求不是以上的所有请求方式，该方法就会响应501错误，也就是不支持这种请求</span></span><br><span class="line">            String errMsg1 = lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> Object[]&#123;method&#125;;</span><br><span class="line">            errMsg1 = MessageFormat.format(errMsg1, errArgs);</span><br><span class="line">            resp.sendError(<span class="number">501</span>, errMsg1);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        HttpServletRequest request;</span><br><span class="line">        HttpServletResponse response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request = (HttpServletRequest)req;</span><br><span class="line">            response = (HttpServletResponse)res;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">&quot;non-HTTP request or response&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.service(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

2. doGet()实现：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取协议 </span></span><br><span class="line">        String protocol = req.getProtocol();</span><br><span class="line">        <span class="comment">//获取http.method_get_not_supported的国际化字符串</span></span><br><span class="line">        String msg = lStrings.getString(<span class="string">&quot;http.method_get_not_supported&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(protocol.endsWith(<span class="string">&quot;1.1&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//如果是HTTP/1.1，返回405禁止访问方法错误</span></span><br><span class="line">            resp.sendError(<span class="number">405</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果不是HTTP/1.1，返回400错误的请求错误  </span></span><br><span class="line">            resp.sendError(<span class="number">400</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

2. doPost()实现：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String protocol = req.getProtocol();</span><br><span class="line">        String msg = lStrings.getString(<span class="string">&quot;http.method_post_not_supported&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(protocol.endsWith(<span class="string">&quot;1.1&quot;</span>)) &#123;</span><br><span class="line">            resp.sendError(<span class="number">405</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.sendError(<span class="number">400</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**其实在工业界，几乎没有直接利用Servlet开发Web应用的了，但是它是一个基础，很多开源框架都是基于Servlet开发的，如大名鼎鼎的[Spring](https://spring.io/)**

# 如何实现？

1. 首先我写一个Servlet类,作用是得到get()请求，然后返回“Hello Servlet!”与打印当前时间。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.getWriter().println(<span class="string">&quot;&lt;h1&gt;Hello Servlet!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">            response.getWriter().println(<span class="keyword">new</span> Date().toLocaleString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

2. 然后配置web.xml文件，建立URL与Servlet处理类 **HelloServlet** 之间的关联关系。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;web-app&gt;</span><br><span class="line"></span><br><span class="line">	&lt;servlet&gt;</span><br><span class="line">		&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line">		&lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">HelloServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">	&lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">HelloServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">hello</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;/<span class="title">web</span>-<span class="title">app</span>&gt;</span></span><br></pre></td></tr></table></figure>
其中**servlet-name**是类名简写，**servlet-class** 是类名。

**servlet-mapping**实现URL与类的映射，这里实现了访问路径 http://127.0.0.1//hello 时调用HelloServlet类的相应方法。

http://127.0.0.1 是一个监听地址，需要服务器实现监听，此时就需要Tomcat。

然后修改Tomcat的conf/server.xml的路径配置。

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">docBase</span>=<span class="string">&quot;F:\\eclipse-workspace\\j2ee\\web&quot;</span> <span class="attr">debug</span>=<span class="string">&quot;0&quot;</span> <span class="attr">reloadable</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

# Servlet的特点

**1. Servlet是单实例多线程。**
>1) 当Web服务器启动或者用户请求抵达服务器时，Servlet被实例化且只存在一个实例。
>2) 当请求抵达时，Servlet容器(如Tomcat)会调度线程 (Dispathchaer Thread)调度它管理下的线程池中等待执行的线程 (Worker Thread) 给请求者。
>3) 线程执行Servlet中的sercive方法。
>4) 请求结束，该线程放回线程池，等待被调用。

**2. Servet使用标准API，可被更多Web服务器调用。**

## 线程安全

由于Servlet是单实例多线程，当多个线程的用户同时访问共享资源时，就会出现<font color="#f07c82">线程安全的问题</font>。

**解决方法:**

首先，定义在 doPost() 和 doGet()里的方法由于是**局部变量**，再每个用户调用实例方法时都会初始化，所以**不存在线程安全**。（一些属性尽量定义在实例的局部方法中）

实在需要共享的资源，只需加<font color="#f07c82">synchronized同步机制</font>，在共享资源被某一线程占用后，该线程就拥有锁，其它线程只有等待该线程执行完毕才能使用该资源（抢占锁后一一执行）。

# Servlet的常用方法

在HttpServlet中sercive方法中，参数列表接受两个对象，一个是<font color="#f07c82">HttpServletResponse</font>对象，一个是<font color="#f07c82">HttpServletRequest</font>对象。

## HttpServletRequest常用方法

**常见方法**

方法名 | 作用
:-: | :-:
request.getRequestURL() | 浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)"
request.getRequestURI() | 浏览器发出请求的资源名部分，去掉了协议和主机名"
request.getQueryString() | 请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到
request.getRemoteAddr() | 浏览器所处于的客户机的IP地址
request.getRemoteHost() | 浏览器所处于的客户机的主机名
request.getRemotePort() | 浏览器所处于的客户机使用的网络端口
request.getLocalAddr() | 服务器的IP地址
request.getLocalName() | 服务器的主机名
request.getMethod() | 得到客户机请求方式一般是GET或者POST

**获取参数**

方法名 | 作用
:-: | :-:
request.getParameter() | 是常见的方法，用于获取单值的参数
request.getParameterValues() | 用于获取具有多值的参数，比如注册时候提交的 "hobits"，可以是多选的。
request.getParameterMap() | 用于遍历所有的参数，并返回Map类型。

**获取头信息**

方法名 | 作用
:-: | :-:
request.getHeader() | 获取浏览器传递过来的头信息。
比如getHeader("user-agent") | 可以获取浏览器的基本资料，这样就能判断是firefox、IE、chrome、或者是safari浏览器
request.getHeaderNames() | 获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息

头信息含义：
>host: 主机地址
>user-agent: 浏览器基本资料
>accept: 表示浏览器接受的数据类型
>accept-language: 表示浏览器接受的语言
>accept-encoding: 表示浏览器接受的压缩方式，是压缩方式，并非编码
>connection: 是否保持连接
>cache-control: 缓存时限

## HttpServletResponse常用方法

1. 设置相应内容

    <font color="#f07c82">PrintWriter pw= response.getWriter();</font>

<pre><code>通过`response.getWriter();` 获取一个PrintWriter 对象

可以使用`println()`,`append()`,`write()`,`format()`等等方法设置返回给浏览器的html内容。
</code></pre><ol>
<li><p>设置相应内容</p>
 <font color="#f07c82">response.setContentType("text/html");</font>
</li>
<li><p>设置相应编码</p>
<ul>
<li><p><code>response.setContentType(&quot;text/html; charset=UTF-8&quot;);</code><br>不仅发送到浏览器的内容会使用UTF-8编码，而且还通知浏览器使用UTF-8编码方式进行显示。所以总能正常显示中文</p>
</li>
<li><p><code>response.setCharacterEncoding(&quot;UTF-8&quot;);</code><br>仅仅是发送的浏览器的内容是UTF-8编码的，至于浏览器是用哪种编码方式显示不管。 所以当浏览器的显示编码方式不是UTF-8的时候，就会看到乱码，需要手动再进行一次设置。</p>
</li>
</ul>
</li>
<li><p>301或者302客户端跳转</p>
<p> 客户端有两种跳转:</p>
<ul>
<li><p>302 表示临时跳转<br>  <code>response.sendRedirect(&quot;fail.html&quot;);</code></p>
</li>
<li><p>301 表示永久性跳转<br>  <code>response.setStatus(301);</code><br>  <code>response.setHeader(&quot;Location&quot;, &quot;fail.html&quot;);</code></p>
</li>
</ul>
</li>
<li><p>设置不使用缓存</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setDateHeader(<span class="string">&quot;Expires&quot;</span>,<span class="number">0</span> );</span><br><span class="line">response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>,<span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">response.setHeader(<span class="string">&quot;pragma&quot;</span>,<span class="string">&quot;no-cache&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>参考: <u><a href="http://how2j.cn/k/servlet/servlet-upload/587.html#nowhere">http://how2j.cn/k/servlet/servlet-upload/587.html#nowhere</a></u></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue + Express + MySQL驾驶行为分析全栈项目(一): 项目初始化</title>
    <url>/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E4%B8%80-%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>自己做了一点点的小尝试：基于前馈神经网络 LSTM 的个体出行目的地预测模型，基于个体历史出行数据，模型可以实现出行目的地的实时动态预测功能。</p>
<p>模型其实具有实际应用功能，为了对其应用场景进行探索，拟开发一个全栈的项目，在Web客户端实现用户出行的动态预测效果，同时能够提供数据可视分析等功能。</p>
<p><strong><a href="https://github.com/SUNYunZeng/AIforDriving">项目地址</a></strong></p>
<p><strong><a href="http://geoai.sunyunzeng.com/">可视化效果</a></strong></p>
<img src="/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E4%B8%80-%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/dy-pre.jpg" class>
<img src="/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E4%B8%80-%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/pre.gif" class>
<center>动态预测效果</center>

<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p><strong>1. 前端界面：</strong><a href="https://cn.vuejs.org/">Vue</a>框架 + <a href="https://www.iviewui.com/">iView组件库</a> + ES6标准 + <a href="https://www.webpackjs.com/">Webpack</a>资源打包工具 + <a href="https://leafletjs.com/">Leftlet</a>地图交互JS库 + <a href="https://www.echartsjs.com/zh/index.html">ECharts</a>图表可视化库。</p>
<blockquote>
<p><strong>Vue</strong>是一个<strong>渐进式的前端开发框架。</strong>它只关注图层界面(不像Angular一样提供全家桶)，通过数据的双向绑定解放开发者，让开发者可以专注于业务逻辑的代码。同时，Vue简单易上手，初学者完全不需要学习任何的新知识。基于Vue搭建前端界面的逻辑，包括界面模块层级关系、路由、操作逻辑等等。<br><strong>iView组件库</strong>是一个基于Vue.js的可视化组件库，提供高质量的前端组件，例如按钮、表格、任务栏等等，基于该组件库提供用户交互的入口。<br><strong>ES6标准</strong>是JavaScript的新一代标准，规范了类的继承，增加了模块的定义与引入、变量的解析赋值、以及 <strong>let、const</strong>命令语法等等。虽然很多是ES5的语法糖，但使得JS更加严谨与灵活。然而很多项目都是用ES6前版本实现的，以及很多浏览器并没完全支持ES6语法，为了向下兼容，采用<a href="https://www.babeljs.cn/">babel</a>编译器对ES6代码编译。<br><strong>Webpack</strong>一种模块化的解决方案，通过模块化提高js代码的复用性，降低项目的耦合性，提高可维护性。利用Webpack使我们的项目模块化，并进行项目的打包。<br><strong>Leftlet</strong>与<strong>ECharts</strong>是两个优秀的前端可视化库，利用它们，项目实现地图轨迹的可视化。</p>
</blockquote>
<p><strong>2. 服务器：</strong><a href="http://www.expressjs.com.cn/">Express</a>框架 + <a href="https://sequelize.org/">Sequelize</a>数据库查询管理库。</p>
<blockquote>
<p><strong>Express框架：</strong>基于Node.js的Web开发框架，可以快速地搭建一个完整功能的网站。本项目基于Express实现了路由的管理与处理、数据库的CRUD操作、深度学习模型的python脚本调用。<br><strong>Sequelize</strong>是一个基于Node.js的对象关系映射（Object Relational Mapping，ORM）实现，通过对SQL语言的封装，实现model与SQL的映射，让开发者可以用OOP的方式操作数据库，优雅的生成安全、可维护的SQL代码。</p>
</blockquote>
<p><strong>3. 数据库：</strong> <a href="https://www.mysql.com/">MySQL</a>关系型数据库。</p>
<h2 id="本教程的食用准则"><a href="#本教程的食用准则" class="headerlink" title="本教程的食用准则"></a>本教程的食用准则</h2><ol>
<li><p>需要有一定的前端基础，包括JS、H5、CSS3基础知识的掌握。</p>
</li>
<li><p>对npm等包管理器有所了解。</p>
</li>
<li><p>具有一定的面向对象的开发经验，具有模块化编程思想。</p>
</li>
<li><p>对于数据库的SQL有初步掌握。</p>
</li>
<li><p>了解Vue等前端框架。</p>
</li>
</ol>
<h1 id="项目总框架"><a href="#项目总框架" class="headerlink" title="项目总框架"></a>项目总框架</h1><p>如下图所示，项目框架是基于Vue项目框架实现，首先通过Vue-cli搭建Vue项目(此处网上教程很多，略过)，然后再框架下创建Server文件夹，用来存放服务器端代码。</p>
<center><img src="/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E4%B8%80-%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/structure.png" class></center>

<p>其中绿色标出的部分并是我自己创建的，可以忽略。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue + Express + MySQL驾驶行为分析全栈项目(二): 服务器搭建</title>
    <url>/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E4%BA%8C-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>自己做了一点点的小尝试：基于前馈神经网络 LSTM 的个体出行目的地预测模型，基于个体历史出行数据，模型可以实现出行目的地的实时动态预测功能。</p>
<p>模型其实具有实际应用功能，为了对其应用场景进行探索，拟开发一个全栈的项目，在Web客户端实现用户出行的动态预测效果，同时能够提供数据可视分析等功能。</p>
<p><strong><a href="https://github.com/SUNYunZeng/AIforDriving">项目地址</a></strong></p>
<p><strong><a href="http://geoai.sunyunzeng.com/">可视化效果</a></strong></p>
<h1 id="服务端结构设计"><a href="#服务端结构设计" class="headerlink" title="服务端结构设计"></a>服务端结构设计</h1><p>结构设计如下图所示：</p>
<img src="/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E4%BA%8C-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/server.png" class>
<blockquote>
<p> <strong>api</strong> 文件夹存放的是网页路由查询逻辑的实现代码。<br><strong>py-script</strong> 存放的是python的脚本及训练好的深度学习模型。<br><strong>tables</strong> 是基于Sequlize的数据库表模型。<br><strong>config-default</strong> 定义了数据库连接信息。<br><strong>db.js</strong> 定义了Sequlize对象模型。<br><strong>func.js</strong> 定义了一些函数接口。<br><strong>index.js</strong> 是服务器的启动入口，定义了路口链接的运行文件。<br><strong>table.js</strong> 将tables文件中的表模型统一用模块接口暴露出来。</p>
</blockquote>
<h1 id="服务器搭建"><a href="#服务器搭建" class="headerlink" title="服务器搭建"></a>服务器搭建</h1><p>服务端采用了基于Node.js运行的Web应用框架——Express，首选需要安装Express框架。(前提是电脑安装了Node.js，如需安装，请参考其它网上教程)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进入在server目录，执行下面命令安装Express</span></span><br><span class="line">npm install express</span><br></pre></td></tr></table></figure>
<p>数据库采用了MySQL数据库，首先需要安装连接数据库的库函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save mysql</span><br></pre></td></tr></table></figure>
<p>然后我们采用了Sequlize库函数方便管理SQL查询，接着安装Sequlize。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save sequelize</span><br></pre></td></tr></table></figure>
<p>我们再安装Express的中间件 body-parser 帮助我们解析JSON、Raw、文本、URL-encoded格式的请求体。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save body-parser</span><br></pre></td></tr></table></figure>
<p>然后再index.js编写我们的服务端启动入口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node server</span></span><br><span class="line"><span class="comment">// use ES6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;babel-register&#x27;</span>)(&#123;</span><br><span class="line">  presets: [<span class="string">&#x27;env&#x27;</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>: <span class="literal">false</span>&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许跨域访问</span></span><br><span class="line">app.all(<span class="string">&#x27;*&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  res.header(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  res.header(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;Content-Type&#x27;</span>);</span><br><span class="line">  res.header(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;PUT,POST,GET,DELETE,OPTIONS&#x27;</span>);</span><br><span class="line">  res.header(<span class="string">&#x27;X-Powered-By&#x27;</span>, <span class="string">&#x27; 3.2.1&#x27;</span>);</span><br><span class="line">  res.header(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> res.send(<span class="string">&#x27;Express Server&#x27;</span>));</span><br><span class="line">app.get(<span class="string">&#x27;/api&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> res.send(<span class="string">&#x27;API Pages&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;success listen at port:3000......&#x27;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在server文件夹下用node.js启动程序，<code>node index</code>, 命令窗口会显示 ‘success listen at port:3000……’ 字样，证明服务器启动成功！这时在浏览器中输入 <code>localhost:3000/api</code>发现浏览器输出 <code>API Pages</code>。</p>
<h1 id="连接数据库访问数据"><a href="#连接数据库访问数据" class="headerlink" title="连接数据库访问数据"></a>连接数据库访问数据</h1><p>首先在 config-default 文件内定义数据库连接信息，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  host: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">  user: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">  password: <span class="string">&#x27;**********&#x27;</span>,</span><br><span class="line">  database: <span class="string">&#x27;your_database&#x27;</span>,</span><br><span class="line">  port: <span class="string">&#x27;3306&#x27;</span>,</span><br><span class="line">  dialect: <span class="string">&#x27;mysql&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后 在db.js 文件中定义Sequlize模型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Sequelize = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./config-default&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sequelize = <span class="keyword">new</span> Sequelize(config.database, config.user, config.password, &#123;</span><br><span class="line">  host: config.host,</span><br><span class="line">  dialect: config.dialect,</span><br><span class="line">  pool: &#123;</span><br><span class="line">    max: <span class="number">5</span>,</span><br><span class="line">    min: <span class="number">0</span>,</span><br><span class="line">    idle: <span class="number">10000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> defineModel = <span class="function"><span class="keyword">function</span> (<span class="params">name, attributes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> attrs = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> attributes) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = attributes[key];</span><br><span class="line">    <span class="comment">// if the value is the mainKey</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> &amp;&amp; value[<span class="string">&#x27;type&#x27;</span>]) &#123;</span><br><span class="line">      value.allowNull = value.allowNull || <span class="literal">false</span>;</span><br><span class="line">      attrs[key] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      attrs[key] = &#123;</span><br><span class="line">        type: value,</span><br><span class="line">        allowNull: <span class="literal">false</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sequelize.define(name, attrs, &#123;</span><br><span class="line">    tableName: name,</span><br><span class="line">    timestamps: <span class="literal">false</span>,</span><br><span class="line">    freezeTableName: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> exp = &#123;</span><br><span class="line">  defineModel: defineModel</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = exp;</span><br></pre></td></tr></table></figure>
<p><strong>Sequlize</strong> 是一个基于Node.js的对象关系映射（Object Relational Mapping，ORM）实现，通过对SQL语言的封装，实现model与SQL的映射，让开发者可以用OOP的方式操作数据库，优雅的生成安全、可维护的SQL代码。</p>
<p>这里我们把Sequlize模型的定义做成了一个的模块接口，只要指定Sequlize参数，就可以生成一个Sequlize模型，这样针对一个数据库中不同的表就可以生成不同的Sequlize对象。</p>
<p>之后根据自己的数据库表设计定义对应的表模型，如项目中 tables 文件夹内的 User1 文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Sequelize = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">&#x27;../db&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = db.defineModel(<span class="string">&#x27;user_1&#x27;</span>,&#123;</span><br><span class="line">  id: &#123;</span><br><span class="line">    type: Sequelize.INTEGER,</span><br><span class="line">    primaryKey: <span class="literal">true</span>,</span><br><span class="line">    allowNull: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  weekday: Sequelize.INTEGER,</span><br><span class="line">  start_time: Sequelize.INTEGER,</span><br><span class="line">  dis_total: Sequelize.FLOAT,</span><br><span class="line">  sem_O: Sequelize.TEXT,</span><br><span class="line">  sem_D: Sequelize.TEXT,</span><br><span class="line">  destination: Sequelize.TEXT,</span><br><span class="line">  lngs: Sequelize.TEXT,</span><br><span class="line">  lats: Sequelize.TEXT,</span><br><span class="line">  travel_dis: Sequelize.TEXT,</span><br><span class="line">  spd: Sequelize.TEXT,</span><br><span class="line">  azimuth: Sequelize.TEXT,</span><br><span class="line">  norm_dict: Sequelize.TEXT,</span><br><span class="line">  key_point: Sequelize.TEXT,</span><br><span class="line">  sem_pt: Sequelize.TEXT,</span><br><span class="line">  time: Sequelize.TEXT</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>因为随着项目不断深入，数据表模型也不断增多。为了统一管理，建立 tables 模块将所有表模型统一打包，用户可按需导入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tables.js 文件</span></span><br><span class="line"><span class="comment">// scan all models defined in models:</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> user1 = <span class="built_in">require</span>(<span class="string">&#x27;./tables/User1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> user2 = <span class="built_in">require</span>(<span class="string">&#x27;./tables/User2&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> user3 = <span class="built_in">require</span>(<span class="string">&#x27;./tables/User3&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> user4 = <span class="built_in">require</span>(<span class="string">&#x27;./tables/User4&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">&#x27;user1&#x27;</span>: user1,</span><br><span class="line">  <span class="string">&#x27;user2&#x27;</span>: user2,</span><br><span class="line">  <span class="string">&#x27;user3&#x27;</span>: user3,</span><br><span class="line">  <span class="string">&#x27;user4&#x27;</span>: user4,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之后再 api 文件夹中定义不同路由的处理逻辑，这里主要是对数据库的访问。</p>
<p>例如 searchAll.js 文件是对整张表进行访问，其内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> table = <span class="built_in">require</span>(<span class="string">&#x27;../table&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"><span class="keyword">import</span> &#123;jsonWrite&#125; <span class="keyword">from</span> <span class="string">&#x27;../func&#x27;</span>;</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> params = req.body;</span><br><span class="line">  <span class="keyword">if</span>(params[<span class="string">&#x27;tableName&#x27;</span>] === <span class="literal">undefined</span>)&#123;</span><br><span class="line">    jsonWrite(res, <span class="literal">undefined</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> user = table[params.tableName];</span><br><span class="line">  (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> traj = <span class="keyword">await</span> user.findAll();</span><br><span class="line">    jsonWrite(res, traj);</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure>
<p>其中 jsonWrite 是我们在fun.js定义的根据请求结果返回res的函数，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jsonWrite = <span class="function"><span class="keyword">function</span> (<span class="params">res, ret</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> ret === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      code: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">      msg: <span class="string">&#x27;操作失败&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.json(ret);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;jsonWrite&#125;;</span><br></pre></td></tr></table></figure>
<p>然后，前端发送post请求，请求体中输入待查询数据表名就可以实现整张表的查询。</p>
<p>这里的服务器代码不能实时更新效果，最后可以采用 nodemon 包检测服务器代码变化，实现代码的实时监测更新。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g  nodemon</span><br></pre></td></tr></table></figure>
<p>然后利用 nodemon 启动 index.js入口文件，就可以实现服务器根据代码更新的自动重启，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nodemon index</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue + Express + MySQL驾驶行为分析全栈项目(五): Leftlet热力图实现</title>
    <url>/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E4%BA%94-Leftlet%E7%83%AD%E5%8A%9B%E5%9B%BE%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>自己做了一点点的小尝试：基于前馈神经网络 LSTM 的个体出行目的地预测模型，基于个体历史出行数据，模型可以实现出行目的地的实时动态预测功能。</p>
<p>模型其实具有实际应用功能，为了对其应用场景进行探索，拟开发一个全栈的项目，在Web客户端实现用户出行的动态预测效果，同时能够提供数据可视分析等功能。</p>
<p><strong><a href="https://github.com/SUNYunZeng/AIforDriving">项目地址</a></strong></p>
<p><strong><a href="http://geoai.sunyunzeng.com/">可视化效果</a></strong></p>
<h1 id="Leftlet底图模块构建"><a href="#Leftlet底图模块构建" class="headerlink" title="Leftlet底图模块构建"></a>Leftlet底图模块构建</h1><p>需要安装的依赖库与样式查看<a href="http://sunyunzeng.com/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E5%9B%9B-Leftlet%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%9B%BE%E5%B1%82%E5%8A%A0%E8%BD%BD%E5%8A%9F%E8%83%BD/">Vue + Express + MySQL驾驶行为分析全栈项目(四): Leftlet组件与图层加载功能</a>。</p>
<p>在 src/components/common 文件夹下添加 LeftletMap.vue文件，作为Leftlet地图的基础模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LeftletMap.vue</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;map&quot;</span>&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;LeftletMap&#x27;</span>,</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        L: <span class="literal">null</span>,</span><br><span class="line">        map: <span class="literal">null</span>,</span><br><span class="line">        map_config: <span class="built_in">this</span>.store.state.map_config</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      initMap () &#123;</span><br><span class="line">        <span class="built_in">this</span>.L = L;</span><br><span class="line">        <span class="keyword">let</span> map = L.map(<span class="built_in">this</span>.$el, &#123;</span><br><span class="line">          center: <span class="built_in">this</span>.map_config.center,</span><br><span class="line">          zoom: <span class="built_in">this</span>.map_config.zoom</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">        <span class="keyword">let</span> baseLayer = L.tileLayer(<span class="string">&#x27;https://api.tiles.mapbox.com/v4/&#123;id&#125;/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png?&#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw&#x27;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            id: <span class="built_in">this</span>.store.state.layerItems[<span class="string">&#x27;box_d&#x27;</span>],</span><br><span class="line">            minZoom: <span class="number">3</span></span><br><span class="line">          &#125;);</span><br><span class="line">        map.addLayer(baseLayer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      <span class="built_in">this</span>.initMap();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .map &#123;</span><br><span class="line">    width: <span class="number">100</span>%;</span><br><span class="line">    height: calc(88vh);</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>其中 this.state 是用Vuex插件定义的全局状态变量，其本身是 src/store/index.js文件中定义的一个对象，在其中我们定义了各种地图的配置选项。具体内容可查看<a href="http://sunyunzeng.com/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E5%9B%9B-Leftlet%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%9B%BE%E5%B1%82%E5%8A%A0%E8%BD%BD%E5%8A%9F%E8%83%BD/">Vue + Express + MySQL驾驶行为分析全栈项目(四): Leftlet组件与图层加载功能</a>。</p>
<h1 id="热力图实现"><a href="#热力图实现" class="headerlink" title="热力图实现"></a>热力图实现</h1><p>首先安装leftlet热力图插件 leaflet-heatmap。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm i leaflet-heatmap --save</span><br></pre></td></tr></table></figure>
<p>然后在src/views/ 文件夹下创建 ODpoint.vue 文件，该组件是对轨迹的O-D(Origin-Destination)点进行热力图分析。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ODpoint.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Form</span> <span class="attr">ref</span>=<span class="string">&quot;formInline&quot;</span> <span class="attr">inline</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">FormItem</span>&gt;</span></span><br><span class="line">        测试用户: <span class="tag">&lt;<span class="name">Select</span> <span class="attr">v-model</span>=<span class="string">&quot;user&quot;</span> <span class="attr">clearable</span> <span class="attr">style</span>=<span class="string">&quot;width:70px&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Option</span> <span class="attr">value</span>=<span class="string">&quot;user1&quot;</span>&gt;</span>User1<span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Option</span> <span class="attr">value</span>=<span class="string">&quot;user2&quot;</span>&gt;</span>User2<span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Option</span> <span class="attr">value</span>=<span class="string">&quot;user3&quot;</span>&gt;</span>User3<span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Option</span> <span class="attr">value</span>=<span class="string">&quot;user4&quot;</span>&gt;</span>User4<span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Select</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">FormItem</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>出发时间:<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">FormItem</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">DatePicker</span> <span class="attr">v-model</span>=<span class="string">&quot;time_range&quot;</span> <span class="attr">:start-date</span>=<span class="string">&quot;new Date(&#x27;2018-01-01 00:00:00&#x27;)&quot;</span> <span class="attr">type</span>=<span class="string">&quot;datetimerange&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">style</span>=<span class="string">&quot;width: 300px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">DatePicker</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">FormItem</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">CheckboxGroup</span> <span class="attr">v-model</span>=<span class="string">&quot;ODSelectoin&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">Checkbox</span> <span class="attr">label</span>=<span class="string">&quot;origin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Checkbox</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">Checkbox</span> <span class="attr">label</span>=<span class="string">&quot;destination&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Checkbox</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">CheckboxGroup</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">FormItem</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;show&quot;</span>&gt;</span>展示<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Map</span> <span class="attr">style</span>=<span class="string">&quot;height: calc(78vh);&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;leftletMap&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后定义展示的逻辑js代码。一些问题可以参考文章：<a href="https://blog.frytea.com/archives/41/。">https://blog.frytea.com/archives/41/。</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入LeftletMap子模块</span></span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Map</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/commom/LeftletMap&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> HeatmapOverlay <span class="keyword">from</span> <span class="string">&#x27;heatmap.js/plugins/leaflet-heatmap&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;post, get&#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/myAjax&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;points_factory&#125; <span class="keyword">from</span>  <span class="string">&#x27;@/utils/traj-handler&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;od&#x27;</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      user: <span class="string">&#x27;user1&#x27;</span>,</span><br><span class="line">      time_range: [<span class="string">&#x27;2018-01-01 00:00:00&#x27;</span>, <span class="string">&#x27;2018-01-31:00:00:00&#x27;</span>],</span><br><span class="line">      ODSelectoin: [<span class="string">&#x27;origin&#x27;</span>],</span><br><span class="line">      heatmapLayer: <span class="literal">null</span>,</span><br><span class="line">      cfg: &#123;</span><br><span class="line">        <span class="string">&#x27;radius&#x27;</span>: <span class="number">0.005</span>,</span><br><span class="line">        <span class="string">&#x27;maxOpacity&#x27;</span>: <span class="number">0.8</span>,</span><br><span class="line">        <span class="string">&#x27;scaleRadius&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&#x27;useLocalExtrema&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">        latField: <span class="string">&#x27;lat&#x27;</span>,</span><br><span class="line">        lngField: <span class="string">&#x27;lng&#x27;</span>,</span><br><span class="line">        valueField: <span class="string">&#x27;eff&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">this</span>.initHeatMap();</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="built_in">Map</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    show () &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.ODSelectoin.length === <span class="number">0</span> || <span class="built_in">this</span>.user === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$Message.info(<span class="string">&#x27;请配置参数&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.$isOnServer) &#123;</span><br><span class="line">        post(<span class="string">&#x27;searchByRow&#x27;</span>, &#123;</span><br><span class="line">          rowName: [<span class="string">&#x27;origin&#x27;</span>, <span class="string">&#x27;destination&#x27;</span>, <span class="string">&#x27;norm_dict&#x27;</span>, <span class="string">&#x27;o_eff&#x27;</span>, <span class="string">&#x27;d_eff&#x27;</span>],</span><br><span class="line">          time: <span class="built_in">this</span>.time_range,</span><br><span class="line">          tableName: <span class="built_in">this</span>.user</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (data.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> res = points_factory(data, <span class="built_in">this</span>.ODSelectoin);</span><br><span class="line">            <span class="built_in">this</span>.heatmapLayer.setData(res.data);</span><br><span class="line">            <span class="built_in">this</span>.$refs.leftletMap.map.setView(res.center, <span class="number">10</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.$Message.info(<span class="string">&#x27;空数据&#x27;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        get(<span class="string">&#x27;../static/data/&#x27;</span> + <span class="built_in">this</span>.user + <span class="string">&#x27;.json&#x27;</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (data.RECORDS.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> basket = [];</span><br><span class="line">            <span class="keyword">let</span> record = data.RECORDS;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> record) &#123;</span><br><span class="line">              <span class="keyword">let</span> tmp_date = <span class="keyword">new</span> <span class="built_in">Date</span>(item[<span class="string">&#x27;time&#x27;</span>]);</span><br><span class="line">              <span class="keyword">if</span> (tmp_date &gt;= <span class="built_in">this</span>.time_range[<span class="number">0</span>] &amp;&amp; tmp_date &lt;= <span class="built_in">this</span>.time_range[<span class="number">1</span>]) &#123;</span><br><span class="line">                basket.push(item);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> res = points_factory(basket, <span class="built_in">this</span>.ODSelectoin);</span><br><span class="line">            <span class="built_in">this</span>.heatmapLayer.setData(res.data);</span><br><span class="line">            <span class="built_in">this</span>.$refs.leftletMap.map.setView(res.center, <span class="number">10</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.$Message.info(<span class="string">&#x27;空数据&#x27;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    initHeatMap () &#123;</span><br><span class="line">      <span class="built_in">this</span>.heatmapLayer = <span class="keyword">new</span> HeatmapOverlay(<span class="built_in">this</span>.cfg);</span><br><span class="line">      <span class="built_in">this</span>.heatmapLayer.addTo(<span class="built_in">this</span>.$refs.leftletMap.map);</span><br><span class="line">      L.control.scale(&#123; <span class="attr">maxWidth</span>: <span class="number">200</span>, <span class="attr">metric</span>: <span class="literal">true</span>, <span class="attr">imperial</span>: <span class="literal">false</span> &#125;).addTo(<span class="built_in">this</span>.$refs.leftletMap.map);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>最后，预览效果：<a href="http://geoai.sunyunzeng.com/#/od">http://geoai.sunyunzeng.com/#/od</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue + Express + MySQL驾驶行为分析全栈项目(三): 前端设计</title>
    <url>/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E4%B8%89-%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>自己做了一点点的小尝试：基于前馈神经网络 LSTM 的个体出行目的地预测模型，基于个体历史出行数据，模型可以实现出行目的地的实时动态预测功能。</p>
<p>模型其实具有实际应用功能，为了对其应用场景进行探索，拟开发一个全栈的项目，在Web客户端实现用户出行的动态预测效果，同时能够提供数据可视分析等功能。</p>
<p><strong><a href="https://github.com/SUNYunZeng/AIforDriving">项目地址</a></strong></p>
<p><strong><a href="http://geoai.sunyunzeng.com/">可视化效果</a></strong></p>
<h1 id="前端结构设计"><a href="#前端结构设计" class="headerlink" title="前端结构设计"></a>前端结构设计</h1><p>下图是整个项目的结构，也就是采用Vue-cli脚手架搭建的前端项目结构<br><img src="/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E4%B8%89-%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1/structure.png" class></p>
<blockquote>
<p><strong>buile</strong> 文件夹存放项目构建脚本。<br><strong>config</strong> 文件夹存放项目的配置信息，包括webpack配置及端口转发等。<br><strong>dist/docs</strong> 文件夹存放的是项目构建后的内容，即编译出的项目代码。<br><strong>node_modules</strong> 这个目录存放的是项目的所有依赖，即 npm install 命令下载下来的文件。<br><strong>server</strong> 文件夹存放的是服务器相关代码与数据。<br><strong>src</strong> 存放前端项目的源码。<br><strong>static</strong> 存放项目的静态资源。<br><strong>index.html</strong> 项目的入口页，也是唯一的HTML页面。<br><strong>package.json</strong> 定义了项目的所有依赖，包括开发时依赖和发布时依赖。</p>
</blockquote>
<p>其中前端开发的大多工作是在 <strong>src</strong> 文件夹下进行的，它的目录结构如下：</p>
<img src="/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E4%B8%89-%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1/src.png" class>
<blockquote>
<p><strong>assets</strong> 文件夹存放资产文件。<br><strong>components</strong> 文件夹存放项目公共的组件(.vue文件)。<br><strong>lib</strong> 文件夹存放的是第三方库暴露出来的接口。<br><strong>router</strong> 存放前端界面的路由逻辑js文件。<br><strong>store</strong> 文件夹存放的是全局共享的变量。<br><strong>utils</strong> 存放辅助函数脚本。<br><strong>view</strong> 存放项目各独立界面(.vue文件)。<br><strong>App.vue</strong> 一个vue组件，是第一个vue组件。<br><strong>main.js</strong> 定义了项目启动的入口。<br><strong>permission.js</strong> 界面初始化工作，包括动态界面的加载。</p>
</blockquote>
<h1 id="界面模版"><a href="#界面模版" class="headerlink" title="界面模版"></a>界面模版</h1><p>前端界面模版是基于 <a href="https://github.com/PanJiaChen/vue-admin-template">vue-admin-template</a>修改的，去除了登录功能，精简了界面逻辑。</p>
<p>界面模版最大的特点可以实现菜单栏的个性定制。</p>
<p>首先在 src/components/Index.vue文件夹内，定义动态菜单栏。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;index-vue&quot;</span>&gt;</span><br><span class="line">    &lt;!-- 侧边栏 --&gt;</span><br><span class="line">    &lt;aside :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;asideClassName&quot;</span>&gt;</span><br><span class="line">      &lt;!-- logo --&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;logo-c pointer&quot;</span> @click=<span class="string">&quot;isShrinkAside&quot;</span> title=<span class="string">&quot;收缩/展开&quot;</span>&gt;</span><br><span class="line">        &lt;img src=<span class="string">&quot;../assets/imgs/logo.png&quot;</span> alt=<span class="string">&quot;logo&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;logo&quot;</span>&gt;</span><br><span class="line">        &lt;span v-show=<span class="string">&quot;isShowAsideTitle&quot;</span>&gt;驾驶分析系统&lt;/span&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;!-- 菜单栏 --&gt;</span><br><span class="line">      &lt;Menu <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;menu&quot;</span> ref=<span class="string">&quot;asideMenu&quot;</span> theme=<span class="string">&quot;dark&quot;</span> width=<span class="string">&quot;100%&quot;</span> @on-select=<span class="string">&quot;gotoPage&quot;</span></span><br><span class="line">            accordion :open-names=<span class="string">&quot;openMenus&quot;</span> :active-name=<span class="string">&quot;currentPage&quot;</span> @on-open-change=<span class="string">&quot;menuChange&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 动态菜单 --&gt;</span><br><span class="line">        &lt;div v-<span class="keyword">for</span>=<span class="string">&quot;(item, index) in menuItems&quot;</span> :key=<span class="string">&quot;index&quot;</span>&gt;</span><br><span class="line">          &lt;Submenu v-<span class="keyword">if</span>=<span class="string">&quot;item.children&quot;</span> :name=<span class="string">&quot;index&quot;</span>&gt;</span><br><span class="line">            &lt;template slot=<span class="string">&quot;title&quot;</span>&gt;</span><br><span class="line">              &lt;Icon :size=<span class="string">&quot;item.size&quot;</span> :type=<span class="string">&quot;item.type&quot;</span>/&gt;</span><br><span class="line">              &lt;span v-show=<span class="string">&quot;isShowAsideTitle&quot;</span>&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">            &lt;div v-<span class="keyword">for</span>=<span class="string">&quot;(subItem, i) in item.children&quot;</span> :key=<span class="string">&quot;index + i&quot;</span>&gt;</span><br><span class="line">              &lt;Submenu v-<span class="keyword">if</span>=<span class="string">&quot;subItem.children&quot;</span> :name=<span class="string">&quot;index + &#x27;-&#x27; + i&quot;</span>&gt;</span><br><span class="line">                &lt;template slot=<span class="string">&quot;title&quot;</span>&gt;</span><br><span class="line">                  &lt;Icon :size=<span class="string">&quot;subItem.size&quot;</span> :type=<span class="string">&quot;subItem.type&quot;</span>/&gt;</span><br><span class="line">                  &lt;span v-show=<span class="string">&quot;isShowAsideTitle&quot;</span>&gt;&#123;&#123;subItem.text&#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;/template&gt;</span><br><span class="line">                &lt;MenuItem <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;menu-level-3&quot;</span> v-<span class="keyword">for</span>=<span class="string">&quot;(threeItem, k) in subItem.children&quot;</span></span><br><span class="line">                          v-<span class="keyword">if</span>=<span class="string">&quot;!threeItem.hidden&quot;</span> :name=<span class="string">&quot;threeItem.name&quot;</span> :key=<span class="string">&quot;index + i + k&quot;</span>&gt;</span><br><span class="line">                  &lt;Icon :size=<span class="string">&quot;threeItem.size&quot;</span> :type=<span class="string">&quot;threeItem.type&quot;</span>/&gt;</span><br><span class="line">                  &lt;span v-show=<span class="string">&quot;isShowAsideTitle&quot;</span>&gt;&#123;&#123;threeItem.text&#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;/MenuItem&gt;</span><br><span class="line">              &lt;/Submenu&gt;</span><br><span class="line">              &lt;MenuItem v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">&quot;!subItem.hidden&quot;</span> :name=<span class="string">&quot;subItem.name&quot;</span>&gt;</span><br><span class="line">                &lt;Icon :size=<span class="string">&quot;subItem.size&quot;</span> :type=<span class="string">&quot;subItem.type&quot;</span>/&gt;</span><br><span class="line">                &lt;span v-show=<span class="string">&quot;isShowAsideTitle&quot;</span>&gt;&#123;&#123;subItem.text&#125;&#125;&lt;/span&gt;</span><br><span class="line">              &lt;/MenuItem&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          &lt;/Submenu&gt;</span><br><span class="line">          &lt;MenuItem v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">&quot;!item.hidden&quot;</span> :name=<span class="string">&quot;item.name&quot;</span>&gt;</span><br><span class="line">            &lt;Icon :size=<span class="string">&quot;item.size&quot;</span> :type=<span class="string">&quot;item.type&quot;</span>/&gt;</span><br><span class="line">            &lt;span v-show=<span class="string">&quot;isShowAsideTitle&quot;</span>&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt;</span><br><span class="line">          &lt;/MenuItem&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/Menu&gt;</span><br><span class="line">    &lt;/aside&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;index&#x27;</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 用于储存页面路径</span></span><br><span class="line">        paths: &#123;&#125;,</span><br><span class="line">        <span class="comment">// 当前显示页面</span></span><br><span class="line">        currentPage: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        openMenus: [], <span class="comment">// 要打开的菜单名字 name属性</span></span><br><span class="line">        menuCache: [], <span class="comment">// 缓存已经打开的菜单</span></span><br><span class="line">        showLoading: <span class="literal">false</span>, <span class="comment">// 是否显示loading</span></span><br><span class="line">        isShowRouter: <span class="literal">true</span>,</span><br><span class="line">        isShowAsideTitle: <span class="literal">true</span>, <span class="comment">// 是否展示侧边栏内容</span></span><br><span class="line">        main: <span class="literal">null</span>, <span class="comment">// 页面主要内容区域</span></span><br><span class="line">        asideClassName: <span class="string">&#x27;aside-big&#x27;</span>, <span class="comment">// 控制侧边栏宽度变化</span></span><br><span class="line">        asideArrowIcons: [], <span class="comment">// 缓存侧边栏箭头图标 收缩时用</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    created () &#123;</span><br><span class="line">      <span class="comment">// 已经为ajax请求设置了loading 请求前自动调用 请求完成自动结束</span></span><br><span class="line">      <span class="comment">// 添加请求拦截器</span></span><br><span class="line">      <span class="built_in">this</span>.$axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.showLoading = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">      &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.showLoading = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 添加响应拦截器</span></span><br><span class="line">      <span class="built_in">this</span>.$axios.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 可以在这里对返回的数据进行错误处理 如果返回的 code 不对 直接报错或退出登陆</span></span><br><span class="line">        <span class="comment">// 就可以省去在业务代码里重复判断</span></span><br><span class="line">        <span class="comment">// 例子</span></span><br><span class="line">        <span class="comment">// if (res.code != 0) &#123;</span></span><br><span class="line">        <span class="comment">//     this.$Message.error(res.msg)</span></span><br><span class="line">        <span class="comment">//     return Promise.reject()</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="built_in">this</span>.showLoading = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">const</span> res = response.data;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">      &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.showLoading = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      <span class="comment">// 第一个标签</span></span><br><span class="line">      <span class="keyword">const</span> name = <span class="built_in">this</span>.$route.name;</span><br><span class="line">      <span class="built_in">this</span>.currentPage = name;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据路由打开对应的菜单栏</span></span><br><span class="line">      <span class="built_in">this</span>.openMenus = <span class="built_in">this</span>.getMenus(name);</span><br><span class="line">      <span class="built_in">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$refs.asideMenu.updateOpened();</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.main = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.sec-right&#x27;</span>);</span><br><span class="line">      <span class="built_in">this</span>.asideArrowIcons = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;aside .ivu-icon-ios-arrow-down&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 监听窗口大小 自动收缩侧边栏</span></span><br><span class="line">      <span class="built_in">this</span>.monitorWindowSize();</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      $route (to) &#123;</span><br><span class="line">        <span class="keyword">const</span> name = to.name;</span><br><span class="line">        <span class="built_in">this</span>.currentPage = name;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      <span class="comment">// 菜单栏</span></span><br><span class="line">      menuItems () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.menuItems;</span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 由于iView的导航菜单比较坑 只能设定一个name参数</span></span><br><span class="line">      <span class="comment">// 所以需要在这定义组件名称和标签栏标题的映射表 有多少个页面就有多少个映射条数</span></span><br><span class="line">      nameToTitle () &#123;</span><br><span class="line">        <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">        <span class="built_in">this</span>.menuItems.forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.processNameToTitle(obj, e);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      getMenus (name) &#123;</span><br><span class="line">        <span class="keyword">let</span> menus;</span><br><span class="line">        <span class="keyword">const</span> tagTitle = <span class="built_in">this</span>.nameToTitle[name];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">this</span>.menuItems.length; i &lt; l; i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> item = <span class="built_in">this</span>.menuItems[i];</span><br><span class="line">          menus = [];</span><br><span class="line">          menus[<span class="number">0</span>] = i;</span><br><span class="line">          <span class="keyword">if</span> (item.text == tagTitle) &#123;</span><br><span class="line">            <span class="keyword">return</span> menus;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (item.children) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, ll = item.children.length; j &lt; ll; j++) &#123;</span><br><span class="line">              <span class="keyword">const</span> child = item.children[j];</span><br><span class="line">              menus[<span class="number">1</span>] = i + <span class="string">&#x27;-&#x27;</span> + j;</span><br><span class="line">              menus.length = <span class="number">2</span>;</span><br><span class="line">              <span class="keyword">if</span> (child.text == tagTitle) &#123;</span><br><span class="line">                <span class="keyword">return</span> menus;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (child.children) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>, lll = child.children.length; k &lt; lll; k++) &#123;</span><br><span class="line">                  <span class="keyword">const</span> grandson = child.children[k];</span><br><span class="line">                  menus[<span class="number">2</span>] = i + <span class="string">&#x27;-&#x27;</span> + j + <span class="string">&#x27;-&#x27;</span> + k;</span><br><span class="line">                  <span class="keyword">if</span> (grandson.text == tagTitle) &#123;</span><br><span class="line">                    <span class="keyword">return</span> menus;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      monitorWindowSize () &#123;</span><br><span class="line">        <span class="keyword">let</span> w = <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">        <span class="keyword">if</span> (w &lt; <span class="number">1300</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.shrinkAside();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">window</span>.onresize = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 可视窗口宽度太小 自动收缩侧边栏</span></span><br><span class="line">          <span class="keyword">if</span> (w &lt; <span class="number">1300</span> &amp;&amp; <span class="built_in">this</span>.isShowAsideTitle</span><br><span class="line">            &amp;&amp; w &gt; (<span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.shrinkAside();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          w = <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断当前标签页是否激活状态</span></span><br><span class="line">      isActive (name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$route.name === name;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断</span></span><br><span class="line">      isShrinkAside () &#123;</span><br><span class="line">        <span class="built_in">this</span>.isShowAsideTitle ? <span class="built_in">this</span>.shrinkAside() : <span class="built_in">this</span>.expandAside();</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 收缩</span></span><br><span class="line">      shrinkAside () &#123;</span><br><span class="line">        <span class="built_in">this</span>.asideArrowIcons.forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">          e.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.isShowAsideTitle = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.openMenus = [];</span><br><span class="line">        <span class="built_in">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.$refs.asideMenu.updateOpened();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.asideClassName = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">          <span class="built_in">this</span>.main.style.width = <span class="string">&#x27;calc(100% - 80px)&#x27;</span>;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 展开</span></span><br><span class="line">      expandAside () &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.isShowAsideTitle = <span class="literal">true</span>;</span><br><span class="line">          <span class="built_in">this</span>.asideArrowIcons.forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            e.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          <span class="built_in">this</span>.openMenus = <span class="built_in">this</span>.menuCache;</span><br><span class="line">          <span class="built_in">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.$refs.asideMenu.updateOpened();</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;, <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">this</span>.asideClassName = <span class="string">&#x27;aside-big&#x27;</span>;</span><br><span class="line">        <span class="built_in">this</span>.main.style.width = <span class="string">&#x27;calc(100% - 220px)&#x27;</span>;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 菜单栏改变事件</span></span><br><span class="line">      menuChange (data) &#123;</span><br><span class="line">        <span class="built_in">this</span>.menuCache = data;</span><br><span class="line">      &#125;,</span><br><span class="line">      processNameToTitle (obj, data, text) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.name) &#123;</span><br><span class="line">          obj[data.name] = data.text;</span><br><span class="line">          <span class="built_in">this</span>.paths[data.name] = text ? <span class="string">`<span class="subst">$&#123;text&#125;</span> / <span class="subst">$&#123;data.text&#125;</span>`</span> : data.text;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data.children) &#123;</span><br><span class="line">          data.children.forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.processNameToTitle(obj, e, text ? <span class="string">`<span class="subst">$&#123;text&#125;</span> / <span class="subst">$&#123;data.text&#125;</span>`</span> : data.text);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>任务栏是根据 this.$store.state.menuItems 定义的内容循环更新，包括子任务栏，其定义在src/store/index.js文件内，需利用<strong>Vuex</strong>状态管理插件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    <span class="comment">// 左侧菜单栏数据</span></span><br><span class="line">    menuItems: [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">&#x27;home&#x27;</span>, <span class="comment">// 要跳转的路由名称 不是路径</span></span><br><span class="line">        size: <span class="number">22</span>, <span class="comment">// icon大小</span></span><br><span class="line">        type: <span class="string">&#x27;md-home&#x27;</span>, <span class="comment">// icon类型</span></span><br><span class="line">        text: <span class="string">&#x27;主页&#x27;</span>, <span class="comment">// 文本内容</span></span><br><span class="line">      &#125;</span><br><span class="line">      &#123;</span><br><span class="line">        text: <span class="string">&#x27;数据视图&#x27;</span>,</span><br><span class="line">        type: <span class="string">&#x27;md-globe&#x27;</span>,</span><br><span class="line">        size: <span class="number">22</span>,</span><br><span class="line">        children: [</span><br><span class="line">          &#123;</span><br><span class="line">            text: <span class="string">&#x27;可视化&#x27;</span>,</span><br><span class="line">            type: <span class="string">&#x27;ios-eye&#x27;</span>,</span><br><span class="line">            size: <span class="number">20</span>,</span><br><span class="line">            children: [</span><br><span class="line">              &#123;</span><br><span class="line">                type: <span class="string">&#x27;logo-steam&#x27;</span>,</span><br><span class="line">                name: <span class="string">&#x27;trajectory&#x27;</span>,</span><br><span class="line">                text: <span class="string">&#x27;轨迹&#x27;</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    setMenus (state, items) &#123;</span><br><span class="line">      state.menuItems = [...items];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>
<p>然后在src/router/index.js文件中定义每个组件的路由规则。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> commonRouters = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    redirect: <span class="string">&#x27;home&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"><span class="comment">// 需要动态定制的任务栏，包括子任务栏</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> asyncRouters = &#123;</span><br><span class="line">  <span class="string">&#x27;home&#x27;</span>: &#123;</span><br><span class="line">    path: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/Home.vue&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;trajectory&#x27;</span>: &#123;</span><br><span class="line">    path: <span class="string">&#x27;trajectory&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;trajectory&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/Trajectory.vue&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createRouter = <span class="function">() =&gt;</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: commonRouters</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resetRouter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newRouter = createRouter();</span><br><span class="line">  router.matcher = newRouter.matcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>
<p>然后在 src/views 文件夹下定义对应路口的界面vue组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Home.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;home&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trajectory.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;home&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>之后，在src/permission.js文件中，定义界面初始化逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;menusToRouters&#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;LoadingBar&#125; <span class="keyword">from</span> <span class="string">&#x27;iview&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hasMenus = <span class="literal">false</span>;</span><br><span class="line">router.beforeEach(<span class="keyword">async</span> (to, <span class="keyword">from</span>, next)=&gt;&#123;</span><br><span class="line">  LoadingBar.start();</span><br><span class="line">  <span class="keyword">if</span>(hasMenus)&#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">const</span> routers = menusToRouters(store.state.menuItems);</span><br><span class="line">      router.addRoutes(routers);</span><br><span class="line">      hasMenus = <span class="literal">true</span>;</span><br><span class="line">      next(&#123;<span class="attr">path</span>: to.path || <span class="string">&#x27;/&#x27;</span>&#125;);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.afterEach(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  LoadingBar.finish()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其中 menusToRouters 方法是将定义的任务栏转化为对应的router对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;asyncRouters&#125; <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">menusToRouters</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> children = [];</span><br><span class="line"></span><br><span class="line">  res.push(&#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/components/Index.vue&#x27;</span>),</span><br><span class="line">    children,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  data.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    generateRouters(children, item);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  children.push(&#123;</span><br><span class="line">    path: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/components/Error.vue&#x27;</span>)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateRouters</span> (<span class="params">children, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (item.name) &#123;</span><br><span class="line">    children.push(asyncRouters[item.name]);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.children) &#123;</span><br><span class="line">    item.children.forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      generateRouters(children, e);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在入口文件 src/main.js 文件中导入permission.js文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The Vue build version to load with the `import` command</span></span><br><span class="line"><span class="comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;@/App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> iView <span class="keyword">from</span> <span class="string">&#x27;iview&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;iview/dist/styles/iview.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@/permission&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局注册</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span>;</span><br><span class="line">Vue.prototype.$axios = axios;</span><br><span class="line">Vue.use(iView);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App) <span class="comment">// 相当于 components: &#123; App &#125;  vue1.0的写法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>初始化的菜单栏就定义完成了。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue + Express + MySQL驾驶行为分析全栈项目(四): Leftlet组件与图层加载功能</title>
    <url>/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E5%9B%9B-Leftlet%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%9B%BE%E5%B1%82%E5%8A%A0%E8%BD%BD%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>自己做了一点点的小尝试：基于前馈神经网络 LSTM 的个体出行目的地预测模型，基于个体历史出行数据，模型可以实现出行目的地的实时动态预测功能。</p>
<p>模型其实具有实际应用功能，为了对其应用场景进行探索，拟开发一个全栈的项目，在Web客户端实现用户出行的动态预测效果，同时能够提供数据可视分析等功能。</p>
<p><strong><a href="https://github.com/SUNYunZeng/AIforDriving">项目地址</a></strong></p>
<p><strong><a href="http://geoai.sunyunzeng.com/">可视化效果</a></strong></p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol>
<li>首先下载安装 leftlet。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install leaflet --save</span><br></pre></td></tr></table></figure>
<ol>
<li>然后在全局入口 main.js 文件中引入leftlet，包括样式文件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入插件与样式</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> L <span class="keyword">from</span> <span class="string">&#x27;leaflet&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;leaflet/dist/leaflet.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局注册</span></span><br><span class="line">Vue.L = Vue.prototype.$L = L;</span><br></pre></td></tr></table></figure>
<ol>
<li>安装leftlet地图图层的加载插件— leaflet.chinatmsproviders</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm i leaflet.chinatmsproviders --save</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Provider <span class="keyword">from</span> <span class="string">&#x27;leaflet.chinatmsproviders&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.Provider = Vue.prototype.$Provider = Provider;</span><br></pre></td></tr></table></figure>
<p>然后引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm i leaflet.chinatmsproviders</span><br></pre></td></tr></table></figure>
<ol>
<li>再安装iView插件。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install iview --save</span><br></pre></td></tr></table></figure>
<p>然后在全局入口 main.js 文件中引入iview插件及样式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> iView <span class="keyword">from</span> <span class="string">&#x27;iview&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(iView);</span><br></pre></td></tr></table></figure>
<ol>
<li>main.js文件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The Vue build version to load with the `import` command</span></span><br><span class="line"><span class="comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;@/App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> iView <span class="keyword">from</span> <span class="string">&#x27;iview&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;leaflet/dist/leaflet.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;iview/dist/styles/iview.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@/permission&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> L <span class="keyword">from</span> <span class="string">&#x27;leaflet&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Provider <span class="keyword">from</span> <span class="string">&#x27;leaflet.chinatmsproviders&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局注册</span></span><br><span class="line">Vue.use(iView);</span><br><span class="line">Vue.L = Vue.prototype.$L = L;</span><br><span class="line">Vue.Provider = Vue.prototype.$Provider = Provider;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App) <span class="comment">// 相当于 components: &#123; App &#125;  vue1.0的写法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="界面展示逻辑"><a href="#界面展示逻辑" class="headerlink" title="界面展示逻辑"></a>界面展示逻辑</h1><p>然后定义我们的页面展示逻辑。</p>
<p>首先在 src/views/ 文件夹下创建 Home.vue 文件。然后定义界面组件，包括返回home按钮与下拉图层选择选项。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Home.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;map&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span>  <span class="attr">id</span>=<span class="string">&quot;map_home&quot;</span> <span class="attr">class</span>=<span class="string">&quot;rightmenu&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;returnHome&quot;</span>  <span class="attr">icon</span>=<span class="string">&quot;ios-home&quot;</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">shape</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">title</span>=<span class="string">&quot;home&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Dropdown</span> <span class="attr">class</span>=<span class="string">&quot;rightmenu&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 20px&quot;</span> <span class="attr">placement</span>=<span class="string">&quot;bottom-end&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;msg&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">Icon</span> <span class="attr">type</span>=<span class="string">&quot;ios-arrow-down&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Icon</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DropdownMenu</span> <span class="attr">slot</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">DropdownItem</span> @<span class="attr">click.native</span>=<span class="string">&quot;mapSet(&#x27;gd&#x27;)&quot;</span>&gt;</span>高德地图<span class="tag">&lt;/<span class="name">DropdownItem</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">DropdownItem</span> @<span class="attr">click.native</span>=<span class="string">&quot;mapSet(&#x27;glg&#x27;)&quot;</span>&gt;</span>谷歌地图<span class="tag">&lt;/<span class="name">DropdownItem</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">DropdownItem</span> @<span class="attr">click.native</span>=<span class="string">&quot;mapSet(&#x27;box&#x27;)&quot;</span>&gt;</span>MapBox<span class="tag">&lt;/<span class="name">DropdownItem</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">DropdownItem</span> @<span class="attr">click.native</span>=<span class="string">&quot;mapSet(&#x27;osm&#x27;)&quot;</span>&gt;</span>OSM地图<span class="tag">&lt;/<span class="name">DropdownItem</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">DropdownItem</span> @<span class="attr">click.native</span>=<span class="string">&quot;mapSet(&#x27;geo&#x27;)&quot;</span>&gt;</span>智图<span class="tag">&lt;/<span class="name">DropdownItem</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">DropdownMenu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Dropdown</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line">  #map &#123;</span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">88vh</span>);</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .rightmenu&#123;</span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">right</span>: <span class="number">70px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">1000</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  #map_home&#123;</span><br><span class="line"><span class="css">    <span class="attribute">right</span>: <span class="number">30px</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="功能实现逻辑"><a href="#功能实现逻辑" class="headerlink" title="功能实现逻辑"></a>功能实现逻辑</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Home.vue </span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        map: <span class="literal">null</span>,</span><br><span class="line">        L: <span class="literal">null</span>,</span><br><span class="line">        baseLayer: <span class="literal">null</span>,</span><br><span class="line">        msg: <span class="string">&#x27;高德地图&#x27;</span>,</span><br><span class="line">        map_config: &#123;</span><br><span class="line">          zoom: <span class="number">15</span>,</span><br><span class="line">          center: [<span class="number">30.541093</span>, <span class="number">114.360734</span>],</span><br><span class="line">          minZoom: <span class="number">2</span>,</span><br><span class="line">          maxZoom: <span class="number">18</span></span><br><span class="line">          <span class="comment">// key: &quot;eb35dddb3aa33c7a8fb4218b39d1e424&quot;  天地图key</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      <span class="built_in">this</span>.initMap();</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      initMap () &#123;</span><br><span class="line">        <span class="built_in">this</span>.L = L;</span><br><span class="line">        <span class="keyword">let</span> map = L.map(<span class="string">&quot;map&quot;</span>, &#123;</span><br><span class="line">          center: <span class="built_in">this</span>.map_config.center,</span><br><span class="line">          zoom: <span class="built_in">this</span>.map_config.zoom</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">        <span class="built_in">this</span>.addLayer(L, map, store.state.layerItems[<span class="string">&#x27;gd_n_a&#x27;</span>],<span class="number">18</span>, <span class="number">3</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      addLayer (L, map, layer_name, maxZoom, minZoom) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.baseLayer !== <span class="literal">null</span>) &#123;</span><br><span class="line">          map.removeLayer(<span class="built_in">this</span>.baseLayer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.baseLayer = L.tileLayer.chinaProvider(layer_name, &#123;</span><br><span class="line">          maxZoom: maxZoom === <span class="literal">undefined</span> ? <span class="built_in">this</span>.map_config.maxZoom : maxZoom,</span><br><span class="line">          minZoom: minZoom === <span class="literal">undefined</span> ? <span class="built_in">this</span>.map_config.minZoom : minZoom</span><br><span class="line">        &#125;);</span><br><span class="line">        map.addLayer(<span class="built_in">this</span>.baseLayer);</span><br><span class="line">      &#125;,</span><br><span class="line">      returnHome () &#123;</span><br><span class="line">        <span class="built_in">this</span>.map.setView(<span class="built_in">this</span>.map_config.center, <span class="number">15</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      mapSet (map_name, L = <span class="built_in">this</span>.L, map = <span class="built_in">this</span>.map) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (map_name) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;gd&#x27;</span>:</span><br><span class="line">            <span class="built_in">this</span>.addLayer(L, map, store.state.layerItems[<span class="string">&#x27;gd_n_a&#x27;</span>], <span class="number">18</span>, <span class="number">3</span>);</span><br><span class="line">            <span class="built_in">this</span>.msg = <span class="string">&#x27;高德地图 &#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;glg&#x27;</span>:</span><br><span class="line">            <span class="built_in">this</span>.addLayer(L, map, store.state.layerItems[<span class="string">&#x27;glg_n&#x27;</span>]);</span><br><span class="line">            <span class="built_in">this</span>.msg = <span class="string">&#x27;谷歌地图 &#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;geo&#x27;</span>:</span><br><span class="line">            <span class="built_in">this</span>.addLayer(L, map, store.state.layerItems[<span class="string">&#x27;geo_n_g&#x27;</span>], <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">this</span>.msg = <span class="string">&#x27;   智图   &#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;osm&#x27;</span>:</span><br><span class="line">            <span class="built_in">this</span>.addLayer(L, map, store.state.layerItems[<span class="string">&#x27;osm&#x27;</span>]);</span><br><span class="line">            <span class="built_in">this</span>.msg = <span class="string">&#x27;OSM地图&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;box&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.baseLayer !== <span class="literal">null</span>) &#123;</span><br><span class="line">              map.removeLayer(<span class="built_in">this</span>.baseLayer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.baseLayer = L.tileLayer(<span class="string">&#x27;https://api.tiles.mapbox.com/v4/&#123;id&#125;/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png?&#x27;</span> +</span><br><span class="line">              <span class="string">&#x27;access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw&#x27;</span>,</span><br><span class="line">              &#123;</span><br><span class="line">                id: store.state.layerItems[<span class="string">&#x27;box&#x27;</span>],</span><br><span class="line">                minZoom: <span class="number">3</span></span><br><span class="line">              &#125;);</span><br><span class="line">            map.addLayer(<span class="built_in">this</span>.baseLayer);</span><br><span class="line">            <span class="built_in">this</span>.msg = <span class="string">&#x27;Mapbox&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>其中 this.state 是用Vuex插件定义的全局状态变量，其本身是 src/store/index.js文件中定义的一个对象，在其中我们定义了各种地图的配置选项。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/store/index.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    <span class="comment">// 底图数据</span></span><br><span class="line">    layerItems: &#123;</span><br><span class="line">      <span class="string">&#x27;tdt_n&#x27;</span>: <span class="string">&#x27;TianDiTu.Normal.Map&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;tdt_n_a&#x27;</span>: <span class="string">&#x27;TianDiTu.Normal.Annotion&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;tdt_s&#x27;</span>: <span class="string">&#x27;TianDiTu.Satellite.Map&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;tdt_s_a&#x27;</span>: <span class="string">&#x27;Satellite.Annotion&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;gd_n_a&#x27;</span>: <span class="string">&#x27;GaoDe.Normal.Map&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;gd_s&#x27;</span>: <span class="string">&#x27;GaoDe.Satellite.Map&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;gd_s_a&#x27;</span>: <span class="string">&#x27;GaoDe.Satellite.Annotion&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;glg_n&#x27;</span>: <span class="string">&#x27;Google.Normal.Map&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;glg_s&#x27;</span>: <span class="string">&#x27;Google.Satellite.Map&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;geo_n&#x27;</span>: <span class="string">&#x27;Geoq.Normal.Map&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;geo_n_p&#x27;</span>: <span class="string">&#x27;Geoq.Normal.PurplishBlue&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;geo_n_g&#x27;</span>: <span class="string">&#x27;Geoq.Normal.Gray&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;geo_n_w&#x27;</span>: <span class="string">&#x27;Geoq.Normal.Warm&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;geo_n_h&#x27;</span>: <span class="string">&#x27;Geoq.Normal.Hydro&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;osm&#x27;</span>: <span class="string">&#x27;OSM.Normal.Map&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;box_d&#x27;</span>: <span class="string">&#x27;mapbox.dark&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;box_l&#x27;</span>: <span class="string">&#x27;mapbox.light&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;box&#x27;</span>: <span class="string">&#x27;mapbox.streets&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//地图配置</span></span><br><span class="line">    mapconfig: &#123;</span><br><span class="line">      zoom: <span class="number">15</span>,</span><br><span class="line">      center: [<span class="number">30.541093</span>, <span class="number">114.360734</span>],</span><br><span class="line">      minZoom: <span class="number">2</span>,</span><br><span class="line">      maxZoom: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="function"><span class="title">setMap</span>(<span class="params">state, key, value</span>)</span> &#123;</span><br><span class="line">      state.mapconfig[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>
<p>然后基于Leftlet的图层切换与返回指定位置功能就实现啦，预览：<a href="http://geoai.sunyunzeng.com/#/home">http://geoai.sunyunzeng.com/#/home</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown简单教程</title>
    <url>/markdown%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Markdown语言简介"><a href="#Markdown语言简介" class="headerlink" title="Markdown语言简介"></a>Markdown语言简介</h1><p>Markdown是一种轻量级的「标记语言」，语法简单易于上手，2004年由<a href="https://daringfireball.net/projects/markdown/">John Gruber</a>创建。Markdown通过纯文本编写的方式实现文章的撰写与排版，然后被转化为html或者pdf，可以轻松地将文章分享。相较于文本编辑器word的文章排版的方式，Markdown通过固定的文本格式实现了绝大多数的排版场景，让创作者可以专心于文章的构思于撰写，而从繁琐的排版工作中解脱出来。</p>
<h1 id="Markdown书写工具"><a href="#Markdown书写工具" class="headerlink" title="Markdown书写工具"></a>Markdown书写工具</h1><p>Markdown也得到了广泛的支持，例如简书、github、知乎、博客园等等都支持直接上传Markdown文档，同时一些桌面程序也支持利用Markdown语法记录文章。推荐的Markdown文档工具如下：</p>
<ul>
<li>Mac系统：<a href="http://25.io/mou/">Mou</a></li>
<li>Windows系统：<a href="http://code52.org/DownmarkerWPF/">MarkPad</a></li>
<li>Linux系统：<a href="https://gitee.com/mirrors/retext">retext</a></li>
<li>网页版：<a href="https://www.jianshu.com/">简书</a>，可支持在线预览Markdown文档的功能</li>
</ul>
<p>一些在线的Markdown工具：</p>
<ul>
<li><a href="http://mahua.jser.me/?utm_source=mindstore.io">MaHua</a>在线编辑器，无须测试 </li>
<li><a href="https://www.zybuluo.com/cmd/?utm_source=mindstore.io">Cmd Markdown</a>客户端编译器</li>
</ul>
<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p>很多博客的文章也是用Markdown写成的，因此花几分钟学习Markdown的语法还是很有必要的。下面介绍最常用的几种Markdown语法。</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a><strong>标题</strong></h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br></pre></td></tr></table></figure>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a><strong>字体</strong></h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**加粗**</span></span><br><span class="line"><span class="emphasis">*斜线*</span></span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>
<p><strong>加粗</strong><br><em>斜线</em><br><del>删除线</del><br>由于markdown支持插入html标签，因此更复杂的字体设置可以通过html标签跟css控制：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>我是黑体字<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;微软雅黑&quot;</span>&gt;</span></span>我是微软雅黑<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;STCAIYUN&quot;</span> <span class="attr">color</span>=<span class="string">#0099ff</span>&gt;</span></span>我是华文彩云<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#00ffff</span> <span class="attr">size</span>=<span class="string">2</span>&gt;</span></span>color=#00ffff<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">gray</span> <span class="attr">size</span>=<span class="string">3</span>&gt;</span></span>color=gray<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">orange</span>&gt;</span></span>背景色是：orange<span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p><font face="黑体">我是黑体字</font></p>
<p><font face="微软雅黑">我是微软雅黑</font></p>
<p><font face="STCAIYUN" color="#0099ff">我是华文彩云</font></p>
<p><font color="#00ffff" size="2">color=#00ffff</font></p>
<p><font color="gray" size="3">color=gray</font></p>
<table><tr><td bgcolor="orange">背景色是：orange</td></tr></table>

<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a><strong>分割线</strong></h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">* 或者 ---</span></span></span><br></pre></td></tr></table></figure>
<p>下面是分割线：</p>
<hr>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。</span></span><br><span class="line"><span class="quote">&gt; 此后如竟没有炬火，我便是唯一的光。倘若有了炬火，出了太阳，我们自然心悦诚服的消失。</span></span><br><span class="line"><span class="quote">&gt; 不但毫无不平，而且还要随喜赞美这炬火或太阳；因为他照了人类，连我都在内。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。此后如竟没有炬火，我便是唯一的光。倘若有了炬火，出了太阳，我们自然心悦诚服的消失。不但毫无不平，而且还要随喜赞美这炬火或太阳；因为他照了人类，连我都在内。</p>
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 有序列表.1</span><br><span class="line"><span class="bullet">2.</span> 有序列表.2</span><br><span class="line"><span class="bullet">-</span> 无序列表.1</span><br><span class="line"><span class="bullet">-</span> 无序列表.2</span><br></pre></td></tr></table></figure>
<ol>
<li>有序列表.1</li>
<li>有序列表.2</li>
</ol>
<ul>
<li>无序列表.1</li>
<li>无序列表.2</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">行内代码： <span class="code">`行内代码`</span></span><br><span class="line">块内代码：</span><br><span class="line"><span class="code">```javascript</span></span><br><span class="line"><span class="code">let name = &#x27;syz&#x27;```</span></span><br></pre></td></tr></table></figure>
<p>行内代码： <code>行内代码</code><br>块内代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;syz&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a><strong>表格</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| Tables        | Are           | Cool  |</span><br><span class="line">| ------------- |:-------------:| -----:|</span><br><span class="line">| col 3 is      | right-aligned | $1600 |</span><br><span class="line">| col 2 is      | centered      |   $12 |</span><br><span class="line">| zebra stripes | are neat      |    $1 |</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>Tables</th>
<th style="text-align:center">Are</th>
<th style="text-align:right">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td>col 3 is</td>
<td style="text-align:center">right-aligned</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
</div>
<p>:——————-: 表示居中，——-:表示靠右居中</p>
<h2 id="外链及图片"><a href="#外链及图片" class="headerlink" title="外链及图片"></a><strong>外链及图片</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">插入链接：</span><br><span class="line">[链接名称](链接地址)</span><br></pre></td></tr></table></figure>
<p><a href="链接地址">链接名称</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">插入图片：</span><br><span class="line">![](图片地址)</span><br></pre></td></tr></table></figure>
<p><img src="/markdown%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/图片地址" alt="图片名称"></p>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a><strong>公式</strong></h2><p>行内公式：使用两个“ $ ”符号引用公式: <script type="math/tex">公式</script></p>
<p>行间公式：使用两对“ $ ”公式$$$$</p>
<p>本博客采用的数学公式库为 <a href="https://katex.org/">katex</a>，它是一个支持HTML的轻量级的数学公式引擎，使用起来也非常简单。</p>
<p>可以通过<a href="https://demo.wiris.com/mathtype/en/developers.php">在线可视化公式编辑器</a>，实现公式代码的生成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">行内公式：$E&#x3D;mc^2$</span><br></pre></td></tr></table></figure>
<p>行内公式：$E=mc^2$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">行间公式：</span><br><span class="line">$$\begin&#123;bmatrix&#125;1&amp;2\\1&amp;4\end&#123;bmatrix&#125;&#x3D;\int_0^1\lim_&#123;x\rightarrow\infty&#125;\operatorname dx$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">\begin{bmatrix}1&2\\1&4\end{bmatrix}=\int_0^1\lim_{x\rightarrow\infty}\operatorname dx</script><h2 id="Markdown进阶"><a href="#Markdown进阶" class="headerlink" title="Markdown进阶"></a>Markdown进阶</h2><h3 id="Tabs"><a href="#Tabs" class="headerlink" title="Tabs"></a><strong>Tabs</strong></h3><p>使用方法：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br><span class="line"></span><br><span class="line">Unique name   : Unique name of tabs block tag without comma.</span><br><span class="line"><span class="code">                Will be used in #id&#x27;s as prefix for each tab with their index numbers.</span></span><br><span class="line"><span class="code">                If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes.</span></span><br><span class="line"><span class="code">                Only for current url of post/page must be unique!</span></span><br><span class="line"><span class="code">[index]       : Index number of active tab.</span></span><br><span class="line"><span class="code">                If not specified, first tab (1) will be selected.</span></span><br><span class="line"><span class="code">                If index is -1, no tab will be selected. It&#x27;s will be something like spoiler.</span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br><span class="line"><span class="code">[Tab caption] : Caption of current tab.</span></span><br><span class="line"><span class="code">                If not caption specified, unique name with tab index suffix will be used as caption of tab.</span></span><br><span class="line"><span class="code">                If not caption specified, but specified icon, caption will empty.</span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br><span class="line"><span class="code">[@icon]       : FontAwesome icon name (full-name, look like &#x27;fas fa-font&#x27;)</span></span><br><span class="line"><span class="code">                Can be specified with or without space; e.g. &#x27;Tab caption @icon&#x27; similar to &#x27;Tab caption@icon&#x27;.</span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Demo 1 - 预设选择第一个【默认】</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button><button type="button" class="tab " data-href="test1-3">test1 3</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<blockquote>
<p>Demo 2 - 预设选择tabs</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
<div class="tabs" id="test2"><ul class="nav-tabs"><button type="button" class="tab " data-href="test2-1">test2 1</button><button type="button" class="tab " data-href="test2-2">test2 2</button><button type="button" class="tab  active" data-href="test2-3">test2 3</button></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<blockquote>
<p>Demo 3 - 没有预设值</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
<div class="tabs" id="test3"><ul class="nav-tabs no-default"><button type="button" class="tab " data-href="test3-1">test3 1</button><button type="button" class="tab " data-href="test3-2">test3 2</button><button type="button" class="tab " data-href="test3-3">test3 3</button></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<blockquote>
<p>Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
<div class="tabs" id="test4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test4-1">第一个Tab</button><button type="button" class="tab " data-href="test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button><button type="button" class="tab " data-href="test4-3"><i class="fas fa-bomb"></i>炸弹</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="Note便签"><a href="#Note便签" class="headerlink" title="Note便签"></a><strong>Note便签</strong></h3><div class="tabs" id="通用设置"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="通用设置-1">通用设置</button><button type="button" class="tab " data-href="通用设置-2">用法1</button><button type="button" class="tab " data-href="通用设置-3">用法2（自定义icon）</button></ul><div class="tab-contents"><div class="tab-item-content active" id="通用设置-1"><p>移植于next主题，并进行修改。</p>
<p>修改 <code>主题配置文件</code><br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note tag style values:</span></span><br><span class="line">  <span class="comment">#  - simple    bs-callout old alert style. Default.</span></span><br><span class="line">  <span class="comment">#  - modern    bs-callout new (v2-v3) alert style.</span></span><br><span class="line">  <span class="comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span></span><br><span class="line">  <span class="comment">#  - disabled  disable all CSS styles import of note tag.</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">simple</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line">  <span class="comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><br><code>icons</code>和<code>light_bg_offset</code>只对方法一生效</p>
<p>Note 标签外挂有两种用法</p></div><div class="tab-item-content" id="通用设置-2"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">class</td>
<td style="text-align:center">【可选】标签，不同的标签有不同的配色<br>（ default / primary / success / info / warning / danger ）</td>
</tr>
<tr>
<td style="text-align:center">no-icon</td>
<td style="text-align:center">【可选】不显示 icon</td>
</tr>
<tr>
<td style="text-align:center">style</td>
<td style="text-align:center">【可选】可以覆盖配置中的 style  <br> （simple/modern/flat/disabled）</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>simple<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note simple %&#125;</span><br><span class="line">默认 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;</span><br><span class="line">default 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;</span><br><span class="line">primary 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;</span><br><span class="line">success 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;</span><br><span class="line">info 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;</span><br><span class="line">warning 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;</span><br><span class="line">danger 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<div class="note simple"><p>默认 提示块标籤</p>
</div>

<div class="note default simple"><p>default 提示块标籤</p>
</div>

<div class="note primary simple"><p>primary 提示块标籤</p>
</div>

<div class="note success simple"><p>success 提示块标籤</p>
</div>

<div class="note info simple"><p>info 提示块标籤</p>
</div>

<div class="note warning simple"><p>warning 提示块标籤</p>
</div>

<div class="note danger simple"><p>danger 提示块标籤</p>
</div>

<blockquote>
<p>modern<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note modern %&#125;</span><br><span class="line">默认 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;</span><br><span class="line">default 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;</span><br><span class="line">primary 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;</span><br><span class="line">success 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;</span><br><span class="line">info 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;</span><br><span class="line">warning 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;</span><br><span class="line">danger 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<div class="note modern"><p>默认 提示块标籤</p>
</div>

<div class="note default modern"><p>default 提示块标籤</p>
</div>

<div class="note primary modern"><p>primary 提示块标籤</p>
</div>

<div class="note success modern"><p>success 提示块标籤</p>
</div>

<div class="note info modern"><p>info 提示块标籤</p>
</div>

<div class="note warning modern"><p>warning 提示块标籤</p>
</div>

<div class="note danger modern"><p>danger 提示块标籤</p>
</div>

<blockquote>
<p>flat<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note flat %&#125;</span><br><span class="line">默认 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;</span><br><span class="line">default 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;</span><br><span class="line">primary 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;</span><br><span class="line">success 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;</span><br><span class="line">info 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;</span><br><span class="line">warning 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;</span><br><span class="line">danger 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<div class="note flat"><p>默认 提示块标籤</p>
</div>

<div class="note default flat"><p>default 提示块标籤</p>
</div>

<div class="note primary flat"><p>primary 提示块标籤</p>
</div>

<div class="note success flat"><p>success 提示块标籤</p>
</div>

<div class="note info flat"><p>info 提示块标籤</p>
</div>

<div class="note warning flat"><p>warning 提示块标籤</p>
</div>

<div class="note danger flat"><p>danger 提示块标籤</p>
</div>

<blockquote>
<p>disabled<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note disabled %&#125;</span><br><span class="line">默认 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;</span><br><span class="line">default 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;</span><br><span class="line">primary 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;</span><br><span class="line">success 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;</span><br><span class="line">info 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;</span><br><span class="line">warning 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;</span><br><span class="line">danger 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<div class="note disabled"><p>默认 提示块标籤</p>
</div>

<div class="note default disabled"><p>default 提示块标籤</p>
</div>

<div class="note primary disabled"><p>primary 提示块标籤</p>
</div>

<div class="note success disabled"><p>success 提示块标籤</p>
</div>

<div class="note info disabled"><p>info 提示块标籤</p>
</div>

<div class="note warning disabled"><p>warning 提示块标籤</p>
</div>

<div class="note danger disabled"><p>danger 提示块标籤</p>
</div></div><div class="tab-item-content" id="通用设置-3"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">color</td>
<td style="text-align:center">【可选】顔色 <br>(default / blue / pink / red / purple / orange / green)</td>
</tr>
<tr>
<td style="text-align:center">icon</td>
<td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td>
</tr>
<tr>
<td style="text-align:center">style</td>
<td style="text-align:center">【可选】可以覆盖配置中的 style  <br> （simple/modern/flat/disabled）</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>simple<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;</span><br><span class="line">2021年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;</span><br><span class="line">小心开车 安全至上</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;</span><br><span class="line">这是三片呢？还是四片？</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;</span><br><span class="line">前端最讨厌的浏览器</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></p>
<div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p>
</div>
<div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>
<div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p>
</div>
<div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>
<div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p>
</div>
<div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p>
</div>

<p>modern<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;</span><br><span class="line">2021年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;</span><br><span class="line">小心开车 安全至上</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;</span><br><span class="line">这是三片呢？还是四片？</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;</span><br><span class="line">前端最讨厌的浏览器</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></p>
<div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>
<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p>
</div>
<div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>
<div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p>
</div>
<div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>
<div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p>
</div>
<div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p>
</div>

<p>flat<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;</span><br><span class="line">2021年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;</span><br><span class="line">小心开车 安全至上</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;</span><br><span class="line">这是三片呢？还是四片？</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;</span><br><span class="line">前端最讨厌的浏览器</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></p>
<div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p>
</div>
<div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>
<div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p>
</div>
<div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>
<div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p>
</div>
<div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p>
</div>

<p>disabled<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;</span><br><span class="line">2021年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;</span><br><span class="line">小心开车 安全至上</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;</span><br><span class="line">这是三片呢？还是四片？</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;</span><br><span class="line">前端最讨厌的浏览器</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>
<div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p>
</div>
<div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>
<div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p>
</div>
<div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>
<div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p>
</div>
<div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p>
</div>

<blockquote>
<p>no-icon<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue no-icon %&#125;</span><br><span class="line">2021年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink no-icon %&#125;</span><br><span class="line">小心开车 安全至上</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red no-icon %&#125;</span><br><span class="line">这是三片呢？还是四片？</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange no-icon %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple no-icon %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green no-icon %&#125;</span><br><span class="line">前端最讨厌的浏览器</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></p>
<div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p>
</div>
<div class="note blue no-icon flat"><p>2021年快到了….</p>
</div>
<div class="note pink no-icon flat"><p>小心开车 安全至上</p>
</div>
<div class="note red no-icon flat"><p>这是三片呢？还是四片？</p>
</div>
<div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p>
</div>
<div class="note purple no-icon flat"><p>剪刀石头布</p>
</div>
<div class="note green no-icon flat"><p>前端最讨厌的浏览器</p>
</div>
</blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="tag-hide"><a href="#tag-hide" class="headerlink" title="tag-hide"></a>tag-hide</h3><div class="note warning flat"><p>请注意，tag-hide内的标签外挂content内都不建议有h1 - h6 等标题。因为Toc会把隐藏内容标题也显示出来，而且当滚动屏幕时，如果隐藏内容没有显示出来，会导致Toc的滚动出现异常。</p>
</div>
<div class="tabs" id="name"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="name-1">Inline</button><button type="button" class="tab " data-href="name-2">Block</button><button type="button" class="tab " data-href="name-3">Toggle</button></ul><div class="tab-contents"><div class="tab-item-content active" id="name-1"><p><code>inline</code> 在文本里面添加按钮隐藏内容，只限文字<br>( content不能包含英文逗号，可用<code>&amp;sbquo</code>;)<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% hideInline content,display,bg,color %&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>content: 文本内容</li>
<li>display: 按钮显示的文字(可选)</li>
<li>bg: 按钮的背景颜色(可选)</li>
<li>color: 按钮文字的颜色(可选)</li>
</ul>
<blockquote>
<p>Demo<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">哪个英文字母最酷？ &#123;% hideInline 因为西装裤(C装酷),查看答案,#FF7242,#fff %&#125;</span><br><span class="line"></span><br><span class="line">门里站着一个人? &#123;% hideInline 闪 %&#125;</span><br></pre></td></tr></table></figure><br>哪个英文字母最酷？ <span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">查看答案
  </button><span class="hide-content">因为西装裤(C装酷)</span>&lt;/span&gt;</span></p>
</blockquote>
<p>门里站着一个人? <span class="hide-inline"><button type="button" class="hide-button" style>Click
  </button><span class="hide-content">闪</span>&lt;/span&gt;</span></p></div><div class="tab-item-content" id="name-2"><p><code>block</code>独立的block隐藏内容，可以隐藏很多内容，包括图片，代码块等等</p>
<p>( display 不能包含英文逗号，可用<code>&amp;sbquo</code>;)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>content: 文本内容</li>
<li>display: 按钮显示的文字(可选)</li>
<li>bg: 按钮的背景颜色(可选)</li>
<li>color: 按钮文字的颜色(可选)</li>
</ul>
<blockquote>
<p>Demo </p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">查看答案</span><br><span class="line">&#123;% hideBlock 查看答案 %&#125;</span><br><span class="line">傻子，怎么可能有答案</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure>
<p>查看答案</p>
<div class="hide-block"><button type="button" class="hide-button" style>查看答案
    </button><div class="hide-content"><p>傻子，怎么可能有答案</p>
</div></div></div><div class="tab-item-content" id="name-3"><p>如果你需要展示的内容太多，可以把它隐藏在收缩框里，需要时再把它展开。</p>
<p>( display 不能包含英文逗号，可用<code>&amp;sbquo</code>;)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% hideToggle display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Demo<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% hideToggle Butterfly安装方法 %&#125;</span><br><span class="line">在你的博客根目录里</span><br><span class="line"></span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line"></span><br><span class="line">如果想要安装比较新的dev分支，可以</span><br><span class="line"></span><br><span class="line">git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line"></span><br><span class="line">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<details class="toggle"><summary class="toggle-button" style>Butterfly安装方法</summary><div class="toggle-content"><p>在你的博客根目录里</p>
<p>git clone -b master <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes/Butterfly</p>
<p>如果想要安装比较新的dev分支，可以</p>
<p>git clone -b dev <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes/Butterfly</p>
</div></details></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="mermaid-绘图"><a href="#mermaid-绘图" class="headerlink" title="mermaid 绘图"></a>mermaid 绘图</h3><div class="note warning flat"><p>mermaid标签不允许嵌套于一些隐藏属性的标签外挂，例如: tag-hide内的标签外挂和tabs标签外挂，这会导致mermaid图示无法正常显示，使用时请留意。</p>
<p>请不要压缩html代码，不然会导致mermaid显示异常</p>
</div>
<p>使用mermaid标签可以绘製Flowchart（流程图）、Sequence diagram（时序图 ）、Class Diagram（类别图）、State Diagram（状态图）、Gantt（甘特图）和Pie Chart（圆形图），具体可以查看<a href="https://mermaid-js.github.io/mermaid/#/">mermaid文档</a></p>
<p>修改 <code>主题配置文件</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># built-in themes: default/forest/dark/neutral</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>
<p>写法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">pie</span><br><span class="line"><span class="code">    title Key elements in Product X</span></span><br><span class="line"><span class="code">    &quot;Calcium&quot; : 42.96</span></span><br><span class="line"><span class="code">    &quot;Potassium&quot; : 50.05</span></span><br><span class="line"><span class="code">    &quot;Magnesium&quot; : 10.01</span></span><br><span class="line"><span class="code">    &quot;Iron&quot; :  5</span></span><br><span class="line"><span class="code">&#123;% endmermaid %&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gcore.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-mermaid.png" alt="mermaid绘图"></p>
<h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3><p>使用方法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% btn [url],[text],[icon],[color] [style] [layout] [position] [size] %&#125;</span><br><span class="line"></span><br><span class="line">[url]         : 链接</span><br><span class="line">[text]        : 按钮文字</span><br><span class="line">[icon]        : [可选] 图标</span><br><span class="line">[color]       : [可选] 按钮背景顔色(默认style时）</span><br><span class="line"><span class="code">                      按钮字体和边框顔色(outline时)</span></span><br><span class="line"><span class="code">                      default/blue/pink/red/purple/orange/green</span></span><br><span class="line"><span class="code">[style]       : [可选] 按钮样式 默认实心</span></span><br><span class="line"><span class="code">                      outline/留空</span></span><br><span class="line"><span class="code">[layout]      : [可选] 按钮佈局 默认为line</span></span><br><span class="line"><span class="code">                      block/留空</span></span><br><span class="line"><span class="code">[position]    : [可选] 按钮位置 前提是设置了layout为block 默认为左边</span></span><br><span class="line"><span class="code">                      center/right/留空</span></span><br><span class="line"><span class="code">[size]        : [可选] 按钮大小</span></span><br><span class="line"><span class="code">                      larger/留空</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Demo</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">This is my website, click the button &#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,,outline %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,larger %&#125;</span><br></pre></td></tr></table></figure>
<p>This is my website, click the button <a class="btn-beautify " href="https://butterfly.js.org/" title="Butterfly"><span>Butterfly</span></a><br>This is my website, click the button <a class="btn-beautify " href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><br>This is my website, click the button <a class="btn-beautify outline" href="https://butterfly.js.org/" title="Butterfly"><span>Butterfly</span></a><br>This is my website, click the button <a class="btn-beautify outline" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><br>This is my website, click the button <a class="btn-beautify larger" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,block %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,block center larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,block right outline larger %&#125;</span><br></pre></td></tr></table></figure>
<a class="btn-beautify block" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify block center larger" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify block right outline larger" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<p><strong>more than one button in center</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,blue larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,pink larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,red larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,purple larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,orange larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,green larger %&#125;</span><br></pre></td></tr></table></figure>
<a class="btn-beautify larger" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify blue larger" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify pink larger" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify red larger" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify purple larger" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify orange larger" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify green larger" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btn-center&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline blue larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline pink larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline red larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline purple larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline orange larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline green larger %&#125;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<div class="btn-center">
<a class="btn-beautify outline larger" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify outline blue larger" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify outline pink larger" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify outline red larger" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify outline purple larger" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify outline orange larger" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
<a class="btn-beautify outline green larger" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
</div>

<h3 id="inlineimg"><a href="#inlineimg" class="headerlink" title="inlineimg"></a>inlineimg</h3><p>主题中的图片都是默认以<code>块级元素</code>显示，如果你想以<code>内联元素</code>显示，可以使用这个标签外挂。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% inlineImg [src] [height] %&#125;</span><br><span class="line"></span><br><span class="line">[src]      :    图片链接</span><br><span class="line">[height]   ：   图片高度限制【可选】</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Demo </p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">你看我长得漂亮不</span><br><span class="line"></span><br><span class="line">![](https://i.loli.net/2021/03/19/2P6ivUGsdaEXSFI.png)</span><br><span class="line"></span><br><span class="line">我觉得很漂亮 &#123;% inlineImg https://i.loli.net/2021/03/19/5M4jUB3ynq7ePgw.png 150px %&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gcore.jsdelivr.net/gh/jerryc127/CDN@m2/img/hexo-theme-butterfly-docs-inlineimg.png" alt="图片示例"></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>npm 常用命令集合</title>
    <url>/npm-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="npm-更新命令"><a href="#npm-更新命令" class="headerlink" title="npm 更新命令"></a>npm 更新命令</h1><p><strong>查看当前 npm 版本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p><strong>更新到最新版本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g npm</span><br></pre></td></tr></table></figure>
<p><strong>更新到指定版本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm -g install npm@6.8.0</span><br></pre></td></tr></table></figure>
<h1 id="npm-升级框架的依赖库"><a href="#npm-升级框架的依赖库" class="headerlink" title="npm 升级框架的依赖库"></a>npm 升级框架的依赖库</h1><p><strong>1. 全局升级 cli 工具</strong></p>
<p>查看版本<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure></p>
<p>升级<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i hexo-cli -g</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 安装 npm check 工具，检查哪些工具需要升级</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g npm-check</span><br><span class="line">npm-check</span><br></pre></td></tr></table></figure>
<p><strong>3. 升级依赖包和系统插件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g npm-upgrade</span><br><span class="line">npm-upgrade</span><br></pre></td></tr></table></figure>
<p><strong>4. 继续升级</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm update -g</span><br><span class="line">npm update --save</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue + Express + MySQL驾驶行为分析全栈项目(六): ECharts实现轨迹动态可视化</title>
    <url>/Vue-Express-MySQL%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE-%E5%85%AD-ECharts%E5%AE%9E%E7%8E%B0%E8%BD%A8%E8%BF%B9%E5%8A%A8%E6%80%81%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>自己做了一点点的小尝试：基于前馈神经网络 LSTM 的个体出行目的地预测模型，基于个体历史出行数据，模型可以实现出行目的地的实时动态预测功能。</p>
<p>模型其实具有实际应用功能，为了对其应用场景进行探索，拟开发一个全栈的项目，在Web客户端实现用户出行的动态预测效果，同时能够提供数据可视分析等功能。</p>
<p><strong><a href="https://github.com/SUNYunZeng/AIforDriving">项目地址</a></strong></p>
<p><strong><a href="http://geoai.sunyunzeng.com/">可视化效果</a></strong></p>
<p>轨迹的动态可视化预期效果可以参考: <a href="https://www.echartsjs.com/examples/zh/editor.html?c=lines-bmap-effect">https://www.echartsjs.com/examples/zh/editor.html?c=lines-bmap-effect</a></p>
<h1 id="ECharts准备"><a href="#ECharts准备" class="headerlink" title="ECharts准备"></a>ECharts准备</h1><p>首先安装EChart组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install echarts --save</span><br></pre></td></tr></table></figure>
<p>然后在 Vue 的 <strong>main.js</strong> 文件中引入百度地图依赖</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;echarts/extension/bmap/bmap&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="封装百度地图轨迹可视化模块"><a href="#封装百度地图轨迹可视化模块" class="headerlink" title="封装百度地图轨迹可视化模块"></a>封装百度地图轨迹可视化模块</h1><p>我们将百度地图轨迹可视化单独包装成一个模块 EChartsMap.vue，该模块作用是接收父模块传来的可视化数据及设置参数，实现对应的可视化效果。</p>
<p>首先创建界面模版：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bmap&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line">.bmap&#123;</span><br><span class="line"><span class="css">  <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">78vh</span>);</span></span><br><span class="line"><span class="css">  <span class="attribute">position</span>: relative;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在 script 标签中引入逻辑代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span>;</span><br><span class="line"><span class="comment">// 引入ECharts组件</span></span><br><span class="line"> <span class="keyword">let</span> echarts = <span class="built_in">require</span>(<span class="string">&#x27;echarts&#x27;</span>);</span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">   name: <span class="string">&#x27;EChartsMap&#x27;</span>,</span><br><span class="line">   props: [<span class="string">&#x27;option&#x27;</span>],</span><br><span class="line">   watch:&#123;</span><br><span class="line">     option: <span class="function"><span class="keyword">function</span> (<span class="params">option</span>) </span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.myChart.setOption(option);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">       myChart: <span class="literal">null</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">this</span>.draw();</span><br><span class="line">   &#125;,</span><br><span class="line">   methods: &#123;</span><br><span class="line">     draw () &#123;</span><br><span class="line">       <span class="built_in">this</span>.myChart = echarts.init(<span class="built_in">this</span>.$el);</span><br><span class="line">       <span class="built_in">this</span>.myChart.setOption(&#123;</span><br><span class="line">         bmap:&#123;</span><br><span class="line">           center: [<span class="number">114.03</span>, <span class="number">22.32</span>],</span><br><span class="line">           zoom: <span class="number">10</span>,</span><br><span class="line">           roam: <span class="literal">true</span>,</span><br><span class="line">           mapStyle: store.state.mapStyle</span><br><span class="line">         &#125;&#125;);</span><br><span class="line">     &#125;,</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>这样子，我们父组件通过子组件的 option 属性进行 ECharts 可视化的配置。</p>
<p>然后子模块通过设置watch监听，实现可视化效果的随父模块数据的动态更新。</p>
<p>我们的ECharts需要在模版渲染成HTML界面后引入，所以在 <strong>mounted()</strong> 函数中使用。</p>
<h1 id="轨迹动态可视化"><a href="#轨迹动态可视化" class="headerlink" title="轨迹动态可视化"></a>轨迹动态可视化</h1><p>首先我们通过样例：<a href="https://www.echartsjs.com/examples/zh/editor.html?c=lines-bmap-effect">https://www.echartsjs.com/examples/zh/editor.html?c=lines-bmap-effect</a> 知道轨迹动态可视化的数据组织形式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    busLines = [&#123;<span class="attr">coords</span>: [[<span class="number">114</span>,<span class="number">25</span>],[<span class="number">115</span>,<span class="number">26</span>], [<span class="number">117</span>,<span class="number">28</span>]...[lng, lat]],</span><br><span class="line">            lineStyle: &#123;</span><br><span class="line">                normal: &#123;</span><br><span class="line">                    color: echarts.color.modifyHSL(<span class="string">&#x27;#5A94DF&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;&#125;,</span><br><span class="line">            &#123;<span class="attr">coords</span>: [[<span class="number">114</span>,<span class="number">25</span>],[<span class="number">115</span>,<span class="number">26</span>], [<span class="number">117</span>,<span class="number">28</span>]...[lng, lat]],</span><br><span class="line">            lineStyle: &#123;</span><br><span class="line">                normal: &#123;</span><br><span class="line">                    color: echarts.color.modifyHSL(<span class="string">&#x27;#5A94DF&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;&#125;]</span><br><span class="line">    myChart.setOption(option = &#123;</span><br><span class="line">        <span class="comment">// 百度底图设置</span></span><br><span class="line">        bmap: &#123;</span><br><span class="line">            center: [<span class="number">116.46</span>, <span class="number">39.92</span>],</span><br><span class="line">            zoom: <span class="number">10</span>,</span><br><span class="line">            roam: <span class="literal">true</span>,</span><br><span class="line">            mapStyle: &#123;</span><br><span class="line">              <span class="string">&#x27;styleJson&#x27;</span>: [</span><br><span class="line">                ...]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        series: [</span><br><span class="line">            <span class="comment">// 基础线条设置</span></span><br><span class="line">            &#123;</span><br><span class="line">            type: <span class="string">&#x27;lines&#x27;</span>,</span><br><span class="line">            coordinateSystem: <span class="string">&#x27;bmap&#x27;</span>,</span><br><span class="line">            polyline: <span class="literal">true</span>,</span><br><span class="line">            data: busLines,</span><br><span class="line">            silent: <span class="literal">true</span>,</span><br><span class="line">            lineStyle: &#123;</span><br><span class="line">                normal: &#123;</span><br><span class="line">                    opacity: <span class="number">0.2</span>,</span><br><span class="line">                    width: <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            progressiveThreshold: <span class="number">500</span>,</span><br><span class="line">            progressive: <span class="number">200</span></span><br><span class="line">        &#125;, </span><br><span class="line">        <span class="comment">// 线上动态点效果设置</span></span><br><span class="line">        &#123;</span><br><span class="line">            type: <span class="string">&#x27;lines&#x27;</span>,</span><br><span class="line">            coordinateSystem: <span class="string">&#x27;bmap&#x27;</span>,</span><br><span class="line">            polyline: <span class="literal">true</span>,</span><br><span class="line">            data: busLines,</span><br><span class="line">            lineStyle: &#123;</span><br><span class="line">                normal: &#123;</span><br><span class="line">                    width: <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            effect: &#123;</span><br><span class="line">                constantSpeed: <span class="number">20</span>,</span><br><span class="line">                show: <span class="literal">true</span>,</span><br><span class="line">                trailLength: <span class="number">0.1</span>,</span><br><span class="line">                symbolSize: <span class="number">1.5</span></span><br><span class="line">            &#125;,</span><br><span class="line">            zlevel: <span class="number">1</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过数据分析发现，我们的轨迹数据只要组织成 busLines (其中设定了轨迹点序列、及轨迹颜色)，然后在ECharts 底图设定 <strong>bmap</strong> 及数据设定 <strong>series</strong> 里面将 <strong>基础线条设置</strong> 与 <strong>线上动态点效果设置</strong> 按照自己喜欢的样式设计好即可。</p>
<p>然后在父模块中先引入EChartMap.vue模块</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleSubmit&quot;</span>&gt;</span>展示<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EChartsMap</span> <span class="attr">:option</span>=<span class="string">&quot;option&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">EChartsMap</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> EChartsMap <span class="keyword">from</span> <span class="string">&#x27;@/components/commom/EChartsMap&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&#x27;prediction&#x27;</span>,</span></span><br><span class="line">    data () &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        bmap: &#123;</span><br><span class="line"><span class="javascript">          center: <span class="built_in">this</span>.$store.state.mapconfig.center,</span></span><br><span class="line">          boundingCoords: [],</span><br><span class="line">          zoom: 15,</span><br><span class="line"><span class="javascript">          roam: <span class="literal">true</span>,</span></span><br><span class="line">          mapStyle: store.state.mapStyle</span><br><span class="line">        &#125;,</span><br><span class="line">        option: &#123;</span><br><span class="line"><span class="javascript">          bmap: <span class="built_in">this</span>.bmap,</span></span><br><span class="line">          tooltip: &#123;</span><br><span class="line"><span class="javascript">            trigger: <span class="string">&#x27;item&#x27;</span></span></span><br><span class="line">          &#125;,</span><br><span class="line">          series: []</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        myChart: <span class="literal">null</span>,</span></span><br><span class="line">        lines: &#123;</span><br><span class="line">          coords: [],</span><br><span class="line">          lineStyle: &#123;</span><br><span class="line">            normal: &#123;</span><br><span class="line"><span class="javascript">              color: <span class="string">&#x27;orange&#x27;</span></span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        lines_option: &#123;</span><br><span class="line"><span class="javascript">          type: <span class="string">&#x27;lines&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          coordinateSystem: <span class="string">&#x27;bmap&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          polyline: <span class="literal">true</span>,</span></span><br><span class="line">          data: [],</span><br><span class="line"><span class="javascript">          silent: <span class="literal">true</span>,</span></span><br><span class="line">          lineStyle: &#123;</span><br><span class="line">            normal: &#123;</span><br><span class="line">              opacity: 0.75,</span><br><span class="line">              width: 3</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          progressiveThreshold: 500,</span><br><span class="line">          progressive: 200</span><br><span class="line">        &#125;,</span><br><span class="line">        lines_state: &#123;</span><br><span class="line"><span class="javascript">          type: <span class="string">&#x27;lines&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          coordinateSystem: <span class="string">&#x27;bmap&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          polyline: <span class="literal">true</span>,</span></span><br><span class="line">          data: [],</span><br><span class="line">          lineStyle: &#123;</span><br><span class="line">            normal: &#123;</span><br><span class="line">              width: 0</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          effect: &#123;</span><br><span class="line">            constantSpeed: 40,</span><br><span class="line"><span class="javascript">            show: <span class="literal">true</span>,</span></span><br><span class="line">            trailLength: 0.3,</span><br><span class="line">            symbolSize: 3.5</span><br><span class="line">          &#125;,</span><br><span class="line">          zlevel: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">// 异步数据处理</span></span></span><br><span class="line">        handleSubmit () &#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$axios.post().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span></span><br><span class="line">                draw(data);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="comment">// 数据可视化函数</span></span></span><br><span class="line">        draw (trajectory) &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.lines.coords = trajectory;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.lines_option.data = [<span class="built_in">this</span>.lines];</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.lines_state.data = [<span class="built_in">this</span>.lines];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> series = [<span class="built_in">this</span>.lines_option, <span class="built_in">this</span>.lines_state];</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.option = &#123;</span></span><br><span class="line"><span class="javascript">          bmap: <span class="built_in">this</span>.bmap,</span></span><br><span class="line">          tooltip: &#123;</span><br><span class="line"><span class="javascript">            trigger: <span class="string">&#x27;item&#x27;</span></span></span><br><span class="line">          &#125;,</span><br><span class="line">          series: series</span><br><span class="line">        &#125;;;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      EChartsMap</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>完整代码请查看：<a href="https://github.com/SUNYunZeng/AIforDriving/blob/master/src/views/Prediction.vue">https://github.com/SUNYunZeng/AIforDriving/blob/master/src/views/Prediction.vue</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>关于中国人口的一点思考</title>
    <url>/%E5%85%B3%E4%BA%8E%E4%B8%AD%E5%9B%BD%E4%BA%BA%E5%8F%A3%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>本篇博客是读了《大国空巢》后的有感而发，也算是胡言乱语吧。首发在知乎，这里只是复述一下。</p>
<p>这本书大陆是13年出版的，但早在07年就已经在香港出版，现在读起来觉得易教授的话振聋发聩。</p>
<p>虽然有些结论或者数据还需要进一步推敲，但整体的论点是立得住的。想想早在零几年大家对计划生育政策无不推崇的背景下，易教授能站在国家民族的角度发出人口问题的呼声，实在令人佩服。</p>
<p>现在国家的人口发展无不印证了易教授的预测，比联合国最早预测的人口低方案2027年负增长足足提前了5年（2021年中国人口净增长48万，2022年大概率负增长）。当然，最新联合国预测中国最快2023年人口负增长，但这个是不是有点马后炮呢。政策的制定是有滞后性的，如果国家能早点意识到人口负增长问题，早点放开生育，现在人口结构问题会有更多的解决空间。</p>
<p>现在不要只盯着中国人口总数，看起来很多，而是关注人口结构，就会发现中国老龄化问题的严重，一个社会只有年轻人才是创造力和活力的源泉，如果中国进入重度老龄化社会，那么日本就是前车之鉴，况且中国是未富先老，将来老年人的社会问题将会很大。</p>
<p>人力也是一种资源，是比石油，煤炭更宝贵的资源，因为自然资源只能1+1=2，而人力资源却是1+1&gt;2。</p>
<p>当然，人力资源并不等于年轻劳动力数量，只是人口多，人的管理和教育跟不上，那么人口并不能发挥出其100%的左右，比如隔壁的印度，但是不能小瞧印度，因为人力资源不只能生产，还是消费的主体，一切生产活动最终是为人服务的，一个庞大的人口市场，在世界中也是不容小觑的。中国最大的竞争力是能投入社会进行生产和消费的巨大的人力资源。</p>
<p>中国改开的经济腾飞，人口是及其重要的因素，叠加九年义务教育及强大的政府管理水平，使得中国自入世之后，靠着廉价大量的人力资源，迅速使中国变为世界工厂。</p>
<p>对于人口爆炸的担心是多余的。随着人口增加，不从事土地生产的人随之增加，才有可能改造技艺提高技术，发掘新的自然资源，进一步提高土地承载量。为什么工业革命后人口迎来大爆炸，还是新型自然资源的发现（第一次工业革命的煤炭，第二次工业革命的石油，以及后来的电气核能），使得粮食可以大规模机械生产，粮食不再是制约人口发展的因素。至少目前人类社会的生产力可以使全球都过上小康生活，但为什么还有挣扎在生存线上的人，说到底还是分配的问题，不是粮食的问题。</p>
<p>人口，尤其是可以作为人力的人口，是一个国家，一个文明得以发展、繁荣的最根本的前提。目前存在的文明，都是生殖崇拜的，那些抵御生育的文明，早已自绝于历史了。人是文明的载体，是国家的基本构成单位。当今世界的竞争，其实就是人力的竞争，高水平人力的竞争，只有人口到达一定规模，才会出现一定量的高智力人口，才能推动科技进步，技术创新，经济发展。</p>
<p>日本，目前陷在低生育泥潭中无法自拔，经济也是失去了三十年，后面会不会失去四十年，五十年，如果看人口结构的话，我想会的。</p>
<p>中国的GDP总量按照现在发展往后推测，大概率超过美国。但是否永远领先美国呢，还是要看人口，人口结构，人力资源数量。美国是一个移民国家，可以直接从全世界掠夺现成劳动力而不用负担20余年的养育投入，目前美国的生育率2021年是1.66，虽然不及世代更替要求的2.1，但是远比中国的2020年的1.3高，况且美国人口结构要远比中国健康。未来的国际竞争，中美竞争，人口是基本盘。</p>
<p>有人说，人口少，放烟花，你不干，有的是人干。但是，说这些话的人没有想过，人口的萎靡，带来的是市场的萎缩，就业岗位的锐减，社会活力的减少，新型岗位（如当前的新能源）的消失，怕到时候不是人口少了生活更简单，而是有工作的人更卷，来保住来之不易的岗位，同时消费策略更保守，反过来使得市场规模的进一步向下。这个时候怕是屋漏偏逢连夜雨。现在人口塌缩，直接反应在婴幼儿市场的萎靡，等5到6年后，又会传导到中小学，包括后面的高校，以及各行各业。人口下滑问题不是立竿见影的，而是几十年的周期后才能显现。我们要做的就是未雨绸缪。</p>
<p>现在人口低生育陷阱问题的接力棒回到了中国。</p>
<p>中国低生育的问题，非常复杂，但可以抽茧剥丝，寻找底层逻辑。主要核心原因，养育成本太高。</p>
<p>高房价，以及家长对孩子过高的教育投入，使得养育成本不断攀升。同时，城市规划不合理，房价奇高导致家庭一般首房只能小三居甚至是两局，就会出现类似于细胞分裂的接触抑制，这种情况家庭基本不会考虑多要娃。而且，现在独生子女观念深入人心，家家只生一个娃，对于生多个娃的家庭就是不公平的。因为全家之力凝聚在一个娃身上的家庭要远比多娃家庭的孩子更有竞争力，导致大家都不敢多生，陷入鸡娃竞赛中，养育成本不断攀升。中国用养育三个娃的成本只养了一个娃（养娃的成本是边际递减的，第二个娃成本是第一个娃的60%，第三个娃是第一个娃的20%），结果却只产生了一个娃的生产力。况且，现在养儿防不了老，甚至会啃老，又不说养娃给女性在职场上带来的负面影响，养娃已经完全是一个亏本买卖，除了大自然基因繁衍的原始欲望或者家长特别喜欢小孩的心情等，现在90后们但凡会算账，在生孩子问题都会三思而行。</p>
<p>对于个人，养娃是一辈子的大事，不得不深思，如果只顾自己的欲望生娃，那将是对娃最大的不负责任。</p>
<p>对于国家，生孩子却是一个国家，一个民族，一个文明能持续发展，在国际中争夺话语权，让民族屹立于世界之林的头等大事。没有了人口，啥都是海市蜃楼，无源之水，无根之木，空中楼阁。</p>
<p>人口不是负担，而恰恰是一个国家最宝贵的财富。一个国家的兴衰总是伴随着人口的兴衰，须知，存人失地，人地皆存，存地失人，人地皆失!</p>
<ul>
<li>文章首发 <a href="https://www.zhihu.com/question/316068996/answer/2768000787">https://www.zhihu.com/question/316068996/answer/2768000787</a></li>
</ul>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>再见2018，你好2019！</title>
    <url>/%E5%86%8D%E8%A7%812018%EF%BC%8C%E4%BD%A0%E5%A5%BD2019%EF%BC%81/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="4b1f43f7e923ee85b6172bce50aa0740e17fde1fc34b3cb351742036035f3f64">d2d85511782da2007828d4bf9243cc92b3e839874176870166682171c5796de1283e13da3d8088acaecee58662bcf2f9530cccb4106aa272e475fdb12e64098045122a91a7ce0ad6e337b34a86f8107b6c0bb672eaeb2baab13493445422b859a66257f4dd3f46025a705527b06e22691ab46dbb3f816ff70b68fad9af44268cfe24cc8b5335a5486546bd59169db78b9d465238e80cff87a0aa511938e25d4ea5f32936879a13f6dadce673c0e05af1a83ea6f8ab8e5c810780b3621bbcefd36226e6cbfc620100406955bb046313bba8b0a2cd912b8fa7176d0a67c05ef856f226356b0e0e8108a60773880b0fbc99e4a37c8c84acd3b4edd9a464ac347af2382da9ce952718adea3bfa758ca2179416fdca63c1d98b2e1457e6be7be0b294586c07e551e259411f279dbb0f2c6bf849b79ad90ba57e76a8e6a599766802ee386faf865ea7419c8ff93fa0627cc513758107ddf0a850ae4ec5297b78a3ac2cc16e275fbc4eab77f76d250d6c7646ae953b3f972f4b9083fd5d52f6a1c4fd98ef0aa05292dab98c1e7a3675fe350b68f48b23ad8565cffa1ff03ee0fe304ada4a7f103caa375c5beea5923548bfaf0f8f21d1b93d1cac724ea6da4f02f653331f5feb7b595f86bae63e9d98b22d2f8f9434f03e2ed41385b8fef8adc759d42e9348d5356fcbc05a7fd7ea34ff84bc5c716048e5b0cfb7bb18302a89b326f37cf32ab21062c6549b8031fb3ab6042d79201d9c631ebbad6ed11309d6df7297b16b634f81e391351ee6901b7ffc982613b5e0ce38adacfd8ac7efc8a86e8fbb282747060e40f73caeee862e9bff4f745cdeee367e49128100fe65245f90e039306b8939cb9a30f9219869be97ac587f70bc435cff798fbe536919669ad9d9b809c1ad64c3cee59a359f97e3f01ead7f6dc23b7edeb763acc131bd4ef44f62dab0245dfcca7386fff93914437210c9388c2ca48e9b9f4ac35e8dccfda780e13f8c97d28cfbc886ce854c1a7f694af4151272312d97a79a636c9c8b9a14dbca3327b76de847a887f28492c4223a0a106ed02d8f58de29ae317b79eb3802ad956fe32e755f48817443ff7852bd3394c8a9619aa960345804e571038bc2b65a67b5e3e13957385da02dc15866d3d70c4dc30b06bb43ddfa0ddd7ea71f4cc27cdfba24ac4b4f53396093cffd471bbaca5710df05f9cfe213e278370c50073cd0fc1938737fd61562938cc6ddf8f3722c682098a0b12f7893ca77550facb81136edf1a5d4049a71fbf269cf1abd2da8cddae0058f04961bcd99484fcd6c4003ba8fac49b73011c6de02dce4a9c0e5f4b7ce874c364a72e136d2211a2fc0cb471616d4c11848053f91bc1c65ddf901f7f81efab7df505d10d3031d07a7a0d69e3e645113dc3daa1ce1ec10b1a203d91bf757609aa6adea6211c16be4c507e53dbb26ba9140440f9d03956acda4ecf4e008bd3f264bddad153844b117be3f056f148dd869739cd4c092cae9be9899107db10c94a59e5b1d9fe871a8accd2d54ecbc4742646698cb3a6ed6c70f8d7c2f3f9dc140791dc0caa59e058a6130d1f7d78229f1806da13e57016c0ad1b09e6a48c7bc2bbd99f90cd050b5daa45d13a7530f8093a2ca5d3a83d2bbf24372d59e7f663021d0bb144bb6d8d6f8b16e1394d4dffe9013929c357f1699e038e3ae080f3af723d1d5963f86fee5e2b577445cdf35584e9f457c6ec4ca8847c3d6d802a3a98ef18fe2f01f49db90be69ae8d747f8c7b7ca6da244217ab36cf4b1a3cacc13fd1cde091e46a2683d215ea8715340052a485eb41e4460b3891074e8cdbee99f4fd7e28abd26cde639f993aa5e60eb3670d6d335c9baccb05666e86a3efdb7159278500e492beb6316939705a39921c9d8b6979e7503afccf9d99c7284fb7d4edb989380a2ea0fc588751430c7b2642dcbaa8616e996d420a93247b106240c2ba01791b3b205c984b336ac5407ea0fd77d85052f26453202fc9ffa274715164c6c8472f60f00cd16f026a648aab5064d6ef71d778657a9322af9bb0bc86bcb085040ead567101d670f54c0ac16ee8ba72f38c483fdca1cfc5a2c1e69aa12d63c55032329c2b5e80d41c5d9da6eb9d08a53748df1d69a16af6eaf237c3eb32b7a746dd7fe26112796f8f498656051e6a96db75dd0da7646473f4308a510df377042efe0eee20b0f4b6c1531513a45cbe2475a8dcbe721792ff6f052e5a981a7c413c91763d14765eb31c397fae794e3327b08150615649c8861cf7f3f5c9b12f1ee18c1352ac57fd982cae0dc4c0d494dc8cd2180fa89f23838dfe5802c432f0de38b1fc5e0165b9ef519dc6158026d4535401cfc76457d72d74e3b25345f5fbc383a7e1598d61c79c26943a2c79d6e49d4891027dd81c247217d5e0bedb4b6d24a356da27e5ba1bde2be0604935754504f407adda11cde3f0b0739a0a4d3507e2eb7b08a072f3cb03cb57bd8f11a0b1e30e8aa4264fab76e0a4854c67f0de6e6b9f4ecd562a9c9bbdc7f6aec2dd35a39d56f5bced147898e4568f63283bc561cee6c9ea690751e65c6d55ec0aac2b92436d71c1d13b2414ee98b546a105a7125cb34332970f18c5c42cded9bd62cc8dbf3737f2055749d2ff8815351af9ada4fd13405c7f8837af8ba1602bc0204dc0a43629aeb44687db6f45541e964bf2620ec3e7548b27f86c925000491ee1b7a307f30b75d8fed30eea39086966b2f04f23c1710e7f6f248f9807ac6869588f7a097e3e7318ea36808b4780d9ce45cfd4a9d153983ede63c87799a6ff233bf6653307391bd5603e220a9bd7139345c2cd4e8bea757e3add777feaa32e641e3b5455658e49beeaf8a22b3883331c8597ad121b1d8875a049a3343a3024b8834db75a14c1f9541f8009371743360e5ec16b686c3a8f69ca976d9ed3f744a30271f608af13f224eb38136d5e40ac47852d11ecd627844e1f95abaf8971f6240aec8437a02800e1c7417d045dc2442816d5d40c26ecaefc32b6d8e60a5316a4b052031e482d229629f25b24a871a0bdf819f3dd4412c1a47dae8a56af5f5c6e93ee2975f5e3e8c0c3fc5dd94b7042c2cb6e62e7926fd0bbf0e7c7b52e6cbb997ee5ad835362ae99425156f5b0f3d7a36df423b1967c36465636a1d00028db021b900f1a6bc918b01fdc3d4cc2210b48b5e01547b2627917bd9f66f95e11cf6af0037ec34d6bb10cf602044c63a3aba06a1aa497ac01262c429aacd463bbfeb7db19fa4ad9a41004a168223a935abe6ce0936dc71a81386be886c8b764912cc081e54f4b84bea938e66f7aa7b35113e15ae6d616e5790818e1074374ef6156f769142d514c7ea61f9746c53c747ece051dd433e3e8c3b53fdc37a1766d29cca1fb4d434304d8f5792b28f069be7415906bd6ab3c0e57f1042ca14703698ffbb1c806d11fd9ab877f60b05bb415708b69497790843eee1a64cc44666a17045d2268a2b9b1ba1ec2bb300f17b549efe60343cba1fc81b46d4c42c238dc20f72bf360b0758b22b120d2dc03cd802e3c1d9bb2ec9aad771377</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">这里需要密码才能访问。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>再见2020，你好2021！</title>
    <url>/%E5%86%8D%E8%A7%812020%EF%BC%8C%E4%BD%A0%E5%A5%BD2021%EF%BC%81/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="ac4514a46710e162b652a422d3f153a9e139512839e18687d029634f624bf95c">d2d85511782da2007828d4bf9243cc92bcf798e72b8c748078cac6c90b0018c214a8369ef990f007a71db0d86e1929a5f8b9526b2e9e928c3aabbb94e36767d554c80568464a79517ce9397aba12f5c1fcc01b1b4235b9c9a93e5d425c789b87fa3046630f83ed22af85f0af1b374e79ac27f87ca69df0d448e342bfea66ab2d498715c75c7e65131fa62cfa25e2029dab334f5028575ee382f6aa5bf51d384743941b814f7dcd50327c229b0d8ad9208955d43953a3685c1b20ba034d26ecc25fc4c4776ef89d1606bd3b6903dd15e2366ac8319c9ec62598c9f5ca49dd4b00aab9e408dc798fc5288036823157a5cdf84ab8971c4b80e5a46b421dc4a2eb170469ed545b0d272fa5b16a011bd0efb8b6d92e6f0e9b8af5998ee11170cfcf751fc362e9ab09ba4500a2cd2ced026d568c1bf22cb159be196d972b12be6c61c5b62e16bc488b8fe07220514827f7bd7c84863a606b4fe41610632187349ecfadeca9eef057b8732910f780d9f302a37b820786b48cf0a3a03e01b5f3702aa059329d3c3cf97cc3a610d8298a79391637f8817b07c7a6517a23f4f47d3ecfc4536666765e65c386f7faec17d1dc0ce6128c7c21287fcb2a32128ab7485c6613137363093362f45217cfed2213ef494f307ecc3a17b518c04a51d2f8a16f91e9bc7ba5e2058c704233946cf3514afafc506af021c3fe5886eb1b5d140f885b88d20a2159ec29f080b88942d35de1ed2ed8ecfcd89637348ded75e044ae50ca9e5c7f3c05bb42f2fc865f1a1171aeb839f9d9e34e7d2033209ad99aef64ce4b844042f59a98d4eabed9c3ffa893dc6bd4c66672eda984ecdf2a40ef4914fb0021e1fcf93f7992d1bbc55ef625abf4cfa9f6c87df4d981332fc49affe51c1e404e033ece6c433455355edb091e2980935e9cc1fbaefce6b360ef6f4a5ecd3f342504b5ea7bc38a7a0bb2d2201df7070a5c935836bab3c734e3e010630762fdb0c48eacd2d2f6279ac382310b4d7a95463edc626816daca372a0a4f4a26d319f6e6f9f67171d5f774426bbd67e856f9435a688f747db95301b1d19202ce9cd6a50e91a02f89202574a32a66215a9dd40a601741865c8de4ec748fad6e84fb5f007facd81dd7adb874422fd45ff72771952e09e996ab730d7697151e091449d6719463c39e51cbb4d74f9e52eab0cad58d9216cbde541f43d530058b3e5edc8a360a47071e110bed30b7dccf712291abb9a883b7698c747164b5a6f57fa207c30947fcff8b8d9eab2f839c6b749c679ea7b62a3b060e04c4b22cff30a1ec948b627e2dc208d13f2cb7cb7b7d153906af7db56ae506a593d19c32040a7fead0bad8e9e33019b6140495a0318880518641de0ec7f554b5a97e2e9ec096c44c5db446a85a1445d91c259fad7635aca3a9e916f1ea4f50dea2d58002e6b49d55bf127f2806fa8061dd0cb5fcf410fd2c4bba4b532c755a63efcc16a87f7d9b8b8d28c0220df5f94fa8fe425473622f968a686bbf740f253e035c589c4c6bb6520f9635fd965a75c7ca82b6758b1d8960710fdfc51bdb72678ca22fac53357bcdd925fb213a1aa59aa55886753b014fd7b911b4dde6069672d7b4ea0251434ca2697a4869f1f34b2b8d5f80207d04fde54ff4dada5c477349159b0ec4777e97280a24eeb375b3c98800e238611ec13ffb8825e5b9171509ca4291704fad573e0e016bbccafaea6ae40e960f4ad01b1ef98a1b94f39abd0bed86652706d5b6d18c584b3632539a6ffa1ceac33dd544ba9cfb54090075d77d57585c6befaa4400b0d49cfab040b8d10b076f5af4d4c136aac77a5f5c4754a607c35b5d3e5593e1aabd46e7f9e4056314bc071372ba367f99e8f1a2a0ef0636676876f63407090fddc2f5d3ce9522a2a1df0a0313c3a558d36e5e793c2f3a1559d4e47627fdc816a7d633ba0a372122d936d7d619aae5d316297df6a737f35539aee91c41b2f6c08d8b18e53d8e7793a264501a77517954a186f0708622c9dfd70c50b7f1a1f0e23b1230fab9390a1941555c6d4f3ad3bf27e891b0fd85b49af550095a98d06d83a6546a1901566447eec5b3f000e9a283dadf04cf5aa09183e8118abeeef60702b2b2c5eabd9ae69002f206dd004b40b164a6bfd260144cf2bd167106ce0fa0a97a64e954b942074e104b6999c5e809ccd9710057109932277b6fb32d5e51d3bd041a06f7d83df8ed91d87a736fbb496f630eed68a6a298539029c903bf6e28328070e873b51766fc03e30430decab228bdc43ea3e9ae056aa3e3a180bf09d8423c7e6168dbe79424cabb35554fa7f32f5fb1cdf330cb9d421c78b6a9ca4b2c8c673c1fdbea50948d80a3b3c5ce62bdf4e07f907d283187157a43ab75bea6a6d35e0f510f15cb3b9578e3a6bdc50903d9f64a31db8b47d2d18633619ba8e1fc53483dd1e19ff53d25df1f46cc07fe500cecb407eb2dd22e876a71386de1ce4850b379538599eefef177b4a5181dd1412af738c9bc31839956d678a8ef3fce3c46c3f61ec648350762c086e73f3e3ff76b8af1dd230274f5bbd2db020c6e322a3ec98a9f4dbedfe7fbd3c5a55a679d55aa74d258e07dfc0650c137dc6e8d4bb924023f80dcb444057b50e6dd7c08d8bba26bbce065669bf5edd97d702ae42f20f60bb371054413e5dd12e66412d0025b0d2d50d80fa1593ce9bb21f96a98fc962313b88cf566f7426cd8175b2920ea7c10a88f73c548bf8dbd7df2cf4a9a371431685c0c99f34aa1af5785e72d129535d3fc25e521e6517d93c46ad700476e12251b43457e33a1e767c2e09f43aee4eb498e26619d0fa665ea3ad3c47dfe3ac87291a9fb0dd7b8df86df9549cba85f2ffd61e464dd02c2ec19efd42b56c0fe2de5c99a65dbce9b666c8ddae5578af5e76ba50a50354d45729629865de54e93156f59694165326642b2e5a66082134568549cef36572b3fe5d203293123772de938b914136f9c24a008c72b7a9599bae045b1fd36260d96676401d99cfd5e7edf553e6b3a3e962f117c325051feb769afafcdaeefc66ca973f5ce23cfe8e670189811517fcd5df36225c3f4c4d1f43286a17f80d0fab284ca9e152c7a5517ad1519e7d1861b41354551e6919971edc46046599be9e9ba67056af16a327e5586ad532fa1c55be75bc49b15966893fe37e3fa0d01007e770cc33fc0de2b9f045f3765e58f4e09485b13f8cf6a919240638096fd92b744b94dbe31e7a0bf8ea8c800d119d3dcda3a6250e2bbe15d5fa4db4879529e5b5f695fb07a51ca1e54eb2c2d86abcf528a34998a5029f4f81e1667dd825d3eae8bd35a9c22df128ba7f6f2fc9fdacda8877281ceec4a9bdba75539cac9b2d5558620b61bf3859dc9444b8e72bfa55133fbf99db8253b3d89433df4ed25ad84ca1ecd91f2ba46caa494488aeaef8ffce54e1f686224c05a1dcfe9c6660d025f8e8eda4c189532762783f08d445f28b09c0a08faaae94625c47cacc3c771aa7bf73c0bfea48d87530140361d6bce3178b1a07b9bb38559c287709c215f0a9c391444a67b1255c4584a90e36d7fac3b4e261aca5a76ac505296092700dd004d2133aa81aa7dbec0efe01eb7d05594abeee68593d72d42e3089ea336588f4b9e78f6db36c7cbb28a1fbc6ebf5823cbd5d2660be96cc8505bae242e529dcb7b6222368518cf819653d6f65112d7230ce128039d2f476ff25b1f0751fe8fb30e946102e9b90933b3f5d3f4c105db1678276693563e13555c6844f34f98db3b0abe7970aecbfe97270241f5dc1b643e8860bc474cf7924ab7c9dcb010a9ea1eca2958cca6427c34ab1d61606953beca2e45008182763b9c0b86897d400a7fc67dd7f3c6a22f7bd15aa8bad48b785ed834487d354bf91c9f7341bbd7bf303a1555ffa7a70d3b95ea2428d5c6f07d7e9f7901f8f22ed35293a2ec494b7182eb516d69ce7c0866a013232c22712493d82e3dafad3b528c29a324f736a0026bfd22b5f5135d196b6218a6c7b67f7d84b01decdf8e6022b809614ee7228c57c44362ed97c48d6e77c93305c30deb76035f30da61f5312bc98b3af7a985074a008559c19184eb53ec740645cb499bc0b311d23201c130b2b20a7a61d50b680d306c04e1be2a7b19ee586f801596cab195d393406b03a621808a0a0fc7b732a973af7192c82987620069097e521e9203ac27b081fe7ad8004d5378214907e040a00756a604a9466621bc6ce8b282cab1f13c421614d85b1472a292b599c3571f1f6653ab052639c87815fb0fe8d839c5214b50099feb02a7f5b0e8a61063314521b2d864b5018f42722424e068324f80c97e9d571bf3c13b4316e8df36ff23c6f3c4f6a75452140473bc9d9d7f6b86a73d17f00a8bc2a7a5444bca56ada05f1e14708df95d5d384326a3d7c0e51228da879c4dd94cdb2b746208a71dc013f51eac43cfdeceef7d24db060ba61dfca0786933526ad3ceaca02574d0b8d2ef9df9861e84aef0035ca123090791f933a55aa006caae85ba6177ba352d53258ba33842bc2f07983a2f8445664e1a3ce895ee8767048b7e97ccb27821260c59d39e550105bfd2d20e1563efb8ebe53bea9a52afd5a8492fbf92a37f0f6705c65a3c93d2c3402406e0fba43e7df6994b8a6e5f8a3c6a7104b211db8c935266d98c9f6a7c05088f48d5ebd7edf124a6356b3c44af65ad748ed0ffce652ef794fef8007f2375ffa99ab025a4d98b90662c1e7e46db6cf4fdd0638a2493f533540eee9bb4f91ccc7729fdf0c5fe8c6db56dd61c483958a4b34981f26ba4aa2747781e6b325f12bfff769784acdfbcf05df4c416fedfd8743646a3df2cc5eff237cb613ce63d19e2b8a9721078a930ae89f00cca06d7494242f00474d58319a2bfad33d392522e405a072440382d14a4fb824e4a1341691e6e81412153076729df801aafa207317ad0ce028570d2aa78f46bdf61aba1763db8f2f6c67827a8d20de483ef8323884135e59137f7e2e7cebccf67d17cce04e2154418a95f7c4e89c4a9ac78f51582899e4acd44069f9d0ada1cd7fdfdc628483240df19336a385819fd0824a70a72b8d009d11fb604e28b86eb29a07373488cb34fefc1d9a5dea66287825e1ebc6f05fa50d9e4525d7ca71095ef967ac78bed3ec7a39abd17698a939cbe1539731913a4b9f4d88879c6b2cc2eaaf14455e1240179e5b1cb4723169499ac61af466eb500c802744579fb92c62e581a798cca550cf84a956f3f1e27bb13ec98e8a5498a59add79573fa347d0c9372a0c0e055c5f23f2310c1b34052902a0823013f2f542298799eb8c8d4070d8ab041d61ebdee09b8af6e3b2be7fe61aba4ae3a4507c993791274d89ed174f611bdc3412f0c8391c6bcb616a828e7542bc4bcd4cc5f07c967e90163283452df6b367167d2afd892d1d44a504f3bd94672d48c738e97d666a41d8b541274ecaa976f820132afc0d40b88b3368d3714a9796df1f221db0790b49ac57da97a63b13f09206529d147e4f8e4a5506aa3d00fad266cd9c00918f0eef72b185bd85a6c0be50a58aba3e1e4cda40b3e6255cf32bfacd3cd3d4e8c0cb6eab4959ef28520912a45145d66c8aeba27dc2f968afbd71803c4670472b0de91b2ca935747565d8caff0c2200bcab5bafe8a7baaed31026aa08f251335b43f0dd19af9dd54249b6fc3f3bbbceb21b227621dd4c784cace557f76854474a352524baac2247c76a9b5354a50f7bd7f38f33b5794746505411a728778c30cd7682f3da95a0291f5ed9d5bb38b58fb3c7af759849440642bbeeb426919508ec362acafdb28181aa054ea962069363bd7e9f29d6f738730</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">这里需要密码才能访问。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>再见2022，你好2023！</title>
    <url>/%E5%86%8D%E8%A7%812022%EF%BC%8C%E4%BD%A0%E5%A5%BD2023%EF%BC%81/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码不对，请重试" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8363c7b37b714cae15b962195cc10d6185e83bd6418d7b1d96e4c6d7e765861d">d2d85511782da2007828d4bf9243cc92bcf798e72b8c748078cac6c90b0018c23cb6bc6e3ea397743db64686511b646bed77e4d9b4a56254ca83c51777b65218cd054b5ca9089bae92060338951734da02803e882e3698b9d54ec32a1150ffb27ef35687d1b53c395915c3128f2367321fd8dd245bdfefef39cb7c1f9945797ff729d8e9b2d634934d083d251da6bf17a13d44a26b9294a8eb54c363589f35543fc87dfc4d3f7faf1529c3f7a103611afe3b21b07b5f7406a1aa7f77932a23ae2024fa71f720bc6168245c97d902a76f286aeb4a28f1892e30923c8d587c434966a0743fa8c43e114dbedb6e7899511290f9891a919c6718fee89d3f283df87e6602ba8e5858b46c14c7b8572f463a26edc0d4b9ea2a3968051de3d15e304fd05ef59510e2239a493ec430a98a4d2cda636f70dd4be8f8fae26439c7bfa2e94848cbb2bc5a4067d0760ce02d7d186301337c4bfe58401d82e14cc6bf8ba323b17b9857479302eecb2cbf94b4c75d5c89836680699dc9c08c20af78283cc3a207aced352640fbff16c87f8f99462f5160db977f88cc34d0664c1dd593da32785c8e8b4c6307f262f6d3f0e5d78b1ffeebbfd41047f2e43bf11c1acdda822892910ebd55ac6d68ef74a47f94a838b26e721ae244314885f2f5323128f026e8171c0476dfb7dedd3807758437dc2b311bb7e550f389337bb65557927bbc7dd53024a402658848d60cab2076dfd2f87cb7bd7102369e6f8c2ca4400fb8acc6e0cdcea8f66cd338330a354ae022407fbb812fcce3843e0b247fc19abe95380bea69a98a4a823746ddaeb6d5afe8954a4b675246d2124dbd98197ae48d8361fdad96caf39f6f2389640ef6da0ff65bf67f752c80d47fc2ca897b45e852b98c3868c14fdf4c75b0c9b9d14d645b22a1bcc054a247547e8fab185d4e553b21c15917061a16de460303c296e9eeff6f40f7698dd9b7fbef0f74b9a2fe7bd287a0d8cefc47dc57d55d8e0e8873ed1a3aca34bc5f76642c5ea5a346c496b82b7c46b8f5f16896bfcb918059d449f51dbc26f4cb423d5d35fb0ba15eb0d1c45ae8a5f1f713fb41a0fc4727dbabb718f447b3c027feb4b6707bc14c488bacd86d264ae6d1b360cb8ef930c4360f9978c4299238d7cd60b867ed91213768d582fd7bdd1c77c2cd9fa120a31278dbc6081d89afadd2e38a668e8de720f17e36b5269982937b5e9ee7fba72810f3957fcb10371747e9c2a31056cbd5890580028b4c27f4b356d05ccd0f3c312b3a8409ba010e7e6f3247afc1df551e98b089ddb7152934af67d97fc50d9674a62c3474d8fc901e337974e289fe7d80c66b2bb85de053ff8082055c27212bfe3a9b26e5be11f82eb0b95e3f828c060e7777f60e2f8803339a5d07b0284266d3f1dcf8fbc7d45b83662b2a544827d600a96d271c617ddc9f215dcf2c2161609b24151152ee0e06ad6d64e785a5f5bc6605b73ad1fa4986a8563c4c3df9f93c104de391b4f1ed8c8143395f7c1f5b304f6a6679fc414489cbc96a0df0613af4afadf4bd3bd59ff278738034956242dfb13775dca35ac1492b98790d34a9ce1991f281466dc7a8d6d3ad8f9efe13bb67a510725cc6d45d0d0d1883584d1b496b02e30067ae16e0e9041f6a458de32d6a747bcc728e9e026213ced427755b1359f69ae2bfc369e88a3a333d9a4cb1a4addcb3881529c8187c0f388fd98d2fdeb6a5a73a123e4b1e5fd1ca5df47ace1ef1d2c39b7f6a6d111848ecec5269c8a87e8bf7c0dbb6efb09178195a5235619c4920860b2add60aa6e649636dd9ec380812d453acca1839dfa74268507cf1eea531b6d397c9635b3926630320d97438ef39da584103c8b38bcb0d8733813b3e7216f664f098a059d80c052b4b09f1264e6342c67b82b07424ee2c8d73f1202e87354b2f16075a48c4e1bab06241a04a65ace75590409d193998f467bc2fe9be25551b23d84588e0b31b3dc4e4a0eb0fa11a3d258940da8f0cd3bd6f2ef1ffe92e41e64965d7ee1f4f1b1242c89e61e05957a320721e78b7b54866a0889a54bdccadc7bdcb30b861f8c39fc49587eac00a030b2e6de5839b50287de1f34a411f3e578001f06ab807f2862efe812380412621d0c8d2ac5ee32378c7df202fb7f1cae21f6c94a7ad2999ff58d9b02a7812a7c7fc5dffad75dd1e549eca0bbd77f95cd2258012520b5b076615e0a4633a4b6d2c0b04c45c64aed2e409ea25aac615a65be219b67889fbf13132ad9103862a2e4d903893bf7eeb978f4373f5c613f0c59bf11c00c47a82b9612f9c33175f0d7f0ac9dfbc2384109505489d65f374071dda43c5301ff0b43c395d1730a0682733b04219156f751be8deef137972aa01ff5e361e32008a91c0f3e1ecd573cfb58715afaa3ea4707969120e60fbdeff444d48615f15c35ae3e34387838cdbf0615a1428d78b412a2b08c67300f00d0b66c9b19d7bdb3c2e608844551a36a0ccfce96edf08dc1ce861a2d3afd0f79dc38889331176dedf9985790724eeed0c2f5f2fd497852bfd2a29ddab15522b6e659c878da3b558260ede3c961b2e9541837078f9a52146b52b1de978a961ca1cba5fec090a8d66b357e85f8ae2bccdec3d9812179dd2c489e32de1275654ee39dec15feadd0ac0401522e1d7aa5cfabd6fc51c8b37594ee43ae6c9d6464af40c00d3b56eadb7eb9d4346a9dec6c94d017e4ecfcd1fd726128378f43a96fd5c6bfa10fb82378c6444778e07b2bfdb71fb5657d2177b0fb7fe589453eeff94fcc1cff9e20e80e1bcefa6394066bc4ed0fb86338b0366e2fd0b745b051f0ebab4d4cb57c34643bbeaa06e8f5c7009da683e455abf90e0be5f36244e75e0a7732837c3cefc1b32ed93a6c849c37160e53ba627c3af4f3ddee22726fc9caeda9a68e9e72366a10c118f54ead0a15d095e4a1685f964a1f86facbc08a94d3093f2c4831d41debbb92c22e09176773230d6167ddf65a41c00bb5b64a77c0aec8f3025ec30d948159475e631a4617d5550757cfdc599b3d62b998481b6406b97e00f123db45274195726fbc1e8dd4b5e579e008bf3cb9ca7b979383924b3d4e8d54c89358f0be919381170b33f10e5298249ee1f1b3555b8a421ae10ea58182f07389f8593065df8318a34bb863dfd8171a923e065ae4a4970b692507d62de5b0ada58885aff9818a4310f9e7f1db79514002c1b08998d66c9d0a4c291b3deade237d3328ca4cf44ff77af04c4c0371638086171445560e55d09be8de58980dd3067e190edfd986024ccef1ba16b081520e34b0aa68f679e15b09c087c7c09ea13f19c8db1c232fa32d35b385e5784f68a7e7653c6e02c419440a0476d9d6df616093846af09d2eb3427bf2608d477da03b0003af2b84ce5aa3e63f60dfc9c73e25d1ce80c439a41dfae8070dd11b4d79ca92a5256c982675b4dee67489cd62ec67249276bcc2ded7ad19567df1346693974baaeab02cc2d6f58cbb932ac25a7639ce559c8b293f00060a23d25ddddcfbd047bd1d6be81bd1abe29059d3be4b0b1ad6719bd4d6d18759a7512b959e48ab6e81bae555411e887a040e1948ee0b1456a20267731355ba0334c8af05f0a9088b775f1dad2b2f5e3b3389b7491a1fe918e57f41506c7a04906b5f2b9fffb14776f09cd438428a898e914a9fc9030c843b450b57481b923a399b7e56bb2d3678270b4cf71463e7b81deb29a9be6167fbed8c55601eb45c287683da28e7cec239bc94d0d882c116e744954e52a8eb361407622993ceb65fd621f450dc793d3afd0fbf35504ebe1e2da9d81613893a0ee8f730da9c6589d75387b4327323f3279a2b977b6395e6d37d96c50a8ccd91cb9dcbfd069db2614ee0eff411cf88329d09ec59ed56fed9cdbe09f255d0e4e968ab9b49cb1a63a37548bb98a9e46ff578355fc300c40643079fbc1645f47bd04d4dd00d381ab33f63c2073c29f3935e67e174da98a407e5c7495903d06db0986d4154e6925ea3483af7c4ca724f04f4e0c133fa2713c1f97f2a314a9bd430d007c0b263c98c0ee4d707c2d213b800b246fc18efe16a71aba2453d633eadabf58ac6133d161ee91d0387a658d38066e0d72c6f32faf3b08b2a7b5e770fa289d1b7367a94b4c0768aa46b42384aa2add500d9dea2574ec0589382b9b8e7570784e87174fd8933965362f4075bc0241eae22734392ee73f5896486f7cfe0cff969289cd9bb0b4a2242c0a7c83ec7c1fc8fff3c63cc16dfa80825f730782e2bb6f1ed874e9b4a85e96dc89cdccf44364a15753e6b85badcf6e35c734614cafa3a3fdc695420bff75f6b9ac22671086d1174b555346f55b69aca4d897dfeca0debb55b408228c5caa534996321466ff21ba501eadd2aae6b1e26ce5adcec9d5746355e42fbee03fd43005b38571933ce27b5f0a14a7fcbf85e75c6c70d28b3c89b4564b4ea7581ee501a66dab7da8b11edca836470e3a7d77dff593c092f53ee4bba17310251c963303e357e7526bead209be6fc7c499e5df0ecdbbd9d338005bd4e03423af7ee328616a437ed20a6d37239f04efa9730bc201bccea85dfc119ef02f151b80612103b3bb3898cb6325f6a303514d73980bf31b65e0d485b8f50a61c424f14b9191210e1aba2b830b30835919681d8fb37873a23c44dc0944ed99699139ca09e39a3bcd9dc6ff6e5f810cb626b3312aa2a6f36b926212440a1f4abd9570b7cab2b70ab1ab6bfb3917a6c3dafeb80347833929e4af24d67572f3bc18a3a87d248f72b6dd8a3de743ec811645e1ca76b7e59a02555256a7b727ce947b596d13ee3e0fd7d5860cb8e203ebbce745a059d38166366fcb897da136854335deb54013112268504043b950e2eff73fbbb43db4e158c6f7e30cd0748c6e4bf3485a3050087adb34af055053b554ef47fece6c0c8982d8a114753f22c994f285c200f525a55e1c826d95ce91355d3d75d7f7e963bebff62dcc3e3f0704c5c92ade8bee86558f7766c9c2efc9275645fb152aa3e41c4b508b765e7720e071eb6ddc0f80c603c52d52ae71f13fd7db2ccc42726fb4e8c7a7f74708497e2a8a514b254139376c442977ed31f78e6f50dc4391657a9c61103a3d963112bea29d0e44c9189daf15883389fb0366a2b2a7abca7dbae1972936e47b997c60aea658631c03e73035a454285d40a6e563a5402af4a95f3b5657d9395d70be0076594679f0fa1fab417998df07d27db701ca90624995c30780cad75272dfbffcf4d5a966ad10eb58ec24c72c329018825349b8473c7e5fe1cf37e6d00b2aa36d0a63a6ef1aa6e22dd1b67b172d3b7380186e41be3327e386992395fa00ddc58f71148ff101ff16af374461682af8b1cde0b25a560c90bb9bec04f60f2ebbd1267848eead7dde1d285c587b7329747f4002b317567b4248a58bb0c9571cc7426736040a54792a727862bf7c4776a4e4fb64cf6d39a3ed2df096bf37192c15393b7d351fdb7a7bf53ea26b0354509bc7b4a29c6178f0e1c4936f5a11f2db3cc0748587e2dec3996a88f71c5f0e893368e73fa570646e4e6a925ed3b6ffb60f87cbb1102225646a2c3ef6ca5077318b421c5574ad890ef83a4342b01ccb6cf182099d8c86da15f94742e2af63ff44db52de09886a595dba2a762c8fd0e6756347a4326356baedde3be5666aa2187bff91cd006a861ee50c83e50d4dedff3b67bf807c6f46d91bc81712973a15e6204df20a4af85067508f157506c44082aba2bb106af159f6b7b7334f0cb03c2c41e1aec2fed32077843e8e9c7b09ec2aacbd298a82f8e6e167d0400a06ae967f5ab062ae68525a1357070d21cccf969522ed1e40aae19b640945b009006dab5efac58c8dd3717c7cb9331d3dfb3a648065dbb62e93f83619b5f92caf878ade6aff6c1dbe4479eca38ff866e7637c742cf20cae97fe53a9358c50ef026ff4b77b7a424aeac67fac0ea527f56bc0d848152ef4d60c99024ddf93c71e3b6fe35c4398b098ef1207e58394018b7405bfac05542800e9a42a6a6fec7e2035627645e07aef4f26874f698fd9199d06b8bec5be09b57f315b4db9a61a53dd721b1d9092f524ba518cfc332fd20192304d497b1392714a61826454fa33b6fd764f34b09fad067a9ba43f24e2948289e6a9602c6983545f26bb8b7dab9c98deb6ccfdf4a379db131a7eb7e7d2e4daa578e2b04d7af934b4372b1578850eb6fb75335fc4c073c49f6a953f3e933319ebeaa90eb8800704de13ea82a6c9231c7258c73ec60</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入查看密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>再见2019，你好2020！</title>
    <url>/%E5%86%8D%E8%A7%812019%EF%BC%8C%E4%BD%A0%E5%A5%BD2020%EF%BC%81/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b23d1bd3e2a32399121cc53d36a2f56c465875c667d9893f9fb9c42d049c32ac">d2d85511782da2007828d4bf9243cc92e0fde23c47234d060cecbf0f9bafc04a7abc700fee5812f7ca05d2b816083fc5ce7e5631bd6610a7f108384e48e8efc3f29efced5bb4fcd50bb9f9faffa61450b646a55ad9d3917a26c2a01c05c3095d5afa707dca749e009e8fd58838e172e7af821ad90dd53c00fb5e6970269b2296fc7fac92eca384ebbd635e870ef1963f706a93ba7f1254050f2c1bc7103a070aa4068aa69d3d5c97d83f37b2fae1b6ddcb548d1104ec8bf99180dd72ca99efeca255700cec57cc3b906610e5171188ff1db36eefe944802ba64eb1c73eae220d6d33fd4765c480ffb7dd63ddfa914b586bb8f7b6ce10ed7594232c2b2b0dc3533295c0733adef4b90fbfb2fb765d1094c1821b7a2990bbf9d56ab00485999964fefa78ea675ca119e06c056a686779368bfac28ccde3f96c484be7d460269debdac11667eac7e0565ea1f568f377c63c07b29ce1557b0ade2ba1728e16cd8553a1dd8ae2ee74065b0336361d213df15e43e17091087e489eebaf48e850a377a09a3d63dfa6319f1fefd8cdc8da2f96708376df8c7737ae8d497cd73cafebd013ceec73c7e82bec607abde334cb7b9ca293f53ca56a30bd910dc8e4feee61e4e6583ce3ed3a983f90b28c5b7abddc8a318273a6134354e214191041eb481225f69b42606d5f84dcf985d6c91a69366d900175e40a165ca27db9ef4d43ba9120b1ead896c5b84632d26b7912e9e834e657df0e64231c6006508110eef2e4942d61cd52790362b09d388ec02b0251c0b573de5198c2a8bf98ad820351687fa6bddefe184eab46df88bf06b98ff0711ee976ebdbc50ee72d53f8e1ed6887c720d73b0ffdd4298d8869c187398362a50f6a29a1471407705fe213c81fa3bb5c4381d48e4b83e50abf34ddcc0eae1cea59911c7f7cf580e6503cfc53313df62ab62f848d27ea307f4ebb7dda29ec5d7f574d6c8110fe4bd64a7088e12fe00c28cfaf12d233fada52cfd489144dfc697d659156871e61a1b79233f933f45debbd093286296198a56064207e24ce0caea0588a2f13c94fe5dd93eaffcd5555120eb4c4d6e6ffc561438fa61d830c89b960a7e33eaaa6469a7dee4e9df23b8fe80f4254b8e570c302635393289d1c7795c32be23a8031b859fffd2f9aa3751ee73a591978b1fe0815b61dd05186c7701f845f7023a87014ff81e3451f6da148f5872868ef793170c229a65c36ab52ffbe2009641d08a046da54cc4b33172a37c547d00fc4e0a3d947fecee455f38153cc749e53dd443063ce798104c339e38cd7a103e9217f0dc44930e0aadc3da66ba248d06c9543b9b196d7e48040d6121dda5bd8d065cb63571587df984befe3149fc5c8f44c72c2b4cd58898c8a420fa4720614ee26d3df9279f1bdeba8c196027f4dbdce72a84fa0e3f5a73deeaaa5930a53ce866cd2f666371e52008c07e8689a5a748820c8607272421178f8db5466c19f6ede9f1a4b918e82e0fb890c9ce49b443e1bbeef50b9f4a1ae6dc0abcfbb34b0aebf670a43da34a03e4bf4005227bf8b7580df32c28d4b9a2475c71929314a046ac03802a86df50651e1670518d6758caa5effbd93ff61fcd6c4f4345722ca501764f36c68d6c275b32e120017ba23d00dfada9093ddc52c93b78383ff5372888cf5747308f52384873883f9792d02bd27a85511c4a0eb6e4c117a4c355f577ee7f4224d8b44a3f46fb6d69ecd62399ce5fa63c78e4a2c6cd872266d40267fcff7c95eeaff0893dd2e0260189e78677ce17d8f9e4581f7ff38e04c9f11aa340ca0179e194929b6b80a0df7ce84cfbd3e0604d8cc3cc36f6ccdc3e64f7691aa3eec0d6fead16987dc38c98c1997c06ec227c72df9d54b285804f6eec82f0b7b9db10e603b06dfccb984658976f61ee5591a8e55f6c592eb41eceef558d7d9dcc11b0bddaaf5923344b5a45f85b74dbfbfe2d2896682a89c8f2ff53aba251476bfb36cb3e2a0ec57efe2cd8d25fe7139d0c0d5a5f5e2731cd0afe24d76a11fe6a4dd9f8fe40bc08ab003cd33351ed22eee2804b00efa48d5488ce52a54a2ec09f1dfa8a3779a16ad39b919af3cac6d5bd70179a5df3cb711f29e76505fdbb26f8cd73f979668b938599e0044a55f0e6529849d170cce274eab13b646f60967bc36d090c6a2200872f0a0ae5fea05be65ab80cc62ee9bef760cd4ab95a1365b821fd0e5750870997af92c573d354ec770b41f07cbf9aeab39b9d47df85dc581b6e17400d5a7d7bb6adf95963efda1950f678137d0a7283b370c64f4f60c2d4df8abb935a2a42c40366b3618f52cbe6b74da7d94cbe96a81c1b3744cda7774676fed3e6f2ee903153e75dbae005bee31aa5a34538376831dc2ddb98a399ea84bf3e6cda21764f27af3a23f877022776f08dd70e6b09c1fc7d8b37c5631833bc265f1a57261e9eac24ade260026f813588967efbbb5e9a606c608a3ae416356d73a35e77fd44a619d839c8e86a6d462097c5f9e39111087c3acef66560dad9841fa2cd79d48a3e03260efd9a24a4a4805af6ad1034702f14d71ab131258c7352579a96d7183bba38d257ecbbba8baa0a7a362fb1996d0d0c1bebdf168c2120f6a5eebb43df52452f0fc5b889e7e9d4042d8903073e898e941d5d72cf6d279001d3292de7ec6281d1550e7f999ded656a81ca912f5b244ac817ad7010882d10fa3444da56927467e0aa778549fc891c43e14514f4c38ccce95d7560d2de9baf540cd18b5e1271b1ae1252ce8b5ddb9409273918431075892282f77d23e2d9ed4a589438e93942d57bbc4ba1ecd0cd1647eaf3416771906fd7cab8aaffb09c020580c46eb2a94c4e761e08f8e385e92b20f5692941afb1ba11d40b7131f38e0f48f61db37ab7d8281084299af2169058481f4eda523d371b59a6670ce2ab0fbb2b03ffb367146021b2aec0c90daeab8793b208712ddf4d945c2e8e3a41c0a2656bd40147e6ae5b688fc84ce0007dbf04818cab8cdd41f57a28da624d0154c14fb134bc4f97133568c204f984670b814571af623c0b9b343a6e21a15b841f5b49540b934180af9b5e53d54e630e3d39df83e83a2ff6de0d78dfce5c91afee84ba2529aea3d1f0b289bffce6015e8246456b912338e7f8d25938bee48aaa2afa37a22bf6c4e092f91c2d26b68aa3590a8912acfc3b0416e676d8deacb6eab217ed3683f6d69818835b49269a0ff89069381378910450fbe2f445983a9431553f0789137ff320627ac8d9920141e7b3cd4b0bc10efc3a752fc3d98252dae10311a1ad890c443f25aaee41c54b3edda8c6dbe08d4965163a197787e8516707af8691350e18e1ebaada82a6b8bf5ac16c77d49f1772b3f14e88aa9bd21858ad06889becc7d5918b1844bf5dd9fcd0a5dc1fde4730ba2d908e4f4076d71866a9a306fbcbe546b1f8447718040e8ddb5def829f4ef4128934525ee5b66a9a562668dcf1e32d0276c05876eddff2a7faa39836b3455b9715f189bed4ad1bf4fc92d4d22e9a7aea1d13f905807a7507c51291628e660256060af79f6349de821b09efe12095a09c61303da93ec1cf0deaeeaddd6dffc7bce587039d3a8ccf04021b4907333964860ac168c5d24a2ed4fbdfe0392798b6e66554d0fee41e630081121c71aa149f50f0cf710d266987781d9af27f572196aa26727e7e846e4b768e5eba96aceb6d9d3159b6de1b3561e97251a8422160f37e3c6b1b333357bd47091527c5f2a1b8f4eb08834e3d7b3850d35c66e729252003129e0f9677a7b3a68dfae49cef48520734bcaf2614c2fb5aa059da7ded372cb5ebf3c05d9d88112ea8208deb01841645af84b9f6fef8910fd380d3565aa2f272dadce35dc3f19d969b130fb56b697c7f0c44dbaf6b8f9069ecd6e9d968b11540c30399d56ca18e368f759fc4ff4993db0704997414cef9ee1fd16fbcabc2fa8c806f4350a6746471f52d963111ac2b8e0395f3e99313ff99595b3fd4dc683d48da68f17e085bc21651ec111cb192e9d3c264080cb06d5d0f34298e9b969beb5efbe84ed3296a738459bfafdfec52e663d471db87c174a4c1bfae0a7da1219b7e931a9a2b510919ba7576e72b428b5f2d73be9987372e4a2acf8581ad667b68b264ccba38c268eadc11be2cbdca1731f0ac3b21020ed38539350dc29a081202b4086fd0e64dba23704fd54c962c2b81cb7158f9d027baf7b596e7ac5e0e35379d252ca57acb25d36e19e6d5d345420a4b350f39e06afc4d5f9f5cb28df0dbe2c3aec994bec1e21a1b0dfb4d56ce2cd0724de836b5f206ac46c592dbb0287c54edaf29ec5c24984d375f49d82aa688d31ff80b9de4a9ff5052d32ca39eebf1eebec4205024c62ed5fa21ed9ff4593838542232af562ec749247805252cae46e91ccb50111084e01010b29d5f26cf992467d919a97397ff0169b9b73dc094061a3351cd0e296fd6a4798655487871896f1ea90a29a7761ee1214ff9d48b7f960da3b5ff0cdf6b757b89aa7f75611ee802e40f9f6ecaaff32086b69f02252e4b7c552d63e70f033b1a292431ffeec89507723ad7fd241eff21b8e164bd523f2ad7a610cb634bb763d520b626261b6d928e06fa79def7cab7f7103abe58a06a97fd3366b9b7508b750b1410e423441000cef061aba4244ceb00b863ac5d8371e5919e3265a5a325d5d639c2c2224281ea80c23d59964e9cf81653ba30d4e85365b27b66c0623a534aee807a6a76c0b5ccea511149b22e40d943b0fa82ae6222b406c937c8fa37a179a12fed1e80fc8bf69164ecf2cc609c80e40e3434d0d0b1955dc69713405a5292f90712c19c09e6ca046780b1c8ea9195dd0112f75e570ea40dab47d943ffebb1b45a49b18dd84d06794e2616730f1afcc667ae8821fcb1bff692a05942b4fb8360859c4b10e275dfc11826c6b8bca78310de41ce529d053d8c4f5ea5628097500e94f222af4e5bf820840eb01caa17fdac37ef35e2702c04469231fd76dd18e38b9332972cbbb7a2b7f84c46fd0101e2757bbbb55c957dbffc95fcf3a528a5643aa3d1f02d9501dbb4027c2b8b25c3d689efa4f017e9c3d76f0457b4d854e478e2ca29fb87ac8c20180de9b50fde6f3151e71cd8ae635cd517f1c5424bdb376f19622b07f29c72d9237966d76fe243342f0a6c5ab851030e74e2bfd92c92637cb4bc1f7a441f81ed5abb086773e52661a2f8ddaf1e50439e94e8a520853cb91ec48319618b4e820735c695d2e98c04073ac60d5b622b4f5651adcd2f34611fedf58ecc8ce0267011e9a6efd74a0f350ac8c1c56e5e1a42128b69bb42f0f17ee932e218d24187a093ad6c0dae97b5b503e1f733588d5c5985b0d802d043e06ffee89c8d0d075f16e16d535fc679d350d6f2a9f12843e8a84a59881a5e10e9121bfe55d880066f7a84510c8571d0661a855e5d14b761b15b7ba1f7a41fa343e6a12cbe2676b2700f26a89fd96a5278f915069952b567c34a2a33e03cefb84f66112324715c01ebc7ad2b8d77ecba62c7b1515c2f3a6ddec739cea27f4ee1dcc75c1bb5b8a58332b0d8a5c3bfc0d738f485be74f6883f9058c28a6b100c081a90277e8e0dd8c1a1badab22e4bad9f245bf7c3cedd27464a3b4154b0f2e79fd135896cea74572adecac03eed37e91107d402dee9ca5f92990629d47b5ee628fb150b6f58ad65cc83e1f4b5a0f868e95902bac8cdec926385f1666d41e037d75da711f043a9d48977c81d16297fba2a8facec6f7db3bb71f8a08f0c52b9fc90d0ca41fab486bdd26b53b72bef3aabdc91fd602f820a0416f9e0c500ac87680a21ca2d5555771b2f87fd22a387abb9eb9336673470da280c71d75fe17f6e6226d4376fafb6a55df39e4bc04349777ab9a65f399b35cf14981d97003a6784966aa29c42cd26c799daffc614256a4df644c8777033b0ce752c425b0615fa300b350</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">这里需要密码才能访问。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>再见2021，你好2022！</title>
    <url>/%E5%86%8D%E8%A7%812021%EF%BC%8C%E4%BD%A0%E5%A5%BD2022%EF%BC%81/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码不对，请重试" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="dff4b644695e9a69abdf06dc47daf5306d57ff7a7620dab2884c3bb955e722da">d2d85511782da2007828d4bf9243cc92bcf798e72b8c748078cac6c90b0018c28845e4c5da17a85193b0f0855b9cee012bd49f40ac040a751c06b143178abbb19e368126e08076b522ea49bfe2e87acb5dc76a5ba054a68c03e7f7656eb8ed65f89953e66e2fab501bc0f10c2d525218d8e450b8faaa062fde805c4b63ba294cc6518d6b63f9864914be1f29c6b7cd20423a30068c3ea3259a2ca991a7cd1f70eac6adc31aa2c36e32b0584c9e76a79f6cce6f8f37d4de3d1a8e70bb42723d36e7368fc55a979be256b46e1237ccce0e695f8266eab8b3d5f17be591f56dcc3b37c381f8eac0f897d0c7ba94e808b88b3b346f46f57ab319299141fc2f034cf2e6aaa3ad4c13f9cd67bf2495de0a945050e41d9626a71dec143206b7d16f539ba1d3c64988ff7ef5270cb929fe3c681abfb2e86b7c561e661f51cf2f36a888cf9a6a2a4bc8db7164e74bf2367b15738d8c880f6491639d850ec9071dd9682da5102a603a983137a6441491a4d4b98bc1e1970bad05cfe657ded44a7599f9cbab95f06e5eace192d307a29c62b24a80158769609e423ea9089f9631515f3b2dd62d599e8a4eaf5fc698aee14501ad03a604d79dc37f66a03cd2bdc845277c3731889845471fce519981f00837514ccc293e168cd5534c5eb4c22482425abb7e0d963c2d62d183a0a1e0c4f080117b7711fd490c50c67196ff180a59144eb3522012680c27170ae5cb03d6c7af0312cb718dd3fca07cce7ab5e00523fe6cc555dde53564a8f3e24cd6e6b7bc1764d603892b32cd953d4535f6c37f60d7f9b17aebb714771394af2283c120faccf61d1be3ef2ea5ee870afbee6a0774612870f6bfe6754701475ad21d0c8067080b83085a62bf0107863da4a454c7b452404417920598350f4b9218e44c474f97ef1a58929075adb3b9492c6e2bd82fed106e52186c988422d93be37025a60b95d2526985291e5fb70e031dbefe4406c02055fc2bbddf15ed082d38d054fed8ddc589022d3ba6f1d57e9f7f0a90c9c0b8eacceb4a95e20efafd26ded57cb926d65d976a8db360e368605a0c032e84016db612ff47a3ba3a12c53d7d46d47dcefce76046926b5b656a6f43cf54b098174f65ef773d1f14ea39f4d6f1014d858cd98dc927d7bbb88493c3ddfcdcc1771b475c9681dfb8b8bf96f93076fa9d1dbc7efde93d8bb552f3d0ffafeee910b8dc9d93cf2e90472682819a21068a3ec65f996b315d9f5af3fe1a4e84c2654cee5bba3b204f14994adeda879bf2149092dc5efcdc6d46cd1a2099f39a7686c3fccf8845b361f471b199a172f7f2b76a001fb1022282f86abf0199e09ed1a6be60fd85770a78cf32fb9e265e6d481b94221a153386edc207a10d695eec58cc82a15f6a9f3586c0f3498974a06e944473f6f2662039c80b8c9846d593975ef04b7b03b5ce6380fa88c62fe506f4ea04e02759343b28072b9f9c8d27a672a06ff5981ef3f106ec09a134ee96d521d20bdefba3dd03628bd4af33a7223cb0ac5bf52b82a73b48e2dcda1571080df98771866f5b4a8989aa13c4ad372180128c29c3d2328039a4df78cdab749dc32c9f5bdd28c40ae19a86b74af356e87d0937634834ebcf61908664568b35786e84da989d5a84d379b22e83633b71226a4c77a22eb7b5c9eb61d588e2fd1c7f3e58174cd5a0ab38ae51022d864376e99f92284ac2e058f0fedfa1ae9959c67ce706c5761fb31bbe7731fe519f602eb35b98a031b26983e0335ddbeaad21d15e17fdd93aa8b08c6a76208072a14fc2ab39438d4b78ec82acc9bbf667c297f068a02cc0df545ceb20abf160c4c0581fd94e8a85dcc08f4c8b43a6e02fa83890b213c72abedcb3e8d83d3933e4c25f034ae1b0898413c537090b952c1fadbcf90e69e6ace7e90d938c6747488188826159669f9bbda18748ca07b8fadfc63fe1c9ebbf493bef0c3d73f0cb94da57ed2d8488a48ab14633d47355ca140932d32d4c41d02c5776c21705ff752ca7df633fe6b74684231d078ddb20a0d80423773348445ca79be31e23c7448ca01eed55923f38695e3bf818ab9a73c5f3521845504718b86de483e7448c7de492c7b99381e8ce413749cf818bedb8a7c3ec65d12c3d0ba07ffa0bbd22039500c2ca9855f972587abba7193675e9c172ae5537245d480a1f9bd1a835c28c137163c1e9af736f194a64c96649a482f5cdfb19351012ee22514f1fd1771242348356ce60c540b1bd9625b6278ebc8dd9f0bd858c3b915abb1c41268904d06d224fcef54be44898e6d00da2fb532d6d7e93f83e58f6ea2f1a604bac48266f20f98aaf01c38926f99dbbc68e3cf29cba7e6785b20f9b024602b06d5d2b209edc3c68d9e905dbc8da7319018753d825b53c4c385271e6888a0f348ec02812f0b420a5680c53f93ed0692850f6444c869be9239624147c8bdfca65281032952669c1f1519a964c35e0bea761c550126458b71c971b060fce35a7ef70b57d678c532e52c33f72b1900c3d975b277803ec0664becd0bf80193da107ec9991d402b9e3b1475514a920a38c8126f63b6cb06f414a44d00bc512a409274f3ddd79446b662772226de418d12e8ee6751bd571e29bc38d69f7e3ce9c98e5ca43fef520add5ab9147a1a8b80f9cd86206016609f0a4e54b7d63814182b350e76b341705850774970888fce641c6b67b6ac17d8e869ca94b14f7a5f5d17f3ead678b48067e41de36eabea65f466ae15662525c6bd8dacf2b90a139c9045956fce1a9c81e001f79efbdcb554ede1e5019871e949d09dead79342e5765e40476b79df496642e238c4f70d54867db375f1226963231ff02e7bd40c7e584549de0628f18cf70d24c42f835070118223c1d2d821dff6fe36ea463d84fdd6220e5a9ffe763f5c4a2282d6159896ac290611a66ffc0c7135de3ff6ca656f08d8e1ed9e05def727920cbbb563e93dca832f86f7552acd7f425e3a846be8d48d430df905341ed6fb8fb682a38542d5c24f6f7532a4c6ad3a0417ccad8fd95423bf54900e57e200e90e5da4fb655f3aec21e2cad45923f2e33aedd67576e6f950a03966c92be013375500a39a8a3d115e7b6e3d4b59fa44dd7d93076216d952c76440bad283c483f82496cc25fd7cc3ba387d8801b0d0a640d73e08730cec8bddd4b9b6850bd8560863dced314e8efc9e6e7916df17dfd7e93d70b282e6c423309ce56a77e41023c081717303598d13f660d20d5893f73d5b60f6c4969103a70c4d3f3d5e0360d8812e8d950cea7f52cd5e0f177c7efc1f0567ecba5246274989b17f3507fa07efe05835e5f53f5595121143e608a7d45fa06df49ef452ba28c8ae29cf958baa503959ec6bc278daa07d7b0354621d0fa7859deeb93aa76f93390e4b0a6a4a04ffb924d81e55e66759dbc57bee21224904a0bb2e3fdf8cfb1c8590bced14f0b0f10f124f25d74cd5ee2870452f3320afd7810b4b097bcbc5e2db1dd1ee09d6b37bc067ac9b714fc8a22d240129fff5dec7b0c23689aa1c4b7fd2cdadac37eefa73cd398809fb9ae71f05283e77617b85cf3fec486c9daf5394dbfd10f26509c43172e56977564494ce050c20faf749a1bffc63bb6c5f7129e1d8066ab5c8b691eb648a585cc3a067fb168162e2368352113a20c42f8ae1d9d9d7ffdba6c8a218950cd54ed0c3b08bab148e3783c3fe1a308bf81e480cb8cabc9581b57d04761cf5fef4bc9c771278710960694a0e7290ed560d2bbd49ecc0b9703e77bb43c575d686546abc22388778d08a7684adf7c74ce232576f4bdf68c99016bcdab83969f59a96c88b935da16b8001b6d5b24adfd5392b9d8c1ebf3acd426bd0252f45e5a220ec5e119730b42dfa0a1a535f168e604d662e3651f5ccad5282362f0c4f1a965a9f3922c508bd835f6e0892d04f313f5586d6f6d440d6c95d5c55696c89b5e15a9f20247c3b927c02126e85b4e2e38656583a6535a049b1905c7fdf7c79cb43b5fe40f73e056eb53c018f4bbf75324dbea07886ca7af1a2ab589d6ab998d5da0161354ab36656d7793448d7a95fa5193b585565af357c8721b398dd01b42dd1c8db049b2f3596d562a5b8530daee8517c2c7d80c6ac77ae1a513f77879ea81ccb494355d8c34042d2292e04273f5162809d754458b93662b905aa0e9d1363431c2b041c7fc57cdd59987cf4eff786fee4b111e29d5daeeca8c1b63a5dba36769e961ae0260da79341378e41ab2eb4a0d544d147406108109633039ef38724bca6a5b7d7bd86b7af0d3ec85c6b727160dd75b25c1afb177dcb59ae6a7e17a7a8f7b93fccd26a68b9dc1f6f32766d39d122405365d747994131f725c6e00f9450c59e482be37b08f3adcaae402226108907bd270891d9e81c7dd8d0cdfa55cb6ce49bf1c209d321ef559a58da5041c2d199738e316452a99c13d337714de06b7700a8c15c26a2f7d52e4dc5b54ccbccff462fa46ce8f21f80e309f3cd4a916044714955f63fb0b7769757d9b92387784ff13165ccaa6b019d7ded5ea8312e93b6a3882bed92c7a7d99b061e51f884b79e6b91424816924bd820ecf8f416fcc6ea94b2527615c6c1b9c3936b47b0191d6bab920f680e38b1b392ed653df59f2fb0c79059201e53f902c8741b02a2781adba88ccd6d1948ab9b7793645aac450b40cc93792026724c040f065572bf392e52bf9a1a077b5bf67193b388e49586ccbce4ce60f88cd883730da18cb6d1ea9d2e61bf1f927c1f1c35c2d185201bbcd02e69cc1daa99e804168a5a81b21d1c2393c9cf79ca8b55c0ef7c29b6f9deb35cc778ab55e95b6a89bc7076b3f29825530b0f7d10d079cb79a1899c999cb1e1295aa325ca59b014ad2412f21c39695a8dc768d1c66144b53881d6adb7c788ec1fc5217090ba3e84b10e00edf32cc1abd29a306059021bb091ec8b21275b8c8c2294d8e23385bf5341757afab830514e684bc2b056d777d128ade4df44535f5d2447da0772be3c56b750814948ffc0aeb173cd5ee0efd668d8c462dbae36f09197f56fa090dafbaefc98ed1a0a5aa02abb61c79fb5746baa00a1db3aaa32a2cbf95c29776eec9d4fd8892259ed0ccafa5cc6c316261a870e626e3befeff6a1d1116d18ad7c6c351f0d6e430d3d2e2eefcfe42694805bbda704045aae944929ceb2df57f441579d26cbf0d0a8b9af9ab43c9e648c57bc3a1001257ee649169be3b8f6760c93c057baf9656f23dd9c2b8e81450044f3a8bd6826bbdb14ca78abd76ef84aa135eb448b22bc84ff04f7d0d729365c5f237e49f3535af11508fc219d935cae6a4c4d7a5c4d180ed72adc4a09afb7e8b4fe08c969e72991a84c6b8a43462da6e91213fde148f0a0276a523b33c48fb6a8be96594c4e5d1a8477b9878b142327947259db9dc6290dd547bc0af5a9d4a38a9ed6ef7bf3cb035b988df42ed169b1416fe73994e488897c8a8f411062f972ca4ffdf2c5c52d666adc001e21bfe1ab9228b0e3003ca71286744739a856ff762dd539cdb37506f4f7ec3ba9e6bbdd382360cdb4d2b64d35ba3009b6aa4c1c96c330938e61648c5e680fb2768966e1d08f1c77560d7de9dcb857b68b85c72e7868b7b1818776981ff5846aab494b62c7f4a808e429df9d23ccd9cce511d12f6cf425cb3fac31b97f5613d397167686fb43757ba248dd6b831f2a9584add0d735a20f63ab266b5dca19e43602f72b9e8cfee5e488d34e3180ddf30a5f4d851baad408dc4d98144c66eece07d88350db1c9152a938c9bf20ef4adc2c6b37709d20370603b890bba6c6fce266fb387c2422eb58986580b448bf1838a17fa2de2b02ff2200045e89af818c29bedfd8bc6dfe652d192891fbb35db9da66049b6aaaa8ed0114cdc3e7e55c18d3603a749374caf93a614fa11321eef778c8e7fe40cd870b576b705fcdd93a77c1b7257b8fd15635e12f17c338f3faf6fd030c98155e44703dc0886cc6441228aa01799ec74274011c9f7b910375e38ce59c8afacf044c70da837b850b9dbba1dee515a66f1c338b1e08cbe4e4abb2c04d972309e6d88314da9b0c346cf65ced054f9ba3d491dfaf0dca2b5803bc678bdf659bbd2768dc3d5034a9492837cbc4ca3137267fa5b7adc3cf922ff76ab5180caf9b01dead5b754e7755ccd4eda5c4c488b3da5e7eb4ab961175c90804112fc6aa2ff89aacee82bdc1d537bfd515cd2d85894fc011facc48730476b53410a2b40c1f7eec28cbb08cef93662c88468f2cb41f42f76e3cb6ba85c4213bf0694cf28c7a8fd6a7e3cf460373da9aac862fe45fd13218e70e3074c062fe919a3b57190e1417dcfb95fa0b8b24136863c24ec59c568167addb5384dd6533200d791e4a0273b14eaffcd9461c18743979a7bbd5f0c20fe7a047cbb10066dc911cdaba82e9dfbf50b62aeb0cb089a7be35f8f71dcd5c7d1e781c6e9e7fa919c301082ec7516a7c65a1089f5fdaa91c35b696d140df1c63ba2f5260502a98bc21af7d56530b2dbed1f85e86e07a2c3df082603188df281d4a0008d10114a19bd95725a0934ff6bb089fe7530695a0173817bc61b23451bf663986f5bb3b72285ecb2011b7aa0bdf92dc615301d3e86f55de10de3d5a7690f7d30fd87f2f152236b7e3d51770ac1f9bf48594b48ef44f6a5549f137a62dfb98e7b09e7d8ea91990df8c98ff5f9fbd51c23ec1c5afb6d59a0a228d97656ab5734a5b8f6e29060dec9bb4dfe615bd1e2c13c3866f952b9132e5cd5d6c5b33909af4d1df589f356e768ddfa1220f0d07ec91ac915b4584dbb00ccfcebf1fda9d201c5782b4312a8f7553b67e3659780c871e4e425f179e8768932469b7d650e8d4f7221738a0e59a2cece5e5b8f8f83091aa1d191feec870ad70c9f2230bc82b2cfd5c75ef9ecaf63df0b4b438e12278cdb0f0b12a93290224f07ba5478a941fd0fd36c770c0326d96d8dec76772c559d9582cee65351bf0bba342cc1dde7e4724bc1cb85f4426b448c329dd89d80e284bb8196fc2ec6a3debdea0684a67c62da47062b10c7bf7cc39c838d8503bbf179dd8fc9883e162390c4d8976e03bc319785777c3b0e205c84e40ca521ca4c17998f7792e8310b3bd898375b2ae4dc0cbb62fcc576dea4097299b2f2d66e0e6060d0e8007f5f974b3e74ac4dd2174b15ab756c9420e06a63cfaa064d1c724aff35d205b77ba0d00a9202be83dee26adc68aa9792ccb875ef8aa866899db3796a37504a26118e2a33c24e8c2386234ffa2ed0e9a7d9148aac5db27e7fde67f90b47b04eb2420d76f24181b4469570853d8675c1a0ce8bcce7136e01ac3c91018e1919dc1e7d01f035fee9a03c132f3cd9a295819724198a655bce16daab2a80706b63590b0386080d32182ace923e76303bd2252ff4952aa971aac30d96cb724193e266341e7e5a8ca80f1cc1869749d5ab3a90905ea9ed4bf0d7c83e75496b36af938dcbb5c97101286441e564033d220afc6bcb1b10d902c2d4e24487c1c962b24407f55a1a31a9393fd160eb7eb9f6fa753799e00bdce4d015bfed254479e94222d4c60dfd50d0fba3729f01a0ae8ebf6be56feb0d70e4e518c2220597e4d6624a7b1d30834254c96b33f21015e7c923ccba53955f79f5f8000ceca1563763c7e455cbb8690a0222585980d9fef10162170b902ba580c0b42c81676cbb4bd9a5cd694077da6b449259526728bb7e327f119fc78f592e396bab0bff6009e8d6f9a118f9c9516c87557</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入查看密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>再见2023，你好2024！</title>
    <url>/%E5%86%8D%E8%A7%812023%EF%BC%8C%E4%BD%A0%E5%A5%BD2024%EF%BC%81/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码不对，请重试" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b34a4b09cc80fba1d2d716e52e429920dc48b1153175d6b7259fc3d1de8ec88f">d2d85511782da2007828d4bf9243cc92bcf798e72b8c748078cac6c90b0018c24c8672940759e71abbf468449d799424e9857571a3a88626537314cd7921c94ecccd788018618e34d97849c56d661ca4ccb6dba474999383f65f7aec0a246977df30eabd8c250ebd6b535db3b6ea0dd52f7677705489c10ab40c4e2b5b8aa38e1cd422e6ce028ef9826b201968d477eb323fb8655975c3708cfc9f0b58a289b25f1be18dfac54b1e563bc40bba61f7b39a81887414656ef39848af03d582729a114289c91fa50264c528442c5004d6f03346f0f8493a0331bdb1b492814ff928e2dbe26f910c096a8e3b90b1da66f2ad69802d7940548bbbfe38e5e9ca52001e8807bdfdea0b7355a0f094aa5398a52153451c1422ea9ab44501b482f2d01523703b3be6a473ac271f4c55514f65105fde426043fbc0ed670a9797e5aac59aa47bf934ff850eaee62b55fab7ff9c7ffa21bdbcd0ea7f24e668b8ea68d7a880b68ba47bde4e4fd7495e427555805fdf4b57972c37b9c8e7e66301ed35e4887eac323dbd1ad43f446b0ad0d2d8686eb0fa410d75f29f5036f6608ceeb035ef83b1b64c01e2179c5cdd17c3dd312f361b77cb77a6b711c9896fadabd473f68390ae0ac5f0dac2b3356ceb09a9922408f61394f67233b1364bde0293504f90ab6b7ef325b9aa911b856fa2ab47f34d2e65720862b4868fe3476e1a75e692520acc0a3925d20206a9b44427f3f5acfa95c84ae54e84c27a64cd172eb9e86d623ffc626b32a08c7807ea6089f4e6ec6e305de9bb02b460320f6f5380dc7d6c38fbb66c5298b117514759668c1950fcbaa010ab3bca64cfbc2566f8036230df4e01c4927d7f55e8ccf55d6bd3bcdb01ca032f1cd5a9e7832bc3a197def32f8630e65c2e2c81252802daf39179b56887645c614dcb2377006c311751b42d3ee630e98edb5ed80fbbbda4446a131d6b7ee12f414efc2d452f2fa3b873d275762d0d4bb685cba84282d3862c8990a4a8e7caca2fa2c60e334931604c9873230a1e5ddab3a3c2e25a69826ed00ba6fd92191e4fe512bc33f8d3ec39b737c35c9e4d469a4c6594594348a7fb194125ba77180f027318fcb6ca78da346b7630b399d028e51edcc208b6f9330e530dbb16cd582204788b44227e3a33ab0a6d90537d0ac2f3455d73375bf620d3a02d5358e0fac56c9e7aa1d1d2d471d82138b383191b9b25b06084f297ca1cba4279000168f94bd6fc7e934b31ff82c95f6abde4dd4d8e3765855376e763fe0d003d9942f160554ee5e4f6c7567474c845348dbad00f27cf6a9e0ad563a5713af09816025356e9e29b3190ce7e936892cf045fc636aef40923cedc441a4cebe6fa4c688474cb7bbaf4dc9140f27b15aada13bf3b075bd623738c299133c2a7e26f0459abcf83b0603317f2b5ca54522f97c79ef36f93d37e184f19203c269e0ecd21e15a079a24064a1c009d4483518faddb2ed110fe68de7f40ddbce56737de835a4ddd58fb8697828a7f55260b498e58876eb9d3c7ef2690929f22b49b618a06f186a1bc1f0e57c2311aa8940ae2ba3ec92430893c9f17e4e6ab3f1449987257710da777c6d778196b9eeb1bc5260af81c28b655f44d0a8336a2fe0fc5077c74be97e09c944f93b8e72994c445c47cda797001e4147e08d666f5f85a37667f79b87d9eddc47773d705dda3222255480c85085a75280dbf8ca0181a71c06e6ab691d10a68fd3c80be11241f303cab6256f94354fcbbbf88ab417f64b8d193476df9179146b606e233458e4ba93ce0c5c061850bab1cbcbcb5359d4df8cbe5f2274c5e00f366e47e161c5e73c67eff4778cd883ce71ca9d4721631c4849ec4311e1651259049c7cb7f08e8fe8431b7ac25d34a6c5d862035e3e876b13236b63472fc71c0dac0ed6dd352344e801636ba18c5c5fbbeccff367ba1a08c62ea203d4b83fba09d1c3dc176154e333ca3d093781151f88f3a35dd7b043587137500899853128d2f642ebffa27be4d4c6907b8e7b01071030322fa8718921218d8ba3b3f00738864803bd6753cd2e4fa1bec15e9741c43d08c5fd816cc6d9f8beea6a039504c10c88646ff8627dc928b7443266c69938949b36f0cbec842cae7b0329ff67b859d4e484deaf9bd224a047b1b58276b035fe01a95742b438f5477800ad8f7383a3b8a525844dc08ba4b2580dd1deadd6c5a664b4784b81ae03c80a04418da5dbcd92b534ce99dcff0ea0c25b23bb495828b9e08ff6a1da0ee2c057107105777eb5d751a0b1b9cc541c03cc2c0eaabe4f9f5be2712f9df5a2002b0344be432eccf654d2e6de8494f608b4f4fe129a8d116d8b03be57611d30a5a7eda10a6aeb6f46a0a629ec869ac86045d97ec650038be74af7dbb96b26ea3b2f66ad4b2d6a40e70c609a8478b81126df475f1989737b0ea805f7a56aa8e494e27bd7ac7af37a66c3bdbae14a99ad6fbd12114fb3300cd8e77168431d82affeef1b6e2d39686095ab46b8797179681852497c18813127f46258712471da8ee61d97663d4284d2ad4596e5191d202f4bc757281e13f1c796c64839f7b70e6089676452ff9003d7288655d617eab0f11d4e6c39c01370c7e42516f8402f5dcdc349cc7df1b08ee4b6a27f44255ed1802cffa0c050e00e3a44fe0172428f55ca4d12b117d3a7f75694e70267fe4d8045de6371e164b1d17f5faa751fd6fcecc667410b80d0f4cebd18658fd7b650cd99cd1cfb2ebe547b1bce6dcd59b5e265a3baad20da1268ccf46dae0d6e0c0a5fc04289865540d76ed6861dde1dbe43dcc4ccf6bd9a254016c1902e63ccb1b3590750ca56d596aa824f8641e56522387c0c1c45eadb4bcebfb2ce24702f8cf68ce54641697e67406f6f1e84362363fb26be0f171d24b9a984922de7a5b3b705c9225d73ef4fa7c1e500308bdf7bf9de799bb8ebb424918c5600870beb446034c62eddd537d84e1018e174ba833fdcf532c009109f1014a70f554e88ff97d840762481e972a3890319e9d1fed47961d632f78f5e26f9861bba37a037983abe19684befd830d70ff91d6e73b0b07da66c8ec6634866af6b7a5dc412f8bf25f08265ac20f0ae8ad9434e4526c3d0334de1ed668b2fbd6742bfba47f326b4ab9cc44b9f420f4106339b073958042250e5f9cf75893523b97cef932c09eb50c5cd194a9901af505cb62af3882c2dbd0a5b6883185bd14968780c4d5b2f9f7719c294157e263c17bcac997e0743f6ae642f0374598a8bc727438c71645d656b4fca37e2b50230aee4c3c176cd9a62729fe56f10056777343aa77934abaf4316535d706ae44f18a89c4e69be654eecba4acb386c0c799638152fd5c56f181cdd03d9762b635cbd7c759b1b970882d70ea39d27156952561cf3dc16452ec73ac651618e0ee3584ced8bb411d175795c9de1c613e5b36069685aa70c925a2d7d5fb5869509a1c41fc0cdbdba105540e8f015b22c0faa0f7e1acafa69f7cd89d32e349769e4e8b2c83e3d7cc365f294377b9d04b14076e9c49e11faadf2310190a590e98e7391818f9b3dd059383d02bee987625448e18a1930dbc9327fba8147cd7eb7b5e3c3f029f141a400dccf85c333f7a8c085669e56ba4ab920cdc72dda87c815247f30a2a7e4e74895934751a2130615d2741c1fb7bfa9c9bb5bdc2dbec314e5fb161a2bc82a6b4e801b7bafb35ac500e67c26022fbc774bcfde21417ff78e3965d4af37bf1738255dc6b221662c56138ba212d4e32146bd64165eb51ed8a8234670374dd4a55b2ff589eeebead5f23dfee7ce697b428798f3de5c4ef2560f4436e80ac5612aa215ad4881bf2487c6ada0b011900f105b571f964f811eb2926ffb2a01bddce538c1ae30d04afda018fa1dbab6ecf61486a23ed37a38e4fff810cf1a139293b85d9fbd0319aef4483d2b58c9cb554d76b076834011f210cbfef7acb1e247c3aa3a639d4533155f0c58592cfebdf4cfdaf565c4e2fbda5f6ddcb01ae7c5249c3dfd536fa1063718861c6f9004443241448fb7e974b213e7b2b7828a9060a08573c311958b577a386940341381381a96cc1fdc3aea1aa88e7c0b60021ce65d264bcc74ccb3cd2ad8135cca56baaef1114938828deacdc229674538064af307b64b5b8525e4c911cfddf3b47f7467fea0e72b531cb8fff1319dfeffb256163cba26bb77282332a2e93f9002edb1bb721eb1f810f0d0752e034173831c1bbbf0f7435a630f509df1e9742ccbcc0070b3ba865fd36ae11d673bed484031eb26ffdeaea8a6ee847dbdfd4796e41726a728475f271fd820c3ceb3e8a98878894aec2de51a8dcd6a465dcc01ea5b75b5bb8598ec5b0377d06f79780c35f0ea42c98dca569021b6d675fd60569995f588e5b43bc4273cda32efed87a8db230360906d1ba43c752366b43ac5ba23ebd2a9c6668bfe6ed48f00c7c867634a7e203fed05f0c55e5b1c17a4890b85ef881e10b81779fc6053f2cd19333f55aefd63f6621249d418f2771e14d54a0eaadc2eb73d767727fa77331d14570014a1a5448ce6a9712c943268cf2d621164554061db35863195fd1260e808b83f4637abff8801082656ebcd45d4a51b5771c90ef36fcbf73aa145385792e97e3d5b6165302fd7f5814fa80479775a0015f1462d1219ebf23b096092dabc62e7270e724121afb3c44be391770e5d730bd2f64d577198837e71f9cd33c398aac7f6f968848c1d614eab31bd4a8b1e55f64b25338d88490dc0f6765271eb3bc18f91600368497dd356d0a801694e899833468cb42990d28b9944cdeefdc3999f53590e31568fa83efd97ff2fe921aa749b5e15a9f3ecea78f30e4cb2d0371069570a16bb321638ea7652e0e082b8bea2ab882242fd7212b68f72b34e990b01be387fb9aec3cab16c8d1af1272e8cd3042a89547e0e2d1fe6d93001cb7d222669be0409112a160a97b7fdf3602cf3b69eace357a27ce57d2b4332648e071c79704a3dc3243a2624636f3ae4c1e627baea0ab5ab561de09b9295d375b7cdf7835bd3b248f64667076069cd1df607d6c31f7375677105921bab4f754838c863dd71304f80d07f397dab31964d535c1cd2cc802bbf266182223ede67ced223536e862890365e869cafb024f9bf2bb2eed7f65422f2aab7f01d5bb3f92fc87c12a5e6c8b1994916dc0f4dcb76e2f1205796d8ae4f5833907d8f6981452395374e5392de3f74d8058e68ba4d95a10146aff835e20d14a138bffc76cab8d1de756dd24a6e57e132d513a1f5ebad2c0f01b1fae120110cc777a556a1a196209fc6141ce627fcd2fd8b2d7ff4d4cc8b04cf6b48515426967ff8314539b67ecc1ff75d13d75d9e085f127dcd6b18b49ac63320383d319a791f9c4f8762893cacf19bd9fc849716a3a626498a6c3f6f4ed070175f53612ca2b052ce9d76d781d56aeb4bf71695345193de8a8b0642c6833510df376e1f30481bf1db15bcb8b030a25d80d804a50d05d3f411f9e9211a84bff59db2f4d35df879d24a0e2cbd0ed73b85eb3e8569358608895f03d5fdaa7d347687cda4ddb30c61cb381d17fe64354070efa09388a5358d00b36e294834badf332e058e3eccfa6e939a54b50135dcd0406301e6567d724807ba6daec055f41cf378bf634e77776b3bcfbaa18ff025a0c0b486e1794461fbf4dbe8d8573313a9dc1b9dac140fefa9b095f02d982cfee6154cd5453f73d88fa7ce14caf764387c286cd03b366edea06fbd8af9c35bdb10238f73e6ddebe60a317ececc1a0154b21973bd44c964a4286f34c8b97dc0501816f46bf8b8857f2f03e75f2c899c2af9275999fbcf17f5703f5686f45de6ea1932034ff956f39e684a84a5fc5c458f29534d9a495d750975acbaeaa06d87dcf537bb7f13813652f9a6e11744a1c616d83212509ab00fa5703397d6c372fcce8a64481811ea9936a056f079a7067784fa33d19f9f80f70f5ab4c1c6a32786c216fab4b1ffd293e4ba8585d8e4df0322c99eab306802e3231f3aaa3f37245b443f1b87659f9c5dc0b029b3ecf4ef467d1b3eb7926bb70f976593b29ec030b1b33186a5ab9d3ed97f7d70b32e6cbf601430b5e2865f5cb27d2a7ff23236a9c444a224293c2bc51f07c85ad133bfaea7cfd184c9cc249120fbb60e26599518faecadaea2660a763d44f335c39fd3457b63c67958f4980d7aa218e63085e6cf06e555d8ed56d0afa4233e41ade04623dd64e1b629d987c4c96736060b44404d6130500d07e5d64cd4f41483929ffd0b6c1cdf38f3e16aea80a50b0e7ecfbebfb1b2181b4a6e5a1481c01c0e0b6a8a33338439833f7d1cf136a4b003047e0bb9bb0386879684ba18eb6b7a119b1324944bd572242f9f85c78c77e666382f0411ae77d3de64e9c84d92f39c5357f94ab9026db27c97b273432edc4e4d29b943533a8393098622421c564332143bf6866b727fa0f9a9751444a04befe796628af7e6d039f34f5d9e558b8adb23d3f60ea1abda15a8f52f3dea1dea287884223a9040dbd18b754ea21c6423163bcc1dbe064d058ddf9d80e122d9f0a34d10dc6a5e9a698c4c133c83eeb0d0bff40cb0a8231d54e654a7f0db6254f0102542f3564a08c22e80cc4da1f9ae8efbab4a5e534d473b899f9e5bdc1c2df0876643cdb175f313a0e3455925685aa4428478afdd0cf553db435d17731f048f6b6922632f174c21e494667d258836652c86879a2a659d8cafa50fb2cabe60c560cb83f3ebaa95de1b178629b9e85e80a57d7bfb17b06868ceab516c52f43f8b2abacdf941a4bb7b87dcea8275da45c6c8f9015a393619a6b71d8320c627ab5ae87a15ce0</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入查看密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>创建博客带给我的思考</title>
    <url>/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B8%A6%E7%BB%99%E6%88%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码不对，请重试" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="d6fd8380609646b58c004a94d99ad53a4abeb888a360cd227069ca9f2947e14f">d2d85511782da2007828d4bf9243cc92bcf798e72b8c748078cac6c90b0018c2c9bf3cca5021d670675dee53bba2e9d980b49dbdab50bfb719c17ec428850c9247edfa109119a192d98cfd2c39991c9c87a2c1b88abd72d7599edfe10d99219e1cb1df167f15305aa45b238a18177287a326d9906ae6b5382ae7473d8b37a8801d799cf046db1c0348a10afc068fcb65ae457fbe682ebb0c51cdfa3c25ca7c4848041a2e9094dac240d05fa00d2ffa1b6e24e8d8640b1a646c2a78c5d4a2fe177a1b39bbe884667ba00232a3fede6c8c2f23b3c2d753e7a418785b49b50e9f62d164b1c329fc73b74060e2787df8f935ccbc7bb5214d16851175735312d7e91e1f8c908c466315238f14f38b17cb3f7b8d1054ec6479f0b0e35d49360c344dd47de2e843efc91f8cc1a58c878a5dacd9a664ab07204c66172ae7b779eee1cf6962eb2e7b6e2ce3cc3ef6e5ca33d669e029efd15636d7a9c3623a6f4b96ce70fae64095c287f97344dfad711bf09a74ea67b2baf7c9ae012b80482d27f330fda2287b782f6c7ecf1d7ca6e69499e4d379eeb2ba67a29557259a0ae2ffa50342c202787cc8ebec59fabdd375624a9a91843d7283b40da8333a4bc45b571daa6ab506ab72e8045bfdd225787fb361020d3d1bc758a640a10b21aacd34270829d79e755caec0c9bc20d754cb06d8790dbf8738df1f3e21c9d5393cfeeae279224782f7e87d9ce96b9b65a0cbeb9ccff74c2f1649ee5f90b82dc9845c92cb28fce32e9954eec126d219ee68e9ea35fd2e1b8008d86b0fc1fcdaae4587698983ea1c66825acde5b76f7dd617964c07277f7dae0e0826328a5cc9ac676e03e3af8235a06f027ea669eb5a7b97a9bdca97d185a30cc16c8cb83f360cab9516ceb3e68a8b5b1133d2049c6dbb9562c4bbdbc926f1d1b95589055d48fd9b22eb67fd800bd5b2b249f90205437673a07c60e91658088b34f825f15a1f99ae4cfa6ee610ba83901659cc291ee8225621e61ea3e096a018b7f9cb59f689cbab2baaf421e1305d9a9ba68782b78850863fdcd40720c56f38b0d7fdd99ea0ebc34c517c22ffdea6e566d4668bfef83a6879961952875eb72ade5e34e01384c03b18fbc03a7baaed7c92d1fb96981f1ec1038027be8867840853c9ba2a711541897f6188158eced397a4788fc5db02240f0cf5a45dd343671abd457c13c4c19c78e8550a2744ed867d0e8514cfd7f75ad5117b63b9019d971d8e555af5036408054fbdaae2c9340ad5fff7bf5f62f89d196fdb00ccb12087e595262585dc1893f402f34da9a3e7c7205d829ead6f68bf99aee8c400fd061bbabe7e3eb780bfa0b91310a7aa36c745e6c25791b91e616674ec41be17997e9818aaa7a43968b8ee285a437dd790a70211d4e881fee2220c67599910d0672706b7e2176279dd832841d569bb61ee8dd94f76a3ec5af8d95c7d1852b2408ce36d15a3457f67de8c115f9874cb3c6df7d4b9780c64344991a778ad07f32cf196d00caddc83482895c8eb62bc015ab2ae410c630e24a90b84aa3cceb449926e1f54f73c8e2f846912ff7fc30579fdba74c81aaea89fd52f29d3dd329902f180b3328381c5dc1fdf491a037b10977ea58a453c16f9a3bda6a5155032e40a7a75efdb235a844f5eb439832c4b9535a473c029181e186b8ade1e06144521e82a135533e7f5c7401c55a35d957e5eecacec26c2a0d54dba860abcf0a44c345ba5581f7eb5b8cd0bf185cdcada4825607bfbb65a289c56545c7b5ff15379025e1cd08e2c132dac1b703fe39ff10cab49aec6708bc8c4fb217fe64187cf3b0efa00ac7097adbe3543836f5ae389f340f36a6537a1212d391a11cf1abb470dfcde2c5d18267daffbd3558db9a83752ad956bb6c95c2c048072f3d1f44ea74266da3fc78c3dfee638df54399ed59f4a105452a1df5e94f80ff362d562c3ace7e1a9940be062adb1e7ea205e4625d2a61bd841cd58e9014cfbad0a73207f599e9603fb7062a516a9ba19bc49c3b2ed23bad43708314bc97b48137228d39ba0d556c4ad65d34872e9d2244cde7e77c32551769a7d14311fe6df8dcf335e15eb3e4407b38b4cd22e4c374ebcbbdc6ab4a9354b1a03769de6d6af82c1e841b7c4b831c6cd197b8304ddd7e54a5d9d2833cec684de7944a0cdfa15aab83e71f816e36f6e8f32fba1a19665fb490a12aa3432cefd7a66049806a8e3546d25660bd5335d2a1ed34420d2249f97b6dbb8291385774880630d15b3452856bae839977744c2db7baebf3d3f9f1d9055fc5d5acde77e7abfb629a8af640742946a4af65c5bbe473c3f134515dec206aa55721bfec2280f5afaf7af204203680317a5b72571ae15ce9803464ad5e9e083658a9f9463acc9d615f3005de974066dc815d481d13cafe33c61e9b0780766889a5475e071c692dbee44fdae6340c74131ae5de7ce0cc3c139288ac9e693c2a733c7b5bc7e3bc3918c44aa60ce7d595a2db3375b2b9c496732626a7d8f31cf073d9b7e3a583fcfbcbb9f8b81ff8c26bfb6d71eb720c48ca1a8b461b199e022344cff234c1eccd353ac7cd4db23ac16783530536c533f7aeede3f7decbaa29ef3b771bc49dd118d1e204fded7fa605a528568bdf60a0979b5263625dddfa944935823c0d28538a5e3bda6c3b0de5875e350bae7c3f43e5ca8f9693732a39353b8d8a3a6aa96f9ee63ef197e5dab3c98ad788dd72e3482c7c7c4177e17a72ba7548be08ebfc785e5ed5c7f95025b40fb2d360996bccaa5ad9ad2bb2e41ebb26070fdf587c27fb4f92950cffa55fc10ed6e4f3e3a8569b2f6d14c034047b45997de4c21e2f9cf782fc555fa590c266e1031c9d8c909ca464e4ad4613da2af829fb2af0fe4723347fbf4e93e9dd9a0bf58743743f788106e23f22560998c37a93c9da2c8f6fd6b6b1eed375822a3e9bee693a1c8f5d3599b1b0970d1af0d6ac24624758eaaeac3fb821b7989796c5c2b2a548e729ac1a709e1ee3217248b948634164bc15063f00492ded984c190971468b83553e09bb47e5250fcf47b902c8f8b423d50659a7195488a1ed7983a55b74f67bab80cb82e9f916172444c22ef8d1ef66b58e5d83b44729ecce74c218bf5d250ddaffcc31a721aa2ae3a489d957bcb2bca5f15b8f3b2da57988f45c62c640232c863e8220386045144e01e0f15b5614c32830e7228037dafce613e2737411851a49d3082461c35485c91180c6609eea8fa9b679d3ebfdc969a77530397b14a8efd81fa38af38e0cf8b18d233379a39f36419688df0310b6c30e5d863f211e5834bcbbb11e7cc75911d4263d217cad712fde93d94377634426c461bfcf2f56fbc8447b27e1130a0ddd0a734dc5c2d04e20ac5541937d060bc6389636c911816a38e7b08c7fdf49773c6797b1e2c3987b467d44d69820ae8bcb72a79cf14c469a56e9cccd65b762df6fc16f811a27b78b363667aded0a4e5d28620651a0b34e77e19733fc57841b90660436a51ddfaef2b67462d0c1fa2c400fae01f14bf8d2ba76b3a3343c2e447c8d0fb2c814ba8582296e028b6f3889f5a93dfba0245f0bb07ce290c59c4b0bd85c21c0b1555869afc68b9b5058a88a991466262e06025b50698772579ec6c5904095487a89c5b6a1e41812d4bf07706eac26ab1d814da7004370c4ad6d24627598b5db8d3d61b168bf126e72bc0d833522981eb21c1641f2a608df7fdd45dc03c51be3d253e1c560fab0dc133e127ece24351e20bc3037dc8876934ec067127245589723f0a5325f223611f71f58a90fc6973acbdde090f569950d9e6a27309a40d4254ab916ae115cf61f0dbc533e07517dfddf525a8edc78385f5e67fa46e09ba80d140b21b38077ad6465444335a715b62987189245bb4376bb54b55ae64f2e8defe2b219ec76428ce1985bc08a031a95904ce0c67544f55ec11b35039e7631c57441623156ce47c6636228607f0478295b0699661d2f88bf83ebb5a65c751a47311eda57bd311e2536faebb56804c464c244a3331e1c5d1b6fb9a238a380aded8e4ca8b41845870b1d95bc05dd06dece1778fc8ce76f44ee54e2047ea81c77172c40bd24fed0ed3e5ac9834ecd003f463fd9d4a64014b02b878d1db9a86a83434f00afb2d0781a330f055400ff05d6ee6e46bb1e88e3fa2627ebbd3359c49108d98b66c881b13b97ae2f3329b6e112ef81b05df8ca7c11d9acfe5656aa92f7e7a1a48289d9eb2411a62fe648f4bc59b2bb2f438f261bc64dd4cc427806a39c9c5ca47ec1ea0e309c7f2781717313642a2ba3162bcc681c3a1409aa1236c04bfbe8bfd3d4a2d488b8a88f4c09d096d3d8745090eedc5e21879b54f95e63cf1033371d3ac700d6a443e22cd44d9be33bd5cc9eec4a23feedc6e4eb435cd225da4b9bd16796ade5914a7f8d85d9a4890e1e83553f4870e1b051a8126a7266a6adb994b52d1a55bece54e0a31e6e8433a1ccb5263f92ed48fc8cc26cec3986db6efb41958946b7bf495372f0615af15b8a4848a69a3855b9bef6fc525f944c08ee5fd0a509b25254058ffb298c29dc69831447c6503abdd7fc29ec0d53c5101f5d28241ababfd4b0403b6df059cf2ec58832a668c28d0a5b081d18d8be651d2faf8d23d16201da22e4ab7334f64a7113b669354f2fa4b61d4fef48a8bfe1761763bebdc061aa8381256682b20aa1e84751e6c8317858b22c1fb8f3090cf33b485b15a298ebf9d5cbabf01eb6141b114cba9bb1ab9395ad06917c10c4902ba1cc6b66000290a9008350f2e8542c3fc2988374eae60845b0463bc58f7b3cdf61c0cb7aa538f42fa0cf0610391e76950e7a9868aa3b057fdc20abbef37b5764a2669a22ef3f209252cc26151dc093f637fc820fd08e693350479ade31bb43a9050bd4e14cf9c6ac54315093ac17ce6fa05c9a8a8b69e0cf38504e03153723affcb661377f9aa94b86311076423d8ad8a862b77b46282841a6f84a078881ee943490c2c9d2cd34031287acbe5bdb2210e64f05374aa7a66899cf4eea952415a012afc6510a2</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入查看密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：从上往下打印二叉树</title>
    <url>/%E5%89%91%E6%8C%87Offer-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>二叉树的层次遍历，用队列保存同一层次的树节点，然后依次遍历。</p>
<p>类似题目<u><a href="http://sunyunzeng.com/Leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/">http://sunyunzeng.com/Leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</a></u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> list;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                root = queue.remove();</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(root.left);</span><br><span class="line">                <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 打印1到最大的n位数</title>
    <url>/%E5%89%91%E6%8C%87Offer-%E6%89%93%E5%8D%B01%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>打印1到最大的n位数。</p>
<p><strong>示例：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入 n = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">打印 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>常规操作是<font color="#f07c82">暴力循环打印</font> 1 到 n 位数，但是大数问题，存在数值溢出。</p>
<p>采用<font color="#f07c82">字符串</font>或者<font color="#f07c82">数组</font>存储中间结果。</p>
<h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>用一个 长度为 n 的数组存储，然后分别在最后一位计算，<font color="#f07c82">每次加一</font>，逢十进一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintToNNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 相加是否大于10</span></span><br><span class="line">        <span class="keyword">int</span> overflow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> nSum = overflow + nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只在最后一位加</span></span><br><span class="line">            <span class="keyword">if</span>(i==len-<span class="number">1</span>)&#123;</span><br><span class="line">                nSum++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nSum &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                nums[i] = nSum;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// &gt;= 10</span></span><br><span class="line">            <span class="comment">// 超出范围</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清楚掉数组前面的零</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">boolean</span> isZero = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)</span><br><span class="line">                isZero = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!isZero) &#123;</span><br><span class="line">                System.out.print(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">while</span> (increment(nums))&#123;</span><br><span class="line">            printArray(nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>使用<font color="#f07c82">递归方法</font>，递归到组后一位，然后依次往前打印。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursive</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == index) &#123;</span><br><span class="line">            printArray(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            nums[index] = i;</span><br><span class="line">            recursive(nums, index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        recursive(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 树的子结构</title>
    <url>/%E5%89%91%E6%8C%87Offer-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h1><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>涉及到二叉树相关的问题，首先想到是剑指O剑指递归。</p>
<p>由于二叉树是否为子树的判断，涉及到是否为 <font color="#f07c82">null</font>的判断，因此需要建立子判定函数，避免空树情况产生干扰。</p>
<p>判断条件：</p>
<p><strong>如果当前树节点与待判断树节点数值相同，则继续进行左右树的数值判断。直到两树中某一树为空。</strong></p>
<p><strong>否则分别对当前树的子树与右树跟带判断子树进行判定。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span> || root2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 不能只判断当前第一个节点，如果首节点是伪相等，就是错误的</span></span><br><span class="line">        <span class="keyword">return</span> isSubtree(root1, root2)||</span><br><span class="line">            isSubtree(root1.left, root2)||isSubtree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1.val==root2.val)&#123;</span><br><span class="line">           <span class="keyword">return</span> (isSubtree(root1.left, root2.left) &amp;&amp; isSubtree(root1.right, root2.right)); </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (isSubtree(root1.left, root2) || isSubtree(root1.right, root2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：丑数</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h1 id="思路-＋-代码"><a href="#思路-＋-代码" class="headerlink" title="　思路　＋　代码"></a>　思路　＋　代码</h1><p>丑数只能是丑数乘以　<strong>2、３、５</strong>。</p>
<p>按照顺序存储丑数，也就是比较每次丑数的大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;index; i++)&#123;</span><br><span class="line">            dp[i] = Math.min(Math.min(dp[i2]*<span class="number">2</span>, dp[i3]*<span class="number">3</span>), dp[i5]*<span class="number">5</span>);</span><br><span class="line">            <span class="comment">//-----here is three &quot;if&quot; judge，rather tha “if else”-----</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] == dp[i2]*<span class="number">2</span>)</span><br><span class="line">                i2++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == dp[i3]*<span class="number">3</span>)</span><br><span class="line">                i3++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == dp[i5]*<span class="number">5</span>)</span><br><span class="line">                i5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：两个链表的第一个公共结点</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入两个链表，找出它们的第一个公共结点。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p>
<p>当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode l1 = pHead1;</span><br><span class="line">        ListNode l2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(l1!=l2)&#123;</span><br><span class="line">            l1 = l1==<span class="keyword">null</span>?pHead2:l1.next;</span><br><span class="line">            l2 = l2==<span class="keyword">null</span>?pHead1:l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%2050~59.md#52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9">参考</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：二叉搜索树与双向链表</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>二叉搜索树的<u><a href="http://sunyunzeng.com/Leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/">中序遍历</a></u>即为一个排序的顺序，按照该顺序依次构建双向链表即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode firstHead = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> TreeNode preHead = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 整个遍历过程与中序遍历相同</span></span><br><span class="line">        <span class="comment">// 遍历到最左侧叶子节点，即最小的叶子节点</span></span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="comment">// 第一次将头指针指向最小叶子节点（处理中间节点pRootOfTree）</span></span><br><span class="line">        <span class="keyword">if</span>(preHead==<span class="keyword">null</span>)&#123;</span><br><span class="line">            preHead = pRootOfTree;</span><br><span class="line">            firstHead = pRootOfTree;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pRootOfTree.left=preHead;</span><br><span class="line">            preHead.right = pRootOfTree;</span><br><span class="line">            preHead = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右节点</span></span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> firstHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer: 顺时针打印矩阵</title>
    <url>/%E5%89%91%E6%8C%87Offer-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>制造一个子函数，用来打印每一层。函数接收的参数是需要打印的<strong>行数跟列数</strong>，以及起始打印的位置（都是 n * n）。</p>
<p>特殊情况处理：<strong>打印行列错误、数组为空、单行或单列数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       printArr(matrix.length, matrix[<span class="number">0</span>].length, <span class="number">0</span>, matrix, res);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span> I,<span class="keyword">int</span> J,<span class="keyword">int</span> s,<span class="keyword">int</span>[][] arr, ArrayList&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(I&lt;=<span class="number">0</span> || J&lt;=<span class="number">0</span> || arr==<span class="keyword">null</span> || arr.length==<span class="number">0</span> || arr[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(I==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;J;i++)&#123;</span><br><span class="line">                res.add(arr[s][s+i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(J==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;I;i++)&#123;</span><br><span class="line">                res.add(arr[s+i][s]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;J;i++)&#123;</span><br><span class="line">            res.add(arr[s][s+i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;I;i++)&#123;</span><br><span class="line">            res.add(arr[s+i][s+J-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=J-<span class="number">1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">            res.add(arr[s+I-<span class="number">1</span>][s+i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=I-<span class="number">1</span>; i&gt;<span class="number">1</span>; i--)&#123;</span><br><span class="line">            res.add(arr[s+i-<span class="number">1</span>][s]);</span><br><span class="line">        &#125;</span><br><span class="line">        printArr(I-<span class="number">2</span>,J-<span class="number">2</span>,s+<span class="number">1</span>,arr, res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：二叉搜索树的后序遍历序列</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p><strong>二叉搜索树</strong>的左子树所有节点小于根节点，右子树的所有节点大于根节点。</p>
<p><strong>后序遍历</strong>是先访问左子树，后访问右子树。</p>
<p>因此，根节点永远在序列的最后位置。找到根节点数值后，根据前面节点数值与根节点的大小关系，找到<strong>左右子树的分割位置</strong>，递归求解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始条件判断</span></span><br><span class="line">        <span class="keyword">if</span>(sequence==<span class="keyword">null</span> || sequence.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 调用重写的辅助函数</span></span><br><span class="line">        <span class="keyword">return</span> VerifySquenceOfBST(sequence, <span class="number">0</span>, sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span>[] sequence, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归截止条件</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 寻找分割节点</span></span><br><span class="line">        <span class="keyword">int</span> currentCutIndex = start;</span><br><span class="line">        <span class="keyword">while</span>(sequence[currentCutIndex]&lt;sequence[end])&#123;</span><br><span class="line">            currentCutIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果右子树存在小于根节点的节点，则该序列不是二叉搜索树的后序遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=currentCutIndex; i&lt;end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i]&lt;sequence[end])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右子树递归寻找</span></span><br><span class="line">        <span class="keyword">return</span> VerifySquenceOfBST(sequence, start, currentCutIndex-<span class="number">1</span>) &amp;&amp; </span><br><span class="line">            VerifySquenceOfBST(sequence, currentCutIndex, end-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：二叉树和为某一值的路径</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>递归求解，左右子树分别遍历（深度优先）。</p>
<p>遍历终止条件为节点为<strong>null</strong>或者是叶子节点且和为目标值。</p>
<p>否则回退列表，寻找更短的路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span></span>&#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        target = target - root.val;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>&amp;&amp;root.right==<span class="keyword">null</span>&amp;&amp;root.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        FindPath(root.left, target);</span><br><span class="line">        FindPath(root.right, target);</span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：二叉搜索树的第k个结点</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>其实就是<a href="http://sunyunzeng.com/Leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/">二叉搜索树的中序遍历</a>翻版。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">private</span> TreeNode node;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        inOrder(pRoot, k);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=k || pRoot==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        inOrder(pRoot.left, k);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt==k)&#123;</span><br><span class="line">            node = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(pRoot.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：二叉树的下一个结点</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>树的问题最容易想到的就是递归方法。</p>
<p>中序遍历顺序是左叶子节点、根节点、右叶子节点。</p>
<p>分为两种情况：</p>
<ol>
<li><p>如果右子节点不为空，则递归寻找后面最左叶子节点。</p>
</li>
<li><p>如果右子节点为空，则递归在父级节点寻找。</p>
<p> 2.1 如果父节点为空，则返回 null。</p>
<p> 2.2 如果父节点左节点等于该节点，则返回父节点。</p>
<p> 2.3 如果父节点右节点等于该节点，则继续递归寻找。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(pNode.right!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getRightNode(pNode.right);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getParentNode(pNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找最左节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeLinkNode <span class="title">getRightNode</span><span class="params">(TreeLinkNode pNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode.left==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getRightNode(pNode.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有右节点，下一节点则是父级节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeLinkNode <span class="title">getParentNode</span><span class="params">(TreeLinkNode pNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode.next==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(pNode.next.left == pNode)</span><br><span class="line">            <span class="keyword">return</span> pNode.next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getParentNode(pNode.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：删除链表中重复的节点</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>利用递归求解，问题分解为去除下一个节点开始链表中重复的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span> || pHead.next==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode next = pHead.next;</span><br><span class="line">        <span class="keyword">if</span>(pHead.val==next.val)&#123;</span><br><span class="line">            <span class="keyword">while</span>(next!=<span class="keyword">null</span> &amp;&amp; pHead.val == next.val)</span><br><span class="line">                next = next.next;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplication(next);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pHead.next = deleteDuplication(pHead.next);</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：剪绳子</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>（2 &lt;= n &lt;= 60）</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p><strong>动态规划</strong></p>
<p>可以分解子问题，即剪一刀，产生两段绳子，长度分别是 i 与 n-i, 在这两条绳子上可以继续剪：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">f(n) = max(f(i), f(n-i))</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=target; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i; j++)&#123;</span><br><span class="line">                <span class="comment">// 剪一刀长度为j，则产生长度为j与i-j长度的绳子</span></span><br><span class="line">                <span class="comment">// 进而判断长度为j的绳子的大值，为max(j, dp[j]);</span></span><br><span class="line">                <span class="comment">// 最后去dp[j]的最大值</span></span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j*(i-j), dp[j]*(i-j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：复杂链表的复制</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>参考 <u><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%2030~39.md#35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%2030~39.md#35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6</a></u></p>
<p>分为三步：</p>
<p><strong>1. 在每个节点的后面插入复制的节点。</strong></p>
<img src="/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/step1.png" class>
<p><strong>2. 每个复制的节点 random 赋值。</strong></p>
<img src="/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/step2.png" class>
<p><strong>3. 拆分。</strong></p>
<img src="/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/step3.png" class>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        RandomListNode cur = pHead;</span><br><span class="line">        <span class="comment">// 先在链表中间插入节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode tmp = <span class="keyword">new</span> RandomListNode(cur.label);</span><br><span class="line">            tmp.next = cur.next;</span><br><span class="line">            cur.next = tmp;</span><br><span class="line">            cur = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后中间节点的 random 指针赋值</span></span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.random!=<span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 这里是当前节点 random 链接的下一个为复制节点的 random 链接</span></span><br><span class="line">                cur.next.random = cur.random.next;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两个链表分离</span></span><br><span class="line">        cur = pHead;</span><br><span class="line">        RandomListNode res = cur.next;</span><br><span class="line">        <span class="keyword">while</span>(cur.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode tmp = cur.next;</span><br><span class="line">            cur.next = tmp.next;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：字符流中第一个不重复的字符</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<p>如果当前字符流没有存在出现一次的字符，返回#字符。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>利用队列进行结果的存储，利用一个数组进行出现次数的统计。</p>
<p>队列对于其中所有出现超过两次的字符进行出栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] tmp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tmp[ch]++;</span><br><span class="line">        queue.add(ch);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()&amp;&amp;tmp[queue.peek()]&gt;<span class="number">1</span>)</span><br><span class="line">            queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty()?<span class="string">&#x27;#&#x27;</span>:queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：左旋字符串</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%B7%A6%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>先将 “abc” 和 “XYZdef” 分别翻转，得到 “cbafedZYX”，然后再把整个字符串翻转得到 “XYZdefabc”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = chs.length-<span class="number">1</span>;</span><br><span class="line">        inverse(chs, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        inverse(chs, n ,len);</span><br><span class="line">        inverse(chs, <span class="number">0</span>, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inverse</span><span class="params">(<span class="keyword">char</span>[] chs, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            swap(chs, i, j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chs, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> t = chs[i];</span><br><span class="line">        chs[i] = chs[j];</span><br><span class="line">        chs[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：字符串的排列</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<p><strong>输入描述：</strong></p>
<p>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>典型回溯法，同 <a href>全排列</a> 解法类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       backtracking(res, str.toCharArray(), <span class="keyword">new</span> StringBuilder(), <span class="keyword">new</span> <span class="keyword">boolean</span>[str.length()]);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(ArrayList&lt;String&gt; res, <span class="keyword">char</span>[] chs, StringBuilder sbd, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(chs==<span class="keyword">null</span> || chs.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(chs.length==sbd.length())&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> String(sbd.toString()));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;chs.length; i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(used[i] || i&gt;<span class="number">0</span>&amp;&amp;chs[i]==chs[i-<span class="number">1</span>]&amp;&amp;!used[i-<span class="number">1</span>])</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    sbd.append(chs[i]);</span><br><span class="line">                    used[i] = <span class="keyword">true</span>;</span><br><span class="line">                    backtracking(res, chs, sbd, used);</span><br><span class="line">                    sbd.deleteCharAt(sbd.length()-<span class="number">1</span>);</span><br><span class="line">                    used[i] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u><font color="#1772b4"><a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&amp;tqId=11180&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">题目链接</a></font></u></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：平衡二叉树</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>平衡二叉树的左右子树的高度差不大于 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isBalanced = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        height(root);</span><br><span class="line">        <span class="keyword">return</span> isBalanced;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span> || !isBalanced)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = height(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = height(root.right);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>&lt;Math.abs(left-right))</span><br><span class="line">            isBalanced = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：序列化二叉树</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p>
<p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>递归序列化与递归反序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String deserializeStr;</span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> root.val + <span class="string">&quot; &quot;</span> + Serialize(root.left) + <span class="string">&quot; &quot;</span> + Serialize(root.right);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       deserializeStr = str;</span><br><span class="line">       <span class="keyword">return</span> Deserialize();</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(deserializeStr.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> index = deserializeStr.indexOf(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        String node = index==-<span class="number">1</span>?deserializeStr:deserializeStr.substring(<span class="number">0</span>, index);</span><br><span class="line">        deserializeStr = index==-<span class="number">1</span>?<span class="string">&quot;&quot;</span>:deserializeStr.substring(index+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(node.equals(<span class="string">&quot;#&quot;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> val = Integer.valueOf(node);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root.left = Deserialize();</span><br><span class="line">        root.right = Deserialize();</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：把数组排成最小的数</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p><strong>字符串的排序。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers==<span class="keyword">null</span> || numbers.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = numbers.length;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">            strs[i] = numbers[i]+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        Arrays.sort(strs, (a, b)-&gt;(a+b).compareTo(b+a));</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s: strs)</span><br><span class="line">            sb.append(s);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：扑克牌顺子</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>首先用一个长度为13的数组统计每个数字出现的次数。</p>
<p>然后满足以下条件为顺子：</p>
<ol>
<li>除大小王外所有数字出现一次。</li>
<li>最大值与最小值差值小于等于4，例如存在 1 跟 6 无法形成顺子。</li>
<li>四个癞子稳赢。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers==<span class="keyword">null</span> || numbers.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">14</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: numbers)</span><br><span class="line">            counts[num]++;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">14</span>;</span><br><span class="line">        <span class="comment">//四个癞子稳赢</span></span><br><span class="line">        <span class="keyword">if</span>(counts[<span class="number">0</span>]==<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 寻找最大值与最小值</span></span><br><span class="line">        <span class="keyword">while</span>(counts[++i]==<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(counts[--j]==<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 例如：最小值1，最大值6肯定不行</span></span><br><span class="line">        <span class="keyword">if</span>(Math.abs(j-i)&gt;<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 用癞子补全，如果癞子够，就可以</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i; k&lt;=j; k++)</span><br><span class="line">            <span class="keyword">if</span>(counts[k]&gt;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其它方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers==<span class="keyword">null</span> || numbers.length&lt;<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        <span class="comment">//统计癞子数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: numbers)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">0</span>)</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=count; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="comment">// 存在重复的</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==numbers[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            count -= numbers[i+<span class="number">1</span>]-numbers[i]-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count&gt;=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：数据流中的中位数</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>参考<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%2040~49.md#411-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0">CyC</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// left-最大堆  right-最小堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; left = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((o1, o2)-&gt;o2-o1);</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; right = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            left.add(num);</span><br><span class="line">            right.add(left.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right.add(num);</span><br><span class="line">            left.add(right.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// N是滞后计数，表示一数据流的长度是多少</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (left.peek()+right.peek())/<span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)right.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：数组中只出现一次的数字</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>利用Map统计每个数字出现的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: array)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(num))</span><br><span class="line">                map.put(num, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.put(num, map.get(num)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(entry.getValue()==<span class="number">1</span>)</span><br><span class="line">                list.add(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        num1[<span class="number">0</span>] = list.get(<span class="number">0</span>);</span><br><span class="line">        num2[<span class="number">0</span>] = list.get(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>与题目<a href="http://sunyunzeng.com/%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3/">只出现一次的数字</a>类似，利用<strong>异或</strong>的知识。</p>
<p>唯一不同是这次是找出两个只出现一次的数字，所以需要找到这两个不同数字的区别，然后分别异或。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dif=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: array)</span><br><span class="line">            dif ^= num;</span><br><span class="line">        <span class="comment">// dif=1100 -dif=0100, dif &amp;= -dif  dif=0100,即只保存最右侧异或结果不同的那一位，分割数组</span></span><br><span class="line">        dif &amp;= -dif;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: array)&#123;</span><br><span class="line">            <span class="keyword">if</span>((num &amp; dif)==<span class="number">0</span>)</span><br><span class="line">                num1[<span class="number">0</span>] ^= num;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num2[<span class="number">0</span>] ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://sunyunzeng.com/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/">类似题目</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：数组中的逆序对</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<p><strong>题目描述:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题目保证输入的数组中没有的相同的数字</span><br><span class="line"></span><br><span class="line">数据范围：</span><br><span class="line"></span><br><span class="line">	对于%<span class="number">50</span>的数据,size&lt;=<span class="number">10</span>^<span class="number">4</span></span><br><span class="line"></span><br><span class="line">	对于%<span class="number">75</span>的数据,size&lt;=<span class="number">10</span>^<span class="number">5</span></span><br><span class="line"></span><br><span class="line">	对于%<span class="number">100</span>的数据,size&lt;=<span class="number">2</span>*<span class="number">10</span>^<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>示例1</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>归并排序，先拆分成单个的数字，然后向上归并同时统计逆数数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span> || array.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> l = left, r = right, m = (left + right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(nums, l, m);</span><br><span class="line">        mergeSort(nums, m+<span class="number">1</span>, r);</span><br><span class="line">        merge(nums, l, m, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = right-left;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> l = mid, r = right;</span><br><span class="line">        <span class="keyword">while</span>(l &gt;= left &amp;&amp; r &gt;= mid+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]&gt;nums[r])&#123;</span><br><span class="line">                count += (r-mid);</span><br><span class="line">                tmp[len--] = nums[l--];</span><br><span class="line">                <span class="keyword">if</span>(count &gt;= <span class="number">1000000007</span>)</span><br><span class="line">                    count %= <span class="number">1000000007</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[len--] = nums[r--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上述判定并不能概括所有的情况，因此用两个循环继续完成辅助数组tmp</span></span><br><span class="line">        <span class="keyword">while</span>(l &gt;= left)</span><br><span class="line">            tmp[len--] = nums[l--];</span><br><span class="line">        <span class="keyword">while</span>(r &gt;= mid+<span class="number">1</span>)</span><br><span class="line">            tmp[len--] = nums[r--];</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;tmp.length; i++)</span><br><span class="line">            nums[left+i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：按之字形顺序打印二叉树</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>其实就是<a href="http://sunyunzeng.com/Leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/">二叉树层次遍历</a>的变体。</p>
<p>遍历过程中，如果是二叉树的偶数层，就顺序遍历；否则逆序遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> layer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> location = <span class="number">0</span>;</span><br><span class="line">        queue.add(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            Integer[] nums = <span class="keyword">new</span> Integer[len];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len; ++i)&#123;</span><br><span class="line">                TreeNode tmp = queue.remove();</span><br><span class="line">                <span class="keyword">if</span>(layer%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">                    location = len-<span class="number">1</span>-i;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    location = i;</span><br><span class="line">                nums[location]=tmp.val;</span><br><span class="line">                <span class="keyword">if</span>(tmp.left!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(tmp.left);</span><br><span class="line">                <span class="keyword">if</span>(tmp.right!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(tmp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            Collections.addAll(list, nums);</span><br><span class="line">            <span class="keyword">if</span>(list.size()&gt;<span class="number">0</span>)</span><br><span class="line">                res.add(list);</span><br><span class="line">            layer++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：数组在排序中出现的次数</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%95%B0%E7%BB%84%E5%9C%A8%E6%8E%92%E5%BA%8F%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>统计一个数字在排序数组中出现的次数。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>不能遍历，否则时间超出。二分查找，寻找边界位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = binarySearch(array, k);</span><br><span class="line">        <span class="keyword">int</span> h = binarySearch(array, k+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (l&gt;array.length-<span class="number">1</span> || array[l]!=k)?<span class="number">0</span>:h-l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n.length;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            m = (r+l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(n[m]&gt;=k)</span><br><span class="line">            <span class="comment">// 保证最后的位置等于或小于查找的元素</span></span><br><span class="line">                r=m;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=m+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：最小的K个数</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<h1 id="思路1-代码"><a href="#思路1-代码" class="headerlink" title="思路1 + 代码"></a>思路1 + 代码</h1><p>维护一个最小堆，该最小堆即为所求。</p>
<p>类似<u><a href="http://sunyunzeng.com/Leetcode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/">题目</a></u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(input==<span class="keyword">null</span> || input.length==<span class="number">0</span> || k&gt;input.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((o1, o2) -&gt; o2-o1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:input)&#123;</span><br><span class="line">            pq.add(num);</span><br><span class="line">            <span class="keyword">if</span>(pq.size()&gt;k)</span><br><span class="line">                pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;(pq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路2-代码"><a href="#思路2-代码" class="headerlink" title="思路2 + 代码"></a>思路2 + 代码</h1><p>该题完全可以先排序后取最小的K个数。</p>
<p>因此排序方法的选取很重要。</p>
<p><strong>## 冒泡方法</strong></p>
<p>只用排k个最小值即可，因此最外圈循环K次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(input==<span class="keyword">null</span> || input.length==<span class="number">0</span> || k&gt;input.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = input.length;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;k+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len-i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(input[j]&lt;=input[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = input[j];</span><br><span class="line">                    input[j] = input[j+<span class="number">1</span>];</span><br><span class="line">                    input[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(input[len-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>## 快速排序</strong></p>
<p><font color="#f07c82"><a href="http://sunyunzeng.com/Algorithm-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">快排</a></font>关键在于<font color="#f07c82">基准</font>的选择，大于基准的数放于一边，小于基准的数放在另一边。</p>
<p>我们的标准是划分的位置刚好是在第<strong>k</strong>个位置，这样 k 位置之前的数组都为排序好的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(input==<span class="keyword">null</span> || input.length==<span class="number">0</span> || k&gt;input.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = input.length;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        sort(input, <span class="number">0</span>, input.length-<span class="number">1</span>, k-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            res.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = low;</span><br><span class="line">        <span class="keyword">int</span> h = high;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = partition(input, l, h);</span><br><span class="line">            <span class="keyword">if</span>(tmp==k)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;k)&#123;</span><br><span class="line">                h = tmp-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = tmp+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> criterion = input[h];</span><br><span class="line">        <span class="keyword">int</span> i = l-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = h;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; input[++i]&lt;criterion);</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; input[--j]&gt;criterion);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(input, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(input,i, h);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：机器人的运动范围</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p><strong>回溯方法</strong>，类似<a href="http://sunyunzeng.com/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/">题目1</a>、<a href="http://sunyunzeng.com/Leetcode-%E5%B2%9B%E5%B1%BF%E6%9C%80%E5%A4%A7%E7%9A%84%E9%9D%A2%E7%A7%AF/">题目2</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] next = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rows&lt;=<span class="number">0</span> || cols&lt;=<span class="number">0</span> || threshold&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        k = threshold;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>, visit);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] visit)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=visit.length || j&gt;=visit[<span class="number">0</span>].length || k&lt;calNum(i)+calNum(j) || visit[i][j] )&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res++;</span><br><span class="line">        visit[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] step: next)&#123;</span><br><span class="line">            dfs(i+step[<span class="number">0</span>], j+step[<span class="number">1</span>], visit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            res += num%<span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：整数中1出现的次数</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>暴力穷举会超出时间，这道题的关键是找规律。</p>
<center><img src="/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/number_of_digit_one.png" class></center>
<center>[图片来自LeetCode 233](https://leetcode-cn.com/problems/number-of-digit-one/solution/shu-zi-1-de-ge-shu-by-leetcode/)</center>

<p>一个数字，分解为十位、百位、千位…上来看。</p>
<p>因为数字由1~n组成，既有十位、百位、千位等组成。</p>
<p><strong>首先，每十个数，个位数字出现一次。每百位数，个位数字出现十次…</strong></p>
<p><strong><code>n/(i*10)*i, i=1, 10, 100, ...</code></strong></p>
<p><strong>其次，对于后面的数，例如1611，从百位数来看，前面的数字 1611/100*10=160, 后面数字为11，因此后面的个位数为 1+1=2， 而1620和1650后面的个位数字都是10个，因此后面个位数字：</strong></p>
<p><strong><code>max(min(n%(i*10)-i+1,0),i)</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i*=<span class="number">10</span>)&#123;</span><br><span class="line">             count += n/(i*<span class="number">10</span>)*i + Math.min(Math.max(n%(i*<span class="number">10</span>)-i+<span class="number">1</span>,<span class="number">0</span>),i);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：正则表达式匹配</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p><strong>动态规划：</strong>利用一个dp(x, y)的数组表示原字符串 s[0, x) 与匹配字符串 p[0, y)是否匹配。</p>
<p><strong>状态转移：</strong></p>
<p>对于dp(x, y)：</p>
<ol>
<li><p>如果 p(y) == ‘.’ || p(y) == s(x-1), dp(x, y)<br>= dp(x-1, y-1)。</p>
</li>
<li><p>如果 p(y) == ‘*’</p>
<p> 2.1 如果 p(y-1) == s(x) || p(y-1) == ‘.’</p>
<p> 1) ‘<em>‘ 复制多个：dp(x, y) = dp(x-1, y)<br> 2) ‘</em>‘ 复制一个：dp(x, y) = dp(x, j-1)<br> 3) ‘*’ 复制零个：dp(x, y) = dp(x, j-2)</p>
<p> 2.2 如果 s 为空且不满足 2.1，则 ‘*’ 复制零个：dp(x, y) = dp(x, j-2)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = str.length+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = pattern.length+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 空字符串处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">            <span class="keyword">if</span>(pattern[i-<span class="number">1</span>]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str[i-<span class="number">1</span>]==pattern[j-<span class="number">1</span>] || pattern[j-<span class="number">1</span>]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pattern[j-<span class="number">1</span>]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(pattern[j-<span class="number">2</span>]==str[i-<span class="number">1</span>] || pattern[j-<span class="number">2</span>]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                        dp[i][j] |= dp[i-<span class="number">1</span>][j]; <span class="comment">// 复制多个</span></span><br><span class="line">                        dp[i][j] |= dp[i][j-<span class="number">1</span>]; <span class="comment">//复制一个</span></span><br><span class="line">                        dp[i][j] |= dp[i][j-<span class="number">2</span>]; <span class="comment">// 删除一个</span></span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                        dp[i][j] |= dp[i][j-<span class="number">2</span>]; <span class="comment">// 删除一个</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：第一个只出现一次的字符</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>用一个LinkedHashMap统计每个字符出现的次数，同时保存顺序。然后String查找该字符第一次出现的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line">        LinkedHashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = chs.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(chs[i]))&#123;</span><br><span class="line">                map.put(chs[i], <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(chs[i], map.get(chs[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character, Integer&gt; entry: map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(entry.getValue()==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> str.indexOf(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者可以用一个数组来模拟Map。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            counts[str.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(counts[str.charAt(i)]==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间复杂度可以继续优化，用两个Bitset分别表示出现一次和出现一次及以上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line">        BitSet bs1 = <span class="keyword">new</span> BitSet(<span class="number">256</span>);</span><br><span class="line">        BitSet bs2 = <span class="keyword">new</span> BitSet(<span class="number">256</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: chs)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!bs1.get(c) &amp;&amp; !bs2.get(c))&#123;</span><br><span class="line">                <span class="comment">// 出现一次</span></span><br><span class="line">                bs1.set(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bs1.get(c) &amp;&amp; !bs2.get(c))&#123;</span><br><span class="line">                <span class="comment">// 出现一次以上</span></span><br><span class="line">                bs2.set(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(bs1.get(c) &amp;&amp; !bs2.get(c))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：滑动窗口的最大值</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>用一个最大堆维护中间的判断结果，每次只需对顶元素调整即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(size&lt;=<span class="number">0</span> || size&gt;num.length)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// 最大堆维护结果</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((o1, o2)-&gt;o2-o1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">            queue.add(num[i]);</span><br><span class="line">        res.add(queue.peek());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=size; i&lt;num.length; i++)&#123;</span><br><span class="line">            queue.remove(num[i-size]);</span><br><span class="line">            queue.add(num[i]);</span><br><span class="line">            res.add(queue.peek());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：翻转单词顺序列</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>先翻转每个单词，再重头到尾进行翻转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = chs.length;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=len)&#123;</span><br><span class="line">            <span class="comment">// 反转单词</span></span><br><span class="line">            <span class="keyword">if</span>(j==len || chs[j]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                reverse(chs, i, j-<span class="number">1</span>);</span><br><span class="line">                i=j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反转整个句子</span></span><br><span class="line">        reverse(chs, <span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chs, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">            swap(chs, i++, j--);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chs, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> t = chs[i];</span><br><span class="line">        chs[i] = chs[j];</span><br><span class="line">        chs[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>博客中添加足迹地图</title>
    <url>/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%B6%B3%E8%BF%B9%E5%9C%B0%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="足迹地图效果展示"><a href="#足迹地图效果展示" class="headerlink" title="足迹地图效果展示"></a>足迹地图效果展示</h1><p><strong>足迹地图可以展示你过去到访过的地方，以及到访地点的介绍与图片记录</strong>，同时不同地标的半径大小表示了访问该地点的频率高低，如下图所示：</p>
<center><img src="/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%B6%B3%E8%BF%B9%E5%9C%B0%E5%9B%BE/%E5%9B%BE1.png" class></center>

<p>其中每个足迹图标都可以点击，点击会弹出左边的介绍栏及对应的介绍文字与图片。<strong>图片点击可以放大显示</strong>，如下图所示：</p>
<center><img src="/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%B6%B3%E8%BF%B9%E5%9C%B0%E5%9B%BE/%E5%9B%BE2.png" class></center>

<h1 id="足迹地图使用方式"><a href="#足迹地图使用方式" class="headerlink" title="足迹地图使用方式"></a>足迹地图使用方式</h1><h2 id="克隆足迹地图项目"><a href="#克隆足迹地图项目" class="headerlink" title="克隆足迹地图项目"></a>克隆足迹地图项目</h2><p><strong>首先，将足迹地图克隆到本地。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;SUNYunZeng&#x2F;FootprintMap.git</span><br></pre></td></tr></table></figure>
<p>会得到如下所示的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FootprintMap</span><br><span class="line">├─ CNAME</span><br><span class="line">├─ css</span><br><span class="line">│  ├─ index.css</span><br><span class="line">│  └─ jquery-jvectormap-2.0.5.css</span><br><span class="line">├─ data</span><br><span class="line">│  └─ config.json</span><br><span class="line">├─ index.html</span><br><span class="line">├─ js</span><br><span class="line">│  ├─ index.js</span><br><span class="line">│  ├─ jquery-1.9.1.min.js</span><br><span class="line">│  ├─ jquery-jvectormap-2.0.5.min.js</span><br><span class="line">│  └─ jquery-jvectormap-cn-merc-en.js</span><br><span class="line">└─ README.md</span><br></pre></td></tr></table></figure>
<h2 id="配置你的足迹数据"><a href="#配置你的足迹数据" class="headerlink" title="配置你的足迹数据"></a>配置你的足迹数据</h2><p><strong>其中 /data/config.json 为配置数据，在里面可以配置你的足迹数据</strong>，结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;latLng&quot;</span>: [<span class="number">36.44852263442782</span>, <span class="number">118.73921200195313</span>],</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;青州&quot;</span>,</span><br><span class="line">        <span class="string">&quot;desc&quot;</span>: <span class="string">&quot;我的家乡，山东东方——青州，国家著名旅游城市。\n旅游景点包括云门山、仰天山、驼山、范公亭、青州博物馆、宋城、古街等等。\n著名美食包括弥河银瓜、老槐树煎包、柿饼、马蹄子烧饼等等。&quot;</span>,</span><br><span class="line">        <span class="string">&quot;photos&quot;</span>:[</span><br><span class="line">            <span class="string">&quot;http://m.qpic.cn/psc?/V115oyNl11FAq7/ETWql2gUF22pNmiMBc.OAZ37OxTay*sinik.eOjVri2aewXK1ZXizNGpMabk*In6gs0SEGmIh82UkaewyV8YgWsu29ZdAYjwW0wjuMdOkzw!/b&amp;bo=VQOAAgAAAAAFF.A!&amp;rf=viewer_4&quot;</span>,</span><br><span class="line">            <span class="string">&quot;http://m.qpic.cn/psc?/V115oyNl11FAq7/ETWql2gUF22pNmiMBc.OAQ0A4hJ0OmPEDYmJjUFJKI2t*ynCY41qGPAI.NMZlbUTh6NeqmgL7UuGmHcPH33ZKUpdGUvyUtlsxeRoKQRaaRk!/b&amp;bo=ngL3AQAAAAAFF14!&amp;rf=viewer_4&quot;</span>,</span><br><span class="line">            <span class="string">&quot;http://m.qpic.cn/psc?/V115oyNl11FAq7/ETWql2gUF22pNmiMBc.OARYef.ZynHj7VLc8N**aHzaQkp4U5oJI4Saa3W68M7O8ynmpV.j*l1JOYoOcYI*WO7r7NotbsyncY3NuLst7vwM!/b&amp;bo=ngL2AQAAAAAFF18!&amp;rf=viewer_4&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;freq&quot;</span>: <span class="number">10</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>latLng：</strong> 为足迹的经纬度，可以通过 <a href="https://jingweidu.bmcx.com/">https://jingweidu.bmcx.com/</a> 查询得到</li>
<li><strong>name：</strong> 足迹地点的名称</li>
<li><strong>desc</strong>：足迹地点的描述， \n 为换行符</li>
<li><strong>photos</strong>：足迹地点的照片链接，为一组图片 url 数据</li>
<li><strong>freq</strong>：足迹地点的到访次数，范围为 [1, 10]</li>
</ul>
<h2 id="将足迹地图部署到你的博客"><a href="#将足迹地图部署到你的博客" class="headerlink" title="将足迹地图部署到你的博客"></a>将足迹地图部署到你的博客</h2><p>将足迹数据修改完毕后，将<strong>项目传到你的 github 中进行托管，然后启用你的足迹地图项目的 github Page 服务，会得到服务地址： <a href="http://xxxx/xxxx/">http://xxxx/xxxx/</a>.</strong></p>
<center><img src="/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%B6%B3%E8%BF%B9%E5%9C%B0%E5%9B%BE/%E5%9B%BE3.png" class></center>

<p><strong>然后利用 iframe 将足迹地图内嵌到你博客中的相应位置，示例代码如下：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">scrolling</span>=<span class="string">no</span> <span class="attr">style</span>=<span class="string">&quot;min-height:480px !important;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://xxxx/xxxx/index.html&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中嵌入的样式可以根据自己需求修改。</p>
<h1 id="进一步的样式调整"><a href="#进一步的样式调整" class="headerlink" title="进一步的样式调整"></a>进一步的样式调整</h1><p>默认的地图为中国地图，足迹点的样式及背景样式都是固定的，如果想对足迹地图进行进一步的定制化，可以对 <strong>/css/index.css 及 /js/index.js 文件进行修改</strong>。</p>
<p>其中 <strong>/js/jquery-jvectormap-cn-merc-en.js</strong>为中国地图，你可以替换为世界地图，具体操作见 <a href="https://jvectormap.com/">https://jvectormap.com/</a></p>
<p>足迹地图依赖的是 <strong>JVectorMap</strong>，关于基本的样式定义可以参考官网 <a href="https://jvectormap.com/documentation/javascript-api/jvm-map/">https://jvectormap.com/documentation/javascript-api/jvm-map/</a></p>
<center><img src="https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/footMapDemo.png"> </center>

<h1 id="续"><a href="#续" class="headerlink" title="续"></a>续</h1><ul>
<li><p>文章首发 <a href="https://sunyunzeng.com/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%B6%B3%E8%BF%B9%E5%9C%B0%E5%9B%BE/">https://sunyunzeng.com/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%B6%B3%E8%BF%B9%E5%9C%B0%E5%9B%BE/</a></p>
</li>
<li><p>项目地址 <a href="https://github.com/SUNYunZeng/FootprintMap">https://github.com/SUNYunZeng/FootprintMap</a></p>
</li>
<li><p>参考 <a href="http://www.wujiayi.vip/index.php/archives/52/">http://www.wujiayi.vip/index.php/archives/52/</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows环境下Hexo+Github搭建个人博客教程</title>
    <url>/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>你是否也想拥有属于自己的博客？是否也想拥有跟我一样的博客空间？如果心动了，就赶紧往下看吧！</strong></p>
<blockquote>
<p>教程炒鸡简单，炒鸡详细，而且博客搭建完全是<strong>Free of Charge!</strong></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h3><p><strong><a href="https://github.com/">Github</a></strong>不仅可以让我们把代码托管在平台上，而且允许我们<strong>利用Github的服务器部署自定义网页</strong>对我们的项目作简介。这个网页就被称为<strong>Github Pages</strong>。这是我们可以利用Github搭建免费博客的基础啦~</p>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p><strong><a href="https://hexo.io/zh-cn/">Hexo</a></strong>是一款轻量但高逼格的搭建博客快速工具，它是基于<a href="https://nodejs.org/en/">Node.js</a>开发的。而Node.js…好了，扯远了…有兴趣的童鞋可以出门左转自己百度…</p>
</blockquote>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>知道了大致的原理，我们首先需要准备搭建博客的材料。如下：</p>
<p><strong><em>1. 一台windows系统的电脑</em><br><em>2. 一个Github账号</em><br><em>3. 安装Node.js</em><br><em>4. 安装Git</em><br><em>5. 安装Hexo</em></strong></p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="申请Github账号，建立一个仓库，并为此创建一个说明网页-Github-Pages"><a href="#申请Github账号，建立一个仓库，并为此创建一个说明网页-Github-Pages" class="headerlink" title="申请Github账号，建立一个仓库，并为此创建一个说明网页(Github Pages)"></a>申请Github账号，建立一个仓库，并为此创建一个说明网页(Github Pages)</h2><p>假设我们都有了Github账号，这是首先在右上角点击“+”号，选择<strong>New repository</strong><br><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/new_repository.png" class></p>
<p><strong>注意  仓库名一定是”你的Github用户名”+github.io !!!</strong></p>
<img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/name_repository.png" class>
<p>之后为我们的项目添加一个<strong>说明Pages</strong>！</p>
<p>建好的项目顶部最右边有个<strong>Setting</strong>按钮，点击进入配置界面，下滑界面，直到看到<strong>Github Pages</strong>，这时你发现竟然自动生成了一个说明网页！</p>
<p>因为Github说明网页的默认地址就是“你的Github用户名”+github.io，其它说明网页都是基于该地址的。<br><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/setting_repository.png" class></p>
<img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/pages_repository.png" class>
<p><strong>Ok!</strong> 到此为止，Gihub Pages的部分就结束了。</p>
<h2 id="搭建Hexo，把Github-Pages修改为自己的博客界面！"><a href="#搭建Hexo，把Github-Pages修改为自己的博客界面！" class="headerlink" title="搭建Hexo，把Github Pages修改为自己的博客界面！"></a>搭建Hexo，把Github Pages修改为自己的博客界面！</h2><h3 id="安装Git以及Node-js！"><a href="#安装Git以及Node-js！" class="headerlink" title="安装Git以及Node.js！"></a>安装Git以及Node.js！</h3><p>因为我们需要通过Git把我们的Hexo生成的网页提交到Github pages上，而Node.js是我们Hexo插件运行的基础！</p>
<ol>
<li><a href="https://gitforwindows.org/">下载安装Windows版Git</a></li>
<li><a href="http://nodejs.cn/">下载安装Node.js</a></li>
</ol>
<p><strong>验证：</strong><br>“Win”+R打开运行界面，输入”cmd”打开命令行窗口。<br>是否安装Git:输入<code>git version</code>出现版本信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git version 2.19.1.windows.1</span><br></pre></td></tr></table></figure>
<p>是否安装Node.js:输入<code>node -v</code>出现版本信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v8.12.0</span><br></pre></td></tr></table></figure></p>
<h3 id="安装及部署Hexo"><a href="#安装及部署Hexo" class="headerlink" title="安装及部署Hexo"></a>安装及部署Hexo</h3><p>首先<strong>创建一个文件夹</strong>，用来放置我们的Hexo。</p>
<p>然后进入我们的文件夹，例如我们文件夹路径为D:\blog</p>
<p>则在终端依次输入并执行<code>D:</code> 、 <code>cd blog</code> 进入文件夹</p>
<p>打开命令终端，利用Node.js的包管理器npm<strong>安装Hexo</strong>:<br><code>npm install hexo-cli -g</code><br>输入<code>hexo -v</code>验证是否安装成功<br>输入<code>hexo init</code>初始化该文件夹<br>输入<code>npm install</code>安装需要的组件<br>输入<code>npm g</code>生成静态文件<br>输入<code>npm s</code>启动服务器，现在在浏览器输入<a href="http://localhost:4000/">http://localhost:4000/</a>打开我们的博客界面！</p>
<p>是不是有点鸡冻！别急，我们还需要把页面推送到Github Pages上，步骤如下：</p>
<p><strong>1. 设置Git的user name和email</strong></p>
<p>在我们创建博客文件夹里右击，选择 Git Base Here，然后在窗口中依次输入<br><code>git config --global user.name &quot;yourname&quot;</code><br><code>git config --global user.email &quot;youremail&quot;</code></p>
<p><strong>2. SSH 授权</strong><br>打开git bash，输入<code>ssh-keygen -t rsa</code>, 接着回车三下。</p>
<p>最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）</p>
<p>登录Github，点击头像下的settings，添加ssh。新建一个new ssh key，将<strong>id_rsa.pub</strong>文件里的内容复制上去<br><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/ssh.png" class></p>
<p><strong>3. 上传项目</strong></p>
<p>首先用IDE(我用的是WebStorm)打开我们的Hexo文件夹，发现它的文档目录是这样的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|-- _config.yml</span><br><span class="line">|-- package.json</span><br><span class="line">|-- scaffolds</span><br><span class="line">|-- source</span><br><span class="line">   |-- _posts</span><br><span class="line">|-- public</span><br><span class="line">|-- themes</span><br><span class="line">|-- .gitignore</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>_config.yml：网站的全局配置文件，设置包括网站标题、副标题、作者、关键字和描述信息等。</p>
<p>package.json：框架的基本参数信息和它所依赖的插件，在 npm 安装时使用 —save 保存进去。</p>
<p>scaffolds：本意是 “脚手架” 的意思，这里引申为模板文件夹。当你 hexo new <layout(布局)> &lt;’title’&gt; 的时候，Hexo 会根据该文件夹下的对应文件进行初始化构建。</layout(布局)></p>
<p>source：正如其名，source 文件夹存储一些直接来自用户的文件，它很重要，如果不出意外你的文章就是保存在这个文件夹下(_posts)。_posts 目录下的md文件，会被编译成 html 文件，放到 public 文件夹下。</p>
<p>public：参考 source 文件夹，在初始化后是没有 public 文件夹的，除非 hexo g 编译生成静态文件后，public 文件夹会自动生成。使用<br>hexo clean 清除 db.json 和 public 文件夹下的所有文件。</p>
<p>themes：主题文件夹，存储主题。相关的主题可以在 Github 上免费采购。</p>
<p>.gitignore：.gitignore 文件作用是声明不被 git 记录的文件，hexo init <folder> 也会产生一个 .gitignore 文件，可以先删除或者直接编辑，对hexo不会有影响。</folder></p>
</blockquote>
<p><strong>打开配置文档_config.yml，修改deploy值（在末尾）:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:SUNYunZeng&#x2F;SUNYunZeng.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>安装在git上部署文章的扩展<code>npm install hexo-deployer-git --save</code></p>
<p>打开终端并进入到Hexo文件系统中，创建一篇新博客<code>hexo new post &quot;博客名&quot;</code></p>
<p>这时文件夹source/_posts文件夹里会出现<strong>博客名.md</strong>的博客文章源文件</p>
<p>文件是markdown格式，书写方法有一套规范，下篇博客会讲到。PS:非常简单啦~</p>
<p>编辑好博客内容后，一顿滚键盘，依次执行以下命令：<br><code>hexo g</code> 生成静态文件<br><code>hexo d</code> 部署到Github Pages</p>
<p>就这样，你的第一篇博客就上传啦！</p>
<h2 id="更换Hexo主题"><a href="#更换Hexo主题" class="headerlink" title="更换Hexo主题"></a>更换Hexo主题</h2><p>由于默认的博客主题可能不能满足大家的需求，所以再提一下更换主题的方法。</p>
<p>首先到<a href="https://hexo.io/themes/">Hexo官网</a>中选择一款喜欢的主题</p>
<p>这里我以我博客采用的主题为例，我采用的<a href="https://github.com/cofess/hexo-theme-pure">pure主题</a></p>
<p>首先在Hexo系统文件夹中打开终端，然后输入<code>git clone https://github.com/cofess/hexo-theme-pure.git themes/pure</code></p>
<p>之后在系统目录theme文件夹下你会发现多出了pure命名的一个文件夹，这就是我们主题保存的位置,其中pure文件夹下的config.yml文件就是我<br>们博客的配置文件，在里面可以自己对博客界面进行个性化配置，详情请参看<a href="https://blog.cofess.com/2017/11/01/hexo-blog-theme-pure-usage-description.html">网址</a><br><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/tree.png" class></p>
<p>在我们的Hexo系统配置文件<strong>config.yml</strong>中，修改theme为我们的pure主题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: pure</span><br></pre></td></tr></table></figure>
<p>然后进入文件夹 <code>cd themes/pure</code></p>
<p>把主题提交<code>git pull</code></p>
<p>重新生成博客静态文件，然后部署到Github Pages<br><code>hexo g</code><br><code>hexo d</code></p>
<p>当当~我们的个性化博客就搭建完毕啦！<br><img src="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/home_page.png" class></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：表示数值的字符串</title>
    <url>/%E5%89%91%E6%8C%87Offer%EF%BC%9A%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p><strong>方法1: 正则匹配</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[]  ： 字符集合</span></span><br><span class="line"><span class="comment">()  ： 分组</span></span><br><span class="line"><span class="comment">?   ： 重复 0 ~ 1 次</span></span><br><span class="line"><span class="comment">+   ： 重复 1 ~ n 次</span></span><br><span class="line"><span class="comment">*   ： 重复 0 ~ n 次</span></span><br><span class="line"><span class="comment">.   ： 任意字符</span></span><br><span class="line"><span class="comment">\\. ： 转义后的 .</span></span><br><span class="line"><span class="comment">\\d ： 数字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(str).matches(<span class="string">&quot;[+-]?\\d*(\\.\\d+)?([Ee][+-]?\\d+)?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>方法2: 特殊情况排除</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> hasE = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> hasP = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 首字母出现的正负号合法</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; (str[i]==<span class="string">&#x27;+&#x27;</span> || str[i]==<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 小数点判定（只出现一次，且不能在E（e）后面出现）</span></span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hasE || hasP)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                hasP = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 指数判定，只出现一次，且不能在最后出现</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">&#x27;E&#x27;</span> || str[i]==<span class="string">&#x27;e&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==str.length-<span class="number">1</span> || hasE)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                hasE = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第二次出现只能在指数后面</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">&#x27;+&#x27;</span> || str[i]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str[i-<span class="number">1</span>]!=<span class="string">&#x27;E&#x27;</span> &amp;&amp; str[i-<span class="number">1</span>]!=<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非法字符判定</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!isInteger(str[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInteger</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>卡尔曼滤波与粒子滤波</title>
    <url>/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<h1 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h1><p>卡尔曼滤波解决的是如何从多个不确定数据中提取相对精确的数据。</p>
<p>1) 实践前提是这些数据满足高斯分布。</p>
<p>2) 理论前提是一个高斯斑乘以另一个高斯斑可以得到第三个高斯斑，第三个高斯斑即为提取到相对精确的数据范围。</p>
<h2 id="什么是卡尔曼滤波"><a href="#什么是卡尔曼滤波" class="headerlink" title="什么是卡尔曼滤波"></a>什么是卡尔曼滤波</h2><p>你可以在任何含有不确定因素的动态系统里使用卡尔曼滤波，而且你应该可以通过某种数学建模对系统下一步动向做一个大概的预测。尽管系统总是会受到一些未知的干扰，但是卡尔曼滤波总是可以派上用场来提高系统预估的精确度，这样你就可以更加准确地知道到底发生了什么事情(系统状态是如何转移的)。而且它可以有效利用多个粗糙数据之间的关系，而单独面对这些数据你可能都无从下手。    </p>
<p>卡尔曼滤波尤其适合动态系统。它对于内存要求极低（它仅需要保留系统上一个状态的数据，而不是一段跨度很长的历史数据）。并且它运算很快，这使得它非常适合解决实时问题和应用于嵌入式系统。</p>
<h2 id="卡尔曼滤波我们可以做什么"><a href="#卡尔曼滤波我们可以做什么" class="headerlink" title="卡尔曼滤波我们可以做什么?"></a>卡尔曼滤波我们可以做什么?</h2><p>我们举一个玩具的栗子：你开发了一款小型机器人，它可以在树林里自主移动，并且这款机器人需要明确自己的位置以便进行导航。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/k00.png" class>
<p>我们可以通过一组状态变量 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/x_.svg"> 来描述机器人的状态，包括位置和速度：</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/k01.png" class>
<p>注意这个状态仅仅是系统所有状态中的一部分，你可以选取任何数据变量作为观测的状态。在我们这个例子中选取的是位置和速度，它也可以是水箱中的水位，汽车引擎的温度，一个用户的手指在平板上划过的位置，或者任何你想要跟踪的数据。</p>
<p>我们的机器人同时拥有一个GPS传感器，精度在10m。这已经很好了，但是对我们的机器人来说它需要以远高于10m的这个精度来定位自己的位置。在机器人所处的树林里有很多溪谷和断崖，如果机器人对位置误判了哪怕只是几步远的距离，它就有可能掉到坑里。所以仅靠GPS是不够的。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/k02.png" class>
<p>同时我们可以获取到一些机器人的运动的信息：驱动轮子的电机指令对我们也有用处。如果没有外界干扰，仅仅是朝一个方向前进，那么下一个时刻的位置只是比上一个时刻的位置在该方向上移动了一个固定距离。当然我们无法获取影响运动的所有信息：机器人可能会受到风力影响，轮子可能会打滑，或者碰到了一些特殊的路况；所以轮子转过的距离并不能完全表示机器人移动的距离，这就导致通过轮子转动预测机器人位置不会非常准确。    </p>
<p>GPS传感器也会告知我们一些关于机器人状态的信息，但是会包含一些不确定性因素。我们通过轮子转动可以预知机器人是如何运动的，同样也有一定的不准确度。    </p>
<p>如果我们综合两者的信息呢？可以得到比只依靠单独一个信息来源更精确的结果么？答案当然是YES，这就是卡尔曼滤波要解决的问题。</p>
<h2 id="利用卡尔曼滤波如何看待你的问题"><a href="#利用卡尔曼滤波如何看待你的问题" class="headerlink" title="利用卡尔曼滤波如何看待你的问题?"></a>利用卡尔曼滤波如何看待你的问题?</h2><p>我们再来看下需要解决的问题，同样是上边的系统，系统状态包括位置和速度。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/k0.png" class>
<p>我们不知道位置和速度的准确值；但是我们可以列出一个准确数值可能落在的区间。在这个范围里，一些数值组合的可能性要高于另一些组合的可能性。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/v1.jpg" class>
<p>卡尔曼滤波假设所有的变量（在我们的例子中为位置和速度）是随机的且符合高斯分布（正态分布）。每个变量有一个平均值ｕ，代表了随机分布的中心值（也表示这是可能性最大的值），和一个方差 $\sigma^2$ ，代表了不确定度。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/v2.jpg" class>
<p>在上图中位置和速度是无关联的，即系统状态中的一个变量并不会告诉你关于另一个变量的任何信息。</p>
<p>下图则展示了一些有趣的事情：在现实中，速度和位置是有关联的。如果已经确定位置的值，那么某些速度值存在的可能性更高。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/v3.png" class>
<p>假如我们已知上一个状态的位置值，现在要预测下一个状态的位置值。如果我们的速度值很高，我们移动的距离会远一点。相反，如果速度慢，机器人不会走的很远。</p>
<p>这种关系在跟踪系统状态时很重要，因为它给了我们更多的信息：一个测量值告诉我们另一个测量值可能是什么样子。这就是卡尔曼滤波的目的，我们要尽量从所有不确定信息中提取有价值的信息！</p>
<p>这种关系可以通过一个称作协方差的矩阵表述。简而言之，矩阵中的每个元素 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/ij.svg" style="height:18px"> 表示了第 i 个状态变量和第 j 个状态变量之间的关系。（你可能猜到了协方差矩阵是对称的，即交换下标 i 和 j 并无任何影响）。协方差矩阵通常表示为Σ，它的元素则表示为 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/ij.svg" style="height:18px">。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e1.svg" class>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/v3.png" class>
<hr>
<p><strong>利用矩阵描述问题</strong></p>
<p>我们对系统状态的分布建模为高斯分布，所以在k时刻我们需要两个信息：最佳预估值 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/xk.svg">（平均值，有些地方也表示为u），和它的协方差矩阵 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/pk.svg" style="height:18px"></p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e2.png" class>
<p>(这里我们只记录了位置和速度，但是我们可以把任何数据变量放进我们的系统状态里)    </p>
<p>下一步，我们需要通过 k-1 时刻的状态来预测 k 时刻的状态。请注意，我们不知道状态的准确值，但是我们的预测函数并不在乎。它仅仅是对 k-1 时刻所有可能值的范围进行预测转移，然后得出一个k时刻新值的范围。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/v4.jpg" class>
<p>我们可以通过一个状态转移矩阵 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/fk.svg" style="height:18px"> 来描述这个转换</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/v5.jpg" class>
<img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/fk.svg" style="height:18px"> 把 k-1 时刻所有可能的状态值转移到一个新的范围内，这个新的范围代表了系统新的状态值可能存在的范围，如果 k-1 时刻估计值的范围是准确的话。

通过一个运动公式来表示这种预测下个状态的过程：

<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e3.png" class>
<p>整理为矩阵:</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e4.png" class>
<p>我们现在有了一个状态转移矩阵，可以简单预测下个状态，但仍不知道如何更新协方差矩阵。</p>
<p>这里我们需要另一个公式。如果我们对每个点进行矩阵A转换，它的协方差矩阵Σ会发生什么变化呢？</p>
<p>Easy，直接告诉你结果。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e5.png" class>
<p>结合（4）和（3）：</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e6.png" class>
<hr>
<p><strong>外界作用力</strong></p>
<p>我们并没有考虑到所有影响因素。系统状态的改变并不只依靠上一个系统状态，外界作用力可能会影响系统状态的变化。    </p>
<p>例如，跟踪一列火车的运动状态，火车驾驶员可能踩了油门使火车提速。同样，在我们机器人例子中，导航软件可能发出一些指令启动或者制动轮子。如果我们知道这些额外的信息，我们可以通过一个向量 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/uk.svg" style="height:18px"> 来描述这些信息，把它添加到我们的预测方程里作为一个修正。</p>
<p>假如我们通过发出的指令得到预期的加速度 a，上边的运动方程可以变化为：</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e7.png" class>
<p>矩阵形式：</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e8.png" class>
<p>其中 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/bk.svg" style="height:18px"> 称作控制矩阵，<img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/uk.svg" style="height:18px"> 称作控制向量（没有任何外界动力影响的系统，可以忽略该项）。</p>
<p>我们增加另一个细节，假如我们的预测转换矩阵不是100%准确呢，会发生什么呢?</p>
<hr>
<p><strong>外界的不确定性</strong></p>
<p>如果状态只会根据系统自身特性演变那将不会有任何问题。如果我们可以把所有外界作用力对系统的影响计算清楚那也不会有任何问题。    </p>
<p>但是如果有些外力我们无法预测呢？假如我们在跟踪一个四轴飞行器，它会受到风力影响。如果我们在跟踪一个轮式机器人，轮子可能会打滑，或者地面上的突起会使它降速。我们无法跟踪这些因素，并且这些事情发生的时候上述的预测方程可能会失灵。    </p>
<p>我们可以把“世界”中的这些不确定性统一建模，在预测方程中增加一个不确定项。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/v6.jpg" class>
<p>这样，原始状态中的每一个点可以都会预测转换到一个范围，而不是某个确定的点。可以这样描述： <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/xk1.svg" style="height:18px"> 中的每个点移动到一个符合方差 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/qk.svg" style="height:18px"> 的高斯分布里。另一种说法，我们把这些不确定因素描述为方差为 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/qk.svg" style="height:18px"> 的高斯噪声。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/v7.jpg" class>
<p>这会产生一个新的高斯分布，方差不同，但是均值相同。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/v8.jpg" class>
<p>对 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/qk.svg" style="height:18px"> 简单叠加，可以拿到扩展的方差，这样就得到了完整的预测转换方程。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e9.png" class>
<p>新的预测转换方程只是引入了已知的可以预测的外力影响因素。</p>
<p>新的不确定性可以通过老的不确定性计算得到，通过增加外界无法预测的、不确定的因素成分。</p>
<p>到这里，我们得到了一个模糊的估计范围，一个通过 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/xk.svg" style="height:18px"> 和 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/pk.svg" style="height:18px"> 描述的范围。如果再结合我们传感器的数据呢？</p>
<hr>
<p><strong>通过测量值精炼预测值</strong></p>
<p>我们可能还有一些传感器来测量系统的状态。目前我们不用太关心所测量的状态变量是什么。也许一个测量位置一个测量速度。每个传感器可以提供一些关于系统状态的数据信息，每个传感器检测一个系统变量并且产生一些读数。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/v9.jpg" class>
<p>注意传感器测量的范围和单位可能与我们跟踪系统变量所使用的范围和单位不一致。我们需要对传感器做下建模：通过矩阵 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/hk.svg" style="height:18px"></p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/v10.jpg" class>
<p>我们可以得到传感器读数分布的范围：</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e10.png" class>
<p>卡尔曼滤波也可以处理传感器噪声。换句话说，我们的传感器有自己的精度范围，对于一个真实的位置和速度，传感器的读数受到高斯噪声影响会使读数在某个范围内波动。<br><img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/v11.jpg" class></p>
<p>我们观测到的每个数据，可以认为其对应某个真实的状态。但是因为存在不确定性，某些状态的可能性比另外一些可能性更高。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/v12.jpg" class>
<p>我们将这种不确定性的方差为描述为 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/rk.svg" style="height:18px"> 。读数的平均值为 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/zk.svg" style="height:18px"> 。</p>
<p>所以现在我们有了两个高斯斑，一个来自于我们预测值，另一个来自于我们测量值。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/v13.jpg" class>
<p>我们必须尝试去把两者的数据预测值（粉色）与观测值（绿色）融合起来。</p>
<p>所以我们得到的新的数据会长什么样子呢？对于任何状态( $z_1$ , $z_2$ )，我们有两个可能性：（1）传感器读数更接近系统真实状态（2）预测值更接近系统真实状态。    </p>
<p>如果我们有两个相互独立的获取系统状态的方式，并且我们想知道两者都准确的概率值，我们只需要将两者相乘。所以我们将两个高斯斑相乘。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/v14.jpg" class>
<p>相乘之后得到的即为重叠部分，这个区域同时属于两个高斯斑。并且比单独任何一个区域都要精确。这个区域的平均值取决于我们更取信于哪个数据来源，这样我们也通过我们手中的数据得到了一个最好的估计值。</p>
<p>唔~这看上去像另一个高斯斑。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/v15.png" class>
<p>已经被证明，当你对两个均值方差都不相同的侧高斯斑进行相乘，你可以得到一个新的高斯斑。你可以自行推导：新高斯分布的均值和方差均可以通过老的均值方差求得。</p>
<hr>
<p><strong>高斯乘法</strong></p>
<p>我们从一维数据开始，一维高斯（均值 u,方差 $\sigma^2$ ）被定义为：</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e11.png" class>
<p>我们想知道两个高斯分布相乘会发生什么。蓝色曲线代表了两个高斯分布的交集部分。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e12.png" class>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e13.png" class>
<p>把（9）带入（10）然后做一些变换，可以得到<br><img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e14.png" class></p>
<p>因式分解出一个部分，表示为 k<br><img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e15.png" class></p>
<p>注意你是如何将处理之前的预测值，仅仅是简单将两者叠加相乘就可以得到新的预测值。现在看下这个公式是多么简单。</p>
<p>如果是一个多维矩阵呢？我们将（12）与（13）表示为矩阵形式。Σ 表示协方差矩阵， <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/u.svg" style="height:18px"> 表示平均向量：</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e16.png" class>
<p>K 被称为卡尔曼增益，待会会用到。</p>
<p>简单，我们快结束了。</p>
<hr>
<p><strong>综合所有信息</strong></p>
<p>我们有两个独立的维度去估计系统状态：</p>
<p>预测值</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e17.png" class>
<p>测量值<br><img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e18.png" class></p>
<p>将两者相乘带入（15）寻找他们的重叠区域：<br><img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e19.png" class></p>
<p>从（14）可知，卡尔曼增益为<br><img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e20.png" class></p>
<p>将（16）中的 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/hk.svg" style="height:18px"> 从两边约去，注意（17）中的K也包含 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/hk.svg" style="height:18px"> 。得到<br><img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/e21.png" class></p>
<p>至此，我们得到了每个状态的更新步骤 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/xk_.svg" style="height:20px"> 是我们最佳的预测值，我们可以持续迭代（独立于 <img class="inline-img" src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/pk_.svg" style="height:20px">）。</p>
<img src="/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E4%B8%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/v15.jpg" class>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上所有公式，仅需要实现（7）（18）（19）    </p>
<p>这使你可以对任何线性系统建模。对于非线性系统，可以使用扩展卡尔曼滤波，只是对观测值和预测值的平均值进行简单线性化。</p>
<p>如果我可以利用卡尔曼解决我的问题，那么希望读者也可以认识到这有多酷，并且在某个新的领域将它实用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/collection/199330648">知乎_如何通俗并尽可能详细地解释卡尔曼滤波？</a></p>
<p><a href="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/#mathybits">How a Kalman filter works, in pictures</a></p>
<h1 id="粒子滤波"><a href="#粒子滤波" class="headerlink" title="粒子滤波"></a>粒子滤波</h1><h2 id="什么是粒子滤波"><a href="#什么是粒子滤波" class="headerlink" title="什么是粒子滤波"></a>什么是粒子滤波</h2><p>粒子滤波是卡尔曼滤波的简化，放松了约束条件，即数据分布不一定是高斯分布，使其更具有泛化能力及对离散值有很好的支持，但是其计算复杂度也相应增加。</p>
<h2 id="粒子滤波的工作原理"><a href="#粒子滤波的工作原理" class="headerlink" title="粒子滤波的工作原理"></a>粒子滤波的工作原理</h2><p>粒子滤波关键是粒子的选取，粒子其实就是预测状态各种有限的可能取值，称为“粒子”，初始粒子的分布一般假设均匀分布。</p>
<p>测量系统负责给出粒子。</p>
<p>状态系统通过上一时刻的粒子状态得到评估这一时刻的粒子各个概率大小。</p>
<p>测量系统给出各个粒子的权重，对所有粒子加权求和得到当前的粒子状态。</p>
<p>测量系统根据粒子的权重，筛选得到下一时刻的粒子，权重大的粒子被选出来的概率大，</p>
<p>循环往复，直到预测完成。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>粒子滤波的关键在于粒子的选择。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>控制论</tag>
      </tags>
  </entry>
  <entry>
    <title>在Linux系统中同步更新我们的Github博客</title>
    <url>/%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E6%88%91%E4%BB%AC%E7%9A%84Github%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><p>类似于<strong>版本管理</strong>，我们把hexo博客文件系统在Github上建立一个分支，通过管理分支提交最新的博客文件系统，保证我们博客框架的更新。然后我们基于最新的<strong>博客框架</strong>，撰写文章，进行Github Pages网页的更新，即我们博客内容的更新。</p>
<p><strong>创建两个分支，一个用于存放博客静态资源，一个用于备份博客的部署文件。</strong></p>
<p><a href="https://www.jianshu.com/p/0b1fccce74e0">参考资料</a></p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><blockquote>
<ol>
<li>一台Linux系统的电脑（我的linux系统是Ubuntu 18.04.2 LTS）</li>
<li>安装<code>node.js</code> 及 <code>npm</code></li>
<li>安装 <code>ssh</code></li>
<li>安装 <code>git</code></li>
<li>按照我们前面教程搭建好的博客</li>
</ol>
</blockquote>
<h1 id="创建Github-博客仓库分支"><a href="#创建Github-博客仓库分支" class="headerlink" title="创建Github 博客仓库分支"></a>创建Github 博客仓库分支</h1><p>首先在我们搭建Hexo博客的电脑上，创建我们博客仓库在Github上的分支。</p>
<ol>
<li><p>打开我们的博客仓库，选择<strong>setting</strong>：</p>
 <img src="/%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E6%88%91%E4%BB%AC%E7%9A%84Github%E5%8D%9A%E5%AE%A2/1.png" class>
</li>
<li><p>选择<strong>Branches</strong>,创建博客仓库的Hexo分支，并将其设置为默认分支。</p>
 <img src="/%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E6%88%91%E4%BB%AC%E7%9A%84Github%E5%8D%9A%E5%AE%A2/2.png" class>
</li>
<li><p>将该仓库克融到本地，并把本地博客的(<strong>所有Hexo目录下文件</strong>)全部拷贝进username.github.io文件目录中去。</p>
<img src="/%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E6%88%91%E4%BB%AC%E7%9A%84Github%E5%8D%9A%E5%AE%A2/4.png" class>
<img src="/%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E6%88%91%E4%BB%AC%E7%9A%84Github%E5%8D%9A%E5%AE%A2/5.png" class>
</li>
<li><p>然后把更新后的博客部署文件提交到Github的hexo分支中。</p>
</li>
</ol>
<p>依次执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &#39;some info&#39;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意事项</strong>：</p>
<ul>
<li>将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。</li>
</ul>
</blockquote>
<ol>
<li>然后我们的博客备份分支就创建好了。</li>
</ol>
<h1 id="Linux-部署项目"><a href="#Linux-部署项目" class="headerlink" title="Linux 部署项目"></a>Linux 部署项目</h1><ol>
<li><p><a href="https://www.cnblogs.com/xiyuan2016/p/7878304.html">安装Node.js 与 npm</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/lxm20145215----/p/5905765.html">安装git</a></p>
</li>
<li><p><a href="https://blog.csdn.net/angus_01/article/details/80118088">linux与Github建立联系</a></p>
</li>
<li><p>把我们创建好的博客备份仓库<code>clone</code>到本机（linux）</p>
<p> 4.1 在要保存的位置执行语句 <code>git clone git@github.com:your.github.io/your.github.io.git</code></p>
<p> 4.2 <strong>进入username.github.io目录，执行<code>npm install</code></strong> (由于仓库有一个.gitignore文件，里面默认是忽略掉 node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录，所以要安装依赖)</p>
</li>
<li><p>安装hexo插件</p>
<p> <code>sudo npm install hexo-cli -g</code></p>
</li>
<li><p>撰写我们的博客文章，然后依次执行下面指令，更新我们的博客备份。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#39;some info&#39;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li>
<li><p>更新博客界面</p>
<p> <code>hexo d</code></p>
</li>
</ol>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><blockquote>
<p><strong>1. 每当撰写博客前，先 <code>git pull</code>，获取最新的博客备份。</strong></p>
<p><strong>2. 写完博客后，先依次执行<code>hexo clean  、 hexo g 、 git add .  、 git commit -m &#39;some info  、 git push&#39;</code>进行博客备份部署文件更新。</strong></p>
<p><strong>3. 最后执行 <code>hexo  d</code>部署博客界面，实现博客更新。</strong> </p>
</blockquote>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>工作签约小记</title>
    <url>/%E5%B7%A5%E4%BD%9C%E7%AD%BE%E7%BA%A6%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码不对，请重试" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="31479f7bf5f1334c095d83b31bfb58307384f071f9dcf467adb071bbdb2629e9">d2d85511782da2007828d4bf9243cc92bcf798e72b8c748078cac6c90b0018c23f950acffb8c9672d2905d412631d7d4ff9d9d312327427d0d1afef51111a900f8fe5f10fd734def824837ab2f0b06878acd2bbe5f1b2d396872d356b34300dedc2a7bcc4aeb7ca85ab2ee546233db2547a5479af61edcb72cb9421f985ee69f523c3f50ad750c8869e636989b6b1542187201fe375a7e0681d19a3de5d0ce40ea57b8edfbf50d08a271c2fc3bc076ba3ca9354198a1f9ed3a8c8a192b81b51832f757f60e1df068ff0235e817359686ae8d68ee8a5ae729dd51edfa262d0c5beaf1d4e4adc7f3d8be5183b07538e53a58891765fe24d605185b6b256f036605dfd03fe543c667ded684b0361b86ea54187f505c5f968b96e72a53247ca4c76f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入查看密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>文档对象模型DOM</title>
    <url>/%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8BDOM/</url>
    <content><![CDATA[<h1 id="DOM是什么？"><a href="#DOM是什么？" class="headerlink" title="DOM是什么？"></a>DOM是什么？</h1><p>DOM，即Document Object Model，文档对象模型，用于操作HTML的编程接口。</p>
<p>它描绘了一个层次化的节点树，允许编程人员进行节点的添加、修改与删除等操作。</p>
<h1 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h1><p>DOM 1级定义了一个<strong>Node</strong>接口，由DOM中所有的节点实现。</p>
<p>一共有<strong>12</strong>中节点类型，其中包括<font color="#f07c82">Document、Element</font>节点类型等，可通过node.<strong>nodeType</strong>查询每个节点的类型，例如，Element的节点类型返回数值为1。</p>
<p>每一个节点都有<strong>childNodes、parentNode、previousSibling、nextSibling、firstChild、lastChild</strong>等节点查询方法。</p>
<center><img src="/%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8BDOM/node.png" class></center>

<p>还有<strong>appendChild、insertBefore、replaceChild、removeChild、cloneNode</strong>等操作节点的方法。</p>
<h2 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h2><p>Document节点表示整个文档。浏览器中的document是一个全局对象，表示HTML页面，是HTMLDocument对象的实例。</p>
<blockquote>
<p>document.documentElement：快速取得对html的引用。<br>document对象只有一个子节点，也就是&lt; html &gt;对象，没必要使用节点操作方法。<br>document的title、URL、domain、referrer等方法可以访问网页的标题、URL地址、域名及连接当前URL的前一URL。<br>document.getElementById()：获取指定id的元素。<br>ducument.getElementsByTagName()：获取指定标签名的元素，例如<code>var img = ducument.getElementsByTagName(&quot;img&quot;)</code>，返回一个HTMLCollection类型的实例，其中<code>img.namedItem(&quot;imgName&quot;)</code>可以返回执行name的元素。<br>ducument.getElementsByName()：获取指定name的元素集合。<br>ducument.write()与ducument.writeln()写入文档。<br>getElementsByClassName()：获取同一类的元素列表，返回NodeList。<br>document.activeElement()：获得当前焦点所在的元素，例如页面加载中，焦点所在的元素是document.body，之后变成null。<br>document.hasFocus()：判断当前文档是否获取了焦点。<br>document.readyState：”loading”正在加载文档，”complete”加载完毕。<br>document.compatMode：”CSS1Compat”渲染模式为标准，”BackCompat”渲染模式为混杂模式。<br>document.charset：查看与设置文档字符集，默认”UTF-16”。</p>
</blockquote>
<h2 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h2><p>Element类型表现为HTML元素，每个HMTML元素都存在<strong>id、title、dir、className、lang</strong>属性。</p>
<blockquote>
<p>getAttribute() setAttribute()和 removeAttribute()操作属性值。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">alert(div.getAttribute(<span class="string">&quot;id&quot;</span>)); <span class="comment">//&quot;myDiv&quot;</span></span><br><span class="line"></span><br><span class="line">div.setAttribute(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;someOtherId&quot;</span>);</span><br><span class="line"></span><br><span class="line">div.removeAttribute(<span class="string">&quot;class&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>attributes属性，是表示一个元素属性的动态的集合，可通过<strong>nodeValue</strong>获取标签值。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = div.attributes.getNamedItem(<span class="string">&quot;id&quot;</span>).nodeValue;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> document.createElement()创建元素。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h2><p>Text，文本节点，用于表示不含HTML标签的纯文本。包含在element类型中。</p>
<p> appendData(text)：将 text 添加到节点的末尾。<br> deleteData(offset, count)：从 offset 指定的位置开始删除 count 个字符。<br> insertData(offset, text)：在 offset 指定的位置插入 text。<br> replaceData(offset, count, text)：用 text 替换从 offset 指定的位置开始到 offset+ count 为止处的文本。<br> splitText(offset)：从 offset 指定的位置将当前文本节点分成两个文本节点。<br> substringData(offset, count)：提取从 offset 指定的位置开始到 offset+count 为止处的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 没有内容，也就没有文本节点 --&gt; </span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;!-- 有空格，因而有一个文本节点 --&gt; </span><br><span class="line">&lt;div&gt; &lt;/div&gt;</span><br><span class="line">&lt;!-- 有内容，因而有一个文本节点 --&gt; </span><br><span class="line">&lt;div&gt;Hello World!&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得div的文本节点，并修改其值</span></span><br><span class="line">div.firstChild.nodeValue = <span class="string">&quot;Some other message&quot;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>document.createTextNode()创建新文本节点。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">element.className = <span class="string">&quot;message&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br></pre></td></tr></table></figure>
<h1 id="DOM操作技术"><a href="#DOM操作技术" class="headerlink" title="DOM操作技术"></a>DOM操作技术</h1><h2 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h2><p>可以通过<font color="#f07c82">doucument.createElement()</font>方法实现动态script代码的引入或创建。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;javascript&quot;</span>);</span><br><span class="line">script.type = <span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line">script.src = <span class="string">&quot;client.js&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure></p>
<p>或者可以通过自定义代码的方式调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptString</span>(<span class="params">code</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>); script.type = <span class="string">&quot;text javascript&quot;</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        script.appendChild(<span class="built_in">document</span>.createTextNode(code)); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex)&#123; </span><br><span class="line">        script.text = code; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadScriptString(<span class="string">&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h2><p>CSS样式可以通过<font color="#f07c82">style</font>属性或元素嵌入样式，或者可以通过&lt; link &gt;引入CSS外部文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> type=<span class="string">&quot;text/css&quot;</span> href=<span class="string">&quot;index.css&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>与动态script一样的原理，可以通过实现样式的动态添加。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">&quot;link&quot;</span>); </span><br><span class="line">link.rel = <span class="string">&quot;stylesheet&quot;</span>; </span><br><span class="line">link.type = <span class="string">&quot;text/css&quot;</span>; </span><br><span class="line">link.href = <span class="string">&quot;style.css&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>]; </span><br><span class="line">head.appendChild(link);</span><br></pre></td></tr></table></figure>
<p>或者可以通过自定义代码的方式调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">&quot;style&quot;</span>); </span><br><span class="line">style.type = <span class="string">&quot;text/css&quot;</span>; </span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    style.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;body&#123;background-color:red&#125;&quot;</span>)); </span><br><span class="line">&#125; <span class="keyword">catch</span> (ex)&#123; </span><br><span class="line">    style.styleSheet.cssText = <span class="string">&quot;body&#123;background-color:red&#125;&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">head.appendChild(style);</span><br></pre></td></tr></table></figure>
<h1 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a>DOM扩展</h1><h2 id="选择符"><a href="#选择符" class="headerlink" title="选择符"></a>选择符</h2><ol>
<li><font color="#f07c82">querySelector()与querySelectorAll()</font>方法。</li>
</ol>
<blockquote>
<p>querySelector()<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取得 body 元素</span></span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">&quot;body&quot;</span>); </span><br><span class="line"><span class="comment">//取得 ID 为&quot;myDiv&quot;的元素</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#myDiv&quot;</span>); </span><br><span class="line"><span class="comment">//取得类为&quot;selected&quot;的第一个元素</span></span><br><span class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.selected&quot;</span>); </span><br><span class="line"><span class="comment">//取得类为&quot;button&quot;的第一个图像元素</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.body.querySelector(<span class="string">&quot;img.button&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>querySelectorAll()<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取得某&lt;div&gt;中的所有&lt;em&gt;元素（类似于 getElementsByTagName(&quot;em&quot;)） </span></span><br><span class="line"><span class="keyword">var</span> ems = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).querySelectorAll(<span class="string">&quot;em&quot;</span>); </span><br><span class="line"><span class="comment">//取得类为&quot;selected&quot;的所有元素</span></span><br><span class="line"><span class="keyword">var</span> selecteds = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.selected&quot;</span>); </span><br><span class="line"><span class="comment">//取得所有&lt;p&gt;元素中的所有&lt;strong&gt;元素</span></span><br><span class="line"><span class="keyword">var</span> strongs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;p strong&quot;</span>);</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈区块链与比特币</title>
    <url>/%E6%B5%85%E8%B0%88%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81/</url>
    <content><![CDATA[<h1 id="什么是区块链和比特币？"><a href="#什么是区块链和比特币？" class="headerlink" title="什么是区块链和比特币？"></a>什么是区块链和比特币？</h1><p>有人说区块链是新一代价值互联网，有人说它是最慢的数据库，有人说区块链是一项类似于蒸汽机一样巨大的发明创新，也有人说区块链是一个巨大的庞氏骗局。到底什么是比特币，为什么它这么火？本篇文章将带你揭示比特币的前世今生。</p>
<p><code>区块链跟比特币的定义</code></p>
<blockquote>
<p>区块链是一种去中心化的分布式记账本，而比特币是账本中所记录的数字货币的一种实现。</p>
</blockquote>
<p>作为区块链的一种实际应用，<code>比特币</code>（Bitcoin）的原型是由中本聪（Satoshi Nakamoto）在2008年11月1日发表的一篇论文中提出的。比特币的真正诞生是在2009年1月3日。到今天为止，比特币的市值已经水涨船高，一枚比特币的价值高达55484.70美元，合362869.94元人民币！</p>
<p><img src="https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/bitcoinline.png" alt="比特币市值趋势图"></p>
<ul>
<li><a href="https://bitcoin.org/bitcoin.pdf">比特币白皮书</a></li>
<li><a href="https://bitcoin.org/files/bitcoin-paper/bitcoin_zh_cn.pdf">比特币白皮书中文版</a></li>
</ul>
<h1 id="区块链要解决什么问题？"><a href="#区块链要解决什么问题？" class="headerlink" title="区块链要解决什么问题？"></a>区块链要解决什么问题？</h1><p>既然区块链是一种去中心化的货币结算体系，那么原来的货币结算体系有什么问题呢？中本聪在论文的原文讲到：<strong>中心化的金融机构由于信任问题，不可避免在交易过程中存在仲裁与纠纷，就导致无法实现不可撤销的交易，在撤销过程中会导致额外的支付成本</strong>。当然，这只是现有中心化货币体系不可避免的问题，而区块链基于分布式存储技术跟密码学，<strong>实现了交易的不可撤销性，通过去中心化金融机构的方式，实现点对点的交易，目的是通过加密上的可靠性解决人们之间的信任问题，从而提高效率</strong>。</p>
<blockquote>
<p>互联网通过提高信息传播的速度来提高效率；区块链通过降低信任成本提高效率。</p>
</blockquote>
<h1 id="区块链的工作原理"><a href="#区块链的工作原理" class="headerlink" title="区块链的工作原理"></a>区块链的工作原理</h1><p>区块链是<code>价值互联网</code>，人们间的财富通过比特币的数量度量，比特币的交易记录代表的是价值的交换。比特币本身是一种<code>加密货币</code>（crypto-currency），是一种虚拟的数字货币，由一串复杂代码组成。基于密码学的设计确保了比特币的所有权不能被篡改，同时保持了一定的匿名性。</p>
<p>区块链为了实现分布式货币体系的功能，需要解答以下几个问题：</p>
<ol>
<li>怎么记账？</li>
<li>怎么转账？</li>
<li>由谁发行货币？</li>
</ol>
<h2 id="怎么记账？"><a href="#怎么记账？" class="headerlink" title="怎么记账？"></a>怎么记账？</h2><p>区块就是记账本，记账操作由区块完成。当一笔交易发生时，需向全体区块广播，然后所有区块都记录下这笔交易信息，完成记账。</p>
<hr>
<p><strong>区块</strong></p>
<blockquote>
<p>区块就是一个带有时间戳的记账本，链就是哈希指针，将区块相连。</p>
</blockquote>
<p>区块分布在不同的网络节点中，且是分布式的。区块的组成包括<code>块头</code>（Block Header）跟<code>块体</code>（Block Body）。</p>
<ul>
<li><p>块头：记录了区块链的版本、指向前一个区块块头的哈希指针（对前一个区块块头算哈希值）、Merkle tree的根哈希值、目标域（target）和随机数（nonce）。</p>
</li>
<li><p>块体：保存交易列表</p>
</li>
</ul>
<p>其中目标域和随机数是挖矿用到的参数，而哈希指针就是连接区块的链。</p>
<blockquote>
<p>哈希指针既可以指向内容地址（通过结合 key-value 的数据库实现，key为当前区块哈希值，value为指向的前一区块哈希值），又可以保存内容的哈希值。如果内容改变，哈希指针也会相应改变。这样不诚实的区块篡改区块链的交易记录几乎不可能实现，因为一旦不诚实区块的交易记录篡改，该区域的哈希值就会改变，后面所有区块的哈希值都要修改，除非不诚实的区块与后面所有区块串通，这几乎是不可能的。</p>
</blockquote>
<hr>
<p><strong>哈希算法</strong></p>
<p>区块链中的哈希指针通过密码学中的<code>加密哈希算法</code>（cryptographic hash function）计算得到，它具有三个性质：</p>
<ul>
<li><p>哈希碰撞 （collision resistance）</p>
<p>  哈希碰撞的数学表达为 $x\neq y\;H\left(x\right)=H\left(y\right)$，即不同的输入值得到了相同的哈希值。理论上任何一种哈希算法都不可避免哈希碰撞，因为输入空间是无限大的，而输出空间只有 $2^{256}$（以区块链所用的SHA-256算法为例）。但想制造哈希碰撞，需要通过暴力求解（brute-force）的方法。但是这种做法并不现实，因为计算量实在太大。借用此原理，可以通过检验一段信息（一串字符）的哈希值是否变化来核实这段信息是否被篡改。目前尚没有哈希函数被证明为哈希碰撞的，只能通过实践的经验。没有百分百安全的哈希函数，曾经被认为安全的哈希函数MD5已被找到人为制作哈希碰撞的方法。</p>
</li>
<li><p>计算不可逆（hiding）<br>  哈希函数的计算为单向的，计算过程不可逆。即计算出的哈希值隐藏了输入的任何信息。只能通过暴力的方法，检测哪个输入值的哈希值为目标哈希值。但是只要输入空间足够大，且输入分布比较均匀，各种取值的可能性接近，则难以实现哈希函数的逆运算，除非地球爆炸（SHA-256算法为例）。为了使得输入满足要求，同时将输入加入一个随机数nonce，再一起哈希，即 $H(x\parallel nonce)$，随机数的分布是比较均匀的。</p>
</li>
<li><p>puzzle friendly<br>  值结果是不可预测的，通过输入值我无法预测将来哈希值的取值范围。主要用于挖矿中<code>工作量证明</code>（proof of work）的计算，通过找到一个比特币块头的随机数nonce，使得 $H(block header)\leq target$,这个target就是目标哈希值。</p>
</li>
</ul>
<hr>
<p><strong>Merkle tree</strong></p>
<p>块体中的交易记录通过默克尔树（Markle tree）的结构体来保存。它的结构与二叉树相同，唯一的区别是指针用哈希指针替代。这样做的目的是为了快速计算记录的交易有没有变化。</p>
<p><img src="https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/merkletree.png" alt="默克尔树"></p>
<p>Merkle tree 主要用来提供 Merkle proof（默克尔证明），来证明一笔交易是否真正发生。Merkle proof的原理是通过比较待验证交易（叶子节点）所最终得到的Merkle tree的根哈希值与轻节点块头保存的根哈希值是否相等即可，需要辅助计算的另一半哈希值由全节点的块体提供。</p>
<hr>
<p><strong>区块总结</strong></p>
<p>区块的物理实体搭载在一个网络节点中，负责对发生过的比特币交易记账。通过哈希指针与前一个区块相连，避免了不诚实区块对交易内容的篡改。每一笔交易都用一个 Merkle tree 的叶子节点保存，通过哈希指针最终指向根节点。区块的块头只保存Merkle tree根节点的哈希值，用来进行Merkle proof检验。</p>
<ul>
<li><p>区块最终会指向第一个区块，被称为创世纪块（genesis block）。</p>
</li>
<li><p>区块链分为全节点与轻节点。</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">全节点</th>
<th style="text-align:center">轻节点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">一直在线</td>
<td style="text-align:center">不是一直在线</td>
</tr>
<tr>
<td style="text-align:center">在本地硬盘上维护完整的区块链信息</td>
<td style="text-align:center">不用保存整个区块链，只要保存每个区块的块头</td>
</tr>
<tr>
<td style="text-align:center">在内存里维护UTXO集合，以便快速检验交易的正确性</td>
<td style="text-align:center">不同保存全部交易，只保存与自己相关的交易</td>
</tr>
<tr>
<td style="text-align:center">监听比特币网络上的交易信息，验证每个交易的合法性</td>
<td style="text-align:center">无法检验网上发布的区块的合法性</td>
</tr>
<tr>
<td style="text-align:center">决定哪些交易会被打包到区块里</td>
<td style="text-align:center">可以验证挖矿的难度</td>
</tr>
<tr>
<td style="text-align:center">监听别的矿工挖出来的区块，验证其合法性</td>
<td style="text-align:center">只能检测哪个是最长链，不知道哪个是最长合法链</td>
</tr>
<tr>
<td style="text-align:center">挖矿<br>（决定沿哪条链挖下去）<br>（当出现等长的分叉，选择哪一个分叉）</td>
<td style="text-align:center">不能决定挖矿</td>
</tr>
</tbody>
</table>
</div>
<h2 id="怎么转账"><a href="#怎么转账" class="headerlink" title="怎么转账"></a>怎么转账</h2><p>转账需要开户，区块链中的开户不需要向一个中心化的机构申请，只需要自己在本地创建一个<code>公私钥对</code>（比特币中公私钥对生成冲突的概率很小，比地球爆炸的概率还小，这样一个私钥就对应一个唯一的电子身份）。</p>
<hr>
<p><strong>公私钥对</strong></p>
<p>公私钥对来自非对称加密（asymmetric encryption algorithm），公钥（public key）对内容加密，私钥（privte key）用来解密，同时私钥也可以用来加密，公钥用来解密。对称加密是用同一把密钥实现内容的加密，关键是找到一个安全传输密钥的途径，否则一旦密钥被破解，所加密的内容很容易被窃听或篡改。非对称加密用公钥加密，配对的私钥解密。公钥可以公开，且不能实现解密，私钥保存在本地，无需随内容传输，这样就保证了加密内容的安全，与https协议的原理一致。区块链中的利用非对称加密实现<code>数字签名</code>，对个人信息进行验证，<strong>用通讯方的私钥加密，然后用其公钥解密验证</strong>。</p>
<hr>
<p>自己给对方转账只需要对方的<code>地址</code>、要转的比特币数量以及自己的<code>公钥</code>即可。</p>
<p>对方地址根据公钥算哈希再通过一定计算得到，自己的公钥是为了验证这笔交易的数字签名是由自己的私钥生成，验证自己的身份。</p>
<p><strong>双花攻击</strong>（double-spending attack）</p>
<p>如果我利用网络的延迟，同时向双发转一笔矛盾的比特币，例如我只有5个比特币，我同时向甲乙两人转5个比特币，就构成了双花攻击。</p>
<blockquote>
<p>区块之间除了有哈希指针指向前一个区块，还有指针指向比特币的来源，这样在转账的同时回回溯检测用户到底有没有双花行为，防范双花攻击。</p>
</blockquote>
<h2 id="由谁发行货币"><a href="#由谁发行货币" class="headerlink" title="由谁发行货币"></a>由谁发行货币</h2><p><code>Coinbase transaction 是生成比特币的唯一方法.</code></p>
<p><code>创世纪</code>，即第一个区块链的区块，2009年1月3日由中本聪在位于芬兰赫尔辛基的一个小型服务器上挖出，并获得了50个比特币的奖励。后面每次新块的产生，系统都会给予一定的比特币奖励，这也是比特币的唯一来源。由于比特币像黄金一样供应量极少且数量有限，所以区块的挖掘被成为挖矿。</p>
<p><strong>比特币产生规则</strong>：起初的21w个区块会有50个比特币的初块奖励，超过21w个区块后，每个区块会有25个比特币，再超过21w个区块后，每个区块获得到奖励会继续减半，只有12.5个比特币。</p>
<hr>
<p><strong>Proof of work</strong></p>
<p>Proof of work —— CPU算力证明是区块被挖出的方法。因此比特币是跟CPU算力资源挂钩。</p>
<blockquote>
<p>区块头有一个 target 目标域，确定了要计算的哈希值的数值范围，只要对区块计算出的哈希值在此范围内，那么这个区块就被挖出。候选区块通过修改区块头中的 nonce 随机数实现对区块哈希值的控制。由于后期挖矿的人不断增加，挖矿的设备也像军备竞赛一样越发豪华（CPU-&gt;GPU-&gt;ASIC芯片 Application Specific Integrated），因此为了保证比特币数量的稳定，通过减小target 目标域提高计算难度。出块难度为10分钟生成一个区块。比特币规定每2016个区块后调整难度阈值，大概两周调整一次。</p>
</blockquote>
<p>通过CPU算力选出记账的区块，可以极大避免<code>51%攻击</code>。因为如果攻击者想要控制区块的生成，需要付出超过51%算力的计算资源，成本上是根本不划算的。</p>
<p><strong>最长合法链</strong></p>
<p>如果两个区块同时被挖出，那么区块链都认为两者有效。后续的候选区块可以选择在分叉的区块中任意选择，直到哪一条链的长度率先到达6，就将此链视为最长合法链，然后撤销另一条分叉链。</p>
<p>比特币初期虽然竞争少，奖励多，但当时比特币不值钱，曾经出现过2w个比特币买1个披萨的案例。而现在虽然比特币竞争激烈，所耗电费相当于<a href="http://jandan.net/p/108666">挪威一年的能源消耗</a>，但价值高。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>区块链本身是一种理论创新，分布式存储、加密算法以及通讯都是现有的技术。它主要解决中心化货币交易体系因不信任导致的纠纷所带来的支付代价问题，包括一些已有的支付方式无法解决的问题，例如跨境付款，而不是与已有的支付方式做竞争。区块链通过密码学上的不可篡改性，把数据从不可信变成可信。从技术角度看，区块链是互联网发展的一个升级，它和互联网相同的是，能提高社会整体的工作效率；不同的是，互联网从通信速度方面提高效率，区块链从信任角度提高效率。未来的区块链项目关键是看能否可以协助人们解决生产生活中的效率问题，而不能被神话，它的概念也不能被滥用，同时它的监管仍需要很长的路要走。</p>
<hr>
<p><strong>参考资料</strong></p>
<ol>
<li><p><a href="https://www.bilibili.com/video/BV1Vt411X7JF?p=1">北大《区块链技术与应用》公开课</a></p>
</li>
<li><p><a href="https://bitcoin.org/bitcoin.pdf">区块链白皮书</a></p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1oJ411E7Lg?from=search&amp;seid=17070640844222129150">【回形针PaperClip】区块链到底是什么？</a></p>
</li>
<li><p><a href="http://jandan.net/p/108666">今年世界总发电量的0.6%被用于挖比特币</a></p>
</li>
<li><p><a href="http://www.xueguoliang.cn/index.php/archives/93/">区块链分享</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>科技</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解JS基础</title>
    <url>/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3JS%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="JS-的-Number-类型精度问题"><a href="#JS-的-Number-类型精度问题" class="headerlink" title="JS 的 Number 类型精度问题"></a>JS 的 Number 类型精度问题</h1><p>我们知道，Java 语言中的长整型范围为 +2^63-1 ~ -2^63-1，而 JavaScript 的 Number 基本类型采用 64 位浮点型表示，为什么 JS 中整型的最大安全范围不是 +2^63-1 ~ -2^63-1 呢？</p>
<p>Java的 的长整型整数也是采用 64 位表示，除了第一位是符号位，剩下的 63 位都可以表示数字。</p>
<p>而 JavaScript 没有单独的整型类型 (Bigint 除外，且 Bigint 不能参与与 Number 类型的运算)，整型、浮点型都统一用 64 位浮点型来表示，采用的是 IEEE754 标准。</p>
<p><strong>IEEE754</strong> 规定，64 位的浮点型中，第 1 位表示正负，2~12 位表示指数位 (实际存储的时候必须加上一个偏移值 1023)，剩下的 64 - 1- 11 = 52 位表示整数位，因为浮点数采用科学计数法，第一位固定是 1，可以不用表示，但是运算时会加上。</p>
<p>比如：</p>
<p>0 01111111011 0000000000000000000000000000000000000000000000000000</p>
<p>表示的就是 1.0000000000000000000000000000000000000000000000000000 * 2^(1019 - 1023) = 0.0625</p>
<h2 id="Number-Max-Value-与-Number-MAX-SAFE-INTEGER"><a href="#Number-Max-Value-与-Number-MAX-SAFE-INTEGER" class="headerlink" title="Number.Max_Value 与 Number.MAX_SAFE_INTEGER"></a>Number.Max_Value 与 Number.MAX_SAFE_INTEGER</h2><p>我们打印 Number 的这两个属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_SAFE_INTEGER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="comment">// 9007199254740991</span></span><br></pre></td></tr></table></figure>
<p><strong>1. Number.Max_Value</strong></p>
<p>其中 Number.Max_Value 就是 Number 类型可以表示的最大浮点数，计算方式如下：</p>
<p>你可以猜到会是：</p>
<p>0 11111111111 1111111111111111111111111111111111111111111111111111,</p>
<p>但这种情况在 IEEE754 标准中表示 NaN，最大的数其实是：</p>
<p>0 11111111110 1111111111111111111111111111111111111111111111111111</p>
<p>转换成二进制的科学计数法表示如下：</p>
<p>1.1111111111111111111111111111111111111111111111111111 * 2^(2046 - 1023)</p>
<p>= 1.1111111111111111111111111111111111111111111111111111 * 2^1023</p>
<p>= (2^53 - 1) * 2^971</p>
<p>我们可以在浏览器调试窗口中验证：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>) * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">971</span>) <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line">(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>) * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">971</span>) === <span class="built_in">Number</span>.MAX_VALUE <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>2. Number.MAX_SAFE_INTEGER</strong></p>
<p>现在就可以解释为什么 JS 的最大整数为 +2^53-1 ~ -2^53-1。</p>
<p>因为 IEEE754 浮点数中整数位最大表示的数为: </p>
<p>1111111111111111111111111111111111111111111111111111 = 2^53-1</p>
<p>比这还大一位的数字的表示为:</p>
<p>100000000000000000000000000000000000000000000000000000 = 2^53</p>
<p>在计算机中表示为:</p>
<p>0 10000110101 0000000000000000000000000000000000000000000000000000 <del>0</del></p>
<p>注意到我们省去掉了一位，按照向偶舍入的规则，不会产生进位。所以这个数还是可以精确表示的，没有问题。</p>
<p>我们再来看看比 MAX_SAFE_INTEGER 大二的数：</p>
<p>100000000000000000000000000000000000000000000000000001</p>
<p>= 1.00000000000000000000000000000000000000000000000000001 * 2^53</p>
<p>在计算机中表示成:</p>
<p>0 10000110101 0000000000000000000000000000000000000000000000000000 <del>1</del></p>
<p>注意到我们省去掉了一位，按照向偶舍入的规则，还是不会产生进位。这个时候就有问题了，这个数跟刚才那个数竟然是相等的，我们来验证下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line"><span class="built_in">console</span>.log(a + <span class="number">1</span> === a + <span class="number">2</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>所以 Number.MAX_SAFE_INTEGER 表示能够准确表示的整数。</p>
<p>进行大数运算时，如果涉及到的的数值超过了 Number.MAX_SAFE_INTEGER，运算就会有误差了，此时的运算最好采用 <a href="https://segmentfault.com/a/1190000019912017?utm_source=tag-newest">Bigint</a> 类型。</p>
<p><strong>3. Number.MIN_VALUE</strong></p>
<p>Number.MIN_VALUE 表达的意思是 JavaScript 能够表示最小的正数，及很接近于 0 的数字，数值为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MIN_VALUE) <span class="comment">// 5e-324</span></span><br></pre></td></tr></table></figure>
<h1 id="0-2-0-1-为什么不等于-0-3"><a href="#0-2-0-1-为什么不等于-0-3" class="headerlink" title="0.2 + 0.1 为什么不等于 0.3"></a>0.2 + 0.1 为什么不等于 0.3</h1><p>这其实是计算机表示浮点数的过程中，由于存储空间的显示，对于某一些浮点数服务精确地表示。</p>
<p>对于十进制转二进制，整数部分除二取余，倒序排列，小数部分乘二取整，顺序排列，所以：</p>
<p>0.1 转化为二进制<br>0.0 0011 0011 0011 0011 0011 0011 … （0011循环）</p>
<p>0.2 转化为二进制<br>0.0011 0011 0011 0011 0011 0011 0011 … （0011循环）</p>
<p>然后采用 IEEE754 标准表示：</p>
<p>0.1<br>指数位： -4;<br>整数位： 1.1001100110011001100110011001100110011001100110011010 (52位)</p>
<p>0.2<br>指数位： -3;<br>整数位： 1.1001100110011001100110011001100110011001100110011010 (52位)</p>
<p>0.1 + 0.2</p>
<p>0.1100110011001100110011001100110011001100110011001101 (52位)  指数位： -3</p>
<p><code>+</code></p>
<p>1.1001100110011001100110011001100110011001100110011010 (52位)  指数位： -3</p>
<p>=</p>
<p>10.0110011001100110011001100110011001100110011001100111 (52位)  指数位： -3</p>
<p>=</p>
<p>1.00110011001100110011001100110011001100110011001100111 (53位)  指数位： -2</p>
<p>此时整数位已经溢出了，最后一位为 1，所以进位：</p>
<p>1.0011001100110011001100110011001100110011001100110100 (52位)  指数位： -2</p>
<p>= 1.0011001100110011001100110011001100110011001100110100 * 2 ^ -2</p>
<p>= 0.010011001100110011001100110011001100110011001100110100</p>
<p>= 0.30000000000000004</p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈蒙特卡罗算法</title>
    <url>/%E6%B5%85%E8%B0%88%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h1><p><strong>蒙特克罗算法</strong>（Monte Carlo method）是以<code>概率统计</code>理论为指导的、通过<code>随机抽样</code>来解决复杂计算问题的方法。</p>
<p>而<code>蒙特卡罗</code>是南欧小国家摩纳多的一个著名的赌城，因为赌博意味着<code>概率</code>，而蒙特卡罗算法就是大数定理的应用。</p>
<p><img src="https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/mt-1.png" alt="蒙特卡罗赌场"></p>
<p>蒙特卡罗算法的现代起源是美国的<code>曼哈顿原子弹计划</code>。<strong>S.M.乌拉姆（美国数学家）和冯·诺依曼</strong>为了计算<code>中子在原子弹内的扩散和增殖</code>情况，首先提出蒙特卡罗算法通过现代计算机模拟计算中子复杂的变化情况。</p>
<p>当时 S.M.乌拉姆（美国数学家）将<code>中子在原子弹内的扩散和增殖问题</code>等价为<code>求解高维玻尔兹曼方程（高维偏微分方程）</code>，然后将<code>求解高维玻尔兹曼方程（高维偏微分方程）</code>又等价为<code>转化成相应形式的随机问题，并通过计算模拟进行求解</code>。</p>
<p>求解高维玻尔兹曼方程（高维偏微分方程）非常复杂，可以通过蒙特卡罗抽样不断逼近真实解。</p>
<h1 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h1><h2 id="求解圆周率-Π"><a href="#求解圆周率-Π" class="headerlink" title="求解圆周率 Π"></a>求解圆周率 Π</h2><p>通过在圆的最小外接矩形内随机生成采样点，分别统计采样点落在圆内的数量及圆外的数量，最终得出圆周率：</p>
<p>$\frac{Area of Circle}{Area of Square} = \frac{\pi r^2}{\left(2r\right)^2}=\frac\pi4$</p>
<p><img src="https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/mt-2.png" alt="求解圆周率"></p>
<h2 id="求解积分"><a href="#求解积分" class="headerlink" title="求解积分"></a>求解积分</h2><p>积分就是求积分函数下面对应的面积，在统计范围内生成大量的采样点，并分别统计采样点落在积分函数上下的数量，得到积分数值</p>
<p>下面函数在 (1,1) 点的取值为1，所以整个红色区域在一个面积为1的正方形里面。在该正方形内部，产生大量随机点，可以计算出有多少点落在红色区域（判断条件 y &lt; x2）。这个比重就是所要求的积分值。</p>
<p><img src="https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/mt-3.png" alt="求解积分"></p>
<h2 id="模拟随机过程"><a href="#模拟随机过程" class="headerlink" title="模拟随机过程"></a>模拟随机过程</h2><p>通过蒙特卡罗算法来模拟博彩过程：</p>
<p>赌徒和庄家对赌抛硬币，如果为正面，本轮赌徒赢，庄家付给赌徒1元，结果为反面，本轮赌徒输，赌徒付给庄家1元。赌徒有初始赌本10元，手上的钱一旦输光则退出赌局，如何来模拟这个博彩过程？</p>
<p>我们首先来分析一下这个过程，赌徒的博彩结果本质上依托于每次抛掷硬币的结果，每一轮博彩就是一个伯努利试验，赢的概率是p=0.5，博彩的过程就是由这一串伯努利试验构成的伯努利随机过程，每轮赌局中，如果赢则赌本增加1元，输则赌本减少1元。</p>
<p>当然了，如果对某一个特定的赌徒，一旦开始进入赌局，则最终由每轮赌局结果构成的序列就是唯一的。那么如果我们想观察整个博彩过程的整体特征，我们该怎么办？好办，还是使用之前讲过的蒙特卡罗方法，采用大量的样本，最终观察样本结果的整体特征。</p>
<p>我们为了说明问题，采用的样本数为赌徒数1000000个，轮数分别为轮数为100,1000,10000轮，也就是每个赌徒最多和庄家分别对赌100,1000,10000轮，如果在这个过程中输光了赌本，则提前退出，如果到100,1000,10000轮还有赌本，赌局也停止。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">sample_list = []</span><br><span class="line">person_num = <span class="number">100000</span></span><br><span class="line">round_num = <span class="number">10000</span></span><br><span class="line"><span class="keyword">for</span> person <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, person_num + <span class="number">1</span>):</span><br><span class="line">    money = <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">round</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, round_num + <span class="number">1</span>):</span><br><span class="line">        result = random.randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> result == <span class="number">1</span>:</span><br><span class="line">            money = money + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> result == <span class="number">0</span>:</span><br><span class="line">            money = money - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> money == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    sample_list.append([person, <span class="built_in">round</span>, money])</span><br><span class="line">sample_df = pd.DataFrame(sample_list, columns=[<span class="string">&#x27;person&#x27;</span>, <span class="string">&#x27;round&#x27;</span>, <span class="string">&#x27;money&#x27;</span>])</span><br><span class="line">sample_df.set_index(<span class="string">&#x27;person&#x27;</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;总轮数:&#123;&#125;,总人数:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(round_num,person_num))</span><br><span class="line">print(<span class="string">&quot;输光赌本提前出局的人数:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(person_num-<span class="built_in">len</span>(sample_df[sample_df[<span class="string">&#x27;round&#x27;</span>]==round_num])))</span><br><span class="line">print(<span class="string">&quot;赌满全场且盈利的人数:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(sample_df[sample_df[<span class="string">&#x27;money&#x27;</span>]&gt;<span class="number">10</span>])))</span><br><span class="line">print(<span class="string">&quot;赌满全场且亏损的人数:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(sample_df[sample_df[<span class="string">&#x27;money&#x27;</span>]&lt;=<span class="number">10</span>][sample_df[<span class="string">&#x27;money&#x27;</span>]&gt;<span class="number">0</span>])))</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总轮数:100,总人数:100000</span><br><span class="line">输光赌本提前出局的人数:31148</span><br><span class="line">赌满全场且盈利的人数:44458</span><br><span class="line">赌满全场且亏损的人数:23923</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总轮数:1000,总人数:100000</span><br><span class="line">输光赌本提前出局的人数:75154</span><br><span class="line">赌满全场且盈利的人数:23441</span><br><span class="line">赌满全场且亏损的人数:1386</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总轮数:10000,总人数:100000</span><br><span class="line">输光赌本提前出局的人数:91902</span><br><span class="line">赌满全场且盈利的人数:8060</span><br><span class="line">赌满全场且亏损的人数:38</span><br></pre></td></tr></table></figure>
<p>从结果中不难发现，这种和庄家1:1的对赌，随着轮数的增加，基本上都破产被收割了。换句话说，哪怕庄家不出千，输赢概率各半，赌的越久，基本上都是输光破产走人，原因是什么？原因是庄家的资金量是无穷的。</p>
<h2 id="接受拒绝采样"><a href="#接受拒绝采样" class="headerlink" title="接受拒绝采样"></a>接受拒绝采样</h2><p>例子：要求函数 $f(Z)$ 关于分布 $𝑝(𝑍|𝑋)$ 的期望，而期望的本质是求积分 <script type="math/tex">\int_{-\infty}^{+\infty}p(z\vert x)f(z)\operatorname dz</script> ，而这个积分往往非常难求，可以根据分布 $𝑝(𝑍|𝑋)$ 采出 𝑁 个采样点， <script type="math/tex">z^{(1)},z^{(2)},z^{(3)},\cdots,z^{(N)}\sim p(z\vert x)\\</script> ，用样本均值来近似期望： <script type="math/tex">\frac1N{\textstyle\sum_{i=1}^N}f(z^i)\approx\\ \int_{-\infty}^{+\infty}p(z\vert x)f(z)\operatorname dz</script></p>
<p>但如果分布 $𝑝(𝑍|𝑋)$ 非常复杂，很难根据分布进行采样，此时采用接受拒绝采样方法实现复杂概率分布的样本采样。</p>
<p>首先我们采用一个已知的简单的<a href="https://baike.baidu.com/item/%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E5%87%BD%E6%95%B0/5021996">概率密度函数</a> $𝑔(𝑥)$ 和常数值 $𝐶$，保证$C∗𝑔(𝑥)≥𝑝(𝑥)$，从分布 $𝑔(𝑥)$ 中获取一个采样样本 $𝑌$，也就是从<a href="https://baike.baidu.com/item/%E7%B4%AF%E7%A7%AF%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0/7763383">累积分布函数</a>中按照 $[0,1]$ 均匀分布采样一个概率，然后取得一个样本值。</p>
<p><img src="https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/mt-6.png" alt="累积分布函数"></p>
<p>从 $[0,1]$ 均匀分布中获取一个采样成本 $𝑈$，如果 <script type="math/tex">\frac{p(Y)}{C\ast g(Y)}\geq U\\</script>，就接受这个采样值 $𝑌$，否则拒绝该采样，不断重复该过程，最终获得服从 $𝑝(𝑥)$ 分布的样本值。 也就是猜出的样本有 $𝑈$ 的概率被接受，有 $1-𝑈$ 的概率被拒绝。</p>
<p><img src="https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/mt-7.png" alt="接受拒绝采样"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>蒙特卡洛方法的思想是使用随机数来进行场景的模拟或者过程的仿真，通过不断增加采样点，逐渐逼近真实解。</p>
</li>
<li><p>其在在金融工程学，宏观经济学，计算物理学等领域应用广泛，主要应用包括但不局限于近似计算不规则面积/体积/积分、模拟随机过程、结合接受-拒绝采样来对分布的未知参数进行统计推断。</p>
</li>
<li><p>蒙特卡洛检测的优点能够简单快速地快速求解复杂问题，结合计算机大量样本的采样实验，以频率逼近概率。</p>
</li>
</ol>
<p><strong>参考：</strong></p>
<ul>
<li><a href="https://www.zhihu.com/question/441076840/answer/1814845300">知乎*如何通俗地理解「蒙特卡洛方法」，它解决问题的基本思路是什么，目前主要应用于哪些领域？</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/monte-carlo-method.html">蒙特卡罗方法入门</a></li>
<li><a href="https://www.bilibili.com/video/BV17D4y1o7J2?from=search&amp;seid=14087390091811873850&amp;spm_id_from=333.337.0.0">B站*蒙特卡洛（Monte Carlo, MCMC）方法的原理和应用</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>理解最大似然估计与最大后验估计</title>
    <url>/%E7%90%86%E8%A7%A3%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E4%B8%8E%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87/</url>
    <content><![CDATA[<h1 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h1><p>最大似然估计（Maxiumum Likelihood Esimation, MLE）是<strong>频率学派</strong>对概率模型的一种参数估计方法。</p>
<p>它要解决的问题是，针对一定数量的<strong>独立重采样</strong>得到的样本，如何找到模型的参数 $\theta$，使得样本采样结果出现的概率最大。</p>
<p>具体来说，假设我们知道人身高的分布是正态分布，及概率密度函数的形式为：</p>
<script type="math/tex; mode=display">f\left(x\right)=\frac1{\sqrt{2\pi}\sigma}exp\left(-\frac{\left(x-u\right)^2}{2\sigma^2}\right)</script><p>其中，人身高的采样是独立同分布的，也就是你的身高不与别人的身高有关，且你们的身高服从同样的分布，即正态分布。</p>
<p>我们通过问卷调查，获得的一定数量人高的样本，然后估计身高分布模型的参数值方差　$\sigma$ 和均值　$\mu$。</p>
<h2 id="似然函数"><a href="#似然函数" class="headerlink" title="似然函数"></a>似然函数</h2><p>数学上采用<strong>似然函数</strong>来解释样本已知，而模型参数未知的情况。</p>
<p>似然函数　$f\left(x\left|\theta\right.\right)$ 指样本　$x$　已知，而模型参数　$\theta$ 未知的函数。</p>
<p>假使模型的参数　$\theta$　已知，而样本　$x$　未知的函数　$f\left(\theta\left|x\right.\right)$ 为<strong>概率函数</strong>。</p>
<p>这有点像”一菜两吃“的意思，比如数学函数　$f(x,y)=x^y$，如果参数　$x$　为定值，例如　$x=2$，则函数变为指数函数　$f(x,y)=2^y$；而如果　$y$　为定值，例如　$y=2$，则函数变为二次函数。</p>
<p>因为似然函数的样本　$x$　服从独立同分布，因此似然函数 $\begin{array}{l}f(x_1,x_2,…,x_n\left|\theta\right.)\end{array}$　可以变为独立同分布的样本求联合概率：</p>
<script type="math/tex; mode=display">\begin{array}{l}f(x_1,x_2,...,x_n\left|\theta\right.)\\=f(x_1\left|\theta\right.)f(x_2\left|\theta\right.)...f(x_n\left|\theta\right.)\\={\textstyle\prod_{i=1}^n}f(x_i\left|\theta\right.)\end{array}</script><h2 id="求模型参数"><a href="#求模型参数" class="headerlink" title="求模型参数"></a>求模型参数</h2><p><code>例子</code></p>
<p>考虑这样一个例子，一个不透明的盒子里有黑白两种颜色的小球，有放回的进行100次抽取，记录下每次抽取小球的颜色，结果出现了80次黑色小球，20次白色小球，那么求盒子里的黑白两种颜色小球的分布情况？</p>
<p>转化为似然函数的问题，合理里其实黑白两种小球的分布已知，也就是说盒子中黑白小球的分布构成了模型，模型的参数已知，如何根据黑白球的采样情况，求盒子黑白球分布的情况。</p>
<p>我们假设黑球占比为　$p$，那么白球的占比就为　$1-p$，那么黑球每次被去取出的概率就等同于黑球的占比　$p$，因此，这次采样的似然函数为：</p>
<script type="math/tex; mode=display">\begin{array}{l}f(x\left|\theta\right.)=p^{80}(1-p)^{20}\\\end{array}</script><p>那么，模型的参数可以说有无穷种情况，如何计算模型的参数　$p$　呢？</p>
<blockquote>
<p>极大似然估计的思想就是，使当前采样情况出行概率最大的模型参数，为求得的结果，即使似然函数取得极大值。</p>
</blockquote>
<p>因此要求得黑白球分布模型，即使似然函数取得极大值，也就是对似然函数求导，使导数为零，即为结果。很容易计算得到　$p＝0.8$。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>其实我们日常生活中无意中就采用了极大似然估计的思想。</p>
<p><code>例子1</code></p>
<p>我们想进一步统计全国人民的身高分布的模型参数，虽然我们知道模型为某一种正态分布，但是我们无法对 14 多亿全国人民都逐一统计各自的身高。这时候，我们可以随机对各省的一部分人进行采样。因为这些省份各人间的身高为独立同分布的，所以可以基于这些样本，基于最大似然估计获得一个身高分布模型。该模型就可以近似的符合全国人民身高的分布模型。</p>
<blockquote>
<p>频率派认为全国人民身高模型是一定的，就像柏拉图的理想型。通过不断的扩大样本的数量，就可以逼近这个背后真正的模型。</p>
<p>而贝叶斯派则认为模型本身也是不定的，这个模型初始有一个参数，可由先验知识获得，然后通过不断的采样修正我们的模型，使得最终的后验概率最大。</p>
</blockquote>
<h1 id="最大后验估计"><a href="#最大后验估计" class="headerlink" title="最大后验估计"></a>最大后验估计</h1><p>最大后验估计是贝叶斯派的法宝，代表了另外一种看待世界的角度。</p>
<p>贝叶斯学派认为，对于要估计的模型人们会有一个预判，例如抛掷硬币正反硬币出现的次数应该五五开，这个预判就是先验函数 $p(\theta)$ 然后根据实际采样不断调整对这个模型参数进行调整，也就是说，这个模型参数本身是不能确定的，我们只能通过不断的实验逐渐获得最合理的模型参数，这一点就完全区别于频率学派的。</p>
<h2 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h2><p>最大后验估计的核心就是贝叶斯公式：</p>
<script type="math/tex; mode=display">\begin{array}{l}f(\theta\left|X\right.)=\frac{f(X\left|\theta\right.)\times p(\theta)}{p(X)}\\\end{array}</script><p>其中　$f(\theta\left|X\right.)$ 为后验概率，　$p(\theta)$　为先验估计，而　$f(X\left|\theta\right.)$ 为前面讲的似然函数，　$p(X)$ 为边缘概率，可以简单的理解为一个归一化常数。</p>
<p>贝叶斯公式已经成为机器学习的核心算法之一，诸如拼写检查、语言翻译、海难搜救、生物医药、疾病诊断、邮件过滤、文本分类、侦破案件、工业生产等诸多方面都有很广泛的应用，它也是很多机器学习算法的基础。在这里，有必要了解一下贝叶斯公式。</p>
<blockquote>
<p>贝叶斯公式是以英国学者托马斯·贝叶斯(Thomas Bayes)命名的。1763年Richard Price整理发表了贝叶斯的成果《An Essay towards solving a Problem in the Doctrine of Chances》，这才使贝叶斯公式展现在世人的面前。</p>
</blockquote>
<p>贝叶斯公式是为了解决”逆概”;问题而提出的。正概问题很常见，比如不透明袋中有黑球M个,白球N个，随手抓起一个球，求是黑球的概率，大家心算一下就能知道是 $\frac{M}{M+N}$。当然，生活中有大量这样的例子，像人口流动统计、金融统计等等，这些统计的特征就是我们事先已经知道了所有样本的分布情况，在此基础上进行概率的计算，这就是“正概”问题。但是，如果我们不知道所有样本的信息（这样的例子比比皆是，例如物理学中我们不可能看到所有电子的运行状态，所以只能通过实验模拟观察大多数的情况去建立最合适的模型去解释），同时我们又想知道样本的概率怎么办呢？贝叶斯公式的作用就体现出来了。</p>
<p>还是一个袋子中装着若干小球，里面有黑色跟白色，我们随机取出一些小球，然后根据小球的情况去计算袋中小球实际的分布情况。此时我们可能有很多种模型（猜测）去解释，随着取出小球数量的增加，我们的模型也越来越精确，越来越逼近实际的情况，然后我们从这些模型中找出最贴合实际的。<strong>总结来说：不同模型的求解就是计算不同的后验概率（事件已经发生，求某种因素导致该事件发生的概率），对于连续的猜测空间是计算概率密度函数；模型比较如果不考虑先验概率（根据以往的经验和分析获得的概率）则运用了最大似然估计。这就是贝叶斯思想的核心</strong>。</p>
<p>下面我举一个<a href="http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/">例子</a>：一所学校里面有 60% 的男生，40% 的女生。男生总是穿长裤，女生则一半穿长裤一半穿裙子。有了这些信息之后我们可以容易地计算“随机选取一个学生，他（她）穿长裤的概率和穿裙子的概率是多大”，这个就是前面说的“正向概率”的计算。然而，假设你走在校园中，迎面走来一个穿长裤的学生（很不幸的是你高度近似，你只看得见他（她）穿的是否长裤，而无法确定他（她）的性别），你能够推断出他（她）是男生的概率是多大吗？</p>
<p>一些认知科学的研究表明（《决策与判断》以及<a href="http://www.douban.com/subject/3199621/">《Rationality for Mortals》</a>第12章：小孩也可以解决贝叶斯问题），我们对形式化的贝叶斯问题不擅长，但对于以频率形式呈现的等价问题却很擅长。在这里，我们不妨把问题重新叙述成：你在校园里面随机游走，遇到了 N 个穿长裤的人（仍然假设你无法直接观察到他们的性别），问这 N 个人里面有多少个女生多少个男生。</p>
<p>你说，这还不简单：算出学校里面有多少穿长裤的，然后在这些人里面再算出有多少女生，不就行了？</p>
<p>我们假设全校总共有H个学生，其中男生（都穿长裤）占60%，只有50%女生穿长裤。我们首先计算穿长裤的人数：<code>H*P(Boy)*P(Pants|Boy)+H*P(Girl)*P(Pants|Girl)</code>，其中<code>P(Boy)</code>为男生比例，<code>P(Pants|Boy)</code>为男生中穿长裤的比率（此题中为100%），女生同理。其中创长裤的女生共有<code>H*P(Girl)*P(Pants|Girl)</code>个，两者一比，我们就得到：</p>
<p><script type="math/tex">P(Girl|Pants)=\frac{P(Girl)*P(Pants|Girl)}{P(Boy)*P(Pants|Boy)+P(Girl)*P(Pants|Girl)}</script>       <strong>式1</strong></p>
<p>而这里面男生女生可以泛指一切事物，所以通用公式为：</p>
<p><script type="math/tex">P(B|A)=\frac{P(B)*P(A|B)}{P(B')*P(A|B')+P(B)*P(A|B)}</script>       —-（B’为B的互补，例如男生女生）       <strong>式2</strong></p>
<p>其实分母就是指所有穿长裤的人的概率<code>P(Pants)</code>也就是<code>P(A)</code>，分子是女生中穿长裤与是女生同时发生的概率，也就是<code>P(Pants,Girl)</code>或者说<code>P(A,B)</code>,所以式2(全概率公式的一种特殊情况）又可以写为：</p>
<p><script type="math/tex">P(B|A)=\frac{P(A,B)}{P(A)}</script>          <strong>式3</strong>            又可以写为</p>
<p><script type="math/tex">P(B|A)*P(A)=P(A,B)</script>                <strong>式4</strong></p>
<p>同理，我们可以得到<code>P(A|B)*P(B)=P(A,B)</code>，所以：</p>
<p><code>P(A|B)*P(B) = P(B|A)*P(A)</code>，即：</p>
<p><script type="math/tex">P(A|B)=\frac{P(A)*P(B|A)}{P(B)}</script>     <strong>式5</strong> </p>
<p><img src="https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/mle_pic_1.png" alt="图１-１"></p>
<p>式3或式4也就是贝叶斯公式。其实式2是一个问题共有两种分类时的情况，例如性别、掷硬币等只有两种情况，现实生活中很多是由多种情况构成，一件事情可能由多个原因影响，那么推广开来，就是贝叶斯公式的通式。如图1-1所示，一个事物有两个影响要素A和B，面积的大小对应发生的概率大小，C事件的发生受到A和B要素的影响。如果计算在C事件发生是受到A事件影响的概率<code>P(A|C)</code>，就是计算<code>A∩C</code>与<code>C</code>的面积之比，也就是<code>P(A∩C)/P(C),P(A∩C)</code>又可以写为<code>P(A,C)</code>，因为<code>P(C|A)</code>表示A条件下C事件发生的概率，<code>P(A)</code>表示A事件发生的概率，即A的面积，所以<code>P(A)*P(C|A)</code>即<code>A∩C</code>的面积，也就是即A和C同时发生的概率<code>P(A,C)</code>。就得到<code>P(A∩C)=P(A)*P(C|A)</code>, 同理：<code>P(B∩C)=P(B)*P(C|B)</code>,因为得到 <code>P(A|C)=P(A)*P(C|A)/(P(A)*P(C|A)+P(B)*P(C|B))</code>。这是一个事物的影响因素由两个组成的情况，我们把所有情况统一起来就是全概率公式:</p>
<p><img src="https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/mle_pic_2.png" alt="式５"></p>
<h2 id="贝叶斯推断"><a href="#贝叶斯推断" class="headerlink" title="贝叶斯推断"></a>贝叶斯推断</h2><h3 id="什么是贝叶斯推断"><a href="#什么是贝叶斯推断" class="headerlink" title="什么是贝叶斯推断"></a>什么是贝叶斯推断</h3><p>贝叶斯推断（BAYESIAN INFERENCE）是一种应用于不确定性条件下的决策的统计方法。贝叶斯推断的显著特征是，为了得到一个统计结论能够利用先验信息和样本信息。</p>
<p>通俗来讲，我想知道A事件的发生，如果没有任何的先验知识，我只能做出它发生与不发生的概率各占50%的判断。但是，幸运的是我知道B事件发生了，根据两者的关联经验，我知道它对A事件的发生起到促进作用，所以我可以更加准确的判断A事件是大概率发生的（如80%），而不是起初的非零即一的50%。如果我有更多A的关联事件，那么我可以做出更加准确的判断，这就是贝叶斯推断。</p>
<p>我们还是看式5：$P(B|A)=\frac{P(A)*P(B|A)}{P(B)}$，<code>P(A)</code>是我们的先验概率，(Prior probability)，即在B事件发生之前，我们对A事件概率的一个判断。<code>P(A|B)</code>称为”后验概率”（Posterior probability），即在B事件发生之后，我们对A事件概率的重新评估。$\frac{P(B|A)}{P(B)}$ 称为”可能性函数”（Likelyhood），这是一个调整因子，使得预估概率更接近真实概率。</p>
<p>为了更直观的解释贝叶斯推断，这里举一个<a href="https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86">维基百科</a>的例子——吸毒监测：</p>
<p>假设一个常规的检测结果的敏感度与可靠度均为99%，即吸毒者每次检测呈阳性（+）的概率为99%。而不吸毒者每次检测呈阴性（-）的概率为99%。从检测结果的概率来看，检测结果是比较准确的，但是贝叶斯定理却可以揭示一个潜在的问题。假设某公司对全体雇员进行吸毒检测，已知0.5%的雇员吸毒。请问每位检测结果呈阳性的雇员吸毒的概率有多高？</p>
<p>令“D”为雇员吸毒事件，“N”为雇员不吸毒事件，“+”为检测呈阳性事件。可得</p>
<ul>
<li>P(D)代表雇员吸毒的概率，不考虑其他情况，该值为0.005。因为公司的预先统计表明该公司的雇员中有0.5%的人吸食毒品，所以这个值就是D的先验概率。</li>
<li>P(N)代表雇员不吸毒的概率，显然，该值为0.995，也就是1-P(D)。</li>
<li>P(+|D)代表吸毒者阳性检出率，这是一个条件概率，由于阳性检测准确性是99%，因此该值为0.99。</li>
<li>P(+|N)代表不吸毒者阳性检出率，也就是出错检测的概率，该值为0.01，因为对于不吸毒者，其检测为阴性的概率为99%，因此，其被误检测成阳性的概率为1 - 0.99 = 0.01。</li>
<li>P(+)代表不考虑其他因素的影响的阳性检出率。该值为0.0149或者1.49%。我们可以通过全概率公式计算得到：此概率 = 吸毒者阳性检出率（0.5% x 99% = 0.495%)+ 不吸毒者阳性检出率（99.5% x 1% = 0.995%)。P(+）=0.0149是检测呈阳性的先验概率。用数学公式描述为：</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/mle_pic_3.png" alt="公式"></p>
<p>据上述描述，我们可以计算某人检测呈阳性时确实吸毒的条件概率P(D|+)：</p>
<p><img src="https://gcore.jsdelivr.net/gh/SUNYunZeng/sources/img/mle_pic_4.svg" alt="公式"></p>
<p>尽管吸毒检测的准确率高达99%，但贝叶斯定理告诉我们：如果某人检测呈阳性，其吸毒的概率只有大约33%，不吸毒的可能性比较大。假阳性高，则检测的结果不可靠。</p>
<p>同时，我们可以计算一下假如一个人吸毒，但他误检测成阴性的概率P(D|-)：</p>
<p>$P(D|-)=\frac{P(-|D)P(D)}{P(-|D)P(D)+P(-|N)P(N)}$</p>
<p>=$\frac{0.01×0.005}{0.01×0.005+0.99×0.995}$</p>
<p>≈0.0000507</p>
<p><strong>可见，一个人吸毒但被误检测为阴性的概率只有0.005%，也就是说一个人如果检测为阴性，则基本可以判定他没有吸毒。但是一个人如果监测为阳性，则只有33%的概率确定他吸毒。这在跟很多医学监测当中的案例很相似，假阳性比假阴性更值得我们关注！</strong></p>
<h3 id="贝叶斯推断与拼接纠正"><a href="#贝叶斯推断与拼接纠正" class="headerlink" title="贝叶斯推断与拼接纠正"></a>贝叶斯推断与拼接纠正</h3><p>贝叶斯推断其实有很多应用，例如语言翻译、中文分词、图像识别等，很多博客也以拼写纠正作为示例，这里我就详细讲一下拼写纠正的过程。</p>
<p>经典著作《人工智能：现代方法》的作者之一 Peter Norvig 曾经写过一篇介绍如何写一个拼写检查/纠正器的文章，详情戳<a href="http://norvig.com/spell-correct.html">这里</a>。</p>
<p>用户在输入过程中，难免会遇到拼写错误的情况，我们要做的就是给出一个或几个纠正后的用户本来想要输入的单词推荐。这里的一个关键问题就是：用户到底想要输入什么单词？</p>
<p>其实用数学的语言来描述，就是要求出P(我们猜测用户要输入的单词|用户实际输入的单词)的大小。</p>
<p>用T表示我们猜测用户输入的单词，用S表示用户实际输入的单词，那么就是求<code>P(t|S)</code> = $\frac{P(S|t)×P(t)}{P(S)}$ 的大小。</p>
<p>对于同一个单词，<code>P(S)</code>的概率是一样的，那么就等价于<code>P(t|S)∝ P(S|t)×P(t)</code>。  <code>∝</code>是正比于，不是无穷大</p>
<p>那么要是的<code>P(t|S)</code>最大，就是使得<code>P(S|t)×P(t)</code>最大。</p>
<p><code>P(S|t)</code>名义上是指我们猜测的单词t是用户真正想输入单词的概率，不同的单词概率不同，这就涉及到最大似然估计。例如用户输入的单词是thriw,这时throw跟thraw都有可能，但是你会想到，o跟i很接近，用户可能要输的单词是throw的可能性比thraw的可能性大得多，根据最大似然估计找出最可能的单词。但是，有时候光有最大似然并不能完美的解决问题，我们还需要利用先验概率<code>P(t)</code>。</p>
<p><code>P(t)</code>使我们猜测的单词出现的概率，这些单词t1、t2、t3….理论上有无穷种，但它是一种先验概率，对于单词来说，可能有点抽象。这里举一个分词的例子：</p>
<p>The girl saw the boy with a telescope.</p>
<p>如果仅用最大似然估计方法的话，可能会给出两种结果：1 The girl saw | the boy with a telescope    2.The girl saw the boy | with a telescope</p>
<p>但是根据我们的常识，一个女孩看着一个拿着望远镜的男孩？拿着望远镜有点莫名其妙，与“看”这个动作联系起来，那么最合适的解释恐怕是女孩拿着望远镜看那个男孩。那么得出这个结论，就是用到我们的先验知识，也就是<code>P(t)</code>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a href="https://zhuanlan.zhihu.com/p/26614750">一文搞懂极大似然估计</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/32480810">聊一聊机器学习的MLE和MAP：最大似然估计和最大后验估计</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/SUNYZBlog/p/9610378.html">机器学习核心算法之——贝叶斯方法</a></p>
</li>
<li><p><a href="http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/">数学之美番外篇：平凡而又神奇的贝叶斯方法</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>理解最小二乘法</title>
    <url>/%E7%90%86%E8%A7%A3%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/</url>
    <content><![CDATA[<h1 id="何为最小二乘"><a href="#何为最小二乘" class="headerlink" title="何为最小二乘"></a>何为最小二乘</h1><blockquote>
<p>最小二乘法是十九世纪统计学的主题曲。<br>从许多方面来看, 它之于统计学就相当于十八世纪的微积分之于数学。<br>            ——史蒂芬·史蒂格勒的《The History of Statistics》</p>
</blockquote>
<p><strong>最小二乘是一种从一系列测量值中，计算最可能真值的数学方法。</strong></p>
<h2 id="小明真实的体重"><a href="#小明真实的体重" class="headerlink" title="小明真实的体重"></a>小明真实的体重</h2><p>在探讨何为最小二乘时，先思考这个问题：</p>
<p>小明是一个健身爱好者，对自己的体重要求非常苛刻，因为这涉及到下一步的训练计划与饮食安排。为了能精确测量出自己的体重，他在市场上购买了9个都号称世界最准的体重秤（小明是个土豪）。</p>
<p>我们知道百分百准确的体重秤是不存在的，这种理想秤只存在于商家的口中。</p>
<p><strong>那么，如何根据这9个比较准确的体重秤，测量出小明的真实体重呢？</strong></p>
<h2 id="可能的计算方案"><a href="#可能的计算方案" class="headerlink" title="可能的计算方案"></a>可能的计算方案</h2><p>假设每个体重秤测出小明的体重值分别为 $y_1,y_2,y_3,…,y_9$，那么可能存在以下几个方案：</p>
<ol>
<li><p>取平均值 $\frac{y_1+y_2+y_3+…+y_9}9$</p>
</li>
<li><p>取中位数 $medium({y_1,y_2,y_3,…,y_9})$</p>
</li>
<li><p>取极大值或极小值</p>
</li>
<li><p>取几何平均数</p>
</li>
<li><p>取调和平均数</p>
</li>
<li><p>掷色子</p>
</li>
<li><p>看心情</p>
</li>
</ol>
<p>有很多种方案，到底哪一种才是最合理的呢？</p>
<p>法国数学家，阿德里安-马里·勒让德（1752－1833）提出让总的误差的平方最小的 $y$ 就是真值，因为他假设如果测量误差是随机的话，测量值应该围绕真值上下波动。取误差平方和的原因是为了将正负误差都统一用正数值表示。</p>
<p>马里·勒让德假设的体重误差和的数学表达式为：</p>
<script type="math/tex; mode=display">S_{϶^2}=\overset9{\underset{i=1}{min(\sum\left(y-y_i\right)^2)}}</script><p>这是一个二次函数，其导数为 0 时，取得极小值：</p>
<script type="math/tex; mode=display">\begin{array}{l}\frac d{dy}S_{϶^2}=\frac{\displaystyle d}{\displaystyle dy}\sum\left(y-y_i\right)^2=2\sum\left(y-y_i\right)\\=2\left(\left(y-y_1\right)+\left(y-y_2\right)+...+\left(y-y_9\right)\right)=0\end{array}</script><p>进而：</p>
<script type="math/tex; mode=display">9y=y_1+y_2+y_3+...+y_9\;\;\Rightarrow y=\frac{y_1+y_2+y_3+...+y_9\;}9</script><p><strong>确定了体重的算术平均数的确使得误差的平方和最小</strong>，也就是测量的9次体重最有可能围绕所测体重记录的平均值波动。</p>
<p><strong>即测量值的平均值是最可能的真值，也是最好的计算方案。</strong></p>
<p>这也就是最小二乘法的精髓，二乘即平方，最小二乘，即测量值与真值间的误差平方和最小。</p>
<p>这里的测量值是简单的线性函数，其实它可以为一个非线性函数 $f(x)$。</p>
<script type="math/tex; mode=display">S_{϶^2}=min(\sum\left(y-f(x)\right)^2)</script><p>其取极小值时的 $y$ 为最可能的值。</p>
<h2 id="测量误差的正态分布"><a href="#测量误差的正态分布" class="headerlink" title="测量误差的正态分布"></a>测量误差的正态分布</h2><p>对于马里·勒让德，数学小王子，高斯（1777－1855）心存怀疑，这个假设如果是错的咋办？</p>
<p>于是他用概率统计的框架对其进行验证。</p>
<p>他首先假设每次测量值 $x_i$ 与真值 $x$ 的测量误差 $϶_i=x-x_i$ 服从一个概率分布，对应的概率密度函数为 $p(϶)$</p>
<p>假设所有的测量构成一个联合概率 $L(x)$ ：    </p>
<script type="math/tex; mode=display">\begin{array}{l}L(x)=p(\backepsilon_1)p(\backepsilon_2)p(\backepsilon_3)...p(\backepsilon_9)\\=p(x-x_1)p(x-x_2)p(x-x_3)...p(x-x_9)\end{array}</script><p>根据<strong>极大似然估计</strong>的思想，联合概率最大的最应该出现，即：</p>
<script type="math/tex; mode=display">\frac d{dx}L(x)=0</script><p>如果最小二乘时对的，那么应该在测量值的平均值 $ \vec x = \frac{x_1+x_2+x_3+…+x_9}9$ 处取得极值，即：</p>
<script type="math/tex; mode=display">\frac d{dx}L(x)\vert_{x=\vec x}=0</script><p>解这个微分方程，得到：</p>
<script type="math/tex; mode=display">p(϶)=\frac1{\sigma\sqrt{2\pi}}e^{-\frac{϶^2}{2\sigma^2}}</script><p>得到正态分布的概率密度函数，也就是说如果马里·勒让德说的“真值回围绕测量值上下波动，那么用最小二乘法得到的值即为最可能的值”是对的，那么测量误差服从正态分布。</p>
<p>而且，这个过程倒推也成立，也就是说如果测量误差服从正态分布，那么最小二乘得到的值即为最可能的值，即：</p>
<script type="math/tex; mode=display">x=\vec x\Leftrightarrow p(϶)=\frac1{\sigma\sqrt{2\pi}}e^{-\frac{϶^2}{2\sigma^2}}</script><p>那么测量误差 $p(϶)$ 是否服从正态分布呢？</p>
<p>这就涉及到概率论里面的<code>中心极限定理</code>：</p>
<blockquote>
<p>样本的平均值约等于总体的平均值。<br>不管总体是什么分布，样本的平均值总会落到总体的平均周围，且成正态分布。</p>
</blockquote>
<p>对于体重测量问题而言，体重值是被测量出来的，体重值的均值就是小明最可能的体重值，而体重值的均值的分布服从正态分布。</p>
<p><strong>因此测量的误差也服从正态分布</strong>，因为测量误差会影响到均值的分布。</p>
<p><code>虽然马里·勒让德提出了最小二乘法，但是高斯从概率论上验证了最小二乘的合理性，真正奠定了最小二乘法的地位。</code></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>最小二乘通过测量值与真值间的误差平方和最小，得到最可能的值。</p>
</li>
<li><p>测量值有可能需要用更复杂的函数表达。</p>
</li>
<li><p>高斯验证了对于多次测量而言，测量值的算数平均值就是最可能的值，因为测量误差服从正态分布。</p>
</li>
</ol>
<p><strong>参考：</strong></p>
<ul>
<li><a href="https://www.zhihu.com/question/37031188/answer/411760828">知乎*最小二乘的本质是什么？</a></li>
<li><a href="https://www.zhihu.com/question/54082000">知乎*如何理解似然函数</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>用JS写算法</title>
    <url>/%E7%94%A8JS%E5%86%99%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="用JS去除字符串前后空格"><a href="#用JS去除字符串前后空格" class="headerlink" title="用JS去除字符串前后空格"></a>用JS去除字符串前后空格</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!str) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> trimRight(trimLeft(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trimLeft</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断字符串（去掉换行、tab等）</span></span><br><span class="line">    <span class="keyword">const</span> judgeStr = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot; \t\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(judgeStr.indexOf(str.charAt(<span class="number">0</span>))!==-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> j = <span class="number">1</span>, len = str.length;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;len &amp;&amp; judgeStr.indexOf(str.charAt(j))!==-<span class="number">1</span>)&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        str = str.substring(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trimRight</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> judgeStr = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot; \t\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> i = str.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(judgeStr.indexOf(str.charAt(i))!==-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; judgeStr.indexOf(str.charAt(i))!==-<span class="number">1</span>)&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        str = str.substring(<span class="number">0</span>, i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="JS-面对经典的排序问题"><a href="#JS-面对经典的排序问题" class="headerlink" title="JS 面对经典的排序问题"></a>JS 面对经典的排序问题</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>选择一个判断标准，然后根据这个标准将数组分割成大小两部分，然后对这两部分分别分割，直到排序完毕。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    partition(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> partition = <span class="function"><span class="keyword">function</span>(<span class="params">arr, left, right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> idx = subSort(arr, left, right);</span><br><span class="line">    <span class="keyword">if</span>(left &lt; idx-<span class="number">1</span>)&#123;</span><br><span class="line">        partition(arr, left, idx-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right &gt; idx)&#123;</span><br><span class="line">        partition(arr, idx, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr, left, right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> target = arr[<span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>)];</span><br><span class="line">    <span class="keyword">let</span> i=left, j=right;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;arr.length &amp;&amp; arr[i]&lt;target)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;target)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=j)&#123;</span><br><span class="line">            [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间负责度</p>
<ul>
<li>如果每次选择的 target 都是中间大小的，则最优 O(nlogn)</li>
<li>如果每次选择都是最大的（对于升序排序），则退化为冒泡排序。</li>
</ul>
</li>
<li><p>空间复杂度 O(1)</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/yuzhihui_no1/article/details/44198701#t2">参考</a></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>分治思想，先划分数组，然后依次排序，归并。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(arr.slice(<span class="number">0</span>,idx)), mergeSort(arr.slice(idx)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">left, right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>, res = [];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;left.length &amp;&amp; j &lt; right.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left[i]&lt;right[j])&#123;</span><br><span class="line">            res.push(left[i++]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.push(right[j++])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;left.length)&#123;</span><br><span class="line">        res.push(left[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;right.length)&#123;</span><br><span class="line">        res.push(right[j++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度 O(nlogn)</p>
</li>
<li><p>空间复杂度 O(n + logn) 也就是 O(n)</p>
</li>
</ul>
<p>归并排序比较稳定，但是比较吃内存空间。快速排序不稳定，但是不消耗内存空间。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[i], j=i;</span><br><span class="line">        <span class="keyword">while</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; arr[j-<span class="number">1</span>]&gt;temp)&#123;</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="大数相加"><a href="#大数相加" class="headerlink" title="大数相加"></a>大数相加</h1><p>js 里面的 Number 用64位浮点数表示，数值范围为 -2^53  ———  2^53   (包含边界)。如果数值相加后的结果超过这个范围，则会导致精度丢失。</p>
<p>大数相加原理是利用数组可以自动扩容来保存计算结果，并用字符串的形式输入与输出。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addBigNum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    [num1, num2] = [num1 + <span class="string">&#x27;&#x27;</span>, num2 + <span class="string">&#x27;&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> len1 = num1.length, len2 = num2.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;(<span class="built_in">Math</span>.max(len1, len2)-<span class="built_in">Math</span>.min(len1, len2)); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(len1&lt;len2)&#123;</span><br><span class="line">            num1 = <span class="string">&#x27;0&#x27;</span> + num1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            num2 = <span class="string">&#x27;0&#x27;</span> + num2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    num1 = num1.split(<span class="string">&#x27;&#x27;</span>).reverse();</span><br><span class="line">    num2 = num2.split(<span class="string">&#x27;&#x27;</span>).reverse();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;num1.length; i++)&#123;</span><br><span class="line">        res[i] = res[i]===<span class="number">1</span>?res[i]:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> s = res[i] + <span class="built_in">parseInt</span>(num1[i]) + <span class="built_in">parseInt</span>(num2[i]);</span><br><span class="line">        <span class="keyword">if</span>(s&lt;<span class="number">10</span>)&#123;</span><br><span class="line">            res[i] = s;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[i] = s-<span class="number">10</span>;</span><br><span class="line">            res[i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="大数相乘"><a href="#大数相乘" class="headerlink" title="大数相乘"></a>大数相乘</h1><p>思路与大数相加类似。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyBigNUm</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    [num1, num2] = [num1 + <span class="string">&#x27;&#x27;</span>, num2 + <span class="string">&#x27;&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> [len1, len2] = [num1.length, num2.length];</span><br><span class="line">    <span class="keyword">let</span> shortNum, longNum, shortLen, longLen</span><br><span class="line">    <span class="keyword">if</span>(len1 &lt; len2)&#123;</span><br><span class="line">        [shortNum, longNum, shortLen, longLen] = [num1, num2, len1, len2];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [shortNum, longNum, shortLen, longLen] = [num2, num1, len2, len1];</span><br><span class="line">    &#125;</span><br><span class="line">    shortNum = shortNum.split(<span class="string">&#x27;&#x27;</span>).reverse();</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;shortLen; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = multiply(longNum, shortNum[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;i; j++) temp += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        res = addBigNum(temp, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num, n</span>)</span>&#123;</span><br><span class="line">    num = num.split(<span class="string">&#x27;&#x27;</span>).reverse();</span><br><span class="line">    n = <span class="built_in">parseInt</span>(n);</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;num.length; i++)&#123;</span><br><span class="line">        res[i] = res[i]?res[i]:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> tmp = res[i] + <span class="built_in">parseInt</span>(num[i])*n;</span><br><span class="line">        <span class="keyword">if</span>(tmp &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            res[i] = tmp;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[i] = tmp%<span class="number">10</span>;</span><br><span class="line">            res[i+<span class="number">1</span>] = <span class="built_in">Math</span>.floor(tmp/<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实现-add-1-2-3-6-add-1-2-3-6-add-1-2-3-6-add-1-2-3-6"><a href="#实现-add-1-2-3-6-add-1-2-3-6-add-1-2-3-6-add-1-2-3-6" class="headerlink" title="实现 add(1,2,3) == 6, add(1,2,3)() = 6,  add(1)(2)(3) = 6, add(1)(2)(3)() = 6"></a>实现 add(1,2,3) == 6, add(1,2,3)() = 6,  add(1)(2)(3) = 6, add(1)(2)(3)() = 6</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [...arguments].reduce(<span class="function">(<span class="params">a, b</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> innerAdd = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">arguments</span>.length===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res += [...arguments].reduce(<span class="function">(<span class="params">a, b</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a+b;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> innerAdd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    innerAdd.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    innerAdd.toValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerAdd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实现-add-1-2-3-res-6-add-1-2-3-res-6"><a href="#实现-add-1-2-3-res-6-add-1-2-3-res-6" class="headerlink" title="实现 add(1)(2)(3)().res = 6, add(1,2)(3)().res = 6"></a>实现 add(1)(2)(3)().res = 6, add(1,2)(3)().res = 6</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [...arguments].reduce(<span class="function">(<span class="params">a, b</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;<span class="attr">res</span>: res&#125;;</span><br><span class="line">    <span class="keyword">let</span> innerAdd = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">arguments</span>.length===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res += [...arguments].slice(<span class="number">1</span>).reduce(<span class="function">(<span class="params">a, b</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a+b;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">            obj.res = res;</span><br><span class="line">            <span class="keyword">return</span> innerAdd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    innerAdd.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    innerAdd.toValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerAdd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实现superBaby"><a href="#实现superBaby" class="headerlink" title="实现superBaby"></a>实现superBaby</h1><p>一个superBaby</p>
<ul>
<li><p>输入<br>superBaby(“syz”)</p>
</li>
<li><p>输出：<br>“I am syz”</p>
</li>
<li><p>输入<br>superBaby(“syz”).eat(“banana”) </p>
</li>
<li><p>输出<br>“I am syz”<br>“Eating banana”</p>
</li>
<li><p>输入<br>superBaby(“syz”).sleep(5000).eat(“banana”)</p>
</li>
<li><p>输出<br>“I am syz”<br>// 等待 5000ms 后输出<br>“Eating banana”</p>
</li>
<li><p>输入<br>superBaby(“syz”).eat(“banana”).sleep(5000).eat(“apple”).firstSleep(5000)</p>
</li>
<li><p>输出<br>// 等待 5000ms 后输出<br>“I am syz”<br>“Eating banana”<br>// 等待 5000ms 后输出<br>“Eating apple”</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperBaby</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _superBaby(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_superBaby</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`I am <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">        that.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.task.push(fn);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span><span class="built_in">this</span>.next(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_superBaby.prototype = &#123;</span><br><span class="line">    <span class="title">constructor</span>: <span class="title">_superBaby</span>,</span><br><span class="line">    <span class="title">task</span>: [],</span><br><span class="line">    <span class="title">next</span>: <span class="title">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> fn = <span class="built_in">this</span>.task.shift();</span><br><span class="line">        fn &amp;&amp; fn();</span><br><span class="line">    &#125;,</span><br><span class="line">    eat: <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`Eating <span class="subst">$&#123;food&#125;</span>`</span>);</span><br><span class="line">            that.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.task.push(fn);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    sleep: <span class="function"><span class="keyword">function</span>(<span class="params">time</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>that.next(), time);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">this</span>.task.push(fn);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    sleepFirst: <span class="function"><span class="keyword">function</span>(<span class="params">time</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>that.next(), time);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">this</span>.task.unshift(fn);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperBaby(<span class="string">&quot;syz&quot;</span>).sleep(<span class="number">5000</span>).eat(<span class="string">&quot;banana&quot;</span>).sleepFirst(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>
<h1 id="手写-apply、call-及-bind"><a href="#手写-apply、call-及-bind" class="headerlink" title="手写 apply、call 及 bind"></a>手写 apply、call 及 bind</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// apply</span></span><br><span class="line"><span class="built_in">Function</span>.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context, args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    context = context || <span class="built_in">window</span>;</span><br><span class="line">    args = args || [];</span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">const</span> res = context.fn(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call</span></span><br><span class="line"><span class="built_in">Function</span>.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">const</span> res = context.fn(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind</span></span><br><span class="line"><span class="built_in">Function</span>.muBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    context = context || <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        that.apply(context, args.concat([...arguments]))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="判断一个对象是否是数组"><a href="#判断一个对象是否是数组" class="headerlink" title="判断一个对象是否是数组"></a>判断一个对象是否是数组</h1><ul>
<li><p>判断是否为数组的实例</p>
</li>
<li><p>判断原型对象与数组的原型对象是否一致</p>
</li>
<li><p>判断对象的构造函数是否是 Array</p>
</li>
<li><p>调用 Array.isArray() 方法</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judgeArray</span>(<span class="params">arr, pattern</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(pattern)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(arr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> arr.constructor === <span class="built_in">Array</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(arr) === <span class="built_in">Array</span>.prototype;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实现-Promise-all"><a href="#实现-Promise-all" class="headerlink" title="实现 Promise.all"></a>实现 Promise.all</h1><p>Promise.all 允许定义的 Promise 按照数组传入，并依次执行 Promise 并将结果保存在一个列表中，返回一个Promise.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">&quot;只要有爱,&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">&quot;在哪里都是天堂！&quot;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.reject(<span class="string">&quot;不要让恨遮蔽了双眼！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// [ &#x27;只要有爱,&#x27;, &#x27;在哪里都是天堂！&#x27; ]</span></span><br><span class="line"><span class="comment">// 不要让恨遮蔽了双眼！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自己实现.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.myAll = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res = [];</span><br><span class="line">        promises.forEach(<span class="function">(<span class="params">promise, index</span>)=&gt;</span>&#123;</span><br><span class="line">            promise.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">                res.push(data);</span><br><span class="line">                <span class="keyword">if</span>(index===promises.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    resolve(res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.myAll([p1, p2]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.myAll([p1, p2, p3]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="模拟-Node-js-的-Event-模块"><a href="#模拟-Node-js-的-Event-模块" class="headerlink" title="模拟 Node.js 的 Event 模块"></a>模拟 Node.js 的 Event 模块</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.fns = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">emit</span>(<span class="params">name, value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">this</span>.fns[name])&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&quot;No such event&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.fns[name].forEach(<span class="function"><span class="params">fn</span>=&gt;</span>&#123;</span><br><span class="line">            fn(value);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">on</span>(<span class="params">name, cb</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">this</span>.fns[name])&#123;</span><br><span class="line">            <span class="built_in">this</span>.fns[name] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.fns[name].push(cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> event = <span class="keyword">new</span> Event();</span><br><span class="line"></span><br><span class="line">event.on(<span class="string">&#x27;sayName&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">event.on(<span class="string">&#x27;sayName&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">event.emit(<span class="string">&#x27;sayName&#x27;</span>, <span class="string">&#x27;syz&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// syz</span></span><br><span class="line"><span class="comment">// I am syz</span></span><br></pre></td></tr></table></figure>
<h1 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h1><p>一般深度克隆可以采用 Json.Parse(Json.stringify())，但是克隆存在一些<a href="https://segmentfault.com/a/1190000020297508">问题</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>?[]:&#123;&#125;;</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">        res[key] = <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span>? deepClone(obj[key]):obj[key];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rawObj = &#123;<span class="attr">name</span>:<span class="string">&#x27;syz&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> testObj = deepClone(rawObj);</span><br><span class="line"></span><br><span class="line">testObj.name = <span class="string">&#x27;xz&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(rawObj)</span><br><span class="line"><span class="built_in">console</span>.log(testObj)</span><br></pre></td></tr></table></figure>
<h1 id="自己实现模版字符串"><a href="#自己实现模版字符串" class="headerlink" title="自己实现模版字符串"></a>自己实现模版字符串</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;zj&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">`我的名字叫<span class="subst">$&#123; obj.name &#125;</span>，今年<span class="subst">$&#123;obj.age&#125;</span>岁`</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> str.replace(<span class="regexp">/\$\&#123;([^&#125;]+)\&#125;/</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> data;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(replace(str))</span><br></pre></td></tr></table></figure>
<h1 id="实现展开任意深度的嵌套列表"><a href="#实现展开任意深度的嵌套列表" class="headerlink" title="实现展开任意深度的嵌套列表"></a>实现展开任意深度的嵌套列表</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -1表示全部展开</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr, depth=-<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth===-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [].concat(</span><br><span class="line">            ...arr.map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(item)?flatten(item):item</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(depth===<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, cur</span>)=&gt;</span>pre.concat(cur),[])</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, cur</span>)=&gt;</span>pre.concat(<span class="built_in">Array</span>.isArray(cur)?flatten(cur, depth-<span class="number">1</span>):cur), []);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实现金钱的每三位划分"><a href="#实现金钱的每三位划分" class="headerlink" title="实现金钱的每三位划分"></a>实现金钱的每三位划分</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="string">&#x27;1234567890&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trans</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.split(<span class="string">&#x27;&#x27;</span>).reverse().reduce(<span class="function">(<span class="params">pre, cur, idx</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((idx%<span class="number">3</span>)?cur:cur+<span class="string">&#x27;,&#x27;</span>) + pre</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(trans(arr));<span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<h1 id="分时函数"><a href="#分时函数" class="headerlink" title="分时函数"></a>分时函数</h1><p>对于需要频繁添加大量DOM结构的操作，如果不设计一定的策略，浏览器在短时间渲染这个多DOM结构，会造成浏览器的卡顿。</p>
<p>此时可以设计分时函数，在指定时间间隔内，执行指定次数的函数，添加指定数量的DOM结构。</p>
<p>例如有一个好友列表，需要动态渲染其中成百上千的列表，此时可以采用分时函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timeChunk = <span class="function"><span class="keyword">function</span>(<span class="params">arr, fn, count, time</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="built_in">Math</span>.min(count || <span class="number">1</span>, arr.length); i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> content = arr.shift();</span><br><span class="line">            fn(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> t = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr.length===<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">clearInterval</span>(t);</span><br><span class="line">                t=<span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ls = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">    ls.push(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> renderFriendList = timeChunk(ls, <span class="function"><span class="keyword">function</span>(<span class="params">content</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    div.innerHTML = content;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;, <span class="number">8</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">renderFriendList();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer：矩阵中的路径</title>
    <url>/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>没有接触过类似的题型，因此看了讲解。</p>
<p>题目给出的是待查询的<strong>矩阵字符串</strong>与对应的<strong>行</strong>与<strong>列</strong>。</p>
<p>首先需要转化为矩阵。</p>
<p>然后利用<strong>回溯法</strong>，起始点依次选择矩阵中的每一个位置，上下左右进行遍历。</p>
<p>需要设置一个<strong>哨兵矩阵</strong>，记录已经访问的，防止重复访问产生无限循环。思想跟<u><a href="http://sunyunzeng.com/Leetcode-%E5%B2%9B%E5%B1%BF%E6%9C%80%E5%A4%A7%E7%9A%84%E9%9D%A2%E7%A7%AF/">http://sunyunzeng.com/Leetcode-%E5%B2%9B%E5%B1%BF%E6%9C%80%E5%A4%A7%E7%9A%84%E9%9D%A2%E7%A7%AF/</a></u>类似。</p>
<p>判定成功条件：<strong>回溯的路径长度与查询路径长度一致</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] next = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cols;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(rows&lt;=<span class="number">0</span> || cols&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.rows = rows;</span><br><span class="line">        <span class="keyword">this</span>.cols = cols;</span><br><span class="line">        <span class="keyword">char</span>[][] m = getMatrix(matrix);</span><br><span class="line">        <span class="keyword">boolean</span>[][] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cols; j++)</span><br><span class="line">                <span class="keyword">if</span>(backtrace(m, str, i, j, <span class="number">0</span>, visit))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">char</span>[][] matrix, <span class="keyword">char</span>[] str, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> pathLen, </span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">boolean</span>[][] visit)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 边界判断</span></span><br><span class="line">        <span class="keyword">if</span>(pathLen==str.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span> || r&gt;rows-<span class="number">1</span> || c&lt;<span class="number">0</span> || c&gt;cols-<span class="number">1</span> || str[pathLen]!=matrix[r][c] || visit[r][c])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 当前格子设定为已访问，防止重复访问</span></span><br><span class="line">        visit[r][c] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] step: next)&#123;</span><br><span class="line">            <span class="comment">// 递归回溯，只要找到一个字符满足要求，就返回true</span></span><br><span class="line">            <span class="keyword">if</span>(backtrace(matrix, str, r+step[<span class="number">0</span>], c+step[<span class="number">1</span>], pathLen+<span class="number">1</span>, visit))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此路不通，格子回归初始状态，重新选择起始格子</span></span><br><span class="line">        visit[r][c] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据一维字符数组生成二维矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[][] getMatrix(<span class="keyword">char</span>[] matrix)&#123;</span><br><span class="line">        <span class="keyword">char</span>[][] res = <span class="keyword">new</span> <span class="keyword">char</span>[rows][cols];</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cols; j++)&#123;</span><br><span class="line">                res[i][j] = matrix[s];</span><br><span class="line">                s++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题--买卖股票的最佳时机</title>
    <url>/%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h1><blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<p><strong>示例1</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">3</span> 天（股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span> 。</span><br><span class="line">     随后，在第 <span class="number">4</span> 天（股票价格 = <span class="number">3</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">6</span>-<span class="number">3</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 在第 <span class="number">1</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天 （股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span> 。</span><br><span class="line">     注意你不能在第 <span class="number">1</span> 天和第 <span class="number">2</span> 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>
<p><strong>示例3</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>贪心算法，通过计算局部最优，综合多个局部最优结果得到全局最优结果</p>
<p>一次循环，只要第二天股票价格比当天高，就买入，否则不买入。</p>
<p>计算当天买入跟第二天卖出的利润和，即为结果。</p>
<p><strong>并不一定要在最低值买入，在最高点卖出。因为每次低买高卖的累积和等于最低点与最高点之间的收益。</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=prices.length-<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&lt;prices[i+<span class="number">1</span>])&#123;</span><br><span class="line">                result += prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">题目链接</a></p>
<h1 id="有手续费版"><a href="#有手续费版" class="headerlink" title="有手续费版"></a>有手续费版</h1><blockquote>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。<br>你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>返回获得利润的最大值。</p>
</blockquote>
<p><strong>示例 1：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: prices = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>], fee = <span class="number">2</span></span><br><span class="line">输出: <span class="number">8</span></span><br><span class="line">解释: 能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">在此处卖出 prices[<span class="number">3</span>] = <span class="number">8</span></span><br><span class="line">在此处买入 prices[<span class="number">4</span>] = <span class="number">4</span></span><br><span class="line">在此处卖出 prices[<span class="number">5</span>] = <span class="number">9</span></span><br><span class="line">总利润: ((<span class="number">8</span> - <span class="number">1</span>) - <span class="number">2</span>) + ((<span class="number">9</span> - <span class="number">4</span>) - <span class="number">2</span>) = <span class="number">8.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意 :</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> &lt; prices.length &lt;= <span class="number">50000.</span></span><br><span class="line"><span class="number">0</span> &lt; prices[i] &lt; <span class="number">50000.</span></span><br><span class="line"><span class="number">0</span> &lt;= fee &lt; <span class="number">50000.</span></span><br></pre></td></tr></table></figure></p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>简单DP问题</p>
<p>当前的状态 <strong>i</strong> 共有两种，<strong>持有股票</strong>与<strong>不持有股票</strong></p>
<p><strong>持有股票状态</strong>可能是 <strong>前一状态买入</strong> 或者 <strong>当前买入</strong>:</p>
<blockquote>
<p>收益方程：$buy<em>{profit}^i=max(buy</em>{profit}^{i-1},   sell_{profit}^{i-1}-prices[i])$</p>
</blockquote>
<p><strong>不持有股票</strong>可能是 <strong>前一状态卖出</strong> 或者 <strong>当前卖出</strong>:</p>
<blockquote>
<p>收益方程：$sell<em>{profit}^i=max(sell</em>{profit}^{i-1},   prices[i]+buy_{profit}^i-fee)$</p>
</blockquote>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//没有stock的收益</span></span><br><span class="line">        <span class="keyword">int</span> sell_profit = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//拥有stock的收益</span></span><br><span class="line">        <span class="keyword">int</span> buy_profit = -prices[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="comment">//今天卖了或者之前卖了的收益</span></span><br><span class="line">            sell_profit = Math.max(sell_profit, prices[i]+buy_profit-fee);</span><br><span class="line">            <span class="comment">//今天买了或者之前买了的收益</span></span><br><span class="line">            buy_profit = Math.max(buy_profit, sell_profit-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//卖了股票的收益肯定大于持有股票的收益，因为持有股票是负收益</span></span><br><span class="line">        <span class="keyword">return</span> sell_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">题目链接</a></p>
<h1 id="有冷冻期版"><a href="#有冷冻期版" class="headerlink" title="有冷冻期版"></a>有冷冻期版</h1><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p>
<h1 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>与 <strong>题目2</strong>类似，不过要增加一个状态 ———— <strong>冻结状态</strong>。</p>
<p><strong>卖出状态</strong>只能由<strong>买入状态</strong>转来。</p>
<p><strong>买入状态</strong>可由<strong>买入状态</strong>或者<strong>冻结状态</strong>转来。</p>
<p><strong>冻结状态</strong>由<strong>冻结状态</strong>或者<strong>买入状态</strong>转来。</p>
<p><strong>注意状态的依赖关系，不要再依赖前一状态之前先改变当前状态。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hold = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sold = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> freeze = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pre_sold = sold;</span><br><span class="line">            sold = hold + prices[i];</span><br><span class="line">            hold = Math.max(hold,freeze-prices[i]);</span><br><span class="line">            freeze = Math.max(freeze, pre_sold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(sold, freeze);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="只允许买卖一次版本"><a href="#只允许买卖一次版本" class="headerlink" title="只允许买卖一次版本"></a>只允许买卖一次版本</h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你<strong>最多只允许完成一笔交易（即买入和卖出一支股票）</strong>，设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span>-<span class="number">1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span>-<span class="number">1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure></p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>动态规划问题。</p>
<p>维护一个值，存储之前i-1天的最大利润，当前i天的最大利润为<strong>当前价格与前i-1天价格最小值的差值与i-1最大利润的较大值。</strong></p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min_price = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">            result = Math.max(result, prices[i]-min_price);</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&lt;min_price) </span><br><span class="line">                min_price = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result&lt;<span class="number">0</span>?<span class="number">0</span>:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="只允许买卖两次版本"><a href="#只允许买卖两次版本" class="headerlink" title="只允许买卖两次版本"></a>只允许买卖两次版本</h1><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 在第 <span class="number">4</span> 天（股票价格 = <span class="number">0</span>）的时候买入，在第 <span class="number">6</span> 天（股票价格 = <span class="number">3</span>）的时候卖出，这笔交易所能获得利润 = <span class="number">3</span>-<span class="number">0</span> = <span class="number">3</span> 。</span><br><span class="line">     随后，在第 <span class="number">7</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">8</span> 天 （股票价格 = <span class="number">4</span>）的时候卖出，这笔交易所能获得利润 = <span class="number">4</span>-<span class="number">1</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 在第 <span class="number">1</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天 （股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span> 。   </span><br><span class="line">     注意你不能在第 <span class="number">1</span> 天和第 <span class="number">2</span> 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><br>示例 3:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>] </span><br><span class="line">输出: <span class="number">0</span> </span><br><span class="line">解释: 在这个情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure></p>
<h2 id="思路-代码-1"><a href="#思路-代码-1" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h2><p>四个状态，即第一次买入与卖出，第二次买入与卖出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        first_buy, first_sell = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>), <span class="number">0</span></span><br><span class="line">        second_buy, second_sell = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="keyword">if</span> first_buy &lt; -price:</span><br><span class="line">                first_buy = -price</span><br><span class="line">            <span class="keyword">if</span> first_buy+price &gt; first_sell:</span><br><span class="line">                first_sell = first_buy+price</span><br><span class="line">            <span class="keyword">if</span> second_buy + price &lt; first_sell:</span><br><span class="line">                second_buy = first_sell - price</span><br><span class="line">            <span class="keyword">if</span> second_buy + price &gt; second_sell:</span><br><span class="line">                second_sell = second_buy + price</span><br><span class="line">        <span class="keyword">return</span> second_sell</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="允许买卖k次"><a href="#允许买卖k次" class="headerlink" title="允许买卖k次"></a>允许买卖k次</h1><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>], k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 在第 <span class="number">1</span> 天 (股票价格 = <span class="number">2</span>) 的时候买入，在第 <span class="number">2</span> 天 (股票价格 = <span class="number">4</span>) 的时候卖出，这笔交易所能获得利润 = <span class="number">4</span>-<span class="number">2</span> = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天 (股票价格 = <span class="number">2</span>) 的时候买入，在第 <span class="number">3</span> 天 (股票价格 = <span class="number">6</span>) 的时候卖出, 这笔交易所能获得利润 = <span class="number">6</span>-<span class="number">2</span> = <span class="number">4</span> 。</span><br><span class="line">     随后，在第 <span class="number">5</span> 天 (股票价格 = <span class="number">0</span>) 的时候买入，在第 <span class="number">6</span> 天 (股票价格 = <span class="number">3</span>) 的时候卖出, 这笔交易所能获得利润 = <span class="number">3</span>-<span class="number">0</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure></p>
<h1 id="思路-代码-2"><a href="#思路-代码-2" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>参考链接<u><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/</a></u></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfitInf</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        buy, sell = -prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            buy = <span class="built_in">max</span>(buy, sell-prices[i])</span><br><span class="line">            sell = <span class="built_in">max</span>(sell, buy+prices[i])</span><br><span class="line">        <span class="keyword">return</span> sell</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, k, prices</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices <span class="keyword">or</span> k&lt;=<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        <span class="comment"># 此时相当于可以无限交易</span></span><br><span class="line">        <span class="keyword">if</span> k &gt;= n//<span class="number">2</span>: <span class="keyword">return</span> self.maxProfitInf(prices)</span><br><span class="line">        <span class="comment"># 0表示不持有股票，1表示持有股票</span></span><br><span class="line">        dp = [[[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i-<span class="number">1</span>&lt;<span class="number">0</span>:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>], dp[i][j][<span class="number">1</span>] = <span class="number">0</span>, -prices[i]</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dp[i][j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j][<span class="number">0</span>], dp[i-<span class="number">1</span>][j][<span class="number">1</span>]+prices[i])</span><br><span class="line">                <span class="comment"># 表明交易是在k=1开始的</span></span><br><span class="line">                dp[i][j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j][<span class="number">1</span>], dp[i-<span class="number">1</span>][j-<span class="number">1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题：二叉树相关</title>
    <url>/%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h1><blockquote>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。<br>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
</blockquote>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree <span class="number">1</span>                     Tree <span class="number">2</span>                  </span><br><span class="line">          <span class="number">1</span>                         <span class="number">2</span>                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        <span class="number">3</span>   <span class="number">2</span>                     <span class="number">1</span>   <span class="number">3</span>                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      <span class="number">5</span>                             <span class="number">4</span>   <span class="number">7</span>                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     <span class="number">3</span></span><br><span class="line">	    / \</span><br><span class="line">	   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">	  / \   \ </span><br><span class="line">	 <span class="number">5</span>   <span class="number">4</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递归算法，每棵树都由子树构成，根节点融合可以通过递归拆分成子树进行。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span>(t2==<span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        t1.val += t2.val;</span><br><span class="line">        t1.left = mergeTrees(t1.left,t2.left);</span><br><span class="line">        t1.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树最大深度"><a href="#二叉树最大深度" class="headerlink" title="二叉树最大深度"></a>二叉树最大深度</h1><blockquote>
<p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
</blockquote>
<p><strong>示例:</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><br>返回它的最大深度 3 。</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>同上，树划分成两棵树，递归求解。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">题目链接</a></p>
<h1 id="N叉树的最大深度"><a href="#N叉树的最大深度" class="headerlink" title="N叉树的最大深度"></a>N叉树的最大深度</h1><blockquote>
<p>给定一个 N 叉树，找到其最大深度。</p>
<p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>
<p>例如，给定一个 3叉树 :</p>
</blockquote>
<img src="/%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3/narytreeexample.png" class>
<p>我们应返回其最大深度，3。</p>
<p><strong>说明:</strong></p>
<p>树的深度不会超过 1000。<br>树的节点总不会超过 5000。</p>
<h2 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路+代码"></a>思路+代码</h2><p>类比二叉树最大深度，迭代求解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;root.children.size(); i++)&#123;</span><br><span class="line">            depth = Math.max(maxDepth(root.children.get(i)),depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><blockquote>
<p>翻转一棵二叉树。</p>
</blockquote>
<p><strong>示例：</strong><br>输入:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>备注:</strong></p>
<p>这个问题是受到 Max Howell 的 <a href="https://www.zhihu.com/question/31202353">原问题</a> 启发的 ：</p>
<blockquote>
<p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p>
</blockquote>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>so easy! 递归完事了。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode obj = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = obj;   </span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题：位运算相关</title>
    <url>/%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：<br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
</blockquote>
<p><strong>示例1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure><br><strong>示例2:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于时间复杂度与空间复杂度的限制，这道题目解决办法一定是很巧妙的。</p>
<p>答案是采用<strong>异或</strong>的方法。</p>
<p>Java的<strong>异或^</strong>是位运算的一种，含义是相同的位数置 0 ，相异的位数置 1 。数字本身(相同数字)的异或结果为 0 ，0 与任何数字的异或结果为其本身。</p>
<p>Hash Map中的hash码映射到数组位置就采用了异或的方法，(h=key.hashcode())^(h&gt;&gt;16);</p>
<blockquote>
<p>例如:<br>0000 0000 0000 <strong>1011</strong> ^<br>0000 0000 0000 <strong>1111</strong><br>0000 0000 0000 <strong>0100</strong></p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            result = result^nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。<br>给出两个整数 x 和 y，计算它们之间的汉明距离。</p>
<p><strong>注意：</strong><br>0 ≤ x, y &lt; 231.</p>
</blockquote>
<p><strong>示例：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: x = <span class="number">1</span>, y = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line"><span class="number">1</span>   (<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>)</span><br><span class="line"><span class="number">4</span>   (<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure></p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>先异或运算 ^ 将相同位置不同数字的置为 1 。</p>
<p>再通过移位， 与 1 进行 与 &amp; 运算，计算出结果。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> z = x^y;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算二进制表示中 1 的数量</span></span><br><span class="line">        <span class="keyword">while</span>(z&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((z &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                result ++;</span><br><span class="line">            &#125;</span><br><span class="line">            z &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="计算m的n次方"><a href="#计算m的n次方" class="headerlink" title="计算m的n次方"></a>计算m的n次方</h1><p>例如 n = 13，则 n 的二进制表示为 1101, 那么 m 的 13 次方可以拆解为:</p>
<p>m^1101 = m^0001 <em> m^0100 </em> m^1000。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = m;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 几个1乘几次</span></span><br><span class="line">                sum *= tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第二位乘两次，第三位乘四次...</span></span><br><span class="line">            tmp *= tmp;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="不用辅助变量交换两个数"><a href="#不用辅助变量交换两个数" class="headerlink" title="不用辅助变量交换两个数"></a>不用辅助变量交换两个数</h1><p>用异或运算 <strong>^</strong> ，相同的数异或为 0 ,且支持<strong>交换律</strong>与<strong>结合律</strong>。</p>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = x^y;</span><br><span class="line">y = x^y;</span><br><span class="line">x = x^y;</span><br></pre></td></tr></table></figure>
<h1 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a>比特位计数</h1><p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<p><strong>示例1:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>示例2:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">5</span></span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>进阶:</strong></p>
<blockquote>
<p>给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？<br>要求算法的空间复杂度为O(n)。<br>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。</p>
</blockquote>
<ol>
<li><p>最容易想到方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=num; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> t = i;</span><br><span class="line">            <span class="keyword">while</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((t &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                    count++;</span><br><span class="line">                t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result[i] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前数字的比特位数量等于左移一位数字的比特位数量加上（当前数字&amp;1）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=num; i++)&#123;</span><br><span class="line">            result[i] = result[i&gt;&gt;<span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题：反转链表</title>
    <url>/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote>
<p>反转一个单链表。</p>
</blockquote>
<p><strong>示例:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure></p>
<p><strong>进阶:</strong></p>
<blockquote>
<p>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h2><p>采用迭代方法，及循环迭代。用一个变量存储上一节点对象，一个变量存储当前节点对象，一个对象存储下一节点对象。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h2><p>采用递归，先递归找到原链表尾巴作为头节点，再依次反转链表。</p>
<p><strong>head.next.next = head;</strong><br><strong>head.next = null;</strong></p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode p = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">题目链接</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题-移动零</title>
    <url>/%E7%AE%97%E6%B3%95%E9%A2%98-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>示例:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>说明:</strong></p>
<pre><code>1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。
</code></pre><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>采用双循环，当遇到零元素时，与后面序列中第一个非零元素交换。</p>
<p><strong>时间复杂度:</strong> $O(n!)$</p>
<p><strong>结果:</strong><br>执行用时 : 16 ms<br>内存消耗 :37.4 MB</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> j =i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j&lt;len&amp;&amp;nums[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j==len) <span class="keyword">break</span>;</span><br><span class="line">                nums[i]=nums[j];</span><br><span class="line">                nums[j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>评论中高赞方法是采用双指针的方式。</p>
<p>先将非零元素按照顺序紧密移动到前面，再按照零元素数量对数组后面元素补零。</p>
<h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[i]=nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; i&lt;len; i++)&#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong><br>执行用时 : 1 ms<br>内存消耗 :39.3 MB</p>
<p><a href="https://leetcode-cn.com/problems/move-zeroes/submissions/">题目链接</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题-合并两个有序链表</title>
    <url>/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例1：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<h1 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h1><p>分为两步：</p>
<p>第一步： 记录所有的链表的数值并排序。因为链表的长度未知，所以需要用 List 来存储。</p>
<p>第二步： 按照排序后的链表数值，建立对应链表。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>&amp;&amp;l2==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2==<span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(l1.val);</span><br><span class="line">            l1=l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(l2.val);</span><br><span class="line">            l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(list.get(<span class="number">0</span>).intValue());</span><br><span class="line">        ListNode pev = result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;size;i++)&#123;</span><br><span class="line">            ListNode tmp = <span class="keyword">new</span> ListNode(list.get(i).intValue());</span><br><span class="line">            pev.next = tmp;</span><br><span class="line">            pev = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>官方题解：采用递归方法。</p>
<p>终止条件：l1 = null 或者 l2 = null。</p>
<p>判断条件：<br>    <code>if(l1.val&lt;l2.val): mergeTwoLists(l1.next, l2)</code><br>    <code>else: mergeTwoLists(l1, l2.next)</code></p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h2><p>官方题解：采用递归。</p>
<p>时间复杂度与空间复杂度最优。</p>
<p>关键在于设计哨兵节点，记录前一个节点。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode preHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode preNode = preHead;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">                preNode.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                preNode.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            preNode = preNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        preNode.next = l1==<span class="keyword">null</span>?l2:l1;</span><br><span class="line">        <span class="keyword">return</span> preHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题：计算众数</title>
    <url>/%E7%AE%97%E6%B3%95%E9%A2%98-%E8%AE%A1%E7%AE%97%E4%BC%97%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h2><p><strong>法1. 我的方法，超笨。用一个Map记录数字出现的次数，然后当次数大于n/2时返回。</strong></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(nums[i])!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                Integer num = map.get(nums[i]);</span><br><span class="line">                map.put(nums[i], num+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(map.get(nums[i])&gt;len/<span class="number">2</span>)  <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>法2. 先排序，后取中位数</strong></p>
<p>代码略</p>
<p><strong>法3. 用一个变量count计数，从0开始，遇到相同的+1，遇到不同的-1，变为零则重新计数。</strong></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> num = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num==nums[i]) count++;</span><br><span class="line">            <span class="keyword">else</span> count--;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">                num = nums[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/majority-element/submissions/">题目链接</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现符合Promise/A+规范的Promise</title>
    <url>/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%AC%A6%E5%90%88Promise-A-%E8%A7%84%E8%8C%83%E7%9A%84Promise/</url>
    <content><![CDATA[<h1 id="Promise异步实现"><a href="#Promise异步实现" class="headerlink" title="Promise异步实现"></a>Promise异步实现</h1><p>之前在<a href="http://sunyunzeng.com/JS%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E5%B0%8F%E7%BB%93/">JS异步函数小结</a>里面初步介绍了JS里面的一些异步操作与 Promise 的使用方法，我们要知其然也要知其所以然，所以让我们看一下如何动手实现自己的 MyPromise。</p>
<h2 id="Promise-A-协议"><a href="#Promise-A-协议" class="headerlink" title="Promise/A+协议"></a>Promise/A+协议</h2><p>协议是实现的基础，Promise/A+协议的中文参考网站如下：</p>
<p><a href="https://www.ituring.com.cn/article/66566">https://www.ituring.com.cn/article/66566</a></p>
<p>英文网站如下：</p>
<p><a href="https://promisesaplus.com/">https://promisesaplus.com/</a></p>
<h1 id="实现最简单的构造函数，可以满足回调函数的调用"><a href="#实现最简单的构造函数，可以满足回调函数的调用" class="headerlink" title="实现最简单的构造函数，可以满足回调函数的调用"></a>实现最简单的构造函数，可以满足回调函数的调用</h1><ul>
<li><p>首先Promise<strong>构造参数只能接受函数</strong>，否则报错。</p>
</li>
<li><p>Promise<strong>内部变量</strong>包括：</p>
<ul>
<li>值 <strong>value</strong> =&gt; 指任何 JavaScript 的合法值（包括 undefined , thenable 和 promise）。</li>
<li>拒因 <strong>reason</strong> =&gt; 值一个 promise 拒绝的原因。</li>
<li>状态 <strong>state</strong> =&gt; promise 执行所处的状态<ul>
<li>Promise规范规定了Promise的状态一共有三种：<strong>Pending、Fulfilled 及 Rejected</strong>。状态之间的转换只能是 Pending =&gt; Fulfilled 或者 Pending =&gt; Rejected，状态的转换不可逆转。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>初步实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyPromise.js</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// Promise的构造函数参数必须是函数，否则报错</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> executor !== <span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Promise resolver <span class="subst">$&#123;executor&#125;</span> is not a function`</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.initValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部参数初始化</span></span><br><span class="line">    <span class="function"><span class="title">initValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="literal">null</span>; <span class="comment">// 值</span></span><br><span class="line">        <span class="built_in">this</span>.reason = <span class="literal">null</span>; <span class="comment">//据因</span></span><br><span class="line">        <span class="built_in">this</span>.state = MyPromise.PENDING; <span class="comment">// 初始状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.PENDING = <span class="string">&quot;Pending&quot;</span>;</span><br><span class="line">MyPromise.FULFILLED = <span class="string">&quot;Fulfilled&quot;</span>;</span><br><span class="line">MyPromise.REJECTED = <span class="string">&quot;Rejected&quot;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>同时 Promise <strong>采用两个回调函数作为值 value 传递</strong>的方法，分别是 <strong>resolve</strong> 函数 及 <strong>reject</strong> 函数，分别对应 <strong>Fulfilled</strong> 状态及 <strong>Rejected</strong> 状态的函数回调，回调函数分别为 <strong>OnFulfilled</strong> 及 <strong>OnRejected</strong>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">OnFulfilled, OnRejected</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// promise 执行成功后回调</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.state === MyPromise.FULFILLED)&#123;</span><br><span class="line">            OnFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// promise 执行失败后回调</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.state === MyPromise.REJECTED)&#123;</span><br><span class="line">            OnRejected(<span class="built_in">this</span>.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="string">&#x27;1&#x27;</span>); <span class="comment">// 报错 TypeError: Promise resolver 1 is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise2.then(<span class="function"><span class="params">data</span>=&gt;</span><span class="built_in">console</span>.log(data)); <span class="comment">// 打印 1可以执行</span></span><br></pre></td></tr></table></figure>
<p><strong>问题</strong></p>
<p>如果promise函数内存在异步，那么 state 状态仍为 Pending 但是 then 函数为同步执行，导致 value 没有同步传递，没有输出。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise3.then(<span class="function"><span class="params">data</span>=&gt;</span><span class="built_in">console</span>.log(data)) <span class="comment">// 没有输出</span></span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>添加 state 为 Pending 状态时的处理，并用两个任务队列 <strong>OnFulfilledCallbacks</strong> 及 <strong>OnRejectedCallbacks</strong> 分别存储状态为 <strong>OnFulfilled</strong> 及 <strong>OnRejected</strong> 的异步执行回调函数，然后等 resolve 函数执行完毕再调用回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyPromise.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve 函数执行，state 变为 FULFILLED</span></span><br><span class="line"><span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">this</span>.OnFulfilledCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(<span class="built_in">this</span>.value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 函数执行，state 变为 REJECTED</span></span><br><span class="line"><span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">this</span>.OnRejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(<span class="built_in">this</span>.reason));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">OnFulfilled, OnRejected</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步执行函数状态为 Pending 时的处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.state === MyPromise.PENDING) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.OnFulfilledCallbacks.push(</span><br><span class="line">                (value) =&gt; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    OnFulfilled(value);</span><br><span class="line">                &#125;));</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.OnRejectedCallbacks.push(</span><br><span class="line">                (reason) =&gt; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    OnRejected(reason);</span><br><span class="line">                &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise3.then(<span class="function"><span class="params">data</span>=&gt;</span><span class="built_in">console</span>.log(data)) <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure>
<h1 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h1><p>根据 Promise/A+ 的规范定义，Promise的 <strong>then 函数返回一个 promise2 以支持链式调用</strong>，因此对代码进行修改：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">OnFulfilled, OnRejected</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> OnFulfilled !== <span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果 OnFulfilled 不是函数或者为空就支持链式调用 .then().then()</span></span><br><span class="line">        OnFulfilled = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> OnRejected !== <span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">        OnRejected = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// promise 执行成功后回调</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.state === MyPromise.FULFILLED) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 上一个 Promise回调函数返回的值交给下一个 Promise调用</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">const</span> x = OnFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                    resolve(x); </span><br><span class="line">                &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// promise 执行失败后回调</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.state === MyPromise.REJECTED) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">const</span> x = OnRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                    resolve(x);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步执行函数状态为 Pending 时的处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.state === MyPromise.PENDING) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.OnFulfilledCallbacks.push(</span><br><span class="line">                (value) =&gt; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="keyword">const</span> x = OnFulfilled(value);</span><br><span class="line">                        resolve(x);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;));</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.OnRejectedCallbacks.push(</span><br><span class="line">                (reason) =&gt; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="keyword">const</span> x = OnRejected(reason);</span><br><span class="line">                        resolve(x);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise4 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="number">2</span>);</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise4.then().then().then(<span class="function"><span class="params">data</span>=&gt;</span><span class="built_in">console</span>.log(data)) <span class="comment">// 2 支持链式调用</span></span><br></pre></td></tr></table></figure>
<h1 id="如果-resolve-函数返回-Promise-或者-带有-thenable-方法的类及-then-方法的处理"><a href="#如果-resolve-函数返回-Promise-或者-带有-thenable-方法的类及-then-方法的处理" class="headerlink" title="如果 resolve 函数返回 Promise 或者 带有 thenable 方法的类及 then 方法的处理"></a>如果 resolve 函数返回 Promise 或者 带有 thenable 方法的类及 then 方法的处理</h1><p>首先定义一个 resolveMyPromise 的处理方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyPromise.resolveMyPromise = <span class="function"><span class="keyword">function</span>(<span class="params">promise2, x, resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 循环调用 thenable 方法时只调用一次</span></span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果返回的 x 等于 promise2，则报错，避免循环调用</span></span><br><span class="line">    <span class="keyword">if</span>(x===promise2)&#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;cannot return the same promise object from onfulfilled or on rejected callback.&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x <span class="keyword">instanceof</span> MyPromise)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 避免null也为object</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( (x!==<span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> x === <span class="string">&quot;object&quot;</span>) || <span class="keyword">typeof</span> x ===<span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果不是 MyPromise 或者不是具有 thenable 的类及方法，就直接传入 x 数据</span></span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 Promise/A+ 的规范依次实现 resolveMyPromise 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">MyPromise.resolveMyPromise = <span class="function"><span class="keyword">function</span>(<span class="params">promise2, x, resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 循环调用 thenable 方法时只调用一次</span></span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 promise2 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise</span></span><br><span class="line">    <span class="keyword">if</span>(x===promise2)&#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;cannot return the same promise object from onfulfilled or on rejected callback.&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// x 为 Promise</span></span><br><span class="line">    <span class="keyword">if</span>(x <span class="keyword">instanceof</span> MyPromise)&#123;</span><br><span class="line">        <span class="comment">// 如果 x 为 Promise ，则使 promise 接受 x 的状态</span></span><br><span class="line">        <span class="comment">// 如果 x 处于执行态，用相同的值执行 promise</span></span><br><span class="line">        <span class="comment">// 如果 x 处于拒绝态，用相同的据因拒绝 promise</span></span><br><span class="line">        x.then(<span class="function"><span class="params">y</span>=&gt;</span>&#123;</span><br><span class="line">            MyPromise.resolveMyPromise(promise2, y, resolve, reject);</span><br><span class="line">        &#125;, <span class="function"><span class="params">r</span>=&gt;</span>&#123;</span><br><span class="line">            reject(r);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 x 为对象或者函数 (x !== null 避免null也为object)</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( (x!==<span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> x === <span class="string">&quot;object&quot;</span>) || <span class="keyword">typeof</span> x ===<span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123; <span class="comment">// 防止调用 then 的 getter 方法调用抛出异常</span></span><br><span class="line">            <span class="comment">// 把 x.then 赋值给 then</span></span><br><span class="line">            <span class="keyword">const</span> then = x.then;</span><br><span class="line">            <span class="comment">// 如果 then 是函数，将 x 作为函数的作用域 this 调用之。</span></span><br><span class="line">            <span class="comment">// 传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise:</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">                then.call(x, <span class="function"><span class="params">y</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">// 如果 resolvePromise 和 rejectPromise 均被调用，</span></span><br><span class="line">                    <span class="comment">// 或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</span></span><br><span class="line">                    <span class="keyword">if</span>(called) <span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    MyPromise.resolveMyPromise(promise2, y, resolve, reject);</span><br><span class="line">                &#125;, <span class="function"><span class="params">r</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(called) <span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    reject(r);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(called) <span class="keyword">return</span>;</span><br><span class="line">                called = <span class="literal">true</span>;</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果不是 MyPromise 或者不是具有 thenable 的类及方法，就直接传入 x 数据</span></span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再在 then 方法里面调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">OnFulfilled, OnRejected</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> OnFulfilled !== <span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果 OnFulfilled 不是函数或者为空就支持链式调用 .then().then()</span></span><br><span class="line">        OnFulfilled = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> OnRejected !== <span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">        OnRejected = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// promise 执行成功后回调</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.state === MyPromise.FULFILLED) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 上一个 Promise回调函数返回的值交给下一个 Promise调用</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">const</span> x = OnFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                    MyPromise.resolveMyPromise(promise2, x, resolve, reject); </span><br><span class="line">                &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// promise 执行失败后回调</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.state === MyPromise.REJECTED) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">const</span> x = OnRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                    MyPromise.resolveMyPromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步执行函数状态为 Pending 时的处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.state === MyPromise.PENDING) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.OnFulfilledCallbacks.push(</span><br><span class="line">                (value) =&gt; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="keyword">const</span> x = OnFulfilled(value);</span><br><span class="line">                        MyPromise.resolveMyPromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;));</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.OnRejectedCallbacks.push(</span><br><span class="line">                (reason) =&gt; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="keyword">const</span> x = OnRejected(reason);</span><br><span class="line">                        MyPromise.resolveMyPromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="正确测试"><a href="#正确测试" class="headerlink" title="正确测试"></a>正确测试</h1><ul>
<li>安装 promises-aplus-tests 测试脚本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install promises-aplus-tests -D</span><br><span class="line">npx promises-aplus-tests promise.js</span><br></pre></td></tr></table></figure>
<ul>
<li>在我们 MyPromise.js 文件夹末尾添加测试 deferred 钩子</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyPromise.deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> defer = &#123;&#125;</span><br><span class="line">    defer.promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        defer.resolve = resolve</span><br><span class="line">        defer.reject = reject</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> defer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = MyPromise;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行代码测试</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npx promises-aplus-tests MyPromise.js</span><br></pre></td></tr></table></figure>
<ul>
<li>结果</li>
</ul>
<img src="/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%AC%A6%E5%90%88Promise-A-%E8%A7%84%E8%8C%83%E7%9A%84Promise/res.png" class>]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>自己实现 React-Redux (一)：React.js中的 context</title>
    <url>/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-React-Redux-%E4%B8%80-%EF%BC%9AReact-js%E4%B8%AD%E7%9A%84-context/</url>
    <content><![CDATA[<h1 id="Redux架构"><a href="#Redux架构" class="headerlink" title="Redux架构"></a>Redux架构</h1><p>Redux是一种前端架构，是由 Facebook 的 <a href="https://justgetflux.com/">Flux</a> 框架演变而来，但避开了 Flux 的复杂性。而 <a href="https://www.jdon.com/idea/flux.html">Flux</a> 是一种模式而非正式框架，通过利用单项数据流补充React的组合视图组件。</p>
<h2 id="Redux要解决的问题"><a href="#Redux要解决的问题" class="headerlink" title="Redux要解决的问题"></a>Redux要解决的问题</h2><p>React的数据流是单项数据流，如果任何一个子组件依赖了父组件的状态，就需要将状态存储到父组件中进行<strong>状态提升</strong>。但假设该父组件又是另一组件的子组件且状态又由另一组件决定，那么状态又需提升至另一组件。层层的状态依赖非常麻烦。</p>
<p>React中可以通过设置 <strong>context</strong>属性实现全局变量的效果，任何该组件的子组件都可以读取到 context 属性；而一旦 context 属性改变，所有依赖 context 属性的组件都会更新。</p>
<p>并且所有能读取到 context 的组件都可以对该属性进行修改，如果在组件关系非常复杂，到处存在这种修改父组件 context 的逻辑，那么可能产生难以预测的后果。</p>
<p>因此 Redux 规范了修改全局属性 <strong>state</strong> 的方法，便于状态改变的维护与管理。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p><strong>1. 单一数据源</strong></p>
<p>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</p>
<p><strong>2. State 是只读的</strong></p>
<p>唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</p>
<p><strong>3. 使用纯函数来执行修改</strong></p>
<p>为了描述 action 如何改变 state tree ，你需要编写 reducers。</p>
<p>reducers是一个<strong>纯函数</strong>，纯函数是输出结果仅依赖于输入参数，且不会有副作用，即<strong>函数执行过程不会产生外部可观察的变化</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>共享的状态如果可以被任意修改的话，那么程序的行为将非常不可预料，所以需要用一种模式 Redux 来统一对数据修改进行管理。</p>
<p>而将 Redux 架构应用到 React 中就是 React-Redux。</p>
<h1 id="React-中的-context"><a href="#React-中的-context" class="headerlink" title="React 中的 context"></a>React 中的 context</h1><p>前面提到，context 的属性是 react 中的全局变量，不是通过单项数据流来实现数据传递，可以<strong>穿透</strong>子组件进行数据传递。</p>
<p>由于该属性直接利用或修改非常危险，所以尽量不要直接使用该属性，就像 Javascript 里尽量避免全局变量一样。</p>
<p>但该属性对于后面实现 React-Redux 很有帮助，所以先简单讲解一下基本使用。</p>
<h2 id="定义组件树"><a href="#定义组件树" class="headerlink" title="定义组件树"></a>定义组件树</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Children/&gt;,</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;Children的颜色&lt;/p&gt;,</span><br><span class="line">        &lt;GrandChildren/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandChildren</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;GrandChildren的颜色&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="父组件定义-context-属性"><a href="#父组件定义-context-属性" class="headerlink" title="父组件定义 context 属性"></a>父组件定义 context 属性</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    textColor: PropTypes.string</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">textColor</span>: <span class="string">&#x27;red&#x27;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getChildContext</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">textColor</span>: <span class="built_in">this</span>.state.textColor&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Children/&gt;,</span><br><span class="line">        &lt;GrandChildren/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父组件通过 <strong>getChildContext</strong> 方法返回对象传递 context。父组件要想 context 属性生效，必须定义 <strong>childContextTypes</strong> 属性，因为 context 是一个危险的特性，按照 React.js 团队的想法就是，把危险的事情搞复杂一些，提高使用门槛人们就不会去用了。如果你要给组件设置 context，那么 childContextTypes 是必写的。</p>
<h2 id="子组件接收-context"><a href="#子组件接收-context" class="headerlink" title="子组件接收 context"></a>子组件接收 context</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandChildren</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    textColor: PropTypes.string</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p style=&#123;&#123;<span class="attr">color</span>: <span class="built_in">this</span>.context.textColor&#125;&#125;&gt;GrandChildren的颜色&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子组件要想读取 context，必须定义 <strong>contextTypes</strong> 进行 context 输入属性验证，然后可以直接使用 this.context 读取父组件属性。</p>
<img src="/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-React-Redux-%E4%B8%80-%EF%BC%9AReact-js%E4%B8%AD%E7%9A%84-context/context.png" class>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><p><a href="http://huziketang.mangojuice.top/books/react/">React.js 小书</a></p>
</li>
<li><p><a href="https://www.jdon.com/idea/flux.html">Flux架构讲解</a></p>
</li>
<li><p><a href="https://www.redux.org.cn/">Redux中文文档</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h1><p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</p>
<p>第 i 件物品的体积是 $v_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p>
<p><strong>输入格式</strong><br>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p>
<p>接下来有 N 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 i 件物品的体积和价值。</p>
<p><strong>输出格式</strong><br>输出一个整数，表示最大价值。</p>
<p><strong>数据范围</strong><br>$0&lt; N,V ≤ 1000$<br>$0&lt; v_i,w_i ≤ 1000$</p>
<p><strong>输入样例</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p><strong>输出样例：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<h2 id="思路-方法"><a href="#思路-方法" class="headerlink" title="思路+方法"></a>思路+方法</h2><p><code>f[i][j]</code>表示面对第 i 件物品时，体积为 j 的背包的最大总价值。<br>两种选择：1. 不放入第 i 件物品。 2. 放入第 i 件物品。</p>
<p>状态转移方程：<strong><code>f[i][j]=max(f[i−1][j],f[i−1][j−w[i]]+v[i])</code></strong></p>
<p>优化：<strong><code>f[j]=max(f[j],f[j−w[i]]+v[i])</code></strong>。此时 j 要从大到小遍历，保证第 i 件物品只能选择一次。否则 <code>f[i][j]</code> 会由 <code>f[i][j−w[i]]+v[i]</code>决定，与题意不符，而顺序遍历却是完全背包的解决方案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Scanner reader = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = reader.nextInt();</span><br><span class="line">        <span class="keyword">int</span> V = reader.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] v = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span>[] w = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">            v[i] = reader.nextInt();</span><br><span class="line">            w[i] = reader.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[V+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=V; j&gt;=v[i]; j--)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j-v[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[V]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 O(VN)</p>
<h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><p>完全背包题目与01背包大体相似，只不过每件物品可以无限选择。</p>
<h2 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h2><p>状态转移方程：<strong><code>f[i][j]=max(f[i−1][j],f[i−1][j−w[i]]+v[i])</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> V = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] w = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span>[] v = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">            v[i] = in.nextInt();</span><br><span class="line">            w[i] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[V+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=v[i]; j&lt;=V; j++)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j-v[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[V]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 O(VN)</p>
<h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h1><p>多重背包是每个物品指定了数量。</p>
<p>有 N 种物品和一个容量是 V 的背包。</p>
<p>第 i 种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p>
<p><strong>输入格式</strong><br>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p>
<p>接下来有 N 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p>
<p><strong>输出格式</strong><br>输出一个整数，表示最大价值。</p>
<p><strong>数据范围</strong><br>0&lt;N,V≤100<br>$0&lt;v_i,w_i,s_i≤100$</p>
<p><strong>输入样例</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p><strong>输出样例：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<h1 id="思路-代码-1"><a href="#思路-代码-1" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h1><p>将多重背包转化为 01背包问题，即将有限量的物品划分为互相独立的部分，每个独立的部分物品可以看作01背包问题，继续采用01背包的思想解决。</p>
<p>状态转移方程：<strong><code>f[i][j]=max(f[i−1][j],f[i−1][j−k*w[i]]+k*v[i])</code></strong>。</p>
<p>将第 i 种物品转化为 <code>p[i]</code>件物品，每件物品的系数分别为 $1，2, 4, …, 2^{k-1}, p[i]-2^k+1 &gt; 0$, k是满足 $p[i]-2^k+1 &gt; 0$ 的最大整数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> V = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] v = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span>[] w = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span>[] s = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">            v[i] = sc.nextInt();</span><br><span class="line">            w[i] = sc.nextInt();</span><br><span class="line">            s[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();</span><br><span class="line">        <span class="keyword">int</span>[]dp = <span class="keyword">new</span> <span class="keyword">int</span>[V+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = Math.min(s[i], V/v[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; num&gt;<span class="number">0</span>; k &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k&gt;num) k = num;</span><br><span class="line">                num -= k;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=V; j&gt;=k*v[i]; j--)&#123;</span><br><span class="line">                    dp[j] = Math.max(dp[j], dp[j-k*v[i]]+k*w[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[V]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 O(V$\sum{log(p(i))}$)</p>
<h1 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h1><p>混合背包其实是 01背包、多重背包和完全背包的混合体。</p>
<p>有 N 种物品和一个容量是 V 的背包。</p>
<p>物品一共有三类：</p>
<p>第一类物品只能用1次（01背包）；<br>第二类物品可以用无限次（完全背包）；<br>第三类物品最多只能用 $s_i$ 次（多重背包）；<br>每种体积是 $v_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p>
<p><strong>输入格式</strong><br>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p>
<p>接下来有 N 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p>
<p>$s_i$=−1 表示第 i 种物品只能用1次；<br>$s_i$=0 表示第 i 种物品可以用无限次；<br>$s_i$&gt;0 表示第 i 种物品可以使用 $s_i$ 次；</p>
<p><strong>输出格式</strong><br>输出一个整数，表示最大价值。</p>
<p><strong>数据范围</strong><br>$ 0&lt;N,V≤1000 $<br>$ 0&lt;v_i,w_i≤1000 $<br>$ −1≤s_i≤1000 $</p>
<p><strong>输入样例</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> -<span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<h2 id="思路-代码-2"><a href="#思路-代码-2" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h2><p>加入if-else判断。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p[i]:每个物品的件数，0代表无穷个</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (p[i] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= V; j++)</span><br><span class="line">            f[j] = max(f[j], f[j - w[i]] + v[i]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= p[i]; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= w[i]; j--)</span><br><span class="line">            f[j] = max(f[j], f[j - w[i]] + v[i]);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> V = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] v = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span>[] w = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span>[] s = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">            v[i] = sc.nextInt();</span><br><span class="line">            w[i] = sc.nextInt();</span><br><span class="line">            s[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">         sc.close();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[V+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=V; j&gt;=v[i]; j--)&#123;</span><br><span class="line">                    dp[j] = Math.max(dp[j], dp[j-v[i]]+w[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=v[i]; j&lt;=V; j++)&#123;</span><br><span class="line">                    dp[j] = Math.max(dp[j], dp[j-v[i]]+w[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> num = Math.min(s[i], V/v[i]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; num&gt;<span class="number">0</span>; k &lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k&gt;num) k=num;</span><br><span class="line">                    num -= k;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=V; j&gt;=k*v[i]; j--)&#123;</span><br><span class="line">                        dp[j] = Math.max(dp[j], dp[j-k*v[i]]+k*w[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[V]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二维背包"><a href="#二维背包" class="headerlink" title="二维背包"></a>二维背包</h1><p>物品的约束条件除了体积外，增加了重量一维，其余跟01背包一样。</p>
<p>有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。</p>
<p>每件物品只能用一次。体积是 $v_i$，重量是 $m_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。<br>输出最大价值。</p>
<p><strong>输入格式</strong><br>第一行两个整数，N，V,M，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。</p>
<p>接下来有 N 行，每行三个整数 $v_i,m_i,w_i$，用空格隔开，分别表示第 i 件物品的体积、重量和价值。</p>
<p><strong>输出格式</strong><br>输出一个整数，表示最大价值。</p>
<p><strong>数据范围</strong><br>$0&lt;N≤1000$<br>$0&lt;V,M≤100$<br>$0&lt;v_i,m_i≤100$<br>$0&lt;w_i≤1000$</p>
<p><strong>输入样例</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p><strong>输出样例：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<h2 id="思路-代码-3"><a href="#思路-代码-3" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h2><p>跟01背包类似，只不过两个状态。</p>
<p>状态转移方程：<strong><code>f[j][k]=max(f[j][k],f[j−w[i]][k-m[i]]+k*v[i])</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> V = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> M = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] v = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span>[] m = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span>[] w = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">            v[i] = sc.nextInt();</span><br><span class="line">            m[i] = sc.nextInt();</span><br><span class="line">            w[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[V+<span class="number">1</span>][M+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=V; j&gt;=v[i]; j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=M; k&gt;=m[i]; k--)&#123;</span><br><span class="line">                    dp[j][k] = Math.max(dp[j][k], dp[j-v[i]][k-m[i]]+w[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[V][M]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h1><p>在01背包的基础上，对不同物品进行了分组，每组只能选取一件物品。</p>
<p>有 N 组物品和一个容量是 V 的背包。</p>
<p>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 $v_ij$，价值是 $w_ij$，其中 i 是组号，j 是组内编号。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p>
<p>输出最大价值。</p>
<p><strong>输入格式</strong><br>第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。</p>
<p>接下来有 N 组数据：</p>
<p>每组数据第一行有一个整数 $S_i$，表示第 i 个物品组的物品数量；<br>每组数据接下来有 $S_i$ 行，每行有两个整数 $v_ij,w_ij$，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；</p>
<p><strong>输出格式</strong><br>输出一个整数，表示最大价值。</p>
<p><strong>数据范围</strong><br>$0&lt;N,V≤100$<br>$0&lt;S_i≤100$<br>$0&lt;v_ij,w_ij≤100$</p>
<p><strong>输入样例</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p><strong>输出样例：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<h2 id="思路-代码-4"><a href="#思路-代码-4" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h2><p>状态转移方程：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> i <span class="title">in</span> <span class="params">(每一种分组)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">for</span> j in <span class="title">range</span><span class="params">(V,<span class="number">0</span>,-<span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="function">        <span class="keyword">for</span> k in 分组[i]:</span></span><br><span class="line"><span class="function">            dp[j] </span>= max(dp[j], dp[j-分组[i][<span class="number">0</span>]]+分组[i][<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> K = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> V = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, ArrayList&lt;<span class="keyword">int</span>[]&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;K; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> s = sc.nextInt();</span><br><span class="line">            N += s;</span><br><span class="line">            ArrayList&lt;<span class="keyword">int</span>[]&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;s;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">                tmp[<span class="number">0</span>] = sc.nextInt();</span><br><span class="line">                tmp[<span class="number">1</span>] = sc.nextInt();</span><br><span class="line">                arr.add(tmp);</span><br><span class="line">                map.put(i, arr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[V+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;K; i++)&#123;</span><br><span class="line">            ArrayList&lt;<span class="keyword">int</span>[]&gt; arr = map.get(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=V; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;arr.size();k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=arr.get(k)[<span class="number">0</span>])</span><br><span class="line">                        dp[j] = Math.max(dp[j], dp[j-arr.get(k)[<span class="number">0</span>]]+arr.get(k)[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[V]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>自己实现 React-Redux (三)：结合 context 和 store</title>
    <url>/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-React-Redux-%E4%B8%89-%EF%BC%9A%E7%BB%93%E5%90%88-context-%E5%92%8C-store/</url>
    <content><![CDATA[<h1 id="构建-createStore-函数实现-Redux-架构"><a href="#构建-createStore-函数实现-Redux-架构" class="headerlink" title="构建 createStore 函数实现 Redux 架构"></a>构建 createStore 函数实现 Redux 架构</h1><p><strong>原理</strong>: 构造一个函数 <strong>createStore</strong>，该函数可以对全局变量的状态进行统一的管理。该函数传入一个全局 <strong>state</strong> 以及状态修改纯函数 <strong>reducer</strong>, reducer 定义了改变状态的逻辑并返回一个新的状态，为后面的动态渲染优化做准备。</p>
<ol>
<li>在 src/index.js 中加入 createStore 函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 初始状态</span></span><br><span class="line">    <span class="keyword">let</span> state = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 定义发布者</span></span><br><span class="line">    <span class="keyword">const</span> listeners = []</span><br><span class="line">    <span class="comment">// 绑定订阅者</span></span><br><span class="line">    <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>)=&gt;</span>listeners.push(listener)</span><br><span class="line">    <span class="comment">// 获取 state</span></span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function">()=&gt;</span>state</span><br><span class="line">    <span class="comment">// 绑定处理函数</span></span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>)=&gt;</span>&#123;</span><br><span class="line">        state = reducer(state, action)</span><br><span class="line">        <span class="comment">// 数据更新自动通知给订阅者</span></span><br><span class="line">        liSteners.forEach(<span class="function"><span class="params">listener</span>=&gt;</span>listener())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化 state</span></span><br><span class="line">    dispatch(&#123;&#125;)</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// 返回状态管理对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;getState, dispatch, subscribe&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> themeReducer = <span class="function">(<span class="params">state, action</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!state)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      themeColor: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;CHANGE_COLOR&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">themeColor</span>: action.themeColor&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(themeReducer);</span><br></pre></td></tr></table></figure>
<h1 id="子组件调用-store-并修改-state"><a href="#子组件调用-store-并修改-state" class="headerlink" title="子组件调用 store 并修改 state"></a>子组件调用 store 并修改 state</h1><p>首先父组件 src/index.js 中定义 store 上下文：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    store: PropTypes.object</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getChildContext</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;store&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Header/&gt;</span><br><span class="line">        &lt;Content/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改 src/Header.js，让它从 Index 的 context 里面获取 store，并且获取里面的 themeColor 状态来设置自己的颜色：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">        store: PropTypes.object</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            themeColor: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>._updateThemeColor()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">_updateThemeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;store&#125; = <span class="built_in">this</span>.context</span><br><span class="line">        <span class="keyword">const</span> themeColor = store.getState().themeColor;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;themeColor&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1 style=&#123;&#123;<span class="attr">color</span>: <span class="built_in">this</span>.state.themeColor&#125;&#125;&gt;动手实现React-Redux&lt;/h1&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Header;</span><br></pre></td></tr></table></figure>
<p>然后界面的标题栏变成了红色：</p>
<img src="/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-React-Redux-%E4%B8%89-%EF%BC%9A%E7%BB%93%E5%90%88-context-%E5%92%8C-store/header.png" class>
<p>如法炮制 Content.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ThemeSwitch <span class="keyword">from</span> <span class="string">&#x27;./ThemeSwitch&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Content</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">        store: PropTypes.object</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            themeColor: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>._updateThemeColor()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">_updateThemeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;store&#125; = <span class="built_in">this</span>.context</span><br><span class="line">        <span class="keyword">const</span> themeColor = store.getState().themeColor</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;themeColor&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p style=&#123;&#123;<span class="attr">color</span>: <span class="built_in">this</span>.state.themeColor&#125;&#125;&gt;React-Redux 的内容&lt;/p&gt;</span><br><span class="line">                &lt;ThemeSwitch/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Content</span><br></pre></td></tr></table></figure>
<p>还有 src/ThemeSwitch.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemeSwitch</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">        store: PropTypes.object</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            themeColor: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>._updateThemeColor()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">_updateThemeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;store&#125; = <span class="built_in">this</span>.context</span><br><span class="line">        <span class="keyword">const</span> themeColor = store.getState().themeColor</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;themeColor&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button style=&#123;&#123;<span class="attr">color</span>: <span class="built_in">this</span>.state.themeColor&#125;&#125;&gt;Red&lt;/button&gt;</span><br><span class="line">                &lt;button style=&#123;&#123;<span class="attr">color</span>: <span class="built_in">this</span>.state.themeColor&#125;&#125;&gt;Blue&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ThemeSwitch;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<img src="/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-React-Redux-%E4%B8%89-%EF%BC%9A%E7%BB%93%E5%90%88-context-%E5%92%8C-store/page1.png" class>
<p>然后给按钮绑定 click 监听事件，使用 store 的 dispatch 方法触发指定事件，修改 state 的颜色。同时使用 store 的 subscript 方法绑定订阅者执行函数，执行颜色更新。</p>
<p>在 src/ThemeSwitch.js 文件中添加代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">_updateThemeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;store&#125; = <span class="built_in">this</span>.context</span><br><span class="line">    <span class="keyword">const</span> themeColor = store.getState().themeColor</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;themeColor&#125;)</span><br><span class="line">    store.subscribe(<span class="built_in">this</span>._updateThemeColor.bind(<span class="built_in">this</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">handleThemeSwitchClick</span>(<span class="params">color</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;store&#125; = <span class="built_in">this</span>.context</span><br><span class="line">    store.dispatch(&#123;</span><br><span class="line">        type: <span class="string">&#x27;CHANGE_COLOR&#x27;</span>,</span><br><span class="line">        themeColor: color</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button </span><br><span class="line">            style=&#123;&#123;<span class="attr">color</span>: <span class="built_in">this</span>.state.themeColor&#125;&#125;</span><br><span class="line">            onClick=&#123;<span class="built_in">this</span>.handleThemeSwitchClick.bind(<span class="built_in">this</span>, <span class="string">&#x27;red&#x27;</span>)&#125;</span><br><span class="line">            &gt;Red&lt;/button&gt;</span><br><span class="line">            &lt;button </span><br><span class="line">            style=&#123;&#123;<span class="attr">color</span>: <span class="built_in">this</span>.state.themeColor&#125;&#125;</span><br><span class="line">            onClick=&#123;<span class="built_in">this</span>.handleThemeSwitchClick.bind(<span class="built_in">this</span>, <span class="string">&#x27;blue&#x27;</span>)&#125;</span><br><span class="line">            &gt;Blue&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给 Header.js、Content.js 文件中添加代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">_updateThemeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;store&#125; = <span class="built_in">this</span>.context</span><br><span class="line">    <span class="keyword">const</span> themeColor = store.getState().themeColor</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;themeColor&#125;)</span><br><span class="line">    store.subscribe(<span class="built_in">this</span>._updateThemeColor.bind(<span class="built_in">this</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在点击按钮，就会执行修改颜色的动作 <strong>CHANGE_COLOR</strong>， 然后修改全局的主题颜色变量 themeColor，进而修改所有内容的颜色：</p>
<img src="/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-React-Redux-%E4%B8%89-%EF%BC%9A%E7%BB%93%E5%90%88-context-%E5%92%8C-store/page2.png" class>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>自己实现 React-Redux (五)：实现 mapDispatch2Props</title>
    <url>/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-React-Redux-%E4%BA%94-%EF%BC%9A%E5%AE%9E%E7%8E%B0-mapDispatchToProps/</url>
    <content><![CDATA[<h1 id="dispatch-的代理工作"><a href="#dispatch-的代理工作" class="headerlink" title="dispatch 的代理工作"></a>dispatch 的代理工作</h1><p>在 <code>src/ThemeSwitch.js</code> 中，ThemeSwitch 组件通过 store 的 dispatch 方法实现了数据的更改，这也导致了组件的强耦合。</p>
<p>我们的思路是让高阶组件 Connect 代替 ThemeSwitch 来实现 dispatch 功能，同时通过 props 将方法传递给 ThemeSwitch 组件。</p>
<p>修改 <code>src/react-redux.js</code>文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> connect = <span class="function">(<span class="params">mapState2Props, mapDispatch2Props</span>)=&gt;</span><span class="function">(<span class="params">OriginComponent</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>._updateProps()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">_updateProps</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;store&#125; = <span class="built_in">this</span>.context</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> stateProps = mapState2Props? mapState2Props(store.getState(), <span class="built_in">this</span>.props) : &#123;&#125;</span><br><span class="line">        <span class="keyword">let</span> dispatchProps = mapDispatch2Props? mapState2Props(store.dispatch, <span class="built_in">this</span>.props) : &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            allProps: &#123;</span><br><span class="line">                ...stateProps,</span><br><span class="line">                ...dispatchProps,</span><br><span class="line">                ...this.props</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 绑定订阅者监听函数</span></span><br><span class="line">        store.subscribe(<span class="built_in">this</span>._updateProps.bind(<span class="built_in">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*以下代码略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="定义-mapDispatch2Props-函数"><a href="#定义-mapDispatch2Props-函数" class="headerlink" title="定义 mapDispatch2Props 函数"></a>定义 mapDispatch2Props 函数</h1><p>在 <code>src/ThemeSwitch.js</code> 文件中定义 mapDispatch2Props 函数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&#x27;./react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemeSwitch</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        themeColor: PropTypes.string,</span><br><span class="line">        handleThemeSwitchClick: PropTypes.func</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button </span><br><span class="line">                style=&#123;&#123;<span class="attr">color</span>: <span class="built_in">this</span>.props.themeColor&#125;&#125;</span><br><span class="line">                onClick=&#123;<span class="built_in">this</span>.props.handleThemeSwitchClick.bind(<span class="built_in">this</span>, <span class="string">&#x27;red&#x27;</span>)&#125;</span><br><span class="line">                &gt;Red&lt;/button&gt;</span><br><span class="line">                &lt;button </span><br><span class="line">                style=&#123;&#123;<span class="attr">color</span>: <span class="built_in">this</span>.props.themeColor&#125;&#125;</span><br><span class="line">                onClick=&#123;<span class="built_in">this</span>.props.handleThemeSwitchClick.bind(<span class="built_in">this</span>, <span class="string">&#x27;blue&#x27;</span>)&#125;</span><br><span class="line">                &gt;Blue&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapState2Props = <span class="function">(<span class="params">state</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        themeColor: state.themeColor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatch2Props = <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        handleThemeSwitchClick : <span class="function"><span class="keyword">function</span>(<span class="params">color</span>)</span>&#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;CHANGE_COLOR&#x27;</span>,</span><br><span class="line">            themeColor: color</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThemeSwitch = connect(mapState2Props, mapDispatch2Props)(ThemeSwitch)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ThemeSwitch;</span><br></pre></td></tr></table></figure>
<p>这样 ThemeSwitch 组件的代码就变得非常整洁，而且扩展性也大大提高。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题：子集</title>
    <url>/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h1 id="求一个数组的所有子集数组"><a href="#求一个数组的所有子集数组" class="headerlink" title="求一个数组的所有子集数组"></a>求一个数组的所有子集数组</h1><blockquote>
<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>说明：解集不能包含重复的子集。</p>
</blockquote>
<p><strong>示例:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h1 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h1><p>从前往后遍历，新子集就是原子集加上新加的数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        List&lt;Integer&gt; inList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(inList);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> size = list.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;size; j++)&#123;</span><br><span class="line">                List&lt;Integer&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;(list.get(j));</span><br><span class="line">                newList.add(nums[i]);</span><br><span class="line">                list.add(newList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h1><p>当成回溯问题求解。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">// 如果有重复数字，则需要 Arrays.sort(nums);</span></span><br><span class="line">        backtracking(res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(ArrayList&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; arr, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> location)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(arr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(arr));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=location; i&lt;nums.length; i++)&#123;</span><br><span class="line">                <span class="comment">// 如果有重复数字，则只调重复的第一个 if(i&gt;location &amp;&amp; nums[i]==nums[i-1]) continue;</span></span><br><span class="line">                arr.add(nums[i]);</span><br><span class="line">                backtracking(res, arr, nums, i+<span class="number">1</span>);</span><br><span class="line">                arr.remove(arr.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/subsets/">题目链接</a></p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>自己实现 React-Redux (二)：初始化工程</title>
    <url>/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-React-Redux-%E4%BA%8C-%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h1><p>在命令行依次输入以下命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用脚手架创建新项目</span></span><br><span class="line">npx create-react-app react-redux</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装类型检查依赖</span></span><br><span class="line">npm install --save prop-types</span><br></pre></td></tr></table></figure>
<h1 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h1><p>安装好后在 src/ 目录下新增三个文件：Header.js、Content.js、ThemeSwitch.js。</p>
<p>修改 src/Header.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;动手实现React-Redux&lt;/h1&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Header;</span><br></pre></td></tr></table></figure>
<p>修改 src/ThemeSwitch.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemeSwitch</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button&gt;Red&lt;/button&gt;</span><br><span class="line">                &lt;button&gt;Blue&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ThemeSwitch;</span><br></pre></td></tr></table></figure>
<p>修改 src/Content.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ThemeSwitch <span class="keyword">from</span> <span class="string">&#x27;./ThemeSwitch&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Content</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;React-Redux 的内容&lt;/p&gt;</span><br><span class="line">                &lt;ThemeSwitch/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Content</span><br></pre></td></tr></table></figure>
<p>修改 src/index.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">&#x27;./Header&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Content <span class="keyword">from</span> <span class="string">&#x27;./Content&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Header/&gt;</span><br><span class="line">        &lt;Content/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Index/&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="启动查看界面"><a href="#启动查看界面" class="headerlink" title="启动查看界面"></a>启动查看界面</h1><p>如下所示：</p>
<img src="/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-React-Redux-%E4%BA%8C-%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E7%A8%8B/window.png" class>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>自己实现 React-Redux (四)：connect 和 mapState2Props</title>
    <url>/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-React-Redux-%E5%9B%9B-%EF%BC%9Aconnect-%E5%92%8C-mapStateToProps/</url>
    <content><![CDATA[<h1 id="子组件直接利用-context-的问题"><a href="#子组件直接利用-context-的问题" class="headerlink" title="子组件直接利用 context 的问题"></a>子组件直接利用 context 的问题</h1><p>第三节我们实现了子组件利用 context 属性，通过统一的修改方式对全局 state 进行修改，同时利用发布者-订阅者模式实现了数据更新的监听及界面重新渲染。</p>
<p>但是仍然存在两个问题：</p>
<ol>
<li><p>子组件都是利用 context 属性来取得 store 对象，进而对全局状态 state 进行修改，这样会导致<strong>很多重复性代码</strong>。</p>
</li>
<li><p>每个子组件都依赖了 context 属性，导致<strong>子组件与父组件形成了强耦合</strong>，不利于组件的复用。例如，前面的 Context 组件需要父组件定义 context 属性，否则主题颜色将无法设置。</p>
</li>
</ol>
<p><strong>解决方法</strong>：</p>
<ol>
<li><p>对于重复使用的代码，可以凝练提取出一个可复用的代码结构。这里可以通过高阶组件（或者装饰器模式）将 context 的控制与相关事件监听代理起来。</p>
</li>
<li><p>对于强耦合问题，可以通过设置 Pure Component，即在高阶组件内部的被装饰组件尽量设计成纯组件。<strong>纯组件</strong>是其状态仅依赖于父组件传入的 props 以及 自己的 state，对于外界依赖极低，因此复用性极高。</p>
</li>
</ol>
<h1 id="抽离出公共的逻辑代码"><a href="#抽离出公共的逻辑代码" class="headerlink" title="抽离出公共的逻辑代码"></a>抽离出公共的逻辑代码</h1><p>我们可以设计一个 connect 函数，该函数的目标是创建一个高阶组件。connect 函数接收两个参数，一个是 <strong>mapState2Props</strong> 函数，一个是原始的被修饰组件 <strong>OriginComponent。</strong></p>
<ul>
<li><p>mapState2Props函数负责从父组件接收 state 并将其转化为 props 传递给被修饰组件 OriginComponent，实现 OriginComponent 与父组件 context 之间的解耦以及公共逻辑代码的抽离。</p>
</li>
<li><p>OriginComponent 是原始的子组件，例如 Context 组件。</p>
</li>
</ul>
<p>新建 <code>react-redux.js</code> 文件，里面的内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/react-redux.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> connect = <span class="function">(<span class="params">mapState2Props</span>)=&gt;</span><span class="function">(<span class="params">OriginComponent</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">            store: PropTypes.object</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.state = &#123;</span><br><span class="line">                allProps: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>._updateProps()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">_updateProps</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;store&#125; = <span class="built_in">this</span>.context.store</span><br><span class="line">            <span class="keyword">const</span> stateProps = mapState2Props(store.getState())</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                allProps: &#123;</span><br><span class="line">                    ...stateProps,</span><br><span class="line">                    ...this.props</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 绑定订阅者监听函数</span></span><br><span class="line">            store.subscribe(<span class="built_in">this</span>._updateProps.bind(<span class="built_in">this</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;OriginComponent &#123;...this.state.allProps&#125;/&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Connect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再 <code>src/Content.js</code> 及 <code>src/Header</code> 文件中利用 Connect 高阶函数实现全局变量管理：</p>
<p><strong>src/Header</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&#x27;./react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        themeColor: PropTypes.string</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1 style=&#123;&#123;<span class="attr">color</span>: <span class="built_in">this</span>.props.themeColor&#125;&#125;&gt;动手实现React-Redux&lt;/h1&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapState2Props = <span class="function">(<span class="params">state</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        themeColor: state.themeColor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Header = connect(mapState2Props)(Header)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Header;</span><br></pre></td></tr></table></figure></p>
<p><strong>src/Content</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ThemeSwitch <span class="keyword">from</span> <span class="string">&#x27;./ThemeSwitch&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&#x27;./react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Content</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        themeColor: PropTypes.string</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p style=&#123;&#123;<span class="attr">color</span>: <span class="built_in">this</span>.props.themeColor&#125;&#125;&gt;React-Redux 的内容&lt;/p&gt;</span><br><span class="line">                &lt;ThemeSwitch/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapState2Props = <span class="function">(<span class="params">state</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        themeColor: state.themeColor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Content = connect(mapState2Props)(Content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Content</span><br></pre></td></tr></table></figure></p>
<p>下一节将对 <em>ThemeSwitch</em> 组件进行重构</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>自己实现 React-Redux (六)：去除 context 依赖，实现 provider</title>
    <url>/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-React-Redux-%E5%85%AD-%EF%BC%9A%E5%8E%BB%E9%99%A4-context-%E4%BE%9D%E8%B5%96%EF%BC%8C%E5%AE%9E%E7%8E%B0-provider/</url>
    <content><![CDATA[<h1 id="Index-组件中的-context-依赖"><a href="#Index-组件中的-context-依赖" class="headerlink" title="Index 组件中的 context 依赖"></a>Index 组件中的 context 依赖</h1><p>Content 组件、Header 组件以及 ThemeSwitch 组件都是依赖于 Index 父组件的 context 属性，而 context 属性在 Index 组件中存在会导致 Index 依赖于额外的属性，扩展性不强。</p>
<p>因此我们需要提炼出一个淡出的组件 provider 来当作 Index 的父组件，来存储全局的 context 属性，实现 Index 组件与 context 属性的解耦。</p>
<h1 id="构建-Provider-组件"><a href="#构建-Provider-组件" class="headerlink" title="构建 Provider 组件"></a>构建 Provider 组件</h1><p>在 <code>src/react-redux.js</code> 文件中添加如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        store: PropTypes.object,</span><br><span class="line">        children: PropTypes.any</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">        store: PropTypes.object</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">getChildContext</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">store</span>: <span class="built_in">this</span>.props.store&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>.props.children&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;Provider&#125;</span><br></pre></td></tr></table></figure>
<p>同时在我们的 Index 组件中就可以利用 Provider 组件包裹住 Index 组件，并向其传入 store 值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">&#x27;./Header&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Content <span class="keyword">from</span> <span class="string">&#x27;./Content&#x27;</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">&#x27;./react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 初始状态</span></span><br><span class="line">  <span class="keyword">let</span> state = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 定义发布者</span></span><br><span class="line">  <span class="keyword">const</span> listeners = []</span><br><span class="line">  <span class="comment">// 绑定订阅者</span></span><br><span class="line">  <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>)=&gt;</span>listeners.push(listener)</span><br><span class="line">  <span class="comment">// 获取 state</span></span><br><span class="line">  <span class="keyword">const</span> getState = <span class="function">() =&gt;</span> state</span><br><span class="line">  <span class="comment">// 绑定处理函数</span></span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>)=&gt;</span>&#123;</span><br><span class="line">      state = reducer(state, action)</span><br><span class="line">      <span class="comment">// 数据更新自动通知给订阅者</span></span><br><span class="line">      listeners.forEach(<span class="function"><span class="params">listener</span>=&gt;</span>listener())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  dispatch(&#123;&#125;)</span><br><span class="line">  <span class="comment">// 返回状态管理对象</span></span><br><span class="line">  <span class="keyword">return</span> &#123;getState, dispatch, subscribe&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> themeReducer = <span class="function">(<span class="params">state, action</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!state)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      themeColor: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;CHANGE_COLOR&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">themeColor</span>: action.themeColor&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(themeReducer);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Header/&gt;</span><br><span class="line">        &lt;Content/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;Index/&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>我们首先利用 React 的“全局变量” context 实现了子组件按钮改变全局颜色样式的效果。</p>
</li>
<li><p>考虑到代码的重复以及组件的可扩展性，我们构建了一个 connect 函数实现了 context 属性及相关改变 state 方法 dispatch 的代理，并通过 props 由高阶组件传递给子组件。</p>
</li>
<li><p>考虑到 context 还在父组件中使其复用性底，因此又构建了代理父组件 Provider 负责存储全局变量管理对象 store，并通过 props 传递给 Index 组件。</p>
</li>
</ul>
<p><a href="https://github.com/SUNYunZeng/imitateReact-redux">项目地址</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>自己实现简单版Vue--1. 编译初始Vue模版</title>
    <url>/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%89%88Vue-1-%E7%BC%96%E8%AF%91%E5%88%9D%E5%A7%8BVue%E6%A8%A1%E7%89%88/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Vue的双向绑定效果如下：</p>
<img src="/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%89%88Vue-1-%E7%BC%96%E8%AF%91%E5%88%9D%E5%A7%8BVue%E6%A8%A1%E7%89%88/demo.gif" class>
<p>Vue的底层到底是怎么实现的呢？</p>
<p>通过手写简单的示例来学习Vue框架的运行机制。</p>
<p>Vue是MVVM框架，其实就是MVC框架在前端的体现，其中的控制器(Controller)由View MOdel(VM)代替。</p>
<p>简单来说，数据更新视图，以及视图更新影响数据这两步操作或者是双向绑定的过程由VM来执行。</p>
<p>而Vue就是一个VM。</p>
<p>Vue的可以说是开箱即用，它的使用非常简单，如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;person.name&#125;&#125; -- &#123;&#123;person.age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;person.fav&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-text</span>=<span class="string">&#x27;msg&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-text</span>=<span class="string">&#x27;person.name&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&#x27;htmlStr&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;msg&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>v-on:click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>@click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;https://www.bilibili.com/video/av80611222?p=3&quot;</span>&gt;</span>v-bind:href<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./Vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line">                person: &#123;</span><br><span class="line"><span class="javascript">                    name: <span class="string">&#x27;海贼——王路飞&#x27;</span>,</span></span><br><span class="line">                    age: 18,</span><br><span class="line"><span class="javascript">                    fav: <span class="string">&#x27;宝藏&#x27;</span></span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="javascript">                msg: <span class="string">&#x27;最简单的插值&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                htmlStr: <span class="string">&#x27;这是v-html&#x27;</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line"><span class="javascript">                handleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">&#x27;这是一个处理点击事件的方法&#x27;</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过 new Vue 新建一个Vue实例，并将元素节点与该实例通过<font color="#f07c82"> el </font> 实现双向绑定，之后h5中的元素内容跟对象数据就融为一体，开发者的关注重点可以集中在代码逻辑的设计，而不是繁琐的页面与数据绑定问题。</p>
<p>我们的实现原理图如下所示：</p>
<img src="/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%89%88Vue-1-%E7%BC%96%E8%AF%91%E5%88%9D%E5%A7%8BVue%E6%A8%A1%E7%89%88/MVVM.png" class>
<ol>
<li><p>需要实现一个Observer通过Object.defineProperty()劫持数据实现数据的监听。</p>
</li>
<li><p>实现一个Dep收集各数据的监听Watcher，负责通知Watcher数据发生变化。</p>
</li>
<li><p>实现Watcher对视图进行更新。</p>
</li>
<li><p>实现Complier对Vue指令（v-text等）进行解析初始化，以及订阅对应的watcher。</p>
</li>
</ol>
<h1 id="Vue模版的编译"><a href="#Vue模版的编译" class="headerlink" title="Vue模版的编译"></a>Vue模版的编译</h1><p>第一步是将H5中的Vue模版进行编译，使得浏览器能够正确展示对应数据。</p>
<p>其中包括这几部分的编译：</p>
<ol>
<li><p>文本模版中插值表达式的编译<br> 也就是双括号中的值能够正确表达出来，例如</p>
</li>
<li><p>元素节点中模版表达式的编译<br> 例如 v-text、v-model、v-html、 v-on:click、 v-bind等</p>
</li>
</ol>
<h2 id="MVue入口类设计"><a href="#MVue入口类设计" class="headerlink" title="MVue入口类设计"></a>MVue入口类设计</h2><p>Mvue类接收一个参数对象作为初始输入，然后利用<font color="#f07c82">Compiler</font>类对模版进行编译及渲染。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MVue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始元素与数据通过options对象绑定</span></span><br><span class="line">        <span class="built_in">this</span>.$el = options.el;</span><br><span class="line">        <span class="built_in">this</span>.$data = options.data;</span><br><span class="line">        <span class="built_in">this</span>.$options = options;</span><br><span class="line">        <span class="comment">// 通过Compiler对象对模版进行编译，例如&#123;&#123;&#125;&#125;插值、v-text、v-html、v-model等Vue语法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.$el) &#123;</span><br><span class="line">            <span class="keyword">new</span> Compiler(<span class="built_in">this</span>.$el, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Complier编译类设计"><a href="#Complier编译类设计" class="headerlink" title="Complier编译类设计"></a>Complier编译类设计</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> compileUtil = &#123;</span><br><span class="line">    <span class="function"><span class="title">getValue</span>(<span class="params">expr, vm</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 处理 person.name 这种对象类型，取出真正的value</span></span><br><span class="line">        <span class="keyword">return</span> expr.split(<span class="string">&#x27;.&#x27;</span>).reduce(<span class="function">(<span class="params">data,currentVal</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data[currentVal];</span><br><span class="line">        &#125;, vm.$data)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">text</span>(<span class="params">node, expr, vm</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> value;</span><br><span class="line">        <span class="keyword">if</span>(expr.indexOf(<span class="string">&#x27;&#123;&#123;&#x27;</span>)!==-<span class="number">1</span>)&#123;</span><br><span class="line">            value = expr.replace(<span class="regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.getValue(args[<span class="number">1</span>], vm);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            value = <span class="built_in">this</span>.getValue(expr, vm);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.updater.textUpdater(node, value);  </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">html</span>(<span class="params">node, expr, vm</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="built_in">this</span>.getValue(expr, vm);</span><br><span class="line">        <span class="built_in">this</span>.updater.htmlUpdater(node, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">model</span>(<span class="params">node, expr, vm</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="built_in">this</span>.getValue(expr, vm);</span><br><span class="line">        <span class="built_in">this</span>.updater.modelUpdater(node, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">on</span>(<span class="params">node, expr, vm, detailStr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> fn = vm.$options.methods &amp;&amp; vm.$options.methods[expr];</span><br><span class="line">        node.addEventListener(detailStr,fn.bind(vm), <span class="literal">false</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">bind</span>(<span class="params">node, expr, vm, detailStr</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// v-on:href=&#x27;...&#x27; =&gt; href=&#x27;...&#x27;</span></span><br><span class="line">        node.setAttribute(detailStr, expr);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 视图更新函数</span></span><br><span class="line">    updater: &#123;</span><br><span class="line">        <span class="function"><span class="title">textUpdater</span>(<span class="params">node, value</span>)</span> &#123;</span><br><span class="line">            node.textContent = value;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">htmlUpdater</span>(<span class="params">node, value</span>)</span>&#123;</span><br><span class="line">            node.innerHTML = value;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">modelUpdater</span>(<span class="params">node, value</span>)</span>&#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译HTML模版对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">el, vm</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.el = <span class="built_in">this</span>.isElementNode(el) ? el : <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">        <span class="built_in">this</span>.vm = vm;</span><br><span class="line">        <span class="comment">// 1. 将预编译的元素节点放入文档碎片对象中，避免DOM频繁的回流与重绘，提高渲染性能</span></span><br><span class="line">        <span class="keyword">const</span> fragments = <span class="built_in">this</span>.node2fragments(<span class="built_in">this</span>.el);</span><br><span class="line">        <span class="comment">// 2. 编译模版</span></span><br><span class="line">        <span class="built_in">this</span>.compile(fragments);</span><br><span class="line">        <span class="comment">// 3. 追加子元素到根元素</span></span><br><span class="line">        <span class="built_in">this</span>.el.appendChild(fragments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">compile</span>(<span class="params">fragments</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取子节点</span></span><br><span class="line">        <span class="keyword">const</span> childNodes = fragments.childNodes;</span><br><span class="line">        <span class="comment">// 2.递归循环编译</span></span><br><span class="line">        [...childNodes].forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是元素节点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isElementNode(child)) &#123;</span><br><span class="line">                <span class="built_in">this</span>.compileElement(child);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 文本节点</span></span><br><span class="line">                <span class="built_in">this</span>.compileText(child);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//递归遍历</span></span><br><span class="line">            <span class="keyword">if</span>(child.childNodes &amp;&amp; child.childNodes.length)&#123;</span><br><span class="line">                <span class="built_in">this</span>.compile(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">compileElement</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> attributes = node.attributes;</span><br><span class="line">        <span class="comment">// 对于每个属性进行遍历编译</span></span><br><span class="line">        <span class="comment">// attributes是类数组，因此需要先转数组</span></span><br><span class="line">        [...attributes].forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> &#123;name,value&#125; = attr; <span class="comment">// v-text=&quot;msg&quot;  v-html=htmlStr  type=&quot;text&quot;  v-model=&quot;msg&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isDirector(name)) &#123; <span class="comment">// v-text  v-html  v-mode  v-bind  v-on:click v-bind:href=&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">let</span> [, directive] = name.split(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">                <span class="keyword">let</span> [compileKey, detailStr] = directive.split(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">                <span class="comment">// 更新数据，数据驱动视图</span></span><br><span class="line">                compileUtil[compileKey](node, value, <span class="built_in">this</span>.vm, detailStr);</span><br><span class="line">                <span class="comment">// 删除有指令的标签属性 v-text v-html等，普通的value等原生html标签不必删除</span></span><br><span class="line">                node.removeAttribute(<span class="string">&#x27;v-&#x27;</span> + directive);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.isEventName(name))&#123;</span><br><span class="line">                <span class="comment">// 如果是事件处理 @click=&#x27;handleClick&#x27;</span></span><br><span class="line">                <span class="keyword">let</span> [, detailStr] = name.split(<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line">                compileUtil[<span class="string">&#x27;on&#x27;</span>](node, value, <span class="built_in">this</span>.vm, detailStr);</span><br><span class="line">                node.removeAttribute(<span class="string">&#x27;@&#x27;</span> + detailStr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">compileText</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 编译文本中的&#123;&#123;person.name&#125;&#125;--&#123;&#123;person.age&#125;&#125;</span></span><br><span class="line">        <span class="keyword">const</span> content = node.textContent;</span><br><span class="line">        <span class="keyword">if</span>(<span class="regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/</span>.test(content))&#123;</span><br><span class="line">            compileUtil[<span class="string">&#x27;text&#x27;</span>](node, content, <span class="built_in">this</span>.vm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">isEventName</span>(<span class="params">attrName</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否@开头</span></span><br><span class="line">        <span class="keyword">return</span> attrName.startsWith(<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">isDirector</span>(<span class="params">attrName</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否为Vue特性标签</span></span><br><span class="line">        <span class="keyword">return</span> attrName.startsWith(<span class="string">&#x27;v-&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">node2fragments</span>(<span class="params">el</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建文档碎片对象</span></span><br><span class="line">        <span class="keyword">const</span> f = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">        <span class="keyword">let</span> firstChild;</span><br><span class="line">        <span class="keyword">while</span> (firstChild = el.firstChild) &#123;</span><br><span class="line">            f.appendChild(firstChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">isElementNode</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 元素节点的nodeType属性为 1</span></span><br><span class="line">        <span class="keyword">return</span> node.nodeType === <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/SUNYunZeng/ImitateVue">https://github.com/SUNYunZeng/ImitateVue</a></p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>自己第一篇SCI文章： LSI-LSTM——个体出行目的地预测模型</title>
    <url>/%E8%87%AA%E5%B7%B1%E7%AC%AC%E4%B8%80%E7%AF%87SCI%E6%96%87%E7%AB%A0-LSI-LSTM-%E4%B8%AA%E4%BD%93%E5%87%BA%E8%A1%8C%E7%9B%AE%E7%9A%84%E5%9C%B0%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="内容导读"><a href="#内容导读" class="headerlink" title="内容导读"></a>内容导读</h1><p>个体驾驶目的地预测对于个性化服务推荐、出行导航、交通调度等基于位置的服务具有重要的参考意义。然而，<strong>个体出行不仅具有长时间依赖性，而且受到出行空间上下文的影响</strong>，使得精准实时的驾驶目的地预测面临较大挑战。目前，长时间依赖关系建模已存在一定的技术手段，<strong>但空间因素对出行过程的影响仍然较少被考虑到。事实上，出发地与沿途的城市功能区、路网关键节点均一定程度反映并影响着司机的出行意图</strong>。为此，本文提出一种基于注意力机制和长短期记忆（LSTM）的个体驾驶目的地实时预测模型LSI-LSTM。该模型在兼顾个体出行长时间依赖性学习的同时，从轨迹点的位置语义、轨迹点与目的地间的空间关联关系两个维度建模空间上下文。具体来说，<strong>使用高德POI和TF-IDF算法建立轨迹语义提取方法t-LSE，以获得轨迹点所在区域的城市功能区类型；基于转向角、速度、已行驶距离三类驾驶状态评价轨迹点的位置重要性，并利用轨迹空间注意力机制t-SAM进一步捕获与潜在目的地有强空间关联的轨迹点。基于上述城市功能区类型和位置重要性，LSI-LSTM对轨迹点的空间上下文进行建模，在不需要外部路网数据的情况下实现细粒度空间出行特征的学习</strong>。基于私家车移动轨迹数据的实验结果表明，本文模型LSI-LSTM的预测精度显著优于所选基准模型（隐马尔科夫、随机森林与LSTM）；同时，消融实验验证了t-LSE与t-SAM的有效性。此外，本文进一步探讨了出行熵、出行距离等因素对模型预测能力的影响。</p>
<p>本文的主要创新如下：</p>
<ol>
<li>LSI-LSTM综合考虑时间依赖、出行位置语义及空间关联对个体尺度目的地预测的影响。</li>
<li>轨迹位置语义提取算法t-LSE为空间出行特征中如何有效耦合城市功能性提供了参考。t-LSE有助于丰富出行位置的先验知识，为更好地捕获语义层面上的出行规律提供支撑。</li>
<li>轨迹空间注意力机制t-SAM使得LSI-LSTM能够以数据驱动的方式实时推测司机的驾驶意图。这得益于t-SAM能够在不依赖路网数据的情况下，利用驾驶状态数据识别位置重要性并发掘潜在空间关联关系。</li>
</ol>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>个体驾驶出行目的地预测作为人类移动分析领域研究的分支，近年来逐渐成为研究热点。该研究关注如何根据一段尚未完成的轨迹及其上下文信息，快速、精准地预测可能抵达的目的地。个体出行过程具有复杂的时间依赖与空间关联关系，同时受到所处的空间上下文影响。个体出行长短距离混杂，并且具有长短期时间依赖关系。传统概率模型如隐马尔可夫，其概率推断的模型设计，难以捕获轨迹的长期依赖；而循环神经网络模型能够自动学习长期依赖关系，已成为主流的预测方法。<strong>但现有预测模型对轨迹的位置语义及空间关联关系的研究和利用尚显不足。</strong></p>
<p>受到路网拓扑的约束及个体出行偏好选择的影响，轨迹点之间存在空间关联关系。<strong>但现有研究主要关注出发位置与目的地间的空间关联关系，而忽略了中间轨迹点与各候选目的地间空间关联的差异性；然而这种差异性往往有助于出行过程的表达。位置语义作为特定区域的城市功能描述，能够辅助揭示司机的频繁出行模式，但较少有个体出行目的地预测模型考虑上述因素的作用。</strong></p>
<p>为此，本文提出一种顾及轨迹点的位置语义及空间关联关系的个体出行目的地预测模型LSI-LSTM，并通过模型对比及消融实验验证LSI-LSTM在多组轨迹数据集上的有效性。</p>
<h1 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h1><p>本文的模型LSI-LSTM由输入模块、出行模式学习模块与目的地预测模块三部分组成，如图 1 所示：</p>
<center><img src="/%E8%87%AA%E5%B7%B1%E7%AC%AC%E4%B8%80%E7%AF%87SCI%E6%96%87%E7%AB%A0-LSI-LSTM-%E4%B8%AA%E4%BD%93%E5%87%BA%E8%A1%8C%E7%9B%AE%E7%9A%84%E5%9C%B0%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/%E5%9B%BE1.png" class></center>
<center>图1 LSI-LSTM模型架构图</center>

<p>其中输入模块负责对轨迹数据、出行时空语义、驾驶状态进行编码与组织，得到移动特征序列。出行模式学习模块利用双层LSTM捕获移动特征序列的长期依赖关系，并基于轨迹空间注意力机制探测并强化关键位置的轨迹特征，最终获得个体出行模式的特征表达。目的地预测模块采用线性全连接残差网络实现特征空间到二维坐标空间的转换，输出目的地预测结果。为了建模空间上下文，输入模块和出行模式学习模块分别实现了本文提出的轨迹位置语义提取方法t-LSE和轨迹空间注意力机制t-SAM，具体介绍如下。</p>
<p>1）轨迹位置语义提取算法 t-LSE<br>t-LSE算法分为位置语义地图构建和轨迹位置语义赋值两步。算法主要流程如图2所示：</p>
<center><img src="/%E8%87%AA%E5%B7%B1%E7%AC%AC%E4%B8%80%E7%AF%87SCI%E6%96%87%E7%AB%A0-LSI-LSTM-%E4%B8%AA%E4%BD%93%E5%87%BA%E8%A1%8C%E7%9B%AE%E7%9A%84%E5%9C%B0%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/%E5%9B%BE2.png" class></center>
<center>图2 轨迹位置语义提取算法t-LSE</center>

<p>为了提高位置语义提取与赋值的效率，预先构建一幅覆盖整个研究区域的位置语义格网地图，其中每个格网单元代表特定的划分区域。t-LSE统计每个单元格内各类POI数量，并基于TF-IDF算法提取该单元格的位置语义向量，该向量的每一维取值表示对应POI类型的重要程度。相对于仅使用唯一的POI标签（如，占比最多的POI类型），语义向量能够更加全面地反映特定区域的城市功能类型。提取的深圳市位置语义示意地图如图3表示，<strong>从展示出来的关键地标建筑（如区域A中的深圳大学）可以看出位置语义格网地图能够一定程度反映城市功能性。</strong></p>
<center><img src="/%E8%87%AA%E5%B7%B1%E7%AC%AC%E4%B8%80%E7%AF%87SCI%E6%96%87%E7%AB%A0-LSI-LSTM-%E4%B8%AA%E4%BD%93%E5%87%BA%E8%A1%8C%E7%9B%AE%E7%9A%84%E5%9C%B0%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/%E5%9B%BE3.png" class></center>
<center>图3 位置语义地图</center>

<p>理论上，出发区域的位置语义能够辅助模型揭示司机潜在的出行偏好；途径的典型城市功能区也可能影响出行意图。因此，t-LSE基于语义地图为出发区域及所有中间轨迹点赋予位置语义。首先利用DBSCAN算法对所有出发轨迹点聚类，识别出各个出发区域。然后取同一类簇内所有轨迹点位置语义的均值作为该区域的位置语义。为避免位置语义稀疏问题，采用轨迹点所在格网内最重要的POI类型作为中间轨迹点位置语义。</p>
<p>2）轨迹空间注意力机制t-SAM<br>t-SAM通过驾驶状态推测各轨迹点所在空间位置对于目的地选择而言的重要性，进而为重要的轨迹点赋予较高的注意力权重，实现司机出行模式的学习与表达。通常而言，<strong>位于路口等关键位置的轨迹点与目的地之间往往有更紧密的空间关联性，能够反映司机在前进方向的选择，进而影响最终目的地的选择</strong>。图4给出司机在具有4个路口的简化路网结构中对7个候选目的地的选择过程。</p>
<center><img src="/%E8%87%AA%E5%B7%B1%E7%AC%AC%E4%B8%80%E7%AF%87SCI%E6%96%87%E7%AB%A0-LSI-LSTM-%E4%B8%AA%E4%BD%93%E5%87%BA%E8%A1%8C%E7%9B%AE%E7%9A%84%E5%9C%B0%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/%E5%9B%BE4.png" class></center>
<center>图4 简化路网中的驾驶过程示例</center>

<p>驾驶过程中途径路口点变化会导致候选目的地抵达概率的变化（仅考虑路网约束）。如图4所示，司机从A地出发，四个出行阶段所在路口位置对应的最可能目的地分别为H、B与C、D与E、D。结合关键位置及该位置司机的出行方向选择信息可有效地缩小潜在目的地的搜索范围。</p>
<p>t-LSE在<strong>无需路网数据</strong>的情况下，利用驾驶状态（速度、转向角、已行驶距离）识别位于“重要空间位置”上的轨迹点，捕获关键移动特征。基于先验知识可知，在关键路口位置或转向处，司机往往会减速慢行且前进方向发生变化，因此低速、转向角大的轨迹点常位于重要的路网位置；司机行驶距离越远，距离最终目的地也越近，轨迹点位置重要程度也相对更高。图5展示了基于某司机真实驾驶状态得到的位置重要性示例，颜色越深表示位置越重要。</p>
<center><img src="/%E8%87%AA%E5%B7%B1%E7%AC%AC%E4%B8%80%E7%AF%87SCI%E6%96%87%E7%AB%A0-LSI-LSTM-%E4%B8%AA%E4%BD%93%E5%87%BA%E8%A1%8C%E7%9B%AE%E7%9A%84%E5%9C%B0%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/%E5%9B%BE5.png" class></center>
<center>图5 轨迹点在三类驾驶状态下的位置重要性可视化</center>

<p>如图5所示，结合转向角与驾驶速度，重要位置的轨迹点 p_5、p_12、p_25  均被成功识别。基于三类驾驶状态，t-LSE构建轨迹点位置重要性计算规则，并作为注意力机制的启发项，计算得到各个轨迹点特征的注意力权重。</p>
<h1 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h1><p>为了验证模型及相关算法的有效性，本文选择深圳市内四名私家车司机2018年全年的驾驶移动轨迹记录为研究数据，其统计信息（年出行OD熵、不同的OD点簇数量、年出行距离、轨迹平均距离、轨迹总数量）如表1及图6所示：</p>
<center>表1 四名司机的年度出行统计</center>
<center></center>

<center><img src="/%E8%87%AA%E5%B7%B1%E7%AC%AC%E4%B8%80%E7%AF%87SCI%E6%96%87%E7%AB%A0-LSI-LSTM-%E4%B8%AA%E4%BD%93%E5%87%BA%E8%A1%8C%E7%9B%AE%E7%9A%84%E5%9C%B0%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/%E5%9B%BE6.png" class></center>
<center>图6 四名司机的年度出行轨迹、OD弧、活动热点空间分布可视化</center>

<p>1）    模型有效性验证实验</p>
<p>本文将LSI-LSTM与三类经典的目的地预测模型（隐马尔科夫HMM、随机森林RF及LSTM）进行对比，结果如图7所示：</p>
<center><img src="/%E8%87%AA%E5%B7%B1%E7%AC%AC%E4%B8%80%E7%AF%87SCI%E6%96%87%E7%AB%A0-LSI-LSTM-%E4%B8%AA%E4%BD%93%E5%87%BA%E8%A1%8C%E7%9B%AE%E7%9A%84%E5%9C%B0%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/%E5%9B%BE7.png" class></center>
<center>图7 模型有效性对比</center>

<p>实验结果表明，<strong>无论是平均绝对误差MAE、平均均方根误差RMSE还是平均相对误差MRE，LSI-LSTM的预测精度均显著高于三种基准模型</strong>。概率模型RF与HMM将连续稠密的轨迹数据转化为精简的出行特征，有效降低了出行过程建模的复杂性和冗余，因此比LSTM表现更好。此外，由于RF与HMM无法捕获长期的时间依赖和建模复杂的出行模式，导致面向出行熵和出行总距离较大的个体预测效果一般。结合表1的出行OD熵来看，<strong>司机的整体预测精度与出行OD熵紧密相关</strong>。出行OD熵度量了司机出行的不规律性，OD熵越高，司机的出行模式越复杂，模型整体预测精度就越低。</p>
<p>2）t-LSE和t-SAM的有效性验证实验</p>
<p>本文采用消融实验来验证算法t-LSE和t-SAM的有效性，实验的结果如图8所示：</p>
<center><img src="/%E8%87%AA%E5%B7%B1%E7%AC%AC%E4%B8%80%E7%AF%87SCI%E6%96%87%E7%AB%A0-LSI-LSTM-%E4%B8%AA%E4%BD%93%E5%87%BA%E8%A1%8C%E7%9B%AE%E7%9A%84%E5%9C%B0%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/%E5%9B%BE8.png" class></center>
<center>图8 模型消融实验</center>

<p>图8实验结果表明，<strong>t-LSE和t-SAM均有效地提高了模型的预测精度，而综合这两种算法的LSI-LSTM预测精度最好</strong>。与t-LSE相比，t-SAM对模型精度的提升更为明显。尽管t-LSE能够刻画轨迹所在位置的城市功能性，但无法揭示用户真正活动的场所类型，导致模型难以在社会活动空间上挖掘用户的移动规律；t-SAM通过识别具有显著位置重要性的轨迹点，能够实时、准确地对出行过程进行细粒度表达。</p>
<p>3）t-LSE和t-SAM的影响因素实验</p>
<p>t-LSE需要构建位置语义格网地图，而格网的划分粒度影响着位置语义的代表性及准确性。为此，本文探讨了不同格网粒度对位置语义有效性的影响，实验结果如图9所示：</p>
<center><img src="/%E8%87%AA%E5%B7%B1%E7%AC%AC%E4%B8%80%E7%AF%87SCI%E6%96%87%E7%AB%A0-LSI-LSTM-%E4%B8%AA%E4%BD%93%E5%87%BA%E8%A1%8C%E7%9B%AE%E7%9A%84%E5%9C%B0%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/%E5%9B%BE9.png" class></center>
<center>图9 不同语义地图格网粒度对四名司机平均预测精度的影响</center>

<p>图9的实验结果表明，<strong>太粗或太细的格网粒度均会影响位置语义对城市功能区的表达</strong>。太细格网粒度划分下的位置语义代表性下降，而太粗粒度会导致轨迹点在不同区域的位置语义区分度降低。针对四名司机的轨迹数据而言，250m-500m是较为合适的格网划分区间，不同应用场景下最优格网划分需要通过格网粒度实验获得。</p>
<p>t-SAM中位置重要性计算依赖于三类驾驶状态，为了探讨不同驾驶状态对t-SAM的影响，本文设计对比实验，结果如图10所示：</p>
<center><img src="/%E8%87%AA%E5%B7%B1%E7%AC%AC%E4%B8%80%E7%AF%87SCI%E6%96%87%E7%AB%A0-LSI-LSTM-%E4%B8%AA%E4%BD%93%E5%87%BA%E8%A1%8C%E7%9B%AE%E7%9A%84%E5%9C%B0%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/%E5%9B%BE10.png" class></center>
<center>图10 不同驾驶状态下四名司机的平均预测精度</center>

<p>结果表明，<strong>三种驾驶状态均能显著提高t-SAM的有效性</strong>，因为行驶距离可以反映长短距离的移动模式，而驾驶速度及转向角可以体现出行的显著移动特征。综合这三种驾驶状态可以更全面地描述轨迹的显著特征，预测精度也最高。</p>
<p>为了进一步探讨t-SAM的工作原理，本文根据t-SAM学习到的各轨迹点注意力权重与预测距离误差计算空间关联度，并通过地图可视化呈现，如图11所示：</p>
<center><img src="/%E8%87%AA%E5%B7%B1%E7%AC%AC%E4%B8%80%E7%AF%87SCI%E6%96%87%E7%AB%A0-LSI-LSTM-%E4%B8%AA%E4%BD%93%E5%87%BA%E8%A1%8C%E7%9B%AE%E7%9A%84%E5%9C%B0%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/%E5%9B%BE11.png" class></center>
<center>图11 某司机各轨迹点格网与候选目的地格网的空间关联度的空间分布及关系图</center>

<p><strong>图11 a)为各个轨迹格网的累积空间关联度</strong>，数值越大，格子颜色越深，则表示该位置与各目的地的关联性也越大，而其中颜色较深的几个位置均位于路口附近，也验证t-SAM可以基于轨迹自身状态启发式地识别关键路网位置。<strong>图11 b) 为子区域A中各轨迹网格与目的地格网332的空间关联关系强度分布图</strong>，其中轨迹格网241、301、317、354与目的地格网332的关联度最大，它们均分布于决定未来走向的关键路口附近。<strong>图11 c) 展现了轨迹格网346与360与候选目的地格网的空间关联度</strong>，可以看出当出行轨迹经过路口轨迹格网361后，前进方向上的格网346与360分别与目的地格网229与332具有强空间关联度，这与路网拓扑约束的结果吻合。<strong>图11 d) 为不同轨迹格网与目的地格网之间的空间关联度热力表</strong>，颜色越深表明关联越紧密，可以发现路网中临近的轨迹格网对目的地有相似的关联度，如轨迹格网317与332、300及301。可视化结果表明通过对轨迹点与目的地间的空间关联关系的探测与学习，t-SAM可以一定程度上辅助用户出行模式的表达。</p>
<p>4）其它影响因素实验</p>
<p><strong>不同出行长度及子轨迹的切分数量会影响到预测精度</strong>，为了探讨这两个因素对模型模型效果的影响，本文开展两项对比实验。</p>
<p>a.    出行总距离对模型精度的影响<br>个体存在长距离出行与短距离出行并存的情况，为了探讨出行总距离对模型精度的影响，本文对比四种模型（LSI-LSTM、HMM、RF与LSTM）在四名司机的数据集上的综合表现，结果如图12所示。</p>
<center><img src="/%E8%87%AA%E5%B7%B1%E7%AC%AC%E4%B8%80%E7%AF%87SCI%E6%96%87%E7%AB%A0-LSI-LSTM-%E4%B8%AA%E4%BD%93%E5%87%BA%E8%A1%8C%E7%9B%AE%E7%9A%84%E5%9C%B0%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/%E5%9B%BE12.png" class></center>
<center>图12 不同出行距离下模型的MAE和MRE表现</center>

<p>图12表明，随着出行总距离的增加，四种模型的MAE均逐渐增加；除了LSTM，其它三个模型的MRE均不断下降。这主要是因为随着出行距离的增加，用于模型训练的轨迹总数量不断减少（如图12子图左上角嵌套的小图可知），因此MAE上升。MRE逐渐降低的原因在于MAE增加率比出行距离增加率小。整体而言，LSI-LSTM在不同的出行距离下，在MAE及MRE上均表现最优。</p>
<p>b.    子轨迹生成数量对模型精度的影响<br>子轨迹是一段已出行但并未完成的从出发点到中间点的轨迹序列，为了模拟用户的出行过程，一条完整的出行轨迹被切分为不同长度的子轨迹集合。为了探讨子轨迹的生成数量对模型精度的影响，本文针对不同子轨迹切分数量进行精度分析实验，如图13所示：</p>
<center><img src="/%E8%87%AA%E5%B7%B1%E7%AC%AC%E4%B8%80%E7%AF%87SCI%E6%96%87%E7%AB%A0-LSI-LSTM-%E4%B8%AA%E4%BD%93%E5%87%BA%E8%A1%8C%E7%9B%AE%E7%9A%84%E5%9C%B0%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/%E5%9B%BE13.png" class></center>
<center>图13 子轨迹生成数量对比实验</center>

<p>实验结果表明，当子轨迹生成的数量越多，模型可以学习更丰富的出行细节，相应的预测精度也越高。但是随着子轨迹生成数量的增加，模型预测精度的提高有限，而模型训练时间却呈线性增长。因此，最合适的子轨迹生成数量可以综合预测精度与模型训练效率进行设置。</p>
<h1 id="讨论与总结"><a href="#讨论与总结" class="headerlink" title="讨论与总结"></a>讨论与总结</h1><p>针对目的地预测任务中对于空间因素利用不足的问题，本文提出一种<strong>综合轨迹点位置语义与空间关联</strong>的预测模型，并通过实验验证分析了模型及相关算法的有效性。未来工作可以围绕如下两个方面展开：</p>
<ol>
<li>深层位置语义提取。城市功能区类型仍属于浅层的位置语义，而更深层个体社会活动位置语义（如“在餐厅吃饭”）的提取，可以更好地揭示司机的出行行为偏好。</li>
<li>冷启动问题。个体目的地预测模型在数据采集初期面临数据稀疏问题，利用群体轨迹数据对模型进行预训练将提供一种解决思路。</li>
</ol>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="论文链接"><a href="#论文链接" class="headerlink" title="论文链接"></a>论文链接</h2><p><a href="https://www.sciencedirect.com/science/article/pii/S092523122100134X">LSI-LSTM: An attention-aware LSTM for real-time driving destination prediction by considering location semantics and location importance of trajectory points</a></p>
<p><strong>引用txt格式：</strong></p>
<p>Zhipeng Gui, <strong>Yunzeng Sun</strong>, Le Yang, Dehua Peng, Fa Li, Huayi Wu, Chi Guo, Wenfei Guo, Jianya Gong,<br>LSI-LSTM: An attention-aware LSTM for real-time driving destination prediction by considering location semantics and location importance of trajectory points,<br>Neurocomputing,<br>Volume 440,<br>2021,<br>Pages 72-88,<br>ISSN 0925-2312,<br><a href="https://doi.org/10.1016/j.neucom.2021.01.067">https://doi.org/10.1016/j.neucom.2021.01.067</a>.<br>(<a href="https://www.sciencedirect.com/science/article/pii/S092523122100134X">https://www.sciencedirect.com/science/article/pii/S092523122100134X</a>)</p>
<h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h2><p><a href="https://github.com/ZPGuiGroupWhu/Human-Mobility-Analysis/tree/master/Travel-Destination-Prediction/LSI-LSTM">https://github.com/ZPGuiGroupWhu/Human-Mobility-Analysis/tree/master/Travel-Destination-Prediction/LSI-LSTM</a></p>
<h2 id="首发微信公众号"><a href="#首发微信公众号" class="headerlink" title="首发微信公众号"></a>首发微信公众号</h2><p>首发地址：<a href="https://mp.weixin.qq.com/s/ynMufJEbiZ1lEFNUqE7_QA">https://mp.weixin.qq.com/s/ynMufJEbiZ1lEFNUqE7_QA</a></p>
<p>团队GitHub网站链接：<a href="https://github.com/ZPGuiGroupWhu">https://github.com/ZPGuiGroupWhu</a></p>
<p>珞珈时空计算团队微信公众号：<strong><font color="blue">Luojia-STC</font></strong></p>
<p>珞珈时空计算团队网站链接：<a href="http://www.luojia-spatial.com/index.html">http://www.luojia-spatial.com/index.html</a></p>
<center><img src="/%E8%87%AA%E5%B7%B1%E7%AC%AC%E4%B8%80%E7%AF%87SCI%E6%96%87%E7%AB%A0-LSI-LSTM-%E4%B8%AA%E4%BD%93%E5%87%BA%E8%A1%8C%E7%9B%AE%E7%9A%84%E5%9C%B0%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.png" class></center>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>自己实现简单版Vue--2. 实现数据绑定视图</title>
    <url>/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%89%88Vue-2-%E5%AE%9A%E4%B9%89Observer%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%8A%AB%E6%8C%81/</url>
    <content><![CDATA[<h1 id="利用Object-defineProperty-方法实现数据的监听"><a href="#利用Object-defineProperty-方法实现数据的监听" class="headerlink" title="利用Object.defineProperty()方法实现数据的监听"></a>利用<code>Object.defineProperty()</code>方法实现数据的监听</h1><p>Object.defineProperty()方法可以具体参考链接：<a href="http://sunyunzeng.com/JavaScript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/#%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7">http://sunyunzeng.com/JavaScript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/#%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7</a></p>
<p>该方法可以定义对象数据在访问操作时的一些约定。</p>
<ol>
<li>定义 Observer 对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.observe(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// data是一个对象，可能嵌套其它对象，需要采用递归遍历的方式进行观察者绑定</span></span><br><span class="line">    <span class="function"><span class="title">observe</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data &amp;&amp; <span class="keyword">typeof</span> data === <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.defineReactive(data, key, data[key]);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过 object.defineProperty方法对对象属性进行劫持</span></span><br><span class="line">    <span class="function"><span class="title">defineReactive</span>(<span class="params">obj, key, value</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 递归观察</span></span><br><span class="line">        <span class="built_in">this</span>.observe(value);</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">false</span>,</span><br><span class="line">            <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 采用箭头函数在定义时绑定this的定义域</span></span><br><span class="line">            set: <span class="function">(<span class="params">newVal</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(newVal !== value)&#123;</span><br><span class="line">                    <span class="built_in">this</span>.observe(newVal);</span><br><span class="line">                    value = newVal;</span><br><span class="line">                    <span class="built_in">console</span>.log(newVal);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>利用Observer对象对数据进行劫持</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MVue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始元素与数据通过options对象绑定</span></span><br><span class="line">        <span class="built_in">this</span>.$el = options.el;</span><br><span class="line">        <span class="built_in">this</span>.$data = options.data;</span><br><span class="line">        <span class="built_in">this</span>.$options = options;</span><br><span class="line">        <span class="comment">// 通过Compiler对象对模版进行编译，例如&#123;&#123;&#125;&#125;插值、v-text、v-html、v-model等Vue语法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.$el) &#123;</span><br><span class="line">            <span class="comment">// 1. 编译模版</span></span><br><span class="line">            <span class="keyword">new</span> Compiler(<span class="built_in">this</span>.$el, <span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">// 2. 创建观察者，观察数据</span></span><br><span class="line">            <span class="keyword">new</span> Observer(<span class="built_in">this</span>.$data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>定义Dep容器及Watcher对象对数据变化进行监听</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">    <span class="comment">// 通过回调函数实现更新的数据通知到视图</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">expr, vm, cb</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.expr = expr;</span><br><span class="line">        <span class="built_in">this</span>.vm = vm;</span><br><span class="line">        <span class="built_in">this</span>.cb = cb;</span><br><span class="line">        <span class="built_in">this</span>.oldVal = <span class="built_in">this</span>.getOldVal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取旧数据</span></span><br><span class="line">    <span class="function"><span class="title">getOldVal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 在利用getValue获取数据调用getter()方法时先把当前观察者挂载</span></span><br><span class="line">        Dep.target = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(Dep.target);</span><br><span class="line">        <span class="keyword">const</span> oldVal = compileUtil.getValue(<span class="built_in">this</span>.expr, <span class="built_in">this</span>.vm);</span><br><span class="line">        <span class="comment">// 挂载完毕需要注销，防止重复挂载 (数据一更新就会挂载)</span></span><br><span class="line">        Dep.target = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过回调函数更新数据</span></span><br><span class="line">    <span class="function"><span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> newVal = compileUtil.getValue(<span class="built_in">this</span>.expr, <span class="built_in">this</span>.vm);</span><br><span class="line">        <span class="keyword">if</span>(newVal !== <span class="built_in">this</span>.oldVal)&#123;</span><br><span class="line">            <span class="built_in">this</span>.cb(newVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dep类存储watcher对象，并在数据变化时通知watcher</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.watcherCollector = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加watcher</span></span><br><span class="line">    <span class="function"><span class="title">addWatcher</span>(<span class="params">watcher</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;观察者&#x27;</span>, <span class="built_in">this</span>.watcherCollector);</span><br><span class="line">        <span class="built_in">this</span>.watcherCollector.push(watcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据变化时通知watcher更新</span></span><br><span class="line">    <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.watcherCollector.forEach(<span class="function"><span class="params">w</span>=&gt;</span>w.update());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在Observer中绑定Dev</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">    <span class="function"><span class="title">defineReactive</span>(<span class="params">obj, key, value</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// ... 省略</span></span><br><span class="line">        <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">            <span class="comment">// ... 省略</span></span><br><span class="line">            <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">// 订阅数据变化时，往Dev中添加观察者</span></span><br><span class="line">                Dep.target &amp;&amp; dep.addWatcher(Dep.target);</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 采用箭头函数在定义时绑定this的定义域</span></span><br><span class="line">            set: <span class="function">(<span class="params">newVal</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">// ... 省略</span></span><br><span class="line">                <span class="comment">// 通知watcher数据发生改变</span></span><br><span class="line">                dep.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>在编译工具中绑定Watcher</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> compileUtil = &#123;</span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">    <span class="function"><span class="title">getContent</span>(<span class="params">expr, vm</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// &#123;&#123;person.name&#125;&#125;--&#123;&#123;person.age&#125;&#125;</span></span><br><span class="line">        <span class="comment">// 防止修改person.name使得所有值全部被替换</span></span><br><span class="line">        <span class="keyword">return</span> expr.replace(<span class="regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.getValue(args[<span class="number">1</span>], vm);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">text</span>(<span class="params">node, expr, vm</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> value;</span><br><span class="line">        <span class="keyword">if</span>(expr.indexOf(<span class="string">&#x27;&#123;&#123;&#x27;</span>)!==-<span class="number">1</span>)&#123;</span><br><span class="line">            value = expr.replace(<span class="regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">// text的 Watcher应在此绑定，因为是对插值&#123;&#123;&#125;&#125;进行双向绑定</span></span><br><span class="line">                <span class="comment">// Watcher的构造函数的 getOldVal()方法需要接受数据或者对象，而&#123;&#123;person.name&#125;&#125;不能接收</span></span><br><span class="line">                <span class="keyword">new</span> Watcher(args[<span class="number">1</span>], vm, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.updater.textUpdater(node, <span class="built_in">this</span>.getContent(expr, vm));</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.getValue(args[<span class="number">1</span>], vm);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            value = <span class="built_in">this</span>.getValue(expr, vm);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.updater.textUpdater(node, value);  </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">html</span>(<span class="params">node, expr, vm</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="built_in">this</span>.getValue(expr, vm);</span><br><span class="line">        <span class="comment">// html对应的 Watcher</span></span><br><span class="line">        <span class="keyword">new</span> Watcher(expr, vm, <span class="function">(<span class="params">newVal</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.updater.htmlUpdater(node, newVal);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">this</span>.updater.htmlUpdater(node, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在MVue类的构造函数中绑定Observer</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MVue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$el = options.el;</span><br><span class="line">        <span class="built_in">this</span>.$data = options.data;</span><br><span class="line">        <span class="built_in">this</span>.$options = options;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.$el) &#123;</span><br><span class="line">            <span class="comment">// 1. 创建观察者</span></span><br><span class="line">            <span class="keyword">new</span> Observer(<span class="built_in">this</span>.$data);</span><br><span class="line">            <span class="comment">// 2. 编译模版</span></span><br><span class="line">            <span class="keyword">new</span> Compiler(<span class="built_in">this</span>.$el, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/SUNYunZeng/ImitateVue">https://github.com/SUNYunZeng/ImitateVue</a></p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式：Java方法</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AJava%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="使用-try-with-resources调用用完需关闭的方法。"><a href="#使用-try-with-resources调用用完需关闭的方法。" class="headerlink" title="使用 try-with-resources调用用完需关闭的方法。"></a>使用 <font color="#f07c82">try-with-resources</font>调用用完需关闭的方法。</h1><p>实现了 <font color="#f07c82">AutoCloseable</font>接口（由一个返回为 <font color="#f07c82">void</font>的<font color="#f07c82">close</font>组成）的资源可以使用<font color="#f07c82">try-with-resources</font>方法。</p>
<p><font color="#f07c82">AutoCloseable</font>接口在Java的类库和第三方类库中许多类和接口都有实现或继承，例如 BufferedReader、InputStream、OutputStream 等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(InputStream in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(dst))&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span>((n = in.read(buf)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    OutputStream </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="重写equals方法规则"><a href="#重写equals方法规则" class="headerlink" title="重写equals方法规则"></a>重写<font color="#f07c82">equals</font>方法规则</h1><ol>
<li><p>使用 <strong>==</strong> 运算符检查参数是否为该对象的引用。如果是，返回 <strong>true</strong>。这只是一种性能优化，但是如果这种比较可能很昂贵的话，那就值得去做。</p>
</li>
<li><p>使用 <strong>instanceof</strong> 运算符来检查参数是否具有正确的类型。 如果不是，则返回 false。 通常，正确的类型是 equals 方法所在的那个类。 有时候，改类实现了一些接口。 如果类实现了一个接口，该接口可以改进 equals 约定以允许实现接口的类进行比较，那么使用接口。 集合接口（如 Set，List，Map 和 Map.Entry）具有此特性。</p>
</li>
<li><p>参数转换为正确的类型。因为转换操作在 instanceof 中已经处理过，所以它肯定会成功。</p>
</li>
<li><p>对于类中的每个「重要」的属性，请检查该参数属性是否与该对象对应的属性相匹配。如果所有这些测试成功，返回 true，否则返回 false。如果步骤 2 中的类型是一个接口，那么必须通过接口方法访问参数的属性;如果类型是类，则可以直接访问属性，这取决于属性的访问权限。</p>
</li>
</ol>
<ul>
<li><p>对于类型为<strong>非 float</strong> 或 <strong>double</strong> 的基本类型，使用 == 运算符进行比较；对于对象引用属性，递归地调用 equals 方法；对于 float 基本类型的属性，使用静态 <strong>Float.compare(float, float)</strong> 方法；对于 double 基本类型的属性，使用 <strong>Double.compare(double, double)</strong> 方法。由于存在 <strong>Float.NaN，-0.0f 和类似的 double 类型</strong>的值，所以需要对 float 和 double 属性进行特殊的处理；虽然你可以使用静态方法 Float.equals 和 Double.equals 方法对 float 和 double 基本类型的属性进行比较，这会导致每次比较时发生自动装箱，引发非常差的性能。 对于数组属性，将这些准则应用于每个元素。 如果数组属性中的每个元素都很重要，请使用其中一个重载的 Arrays.equals 方法。</p>
</li>
<li><p>某些对象引用的属性可能合法地包含 <strong>null</strong>。 为避免出现 NullPointerException 异常，请使用静态方法 <strong>Objects.equals(Object, Object)</strong> 检查这些属性是否相等。</p>
</li>
</ul>
<h1 id="重写equals方法时一定重写hashCode方法。"><a href="#重写equals方法时一定重写hashCode方法。" class="headerlink" title="重写equals方法时一定重写hashCode方法。"></a>重写<font color="#f07c82">equals</font>方法时一定重写<font color="#f07c82">hashCode</font>方法。</h1><p>基于Hash值的散列数据结构，例如hashMap、HashSet等，需要基于Hash值判断两个是否相等，其实是根据<font color="#f07c82">equals</font>方法来判断。</p>
<p><font color="#f07c82">equals</font>方法改变，要想实例也能跟被基于hash的散列结构识别，需要将<font color="#f07c82">hashCode</font>方法重写。</p>
<h1 id="时刻重写toString方法。"><a href="#时刻重写toString方法。" class="headerlink" title="时刻重写toString方法。"></a>时刻重写<font color="#f07c82">toString</font>方法。</h1><h1 id="使用clone方法对于可变对象的克隆需要谨慎。"><a href="#使用clone方法对于可变对象的克隆需要谨慎。" class="headerlink" title="使用clone方法对于可变对象的克隆需要谨慎。"></a>使用clone方法对于<font color="#f07c82">可变对象</font>的克隆需要谨慎。</h1><p>克隆出来的对象的类型与原始对象的一致，并且<font color="#f07c82">x.clone != x</font>返回<font color="#f07c82">true</font>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashTable的克隆方法，需要深度克隆，保证克隆出来的对象是原先对象的深层拷贝，桶或链都拷贝一份</span></span><br><span class="line"><span class="comment">// Recursive clone method for class with complex mutable state</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Entry[] buckets = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object key;</span><br><span class="line">        Object value;</span><br><span class="line">        Entry  next;</span><br><span class="line"></span><br><span class="line">        Entry(Object key, Object value, Entry next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key   = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next  = next;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recursively copy the linked list headed by this Entry</span></span><br><span class="line">        <span class="comment">//Entry deepCopy() &#123;</span></span><br><span class="line">        <span class="comment">//    return new Entry(key, value,</span></span><br><span class="line">        <span class="comment">//        next == null ? null : next.deepCopy());</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">// 避免链表过长导致栈溢出错误</span></span><br><span class="line">        <span class="function">Entry <span class="title">deepCopy</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Entry result = <span class="keyword">new</span> Entry(key, value, next);</span><br><span class="line">            <span class="keyword">for</span>(Entry p = result; p!=<span class="keyword">null</span>; p=p.next)&#123;</span><br><span class="line">                 p.next = <span class="keyword">new</span> Entry(p.next.key, p.next.value, p.next.next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> HashTable <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HashTable result = (HashTable) <span class="keyword">super</span>.clone();</span><br><span class="line">            result.buckets = <span class="keyword">new</span> Entry[buckets.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckets.length; i++)</span><br><span class="line">                <span class="keyword">if</span> (buckets[i] != <span class="keyword">null</span>)</span><br><span class="line">                    result.buckets[i] = buckets[i].deepCopy();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="在可比较大小的类中考虑实验Comparable接口。"><a href="#在可比较大小的类中考虑实验Comparable接口。" class="headerlink" title="在可比较大小的类中考虑实验Comparable接口。"></a>在可比较大小的类中考虑实验<font color="#f07c82">Comparable</font>接口。</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<font color="#f07c82">conpareTo()</font>中比较大小时，避免使用<font color="#f07c82"> &lt; </font>或者<font color="#f07c82"> &gt; </font>,应该使用包装类中的<font color="#f07c82">compare()</font>方法或者自己实现<font color="#f07c82">Comparator</font>接口中的<font color="#f07c82">compare()</font>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Comparator based on static compare method</span></span><br><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="keyword">new</span> Comparator&lt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o1.hashCode(), o2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Comparator based on Comparator construction method</span></span><br><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder =</span><br><span class="line">        Comparator.comparingInt(o -&gt; o.hashCode());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>参考：</strong> <u><a href="https://sjsdfg.github.io/effective-java-3rd-chinese/#/">https://sjsdfg.github.io/effective-java-3rd-chinese/#/</a></u></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式: Java泛型</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="不要使用原始类型"><a href="#不要使用原始类型" class="headerlink" title="不要使用原始类型"></a>不要使用原始类型</h1><p><strong>原始类型</strong>是Java(5之前)的历史遗留问题，<strong>之前集合对于类型在编译期间不进行检查，而在运行期进行类型检查。</strong></p>
<p>这导致问题的定位困难，降低效率。</p>
<p>此后采用<strong>泛型</strong>解决这个问题，保证在编译期间进行检查。</p>
<p>例如<font color="#f07c82">List</font> 类型是原始类型，而<font color="#f07c82">List&lt; E &gt;</font>是泛型类型，指定了参数化类型为 <font color="#f07c82">E</font> 类型。</p>
<p><strong>List</strong>表明可以存储任何类型的对象，<font color="#f07c82">List&lt; E &gt; </font>是它的子类型，可以转化为<strong>List</strong>类型，但是丧失了安全性检查；而<font color="#f07c82">List&lt; E &gt; </font> 却不是<font color="#f07c82">List&lt; Object &gt; </font>的子类型。<font color="#f07c82">List&lt; Object &gt; </font>只能是<font color="#f07c82">List&lt; Object &gt; </font>。</p>
<p>如果想实现类似于<strong>List等存储任何类型的对象</strong>， 可以利用<strong>无限制通配符类型（unbounded wildcard types）</strong>表示泛型类型，即<font color="#f07c82">List&lt; ? &gt; </font>。</p>
<p><strong>泛型的几个注意点：</strong></p>
<p><strong>1. 类字面常量不允许使用泛型</strong></p>
<p>数组<font color="#f07c82">String[].class</font>、基本类型<font color="#f07c82">int.class</font>、不带参数化类型的类<font color="#f07c82">List.class</font>可以使用。</p>
<p><strong>2. instanceof 只能对无限制通配符类型的参数化类型的类或接口使用。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> Set)&#123;</span><br><span class="line">    Set&lt;?&gt; s = (Set&lt;?&gt;) o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">术语</th>
<th style="text-align:center">中文含义</th>
<th style="text-align:center">举例    </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Parameterized type</td>
<td style="text-align:center">参数化类型</td>
<td style="text-align:center">List&lt; String &gt;</td>
</tr>
<tr>
<td style="text-align:center">Actual type parameter</td>
<td style="text-align:center">实际类型参数</td>
<td style="text-align:center">String    </td>
</tr>
<tr>
<td style="text-align:center">Generic type</td>
<td style="text-align:center">泛型类型</td>
<td style="text-align:center">List&lt; E &gt;    </td>
</tr>
<tr>
<td style="text-align:center">Formal type parameter</td>
<td style="text-align:center">形式类型参数</td>
<td style="text-align:center">E    </td>
</tr>
<tr>
<td style="text-align:center">Unbounded wildcard type</td>
<td style="text-align:center">无限制通配符类型</td>
<td style="text-align:center">List&lt;?&gt;    </td>
</tr>
<tr>
<td style="text-align:center">Raw type</td>
<td style="text-align:center">原始类型</td>
<td style="text-align:center">List    </td>
</tr>
<tr>
<td style="text-align:center">Bounded type parameter</td>
<td style="text-align:center">限制类型参数</td>
<td style="text-align:center">&lt; E extends Number&gt;    </td>
</tr>
<tr>
<td style="text-align:center">Recursive type bound</td>
<td style="text-align:center">递归类型限制</td>
<td style="text-align:center">&lt; T extends Comparable&lt; T &gt;&gt;    </td>
</tr>
<tr>
<td style="text-align:center">Bounded wildcard type</td>
<td style="text-align:center">限制通配符类型</td>
<td style="text-align:center">List&lt;? extends Number&gt;    </td>
</tr>
<tr>
<td style="text-align:center">Generic method</td>
<td style="text-align:center">泛型方法</td>
<td style="text-align:center">static &lt; E &gt; List&lt; E &gt; asList(E[] a)    </td>
</tr>
<tr>
<td style="text-align:center">Type token</td>
<td style="text-align:center">类型令牌</td>
<td style="text-align:center">String.class    </td>
</tr>
</tbody>
</table>
</div>
<h1 id="列表优先于数组"><a href="#列表优先于数组" class="headerlink" title="列表优先于数组"></a>列表优先于数组</h1><p>即<font color="#f07c82">List</font>优先于数组。</p>
<p>因为数组是<strong>协变类型</strong>的，所以下面代码编译期间是合法的, 但是运行期间是违法的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] o = <span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line">o[<span class="number">1</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>尽量使用<strong>列表</strong>来在编译过程中就确保安全性，虽然会损失掉一定的性能与简洁性。</p>
<p>下面代码运行有警告，因为java程序中的泛型信息在编译后会进行<strong>擦除</strong>（这意味着它们只在编译时执行类型约束，并在运行时丢弃它们的元素类型信息），为了与Java5之前的代码共存。</p>
<p>因此实际在运行中虚拟机并不知道返回数组具体类型，返回的类型是顶层类 Object, 在强制转换为<strong>T[]</strong>时会有问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Chooser</span><span class="params">(Collection&lt;T&gt; choices)</span> </span>&#123;</span><br><span class="line">    choiceArray = (T[]) choices.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此最好采用List替代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Chooser</span><span class="params">(Collection&lt;T&gt; choices)</span> </span>&#123;</span><br><span class="line">    choiceList = <span class="keyword">new</span> ArrayList&lt;&gt;(choices);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="优先考虑泛型"><a href="#优先考虑泛型" class="headerlink" title="优先考虑泛型"></a>优先考虑泛型</h1><p>一个简单实现的栈，原始版本 vs 添加泛型版本。</p>
<p><strong>原始版本</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">    <span class="comment">// 存储数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 默认长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    <span class="comment">// 元素桶</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Stack&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span></span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        Object res = elements[--size];</span><br><span class="line">        <span class="comment">// 清除无用的引用</span></span><br><span class="line">        elements[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ensureCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(elements.length==size)</span><br><span class="line">            elements = Arrays.copyOf(elements, size*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样的版本Stack每次取出元素都要进行强制类型转换。</p>
<p><strong>泛型版本</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 存储数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 默认长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    <span class="comment">// 元素桶</span></span><br><span class="line">    <span class="keyword">private</span> E[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保强制转换是安全的。有问题的数组（元素）保存在一个私有属性中，永远不会返回给客户端或传递给任何其他方法。 保存在数组中的唯一元素是那些传递给 push 方法的元素，它们是 E 类型的，所以未经检查的强制转换不会造成任何伤害</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 强制类型转换，因为无法创建泛型数组 new E[DEFAULT_INITIAL_CAPACITY];</span></span><br><span class="line">        elements = (E)<span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        E res = elements[--size];</span><br><span class="line">        <span class="comment">// 清除无用的引用</span></span><br><span class="line">        elements[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ensureCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(elements.length==size)</span><br><span class="line">            elements = Arrays.copyOf(elements, size*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="考虑泛型方法"><a href="#考虑泛型方法" class="headerlink" title="考虑泛型方法"></a>考虑泛型方法</h1><p>声明类型参数的<strong>类型参数列表</strong>位于方法的<strong>修饰符</strong>和<strong>返回类型</strong>之间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Generic method</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> </span>&#123;</span><br><span class="line">    Set&lt;E&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(s1);</span><br><span class="line">    result.addAll(s2);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="限定通配符增加API灵活性"><a href="#限定通配符增加API灵活性" class="headerlink" title="限定通配符增加API灵活性"></a>限定通配符增加API灵活性</h1><p><strong>PECS代表： producer-extends，consumer-super。</strong></p>
<p>如果一个参数化类型代表一个 <font color="#f07c82">T</font> 生产者，使用 <font color="#f07c82">&lt;? extends T&gt;</font>；如果它代表 <font color="#f07c82">T</font> 消费者，则使用 <font color="#f07c82">&lt;? super T&gt;</font>。 在我们的 <font color="#f07c82">Stack</font> 示例中，<font color="#f07c82">pushAll</font> 方法的 <font color="#f07c82">src</font> 参数生成栈使用的 <font color="#f07c82">E</font> 实例，因此 <font color="#f07c82">src</font> 的合适类型为 <font color="#f07c82">Iterable&lt;? extends E&gt;</font>；<font color="#f07c82">popAll</font> 方法的 <font color="#f07c82">dst</font> 参数消费 <font color="#f07c82">Stack</font> 中的 <font color="#f07c82">E</font> 实例，因此 <font color="#f07c82">dst</font> 的合适类型是 <font color="#f07c82">Collection &lt;? super E&gt;</font>。</p>
<p><strong>所有 <font color="#f07c82">Comparable</font> 和 <font color="#f07c82">Comparator</font> 都是消费者。</strong></p>
<h1 id="可变参数与泛型"><a href="#可变参数与泛型" class="headerlink" title="可变参数与泛型"></a>可变参数与泛型</h1><p>可变参数: 类型 <font color="#f07c82">T</font> 加<font color="#f07c82">…</font>构成，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String ... strs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(String s: strs)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java用一个数组来保存变长的参数，但是<strong>可变参数的类型与泛型要注意混淆</strong>。</p>
<p>考虑一个<strong>例子：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T ... t)&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">String[] strs = toArray(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上面的会报错，因为泛型传递的是非具体类型，也就是编译时的类型信息要多与运行时信息（由于擦除），因此可变参数的数组用 <font color="#f07c82">Object</font>类型存储，当<font color="#f07c82">Object</font>转为<font color="#f07c82">String</font>时，会报错<font color="#f07c82">ClassCastException</font>。</p>
<p><strong>另一个例子：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;String&gt;... stringList)</span></span>&#123;</span><br><span class="line">    Object[] obj = stringList;</span><br><span class="line">    List&lt;Integer&gt; intList = List.of(<span class="number">15</span>); <span class="comment">// List.of生成一个不可变列表（不能用set设置数值）</span></span><br><span class="line">    obj[<span class="number">0</span>] = intList; <span class="comment">// 发成堆污染</span></span><br><span class="line">    String s = obj[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// 出现警告，编译没错，但是运行报错 ClassCastException。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，可变参数中混淆了泛型，还是很容易产生类型转换的不安全性，但是Java并没有因此抛弃，而在<font color="#f07c82">Arrays.asList(T… a)，Collections.addAll(Collection&lt;? super T&gt; c, T… elements)，EnumSet.of(E first, E… rest)</font>中大量使用，说明<strong>只要保证可变参数中的泛型是安全的（以下三点），就可：</strong></p>
<p><strong>1. 可变参数数组不会存储跟修改。</strong><br><strong>2. 可变参数数组的引用不会转义。</strong><br><strong>3. 可变参数数组仅用来为方法传递可变参数。</strong></p>
<p>当然，可变参数数组可以变为列表，但同时降低了一定性能与可读性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">toArray</span><span class="params">(List&lt;T&gt; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">List&lt;String&gt; strs = toArray(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>可变参数的另一个用法</strong></p>
<p>因为可变参数数组的产生都会产生性能损耗，因此当 95％ 的调用是三个或更少的参数的方法，那么声明该方法的五个重载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span>... rest)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<h1 id="异构容器"><a href="#异构容器" class="headerlink" title="异构容器"></a>异构容器</h1><p>泛型中规定的可变类型数量总是有限的，例如单个类型约束<font color="#f07c82">&lt; T &gt;</font>以及Map的<font color="#f07c82">&lt; K , V&gt;</font>。</p>
<p>异构容器可以通过<strong>参数化键</strong>的方式，实现泛型设定数量的灵活性。例如在数据库查询中任意列值。</p>
<p>下面是一个异构容器的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span></span>&#123;</span><br><span class="line">    <span class="comment">// 用Class&lt;T&gt;存放未知的键</span></span><br><span class="line">    Map&lt;Class&lt;?&gt;, T&gt; favorites = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span></span>&#123;</span><br><span class="line">        favorites.put(Object.requireNonNull(type), type.cast(instance));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type.cast(favorites.get(type));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Favorites f = <span class="keyword">new</span> Favorites();</span><br><span class="line">    f.put(String.class, <span class="string">&quot;syz&quot;</span>);</span><br><span class="line">    f.put(Integer.class, <span class="number">12</span>);</span><br><span class="line">    f,get(String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 <font color="#f07c82">Column</font>Class&lt;/font&gt; 对象作为此类型安全异构容器的键。 以这种方式使用的 Class 对象称为类型令牌。 也可以使用自定义键类型。 例如，可以有一个表示数据库行（容器）的 <font color="#f07c82">DatabaseRow</font> 类型和一个泛型类型 <font color="#f07c82">Column&lt; T &gt;</font> 作为其键。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式：Java枚举类与注解</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AJava%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="枚举类替代整形常量"><a href="#枚举类替代整形常量" class="headerlink" title="枚举类替代整形常量"></a>枚举类替代整形常量</h1><p>枚举类的基本形式如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Apple</span>  </span>&#123; FUJI, PIPPIN, GRANNY_SMITH &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Orange</span> </span>&#123; NAVEL, TEMPLE, BLOOD &#125;</span><br></pre></td></tr></table></figure></p>
<p><font color="#f07c82">enum</font>关键字指明一个类继承 <font color="#f07c82">abstract</font>Enum。</p>
<p>该类有两个重要的方法：</p>
<ol>
<li><p><font color="#f07c82">ordinal()</font>. 返回整形序列值（从0开始）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    SPRING, SUMMER, FALL, WINTER</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(Season.SPRING.ordinal())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><font color="#f07c82">Enum()</font>. 只能被继承Enum的类调用的构造方法，枚举类中每个实例调用该方法实现赋值，每个实例的构造方法都是私有的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>枚举类的特征</strong><br><strong>1. 不能被继承其它类也不能被其他类继承，但可以实现接口，对枚举类内部实例进行组织。</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Season</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>), SUMMER(<span class="string">&quot;夏天&quot;</span>), FALL(<span class="string">&quot;秋天&quot;</span>), WINTER(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">    <span class="comment">// 必须为private的构造器，因为枚举类本身是final的，其内部实例也是final，且在枚举类生成同时调用私有的构造器实现值的赋予</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span> name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现接口，每个实例都有该接口，可以返回对应的中文名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        return name;</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@test</span></span><br><span class="line">    System.out.println(Season.SPRING.getName());</span><br><span class="line">    <span class="comment">// 打印 春天</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 类中每个实例可以重写其中定义的抽象方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Season</span> <span class="keyword">implements</span></span>&#123;</span><br><span class="line">    SPRING(<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(return <span class="string">&quot;春天&quot;</span>)</span>, </span></span><br><span class="line"><span class="function">    <span class="title">SUMMER</span><span class="params">(<span class="keyword">public</span> String getName(return <span class="string">&quot;夏天&quot;</span>)</span>), </span></span><br><span class="line"><span class="function">    <span class="title">FALL</span><span class="params">(<span class="keyword">public</span> String getName(return <span class="string">&quot;秋天&quot;</span>)</span>), </span></span><br><span class="line"><span class="function">    <span class="title">WINTER</span><span class="params">(<span class="keyword">public</span> String getName(return <span class="string">&quot;冬天&quot;</span>)</span>)</span>;</span><br><span class="line">    <span class="comment">// 必须为每个实例都重写抽象方法，否则报错</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span> name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现接口，每个实例都有该接口，可以返回对应的中文名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@test</span></span><br><span class="line">    System.out.println(Season.SPRING.getName());</span><br><span class="line">    <span class="comment">// 打印 春天</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 可利用枚举实现单例</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> enmu Sigleton&#123;</span><br><span class="line">    SINGLETON;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;method&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@test</span></span><br><span class="line">System.out.println(Singleton.SINGLETON.method())</span><br><span class="line"><span class="comment">// 打印 method</span></span><br></pre></td></tr></table></figure></p>
<p><strong>4. 调用values()方法遍历枚举类型中的每个实例</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Season season: Season.values)&#123;</span><br><span class="line">    System.out.println(season.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>嵌套枚举</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The strategy enum pattern</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PayrollDay</span> </span>&#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,</span><br><span class="line">    SATURDAY(PayType.WEEKEND), SUNDAY(PayType.WEEKEND);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PayType payType;</span><br><span class="line"></span><br><span class="line">    PayrollDay(PayType payType) &#123; <span class="keyword">this</span>.payType = payType; &#125;</span><br><span class="line">    PayrollDay() &#123; <span class="keyword">this</span>(PayType.WEEKDAY); &#125;  <span class="comment">// Default</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> minutesWorked, <span class="keyword">int</span> payRate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> payType.pay(minutesWorked, payRate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The strategy enum type</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">PayType</span> </span>&#123;</span><br><span class="line">        WEEKDAY &#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">int</span> minsWorked, <span class="keyword">int</span> payRate)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> minsWorked &lt;= MINS_PER_SHIFT ? <span class="number">0</span> :</span><br><span class="line">                  (minsWorked - MINS_PER_SHIFT) * payRate / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        WEEKEND &#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">int</span> minsWorked, <span class="keyword">int</span> payRate)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> minsWorked * payRate / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">int</span> mins, <span class="keyword">int</span> payRate)</span></span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MINS_PER_SHIFT = <span class="number">8</span> * <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> minsWorked, <span class="keyword">int</span> payRate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> basePay = minsWorked * payRate;</span><br><span class="line">            <span class="keyword">return</span> basePay + overtimePay(minsWorked, payRate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实例属性代替内置序数"><a href="#实例属性代替内置序数" class="headerlink" title="实例属性代替内置序数"></a>实例属性代替内置序数</h1><p>内置序数会随枚举内部类位置而改变，通过在内部类的实例属性实现标记与类的一一对应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Ensemble</span> </span>&#123;</span><br><span class="line">    SOLO(<span class="number">1</span>), DUET(<span class="number">2</span>), TRIO(<span class="number">3</span>), QUARTET(<span class="number">4</span>), QUINTET(<span class="number">5</span>),</span><br><span class="line">    SEXTET(<span class="number">6</span>), SEPTET(<span class="number">7</span>), OCTET(<span class="number">8</span>), DOUBLE_QUARTET(<span class="number">8</span>),</span><br><span class="line">    NONET(<span class="number">9</span>), DECTET(<span class="number">10</span>), TRIPLE_QUARTET(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numberOfMusicians;</span><br><span class="line"></span><br><span class="line">    Ensemble(<span class="keyword">int</span> size) &#123; <span class="keyword">this</span>.numberOfMusicians = size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusicians</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> numberOfMusicians; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="按位属性替换为EnumSet"><a href="#按位属性替换为EnumSet" class="headerlink" title="按位属性替换为EnumSet"></a>按位属性替换为EnumSet</h1><p><strong>替代前:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_BOLD          = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_ITALIC        = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_UNDERLINE     = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;  <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_STRIKETHROUGH = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;  <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parameter is bitwise OR of zero or more STYLE_ constants</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyStyles</span><span class="params">(<span class="keyword">int</span> styles)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改后：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EnumSet - a modern replacement for bit fields</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Style</span> </span>&#123; BOLD, ITALIC, UNDERLINE, STRIKETHROUGH &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Any Set could be passed in, but EnumSet is clearly best</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyStyles</span><span class="params">(Set&lt;Style&gt; styles)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------</span></span><br><span class="line">text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="使用EnumMap"><a href="#使用EnumMap" class="headerlink" title="使用EnumMap"></a>使用EnumMap</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">LifeCycle</span> </span>&#123; ANNUAL, PERENNIAL, BIENNIAL &#125;</span><br><span class="line">    <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">final</span> LifeCycle lifeCycle;</span><br><span class="line"></span><br><span class="line">    Plant(String name, LifeCycle lifeCycle) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.lifeCycle = lifeCycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Using an EnumMap to associate data with an enum</span></span><br><span class="line">Map&lt;Plant.LifeCycle, Set&lt;Plant&gt;&gt;  plantsByLifeCycle =</span><br><span class="line">    <span class="keyword">new</span> EnumMap&lt;&gt;(Plant.LifeCycle.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Plant.LifeCycle lc : Plant.LifeCycle.values())</span><br><span class="line">    plantsByLifeCycle.put(lc, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Plant p : garden)</span><br><span class="line">    plantsByLifeCycle.get(p.lifeCycle).add(p);</span><br><span class="line"></span><br><span class="line">System.out.println(plantsByLifeCycle);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式：Java类和接口</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AJava%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="使类与成员可访问性最小"><a href="#使类与成员可访问性最小" class="headerlink" title="使类与成员可访问性最小"></a>使类与成员可访问性最小</h1><h2 id="成员（类、接口、方法、字段）的访问级别"><a href="#成员（类、接口、方法、字段）的访问级别" class="headerlink" title="成员（类、接口、方法、字段）的访问级别"></a>成员（类、接口、方法、字段）的访问级别</h2><ul>
<li><p><font color="#f07c82">private</font> —— 该成员只能在声明它的顶级类内访问。</p>
</li>
<li><p><font color="#f07c82">package-private</font> —— 成员可以从被声明的包中的任何类中访问。从技术上讲，如果没有指定访问修饰符（接口成员除外，它默认是公共的），这是默认访问级别。</p>
</li>
<li><p><font color="#f07c82">protected</font> —— 成员可以从被声明的类的子类中访问（会受一些限制 [JLS, 6.6.2]），以及它声明的包中的任何类。</p>
</li>
<li><p><font color="#f07c82">public</font> —— 该成员可以从任何地方被访问。</p>
</li>
</ul>
<h2 id="公共类的实例字段很少情况下采用-public-修饰"><a href="#公共类的实例字段很少情况下采用-public-修饰" class="headerlink" title="公共类的实例字段很少情况下采用 public 修饰"></a>公共类的实例字段很少情况下采用 public 修饰</h2><p>如果需要<strong>调用私有成员</strong>，就<strong>写一个方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</span><br><span class="line">    <span class="keyword">return</span> PRIVATE_VALUES.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="公共类中使用访问方法而不是访问属性"><a href="#公共类中使用访问方法而不是访问属性" class="headerlink" title="公共类中使用访问方法而不是访问属性"></a>公共类中使用访问方法而不是访问属性</h1><p>虽然包内访问权限，如果只包内可见是可行的，也可以，同时可以避免视觉混乱，但是不提倡这样做。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Degenerate classes like this should not be public!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>提供提供方法与设置方法</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Encapsulation of data by accessor methods and mutators</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">this</span>.x = x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">this</span>.y = y; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h1><p>不变类中<font color="#f07c82">所有实例的信息在生命周期中都是固定的</font>，因此是安全可靠的。</p>
<h2 id="不变类的设计规则"><a href="#不变类的设计规则" class="headerlink" title="不变类的设计规则"></a>不变类的设计规则</h2><ul>
<li><p><font color="#f07c82">不要提供修改对象状态的方法</font> （也称为 mutators）。</p>
</li>
<li><p><font color="#f07c82">确保这个类不能被继承。</font>  这可以防止粗心的或恶意的子类，假设对象的状态已经改变，从而破坏类的不可变行为。 防止子类化通常是通过 final 修饰类，但是我们稍后将讨论另一种方法。</p>
</li>
<li><p><font color="#f07c82">把所有属性设置为 final。</font>  通过系统强制执行，清楚地表达了你的意图。 另外，如果一个新创建的实例的引用从一个线程传递到另一个线程而没有同步，就必须保证正确的行为。</p>
</li>
<li><p><font color="#f07c82">把所有的属性设置为 private。</font>  这可以防止客户端获得对属性引用的可变对象的访问权限并直接修改这些对象。 虽然技术上允许不可变类具有包含基本类型数值的公共 final 属性或对不可变对象的引用，但不建议这样做，因为它不允许在以后的版本中更改内部表示。</p>
</li>
<li><p><font color="#f07c82">确保对任何可变组件的互斥访问。</font>  如果你的类有任何引用可变对象的属性，请确保该类的客户端无法获得对这些对象的引用。 切勿将这样的属性初始化为客户端提供的对象引用，或从访问方法返回属性。 在构造方法，访问方法和 readObject 方法中进行防御性拷贝。</p>
</li>
</ul>
<h1 id="多使用组合而不是继承"><a href="#多使用组合而不是继承" class="headerlink" title="多使用组合而不是继承"></a>多使用组合而不是继承</h1><p>如果父类不是为了继承而专门设计，那么后面父类的修改可能会导致子类产生严重的bug。</p>
<p>明智的方法是多使用组合<font color="#f07c82">composition</font>。即在类内部使用其它类的引用。</p>
<p>一个<font color="#f07c82">新类</font>由一系列<font color="#f07c82">现有类</font>组成，<strong>新类的方法通过调用现有类的方法获取结果</strong>，成为<font color="#f07c82">转发 (farwarding)</font>。</p>
<h1 id="继承需要深思熟虑还要详细的设计文档"><a href="#继承需要深思熟虑还要详细的设计文档" class="headerlink" title="继承需要深思熟虑还要详细的设计文档"></a>继承需要深思熟虑还要详细的设计文档</h1><p>测试为继承而设计的类的唯一方法是<font color="#f07c82">编写子类</font>。</p>
<p><strong>构造方法绝不能直接或间接调用可重写的方法。</strong></p>
<p>For example:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Broken - constructor invokes an overridable method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Super</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        overrideMe();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overrideMe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Blank final, set by constructor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Instant instant;</span><br><span class="line"></span><br><span class="line">    Sub() &#123;</span><br><span class="line">        instant = Instant.now();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overriding method invoked by superclass constructor</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overrideMe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(instant);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line">        sub.overrideMe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述子类由于重写了方法，调用父类时 instant 成员没有指向任何一个对象，因此有问题。</p>
<p>专门为了继承而设计类是一件很辛苦的工作。你必须建立文档说明其所有的自用模式，并且一旦建立了文档，在这个类的整个生命周期中都必须遵守。如果没有做到，子类就会依赖父类的实现细节，如果父类的实现发生了变化，它就有可能遭到破坏。为了允许其他人能编写出高效的子类，还你必须导出一个或者多个受保护的方法。除非知道真正需要子类，否则最好通过将类声明为 <font color="#f07c82">final</font>，或者确保没有可访问的构造器来禁止类被继承。</p>
<h1 id="接口优先抽象类"><a href="#接口优先抽象类" class="headerlink" title="接口优先抽象类"></a>接口优先抽象类</h1><p>抽象类的实现只有继承，限制了<strong>混合类型</strong>的定义。</p>
<p>同时，对于非层次的类级关系，想要为类<strong>添加额外</strong>的功能，接口是一个很好的方法。</p>
<p><strong><font color="#f07c82">骨架抽象类</font></strong>，首先是一个<strong>抽象类</strong>，然后该抽象类<strong>实现了一个接口</strong>的基本方法，形成默认的方法实现，提供基础的功能。</p>
<p>用户可以自由的选择是选择<strong>继承该抽象类</strong>还是<strong>直接实现该抽象类实现的接口</strong>，从而保证灵活性。</p>
<p>骨架抽象类的例子：<font color="#f07c82">AbstractList、AbstractSet</font>等。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Skeletal implementation class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMapEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Entries in a modifiable map must override this method</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implements the general contract of Map.Entry.equals</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(e.getKey(),  getKey())</span><br><span class="line">            &amp;&amp; Objects.equals(e.getValue(), getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implements the general contract of Map.Entry.hashCode</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey())</span><br><span class="line">             ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">&quot;=&quot;</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="接口用户定义类型"><a href="#接口用户定义类型" class="headerlink" title="接口用户定义类型"></a>接口用户定义类型</h1><h1 id="层次类优先于标签类"><a href="#层次类优先于标签类" class="headerlink" title="层次类优先于标签类"></a>层次类优先于标签类</h1><p><strong>标签类：</strong>是一个类，该类的实例根据<strong>构造方法传入标签</strong>的不同而不同。</p>
<pre><code>问题：代码可读性差，扩展性差，且内存负担大，因为类实例保存很多不属于它本身的字段。
</code></pre><p><strong>层次类：</strong>即在顶层实现一个<strong>抽象类</strong>，该抽象类将属于<strong>公共的方法、字段及依赖于标签值的方法包括起来，提供实现样板</strong>。然后根据需求依次实现不同的<strong>子类</strong>，每个子类实现各自的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标签类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tagged class - vastly inferior to a class hierarchy!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Figure</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Shape</span> </span>&#123; RECTANGLE, CIRCLE &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tag field - the shape of this figure</span></span><br><span class="line">    <span class="keyword">final</span> Shape shape;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These fields are used only if shape is RECTANGLE</span></span><br><span class="line">    <span class="keyword">double</span> length;</span><br><span class="line">    <span class="keyword">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This field is used only if shape is CIRCLE</span></span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor for circle</span></span><br><span class="line">    Figure(<span class="keyword">double</span> radius) &#123;</span><br><span class="line">        shape = Shape.CIRCLE;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor for rectangle</span></span><br><span class="line">    Figure(<span class="keyword">double</span> length, <span class="keyword">double</span> width) &#123;</span><br><span class="line">        shape = Shape.RECTANGLE;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(shape) &#123;</span><br><span class="line">          <span class="keyword">case</span> RECTANGLE:</span><br><span class="line">            <span class="keyword">return</span> length * width;</span><br><span class="line">          <span class="keyword">case</span> CIRCLE:</span><br><span class="line">            <span class="keyword">return</span> Math.PI * (radius * radius);</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(shape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 层次类</span></span><br><span class="line"><span class="comment">// Class hierarchy replacement for a tagged class</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Figure</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Figure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> radius;</span><br><span class="line"></span><br><span class="line">    Circle(<span class="keyword">double</span> radius) &#123; <span class="keyword">this</span>.radius = radius; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Math.PI * (radius * radius); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Figure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> length;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> width;</span><br><span class="line"></span><br><span class="line">    Rectangle(<span class="keyword">double</span> length, <span class="keyword">double</span> width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width  = width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> length * width; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类之间的层次关系可读且灵活</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    Square(<span class="keyword">double</span> side) &#123;</span><br><span class="line">        <span class="keyword">super</span>(side, side);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h1><p><strong>嵌套类</strong>最好只存在于宿主类 (enclosing class) 中, 否则，就应将其设计为<strong>顶层类</strong>。</p>
<p><strong>四种嵌套类：</strong><font color="#f07c82">静态内部类</font>、<font color="#f07c82">非静态内部类</font>、<font color="#f07c82">匿名类</font>、<font color="#f07c82">局部类</font>。</p>
<p><strong>静态内部类：</strong>不与类的实例有关联，一个用法是提供类的帮助类。</p>
<p><strong>非静态内部类：</strong>确定<strong>与实例有关联</strong>才用，否则其默认将引用传给宿主类的实例，会占用存储空间与时间。最常用方法就是 Adapter 模式，可将外部类的实例视为某个不相关类的实例。</p>
<p><strong>例子：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Typical use of a nonstatic member class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ... <span class="comment">// Bulk of the class omitted</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>匿名类：</strong> 只能在<strong>非静态上下文环境中</strong>使用时声明与实例化，<strong>在静态上下文环境</strong>，只能带有<strong>常量型变量</strong>（<font color="#f07c82">final</font>修饰的基本类型及初始化为 <font color="#f07c82">String</font>）。不能执行 <font color="#f07c82">instanceof</font> 方法测试，不能在运行外实例化，不能实现多个接口或继承一个类同时实现一个接口。常用：<strong>创建小函数对象和处理对象的首选方法。</strong></p>
<p><strong>局部类：</strong>非静态上下文中定义它们时，它们才会包含实例，并且它们不能包含静态成员。</p>
<h1 id="永远不要将多个顶级类或接口放在一个源文件中"><a href="#永远不要将多个顶级类或接口放在一个源文件中" class="headerlink" title="永远不要将多个顶级类或接口放在一个源文件中"></a>永远不要将多个顶级类或接口放在一个源文件中</h1><p><strong>保证在编译时不能有多个定义。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>迈向新阶段：学生时代的落幕</title>
    <url>/%E8%BF%88%E5%90%91%E6%96%B0%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%AD%A6%E7%94%9F%E6%97%B6%E4%BB%A3%E7%9A%84%E8%90%BD%E5%B9%95/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码不对，请重试" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="72f77a8cd4cfae82a1e7628e9933da9e7d36864c868c4f65d0d3669e7a1c363f">d2d85511782da2007828d4bf9243cc92bcf798e72b8c748078cac6c90b0018c2216db0f680e524127698fa60d0ecb6cb7c43c2d94704de6445c5cd93f22868e8008d27ec7735ca9d2d924c593efca1c650a1a797e4acbbf0b0bfeb72dc1b2b0b7937b5dfc1f582daf8961d4aa3b3d186fb12201df83c3f759bf097943342e1c09d83a00d08469fad504bd45dc717b09b9ebc560382fa9ce407cf6162236e8b416aaa094ca9eba9bca2dc6e31d7da73537083449c31f582139db0e53e71f56f7ed47f0f23754d62a416489930fef8a80d3656194efffe58719dc614f0bb2fc90891697d238bde3ffdfc7dc2067221f309b29bd010c03dc8255f270640bf6877c6369b88aa9aeaf38de1725747ba0ec563cf02d00adba995489f9bedcd4c9d338619b66c5203dee70796d8c689eb6c5a036e557187379dee665f29c802f3fca6f1b33dfc210032f41ae7c4a9966428bdbc5dbdb61eba2b700370f17edce16b74d0b82c262f99d3fc87074af7a7d972a105823af5769ff4d20655ea881bfa2f2e672081ed604a07e3f94483daf7cc31f144adf9969c8fb1921db68c483d5d3c59e89d234c21fccab9bd35e13c27f8cb26bfeaf57c5c07be04162174821dd1ce5fc38677195a83b28b4c703c0f949406cabd32cb988b31eb6cedcda160cc763ec3dcd721568d11775d971706aad6a61e4bc68cd3579cfb66941f33ab6d7e82c0d8bfbff3aa82c50f8fd5a50eed64e0f3f413981b237170c039562a744ad9f3e67a8ccffb8c0d3cc75e2c1344f2351da9aae8f2f2960f6b4dc643331b1fb092d7b67f9bd236cafb9bcb1d5bc51d9ff18a8ade9373924c57c27c2e435658980758b4c93e8e2cd705067649452fdd96b4b090696c7ff60d256e3f1054353f23a5a112da452b4fb587195f2f5bcb850ef7536663f3d5a331d9d021d92b0575e53a498bad2be4bec61bd9cb91ffb5a805d3bc9a4d4eae969c0107663142193fbb715a88b0e918bce59d1d2ffd1dae3de9ef16c8a0200415d61d23c96b2501466dad323b6aaceda0a44d567e646523af4d510ea4e4ce43752935192d759cf7c0951d1a7ea107631d46cc281b7d2b23aceea1dbf7735bae71af5ef2115a957539bf8ee7153f6579355ad5da693134f43374b9e6f7f23c354fda4fd5d9a21433d09ad0b82b91a89f909a1497f8c5995171c052f4d0488945cba550b7bb9c4801e7273549563cf67311d1cb47117411c6cb65676a639f0b9f640535e71757ae71e9910ccca363d9dc86495ccf8294e0eb2ecacf3f695df8fc76f46b30dbafc742c43caa025f4b82d086b31423b7e8b09656428a1b566a0a6f700bcb2a510000645378cd30589b620b63cf97292601cf731683acccc81a262912edd801fbdf9605fd298a91ed397c5b04502d9ad91e5d5ee5d2424f94c8469046d92c7185dfe82cbf8b61ac18ef9790b8f56f012b32d1641701b571be43fcf5ca5922afe177af0f27a1183da5168ff8bf76d1edce853e084802f72ce7384497d6e65fcc1fa7bfd12e658d15cc6a86ed748018418f51eb5e9d2fd21b4d7867424bf76c9195a7e487730332b0bf5a4ac23cea8c0de00b7d1db12d44c4bae896be0f2c1afac2870b22b22500a396eef1231b4141d7f662db7cf7f998758e40d08773049ff8ddc8a91d4d571b0973d2ff5bd3277b3e2e4510fa62b0d7f536b55a536dd800493c443d672bc2bd2b7431b55255402626a8d0908eb65e442030a33965221e4b0d03c00449116240f7d93bcc9822e8100aa1d09789af71f9bcb99462b8c03d66c94748d288f52429597f0b232094e8ee0c24c5462eba428333fcd79fbb7a151f31fe50730d2c8b3afb84d32a1487dacc3821aaaa4a8c485e4773902043344fafff6a18030ee55692bd512e225c5822de7f4417be895466adf5578f4bcf949af932fa7bdc0b7689aa008bd9cc7d18b8a8ecaeac6390564ee0cd8fca81cb4ac62e1176b8ab8ffeda570241b10df4e26ae1763daf05bd59077728dc2a3eb086e7ab84633c401d16581471f7015e4b7af90071ec2b043a1ad02bbf34f85c5797804101a0c9463fb4dd64fcd7a50e12d2db9a63c8e2009ffab40a3925e332a2634bf9509c80ba878083be8036b9c829a5b454074da4658ca7fc1da107b6d8e3dc5da45ac15dda963c457b0d4022efac409d2867de2c91d2504392dc9bea0b2cd1700942877e498478c6205c408e139366a94b585813f06e145ec56380e427689b46a7ea7c49e82747ef37360147eceeba854727c847550df90b529ac959723725bec9fe6e797532de53c84334670ef973f5e0bce918c705fd680e45742b02fd028eb82fbe07fbe1b67134c858c6f369f8bb78fb8f1259fb20912fa8edb2cc73dfbf7239878a37af9b9aad0d49c775bbbd23031a2e26eb2133db2d56599cf9b0bf8f037d9e1c4b69195fc6e5fb657add85aaf4710788b3f49306bb5e53e8f5adfac7ba1726ab94dd1e13fa2a98e079d0f5bbbeee900064d72646c52d47dd2cfc0f769164f0ec1f7f79926d876d57ed59dea939935a04a13b7a760152e1a54ee92830c4db6e249ff3619d54f7b9cdce88872b37eb2a12aa55e4fc2411972ac72af29400e046497340adf4113be06f3ecfb17e9677af0efe2afc76443994e10e6b6bde226a3c1e7691a2ae73efd2b75cee89548e0ac975a97e6a12d766a063bdf70efd392a0a8aedec5bfc2e1dfe6527a464bea561267cb2906f39cf2216ce8a356f98d90f164c5cd5829d7201de80112ae138f5d05a6dfdc9ea0a7c7b7dc7963128ff863ce15bbb7da53e359e1b852d426d129a1f415d5e9bade154c9fda658e0c946edefb09b5c280e8b9c18042186383315d441b54c443b653dcfa6389a9529c82aa8ac13b38e5222d3cafe2850e237d1c9549ccbfab9d0c4a7663b8fbe5a8d8694d2478c5c390c811387ffb192ae3ee652fa2f5cfae6c103a4053f71ef549214316892524682caf7727413a4115725901e9bad2cb55178df3ef889cec1ef58a48b5dab9ec920eeb1d8264f64ba57c26943c20565a62110463dad9e10351e1c164e8fbe3110f9cb78e9bfe522cf49ac267c9193601991eeba52d0dfb73fb13ee942497d720ae494ac9292982c4fd4d047f70d531ecfe19031a6ac723addda2020b586469110d7d5e1d46b2a380595e15121b2c7ec8a07616103e9b22c31278c5214498f97469b54f27fee913c2416846a2346130b478f63154994baa2f6b7f92b7fccac3931f16ade27aec9df223ec161b3912cf4978afe734a2d963444301e43c9628826e42764bc1f527965dd23185b6c8f63ff42090e2bf0f4b2d635d524acac0b609e74871470ea1da7e452c37c1816a9e9c3821e8f8596e27d68d9aec00b251d24bc7294e683c5f71dca9d5714e42971a806369ed886676850a876624916415bd8baeca167e978c357fea115d1be8db0386e3bddfdb585d0145dbf847dc634958dd099d161a1289ff224ca0bb390c6f89b067c29f70355cab03d0dc3bc0dda8e6cab08cc386b562d30db00594eaf7beaeba5c3f534d23fbed3dbe44ed01a3f624e1ba32dc51bf5ad7368c63efedc55eee08c414a0dfbd7ac1e69b1fc7689589271295d07df07c667d78fd2ddf2846d6f92b3b7172261344f9813847084c1a59dd8eba24bbfc6cbe199c68ab1726d7d4c652356e1b0d1aaeef56a000c7bb9a94ac59f64badb89273d47fd5bed23f228c0b6271ea2706513a0bec7f08f984859265c186cf40461579a16848b980136e8133d024576127314430794f0dfd292e47169528256ba92d11333d17aa571b93e473b2fafe79368243a5874742fb83b54bffeb84dab29f2b6ad9b78830abfc27f33912385438b02d107e0c6ffcba1eb52ccf1a8382c4b31a9a8d221d9adff3d5fae39e090a83ac761814a09d530f5bcf38d6ad527c649e1f3dbce5c77b16893193b67fdd6fad87cbc3f383e9621a06fd6b932ac706362887ee69dc9b23a928308c1ee031fb4f3dec2648261267792a1e82126fe224d6e1df59afa37cb9728b8334e52ae114353238d6caa61198bfeee630d78dbda6c280f73db54d984b8bc920b7804c7c781c6c9fbd374b964f4ac289d3a8779cc07253b6cf4ebcc3dce1d2f8d12cb48fc7a8b7c8952921731a8d5ed0f014c5aecbb1c853e668f967125662d8e447a70f40e87d09d5b5b566ffbda94bdbbd04c65b2e792f5ca08af405630e42ea897926487ebfe88a4a1313aec30f37b3b51f82d21cad1ac607bfef73ad94e033d199afd1aaed94a052dbf474a7332884d0b2bd9db600218aa08087aaae7a14cec208045590de5fbc8063a3b0fbe0ccccade0af40688d1bfc8095d4993f99e160991367015a0de8f801246cb61871d88ad555f54324d9661efb6cb13e66754d71a7e9acddb0a861da012c086df94b0377596946fc0f6dfcd74ffa242f0b6f15872aa4e00c3700c83e33acb4023c274513bdfdf69c99142dce6236012381fd68cc6b90d9d3aa4c4bbc1ceacc1b0ce771048dd1ac77199cda46e1b257a66d4e38b562737e8833acd3ee12da7dee71f855afd585ac458ba6756393f0de05cd0c0b2e2fcd4b315d262faaf4041aea10c8a3267116752b2bd78618109cb9879f73c3a708a5ea4e6d72bc77f5c33b4b81cddf0674c541fc22b6778c45670431c8d486a7ce40b79b1942a1b8044db95338ba4ca7b5bae21a9e80d19d48a62783ecf38394bcbb850d771769ded89ef9ddb5d4d5dcd72eb361896738552f22ddc911cf56af464e9bf9b2312166cb8580dedf4eb6ad092d2bf9d29935613957a98f694280dc817e52046c09b150b0b360909e22842202ed93d73b7821a8150a8a9472b7121d7bc2cf5582f7d468a3a60c8a1deb8b0ce22efe0ceefe16fb437b255bd77f92c47d0fcf00027a70b197c6f17702a4fe94b8136ed32fb26315384c959183a731aed4ceffba137894f5104d9c7f9f8b0284618ddb51aa64bc79e520a868bb64e9bbc1ec619c727d6e8637e5ca49790a4ae9c7367d8bd2a0eae797ad98ed37fa3bf9e787518641474321d5bdb11a74761f1c66678a6596941904576e965e87a6f6df79b62793571fb9a63ebd5156c8b3a783a337b10e4217254a6ddc2525a8c59ad2ce2f48f49b5c5c4ef11b1849c01ff95d8dbdb470bbc6f829e49edfd8dbb82f19837ac85e3c4c2ffddd0975af9d128f4592f017348554dcabd7371022f996f0e72ea98298f25b2c933f2d84601495c44e2a67da520549e59e43d2cb1ee3707c7a9b8e6b2e82ec200eac00cefdb7cb19390029fbdf3e78dbe96dd5378783ec0bee95a671124f7832e2b8bba0e0b0b7836a54778b6e2bea8eb0e6fd071f832f8581cd8a3a7478f0e902118ef3d1746519135ac63dec16206b199352c1809b94401894b21896b613b67714c0f46cc2966fc4daaf8e43e62221e2fd7f8b83d1481fc7bd203e2a8cabdaae7f882091bd7fa72433d0c7faaa5029f7af0554945df2b4aeaa5f2ae78c59aa86a54854d7f5b42e5b99f4faec65786c832b6d2cde0b15331ac200d75030cf5514de6d513aef835f67a68b3e1ea316ecdba3cf21a2e87fd90858d8c26b827e05de30066201b44ce2168535f9eb5a82d142802656d7b625475a221309af2ff42a0891da4fda2d53d72168ab8c9a945c3ff3dce6c9234c70a38f6d0249b984dc4640d287facb94eb0e68cd1a30527932303aafe4fa32bdb64f72bf77b9d4a3ea19868313fb060742c389304c53232ad5be228f71f5ec960da17d32aa089748300f32f46dd34c4f84418d4adc0a1b0275fd4ad1495e302b91cf470c90b4e0d172444fa18035729d87a41e7a1f44b05b13425abb973ca5b7c7d327948cc7fa41d679e8d60a8384dedf5bf69046067e4a8b23eeee36eb5361c18d1d473ea91eb3d99a3322f4c00dc7e6147cc69babab4075dcba9a97ef3180f6e344a3dfdf2491b081f17e6ae928e637b47d4da646de4d24ea9d4243238a2d94956c27ae07a4b573565eb32eee549584713ca67b957de6bf40b1288d0aa9f4b793edc82224e08c208d776ce715aa4857eba763766b8de2a8404ad34fbb51fa5e289a9e648d406cfee651f28d18f5ae7476dc78564c062c80774cc766815da45abf76c77437dcfc84c3514958e0fe1049eab2668b7e75661af299474877f33c0a72551706dca5c89dfdfbc2d9dfebf603c3b3b4654a207e9d996164531ce499b9c6f5e9a89eda95060bb3681faba07c822458d8087af4772bff88b84b45b882a5ed378b4fc62c89b10e12df3bd471c6f376d17a97ee74accd9780610f23c982d9ef2194a7f5f9738ecc37955d9fa6315ae212c6b9d84414dd25cd9264f768145e2aa7107c42dd5998ae3b176aef3473a5f845d92196b9eb7264a3b491346813df15c266b982bef2f17e66f7a7939c118611b45b7636b4fe8233235d8836920aca2d6ef3758f58b977874e2f70ab5236f047a6be5725bd407a4e11a321493fb5bcf6f122f056df486564f991a955199da3553d8265014f55409759260964f8431532ebfde9b4f7144d99ffbfba66f0c9a28177868183c86a99055d571c93e6f33464c60a4a53350adf0a311c5df4a76bdd349ee0fb87ab31d5398ddf47f7e64a049117958042d8da4dd1ff49c20d8bedbc2f92641995c5db5580d80f126597c239d2d7326d158396674718d5dcb0bc47893c3f741a4081d5aa386d148a861c803119548adfb955b71320267d86e578ba87498650015f0836541e3e6286f2af8032df07ede22a619c914aa789dd29a635e0f8f3acfff1bc35e461564e575611a2d9d5172f0ac31435fe5b19c55442554d3eefb607f8d49f53596b4baeaba0cddd757c9ffbd6633c8c918e6e6aacd575ca146d383d33554318c2932d465b6f0912bebeab628fdd2774d70fb6876a93d6827ee79f46080a4ea66e13d125eb695326d257405f970b33a991146bda03b650edab34e4eaae737d6656334c7249abc79e93b961900377647b1fd6351f27c044705ff2af3bae91734d9ebbe1eb3c803cc6435bc5bf81ee97b9a95615d0ef679a6234b4abba9ca41d0ef4df5193ee8ebd9a105d8d1c34f27eb0d5e6c77b524028e6049d9dd5b7202655b2c1bb7955ad683319bff656275b913fb8e477bc9cdafbb41027dd7fbdc420be5de75c5c5dc430d9cf8b0290f22afeb91c693b4f3d737a0e2f9de0db7daa19ab89b56c07e6602eacd134a5d27b8204965dd182f8b11fd1a601be5e9a13dd3029dcc02d72186efd5b9a4631f40edb682955f71e053d50e545cbedb9a9bd350c03fd71353b2cb48f3e8f6285f159d3c4c7b3d56d49df6c3b6387230e10b18b8206bc2efe108dec03b23e661502a043adaa91e37c6f7a6944118dbdfdc753a2a7dbe385096b0fd5ae7468e9de79a6f0b5228b596d46b0e242a04b76be1903374cfd1486c694d2ee7c9975c9e015c4ca2e7afba45edfbd090396aeb76533664bb93d50073fcfc7b63436eab3fb5848c3fd6ac3737a7ce98f1f2e9c6e4e89bcf126d1e1dfc7559b499da381a468b06b8f04cac5851a580db0c8d988f9cfb9717f7779585b75a04e8e461aeb97a6349d53266c9c4c68a3f177ed8675bf7f0a4f5e12426dc1bfa341a8222e9aab750136af18dc2d6c30ee431b0af95fc4b5cce025ab00ccc3871f864d295e741033f1326001501ca42f1303b6ea56c8048f08cea8362a2186d7bb3811b3fd89e27575cb5751e4818154de34a9a55ca8db628e9b739408c95a47191586aa8d58afefa73651d01603dd1c47ce394fc9c93ec0c9d9c25f22ddf0f88a1ed53691b0fa4dfb3dfe38930711e5d292196884c131408ba1ca8073ec8dfd2e157644ac2fac77cffbc82d96839dda5d03b4ebcfb06209416d8bce7efcc911a61fb53eaffb4a5863a90fb113dad112f774bdd19967c75bc104a4c35855009f2f127b09e008d0893f7e528a0bf53a88cb15a31760cdd661a77567394298be9398ab26a133723c6eee2c8c688c4227170a64864361b48bd2fede6a5d2786e78629ae7d5c754abcab07e166ddb4eaa71c68ec32c4603e1a325688e37f27154a6c52be58a616b30dda948acb95310303c6efd078946c6ef577f9b769859f59d14fcf1e0321f16b6c7ad76e8631780a8b3cbe5e58157ed5a91e9a7a1a8e51f75057e2da27b6c966200e36bced7fd2322eb4a5628fa40d62714d0244fc3b83bdb50698a7526120fc37032c4eb211f84eac6c2898c6c19d83d5731626e3f48a6405a3e2b5770429b775fe0f593888afea44f7dd5baff924527ca1fb3996d9c6c37abb8e6ad76e40fd03adab496a21cf6c0ed241a9796217695e4517b51a62ed9d746f69d94298d58d87c1367bffe788d1575153a833dedd358ec3de4dc763ace5682ab33f6fd6349bbfc927396562f94a0bce609e5205a9643ca77dcfc2ee6d2d7dfa9716f66582ab2e0d88db38c9763e9f6a337bf5a19688897c42ec613d720e6c7f467096278348acc9e6f0fbeac819293982e4eeb998995d8cd21f2efcb1a877b513a735c7b23b634d97bb5fa09af07b8ddcaaa98233f35bce54a8f604fcc514c10c5a0652cc9791df5e0d09872e882832deda4eb7e91e498265f3a42639fbe2cd72986280bd0f3a135f20bc1903e3118dbda904996957f0dc210357458f7fdf1cc7be4a0d2c582775aae46386e0093234f871833f59aa4505f348e1f39ccdc7d701d9b3b10c6022c1503d8e553eb29af2bc069f8e35537a529b00fc68b5216bb0284d7a4c09306dfafe99d837b84ea3c85a55e796c4056f78dfb052e63d5b6ac2d61b7ce418a63bca94ac6a733329af70792845944e0809f33023f1005b43b1fb9e83ed2a6ebc8910ea0fc8925a977ce1d94e5abe2829fb91ea607a12ae57bf2670284b5f9e8be71be38757925e029eedb88b49df37abca78eb697d790566849a4c2bfceba14338a9d3f9bbe9fe2e6c49c3da345842637190d7162d91a071e1e2999653dc884fbe6a6407397ada134b65a0d3e98502752699bfaf6091196df56f2a260f90af9e5d5649e95cae14f05762c4d5779f8fd236f8449f9db18df92c53cac38b2e46529bec4076b2ecac66d0e0a52f49e0f691ebc1c1af9cc41f44764cc10cb9021f16f3f121e77e50f7a0da62f21360fc65782cf59e508679f0c7689c972a46175d16a9abfe2cc601076bd1a3ba3689d283957d6173605096ef17beb6bb76cd68440849b67a16d7940551e5f85ff94c4a2bd489fbf7ed200cdf331af5b0145d01e4169200313764eb986416e0ea3854b9efa9148e6d70c470a59f85152b170ebff1d585a1b795efd62cbb366167eced405210ad8e75c9db12133c7db965fd855d51ab70f5d3be3394a02256d4fc38ce3d262671ea26f7ad40c3aea279b93cbb04f20f1104ae2c7cb9942854df9ec8c9f4afa9c491aa8952bc09959b916d0bc71862d0779e7a13ee743d0a9b9d90874b3725f1a4b9e4157742f2159e65425e2f83b2afc16dfa38369fb94c1cf3cc3739392de931986b0ba15ebd6096e9f893e50351a9b26bce3f5b25078f1cb65e159acdbdc1d2ca088c0d4f23b32b39c534f902d1a17c5b3eccd0da7e068f43bc7cf889e36ce8906d5317f6424515258c25db27927aeb0ebc17e53637c0d7036b76a82c025da1e0148f60a32a0638bd0661cdaf90032266b662af4fe05b0d79b035f96766af472259d897fb08549f9c6a9d52c935c38d967e532f17ac13ebe2761439144df05cd6a3fc50e2001fe41b131867d4cee217714bfede0ee76d61155d9606afaa94377132a0d11a9ea6e348f8641cf8d5f14f7cf84e135f1d5ccb50b07c30eac40ed1a4b81d963d16adee609c40c62cb4f2ba46441c30c098671270b957ab7fa21b388609f1c809aa3211d6bf74b62bc8c54691be4d67d2c3c81b458064c7bb0e71f57491edf4d513a2e6770fbbfc15af20b85bca4546671fab1797f4d7d592d19809f107410735e832b413b949b236a755013e549c633bd1ebab803f545fd1c63ab43a70666c15ea2a6a9a7d836801e399c043d88c8fea623facc4cc4b8b696a60b390d28075f5aca49b32446c075d1ca45a866fde6651663154b7044af2ec0f56c56940ebd92b884d858ab4b0d77c1f15547d4f0101d207479f3213218d515c5c56019685967de58f4ee219f3e147c3bae6b3e04bded9da81107c98a77138bf25eeae93568109ea8ea1f074d2d55b91ffc981afc1c319cb5bb5d1619011552934be56769d807e0f18562d0e50e37cc286bf3003c0061f86531e4f4c0508ba5b3b760b4344ef0381b03279eddd303f6ee8d78cf85563e23782eaa73e95d91f134b08343097fdc482ce178cd26a20679b5c0466b2428b66c6e2fbdebef16b5dcec94795b401574d9dcab6370d91c9c846239a181477dcd00a94d2559d83b9d5a8129fe24fd5488945ed8b369d5e9a971e2bf00ff27f2dbb5340ebe38b58656df41010442738e27c262ff5c4a3da26c29798513a05859066f7289619b5e8477334c5d52c916ad899df578f0289b1413074664e15f14c345fdaf145ee95aa6a0b494379ad9b0d13345a55991bc0df61f254509a410ad36dd911b57b9c9c291551dff45519b0654c9d26cad4f05ff4281ef9f5f42af7ae213e453325fc3af292b41b68be4ca5c2034fec2b8b3dd985ddc6d56d5e9cc20755fc67ccf764fd1f0740dfaf63c45d2eea60f67293e7f3d7726068c39f66ac1e4a3aee43dc084170e43cdf3afeea69b30aec69c62dc84808ac465e4a1f7fc0e564b401f55ed67ae16c4a3883e702e658f480b21ef26c13766e67d0dcd68646464d20d129f9813a3d2eb6acba6ba93663cc6a359a34526918d3ad06a417c100cb678821d38c4060df6574d4f83901822f870d68d7232a6c0b383c6d9d0238a555a781a2931df9c459e95cbe1467cdffab34c452898627cc84a093f90ef9c64eb3d76ac0aaa9c094f94a1af4dd3856f3f881f618adc3cbf8b609bdc1bb9ed786537b1fe285194bdf8358369ca2af734c2f64002c445e6ac39d87daaf07de76ead8702eb9ef86e70d81950745e61e1118e875946cbc1b7fcc1a691bd8ecd0dba2bb6b3f2bf214f76dca3d34e63b82eadac5592399b024a5251fcfcea2753b8d74e611046c49c6d565e6f40b6f8c013b822cbb0700651bec8a83f90d3660eff5205ddd0caa3b04c290b340693f12c1db0e3da5198eaf438fb0271f37f380fa6c9540fb766a00fb0ce4e625abd957fd85d17cd4cff08cbad921c2fc0d0ec67fc94e23c031a5b5a665ac506570b89d4508dae4c4450177e0b66e972394f3d83f57b5e68dbdba85367b6c007cfa3837418d34793942feaeffd7b33e86dda5570e22aeb189ed7100c1c88115dfb6d57fffdd1b94d0e68ba2cf4db764cb00d69ba80d9f4940465177f15a2bdd2f0ec6f471b922a60c827cc01d50f7fb04d0f291be39e6943330d73c9255efb6237b54a021a75380313c505d10e2c5aaeb203f9f9f7cf6f636caa4578e69a0575a5b6d712f8f1e95bf9ac207b469b43fb752c92c8849a1bce1bc44aed6d94daf850ede2dbcbfb5bc038076ffc9abd059db4570cf8f6077a7aa7612b38d8a8a2dc8faa224d14e8413d5b9a96f0c4a60cd39e9f020621db76aecd1fd06cbd1e4d332a8802d315ef148823dc131866a627daf42f2e799fee46bed40b13ef1ba215ce6d4bfa61726b25aed1e2a44218ba148c0aef08c35025cca76be553a5ba73e12d23b251a9b34ff7bf928039217451d4d564e2f538f4f9aadbedb809b845125925aee4dae6488589eccc250133d33e2bf7817fd4f1ccd7833fbfee5f45bdfb7fcd535179eaa5d68305d3b6b53f83577c43b1292060359ad11967c1263aa8c93190cfaa68636a2471176767f4e8d04ef910ad274ac97ac03ee24f6eeba350a76a02f01b19e08b8a1936d2f2f25791b4810b1920d2f1a762e75d230d46add77e07c8824e2d327de36aa0d36e87878c79f977b27018be2eec997a5565d31c64f45cff0af7d8d31344f8184c2024c33e243108dd173bd1db827f644d972b1a541f251a9dd6b9635e6b2f2a99fabeb705a186e040c22557686f8ce977802b5a98e66e973490da74c5620dcc44d39333147ed8e702fdc5da97e31342050da6359173dd0abc54020de5fb39b08b0830a155918c36569d8d88257c1cc9bd2854cc3aadc606316c8e510494581c995ebc0fde7f19036c379d3ddb052ac10230d5f612d4d441bdfa33240f45a7825f134f38b37aba08960e8752f834a2b5f114a7e5e1d494c34031750d0dd0ba65b7c7839364346ebf34358e9b693cb1f1e00e7d80d0cb23ceba4ff9b1d465dd41a477681889c1769c67f49d85c8422dadc1300ec2d3fa9ff57b7c906b1634a01e6d05c9cc89511b47b7c31d098418e4acf00716aaaa244b330ad3602b7b4fc3028b9de60cce8f0cdd69ba574b167ca6c20c2c684881ba19dff594149157ff0fb6bd0acf7c74d38ed2d24ef10e777426ec8cca845219c5a55f91c5248df00e758ce7ccf008901acc53edce70c3100257971cc35a261cdf1ec74830722539160f1c79ba880a20c9325923</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入查看密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>自己实现简单版Vue--3. 实现数据的双向绑定和Proxy代理</title>
    <url>/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%89%88Vue-3-%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8CProxy%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="数据的双向绑定"><a href="#数据的双向绑定" class="headerlink" title="数据的双向绑定"></a>数据的双向绑定</h1><p>之前我们已经实现数据影响视图，即数据更新调用setter()方法里绑定的方法，通过Dev通知Watcher更新视图。</p>
<p>然后我们需要实现视图影响数据进而再影响视图。</p>
<p>通过为input节点利用Object.addEventListener()绑定事件监听，再调用数据更新方法更新数据。</p>
<p>数据更改后由于之前已经实现了数据更改后页面的自动更新，由此数据自然驱动视图。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译模版具体执行</span></span><br><span class="line"><span class="keyword">const</span> compileUtil = &#123;</span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">    <span class="function"><span class="title">model</span>(<span class="params">node, expr, vm</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="built_in">this</span>.getValue(expr, vm);</span><br><span class="line">        <span class="comment">// v-model绑定对应的 Watcher, 数据驱动视图</span></span><br><span class="line">        <span class="keyword">new</span> Watcher(expr, vm, <span class="function">(<span class="params">newVal</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.updater.modelUpdater(node, newVal);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 视图 =&gt; 数据 =&gt; 视图</span></span><br><span class="line">        node.addEventListener(<span class="string">&#x27;input&#x27;</span>, <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.setVal(expr, vm, e.target.value);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">this</span>.updater.modelUpdater(node, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="this-data的代理"><a href="#this-data的代理" class="headerlink" title="this.$data的代理"></a>this.$data的代理</h1><p>我们可以通过在vm对象中使用this.person.name直接修改数据，而不是通过this.$data.person.name实现。</p>
<p>利用this.$data的代理实现。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> MVue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line">                person: &#123;</span><br><span class="line"><span class="javascript">                    name: <span class="string">&#x27;海贼——王路飞&#x27;</span>,</span></span><br><span class="line">                    age: 18,</span><br><span class="line"><span class="javascript">                    fav: <span class="string">&#x27;film&#x27;</span></span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="javascript">                msg: <span class="string">&#x27;最简单的插值&#x27;</span>,</span></span><br><span class="line"><span class="handlebars"><span class="xml">                htmlStr: &#x27;<span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是v-html<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>&#x27;</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line"><span class="javascript">                handleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">&#x27;这是一个处理点击事件的方法&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 使用代理的方式可以直接这样修改数据</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.person.name = <span class="string">&#x27;海贼王——路飞&#x27;</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MVue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始元素与数据通过options对象绑定</span></span><br><span class="line">        <span class="built_in">this</span>.$el = options.el;</span><br><span class="line">        <span class="built_in">this</span>.$data = options.data;</span><br><span class="line">        <span class="built_in">this</span>.$options = options;</span><br><span class="line">        <span class="comment">// 通过Compiler对象对模版进行编译，例如&#123;&#123;&#125;&#125;插值、v-text、v-html、v-model等Vue语法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.$el) &#123;</span><br><span class="line">            <span class="comment">// ... 省略</span></span><br><span class="line">            <span class="comment">// 通过数据代理实现 this.person.name = &#x27;海贼王——路飞&#x27;功能，而不是this.$data.person.name = &#x27;海贼王——路飞&#x27;</span></span><br><span class="line">            <span class="built_in">this</span>.proxyData(<span class="built_in">this</span>.$data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//用vm代理vm.$data</span></span><br><span class="line">     <span class="function"><span class="title">proxyData</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> data)&#123;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>,key,&#123;</span><br><span class="line">                <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> data[key];</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">                    data[key] = newVal;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/SUNYunZeng/ImitateVue">https://github.com/SUNYunZeng/ImitateVue</a></p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
